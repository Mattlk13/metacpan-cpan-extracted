#!/usr/bin/perl
use 5.014 ; use strict ; use warnings ; 
use Scalar::Util qw/looks_like_number/; 
use Getopt::Std; getopts "~=/:3qvm:",\my%o;
use Term::ANSIColor qw/:constants color/; $Term::ANSIColor::AUTORESET = 1 ;

my $isep = $o{'/'} // "\t" ; # 入力の区切り文字
my $t00 ;  # 表の左上隅に載せる文字列
my %ax2 ; # キーは横軸の項目名となる。
my %C ; # セルの値 
my %Cc ; # 1件を1個と数える。
my %Ce ; # 空文字列の個数を数える。

& Init ;
& Input ; 
& Output ; 
exit 0 ; 

sub Init { 
    * CYAN = * GREEN = sub { @_ } if $o{q} ; # -q により着色コマンドを無効化する。
    $o{'/'}
}

sub Input { 
  	$t00= $o{'='}? <> : "X1\tX2" ; 
  	chomp $t00; $t00 =~ s{\t}{*} ;

  	#my $intflag ; 
  	#$SIG{INT} = sub { $intflag = 1 ; *STDOUT=*STDERR} ;

	while(<>){
	    chomp;
	    my @F = split /$isep/ , $_ , 3 ; #3列目以降は連結する。  -x と組み合わせて使うとよいかも。
	    my $n =  $o{3} ? ( shift @F ) : 1 ; # -3 なら先頭を取り出す。
	    @F[0,1] = @F[1,0]  if $o{'~'} ; # -x で出力行列の縦と横を反転する	
	    grep { $_ //= 'undef' } @F[0,1] ;

	    $ax2 { $F[1] } ++ ;  
	    $C  { $F[0] } { $F[1] } += $n || 0 ;  
	    $Ce { $F[0] } { $F[1] } ++ if $n eq '' ;
	    $Cc { $F[0] } { $F[1] } ++ if $o{3} ;

	    #last if ( $intflag ) ;
	}
}

sub Output { 
	my @a1 = StrNumSort ( keys %C ) ; # 縦軸の各項目名
	my @a2 = StrNumSort ( keys %ax2 ) ; # 横軸の各項目名
	
	# -x のオプションで、指定された数をかけ算して、整数部分を取り出す。
	cellMult ( \%C, $o{m} ) if defined $o{m} ;
		
	# 一番目のクロス表を表示
	showMat(  \%C , \@a1 , \@a2 , $t00 ) ;
	#return  if !$o{3} ;
	
	# -v が指定しているかどうかで異なるクロス表を表示する。
	if ( $o{v} ) { 
		print "\n" ;
		showMat( \%Cc , \@a1 , \@a2 , "items" ) ;  # カウント対象となったすべての行数
		print "\n" ;
		showMat( \%Ce , \@a1 , \@a2 , "empties" ) ; # 空文字列がいくつ出現したか
	}

	# my %Cv ; for my$i(@a1){for my$j(@a2){$Cv{$i}{$j}=($Cc{$i}{$j}//0)-($Ce{$i}{$j}//0)}}
}


sub StrNumSort ( @ ) {
	+( sort { $a cmp $b } grep { ! looks_like_number ($_) } @_ ) ,
	 ( sort { $a <=> $b } grep {   looks_like_number ($_) } @_ ) ;
}

sub showMat ( $$$$ ) { 
	my ($C,$a1,$a2,$h11) = @_ ; # セル, 縦軸, 横軸, 出力表の左上の文字列
	print CYAN "$h11\t" , GREEN join("\t",@{$a2} ),"\n" ; # 出力の1行目
	for my $i ( @{ $a1 } ) {
	    print GREEN $i, "\t" ;  #  出力の1列目
	    print join ( "\t" , map { $C -> { $i }{ $_ } || 0 } @{ $a2 } ) , "\n" ;
	}
}

sub cellMult ( $$ ) {
    for my $i ( keys %{ $_[0] } ) {
        for my $j ( keys %ax2 ) {
            $_[0]->{$i}{$j} = defined $_[0]->{$i}{$j} ? int ( $_[0]->{$i}{$j} * $_[1] ) . "." : '' ;
        }
    } 
}



sub VERSION_MESSAGE {}
sub HELP_MESSAGE {
    use FindBin qw[ $Script ] ; 
    $ARGV[1] //= '' ;
    open my $FH , '<' , $0 ;
    while(<$FH>){
        s/\$0/$Script/g ;
        print $_ if s/^=head1// .. s/^=cut// and $ARGV[1] =~ /^o(p(t(i(o(ns?)?)?)?)?)?$/i ? m/^\s+\-/ : 1;
    }
    close $FH ;
    exit 0 ;
}

=encoding utf8

=head1 NAME
 
 crosstable -- Produce the crosstable from the 2 column data. Can also sum up a additional column by -3 switch option.

 2列のデータを度数を数えて、クロステーブルにする。
 Count the numbers of the frequencies of the combination of the 2 columns, and produce crosstable.
   

 オプション : 
   -3   : 2列のデータのさらに左の1列は加算対象の数と見なす。(Sum the first line added to the left of the two columns.)
   -~   : 出力表の、縦軸と横軸を反転する。 (Transpose the output table btw. vertical and horizontal axis.)
   -=   : 入力の1行目を列名の並びと見なし、データの値とは扱わない。2行目からを加算対象のデータとして扱う。(Skip the 1st input line.)
   -m N : 出力表において、N をかけ算した数の整数部を表示する。(Multiply number and take Integer part. E.g. N=1e-5)
   -v   : -3 が指定された場合に他の有用な情報も出力 (個数、空文字列) Other entailing information.
   -q   : 色を出さないようにする。 No color by ANSI color.
   -/ REGEX : 区切り文字の指定。コンマ , などに変更が可能。未指定ならタブ文字。Specify the delimiter. Default : tab

 関連するコマンド : 
   keyvalues 

 開発上のメモ :
   * もっと高速化できるかもしれない。
   * Ctrl+Cについての処理をうまく共通化したものをプログラムに加えたい。
   * 何行まで処理したかの親切機能が無い。入力を　TTYから待っていることの親切機能も無い。
   * 縦軸と横軸のそれぞれの表示順序を豊富にしても良さそう。

=cut
