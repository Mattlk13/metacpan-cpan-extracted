NAME

    Syntax::Operator::In - infix element-of-list meta-operator

SYNOPSIS

    On a suitably-patched perl:

       use Syntax::Operator::In;
    
       if($x in<eq> @some_strings) {
          say "x is one of the given strings";
       }

DESCRIPTION

    This module provides an infix meta-operator that implements a
    element-of-list test on either strings or numbers.

    Current versions of perl do not directly support custom infix
    operators. The documentation of XS::Parse::Infix describes the
    situation, with reference to a branch experimenting with this new
    feature. This module is therefore almost entirely useless on standard
    perl builds. While the regular parser does not support custom infix
    operators, they are supported via XS::Parse::Infix and hence
    XS::Parse::Keyword, and so custom keywords which attempt to parse
    operator syntax may be able to use it.

    For operators that already specialize on string or numerical equality,
    see instead Syntax::Operator::Elem.

OPERATORS

 in

       my $present = $lhs in<OP> @rhs;

    Yields true if the value on the lefhand side is equal to any of the
    values in the list on the right, according to some equality test
    operator OP.

    This test operator must be either eq for string match, or == for number
    match, or any other custom infix operator that is registered in the
    XPI_CLS_EQUALITY classification.

TODO

      * Improve runtime performance of compiletime-constant sets of
      strings, by detecting when the RHS contains string constants and
      convert it into a hash lookup.

      * Consider further on the syntax for this operator. Maybe instead of
      the circumfix anglebrackets, a single colon might look nicer?

         $lhs in:OP @rhs
      
         $x in:== @numbers
         $x in:eq @strings

      Does the lacking of end marker make parsing harder though?

      * Consider cross-module integration with Syntax::Keyword::Match,
      permitting

         match($val : elem) {
            case(@arr_of_strings) { ... }
         }

      Or perhaps this would be too weird, and maybe match/case should have
      an "any-of" list/array matching ability itself. See also
      https://rt.cpan.org/Ticket/Display.html?id=143482.

AUTHOR

    Paul Evans <leonerd@leonerd.org.uk>

