#!Spp

(use Tools)
(use Optimizer)
(use AtomToStr)

(my $RULE :Spp)
(my $DOOR :TOP)
(my $MAIN :MAIN)
(my $FALSE [:bool, :false])
(my $TRUE [:bool, :true])
(my $NIL [:nil, :nil])
(my $CONTEXT $MAIN)
(my %ST { $MAIN => {} })
(my $CONTEXT-STACK [ $MAIN ])
(my $CALL (uuid))
(my @CALL-STACK [ $MAIN ])
(my $BLOCK (uuid))
(my @BLOCK-STACK [ $BLOCK ])
(my $TC 0)
(my $DEBUG 0)

(set %ST $MAIN $MAIN [:context $MAIN])
(set %ST $BLOCK {})

(my %OP-MAP {
  :!=  => (def (x) (eval-ne x)),
  :+   => (def (x) (eval-add x)),
  :+=  => (def (x) (eval-inc x)),
  :-   => (def (x) (eval-sub x)),
  :<   => (def (x) (eval-lt x)),
  :<<  => (def (x) (eval-push x)),
  :<=  => (def (x) (eval-le x)),
  :=   => (def (x) (eval-assign x)),
  :==  => (def (x) (eval-eq x)),
  :>   => (def (x) (eval-gt x)),
  :>=  => (def (x) (eval-ge x)),
  :>>  => (def (x) (eval-unshift x)),
  :and => (def (x) (eval-and x)),
  :&&  => (def (x) (eval-and x)),
  :in  => (def (x) (eval-in x)),
  :is  => (def (x) (eval-is x)),
  :or  => (def (x) (eval-or x)),
  :||  => (def (x) (eval-or x)),
  :~~  => (def (x) (eval-match x)),
})

(my %SPP-MAP {
  :begin    => (def (x) (eval-exprs x))
  :!=       => (def (x) (eval-ne x)),
  :+        => (def (x) (eval-add x)),
  :+=       => (def (x) (eval-inc x)),
  :-        => (def (x) (eval-reduce x))
  :<        => (def (x) (eval-lt x)),
  :<=       => (def (x) (eval-le x)),
  :=        => (def (x) (eval-assign x))
  :==       => (def (x) (eval-eq x))
  :>>       => (def (x) (eval-unshift x))
  :and      => (def (x) (eval-and x))
  :block    => (def (x) [:context $BLOCK])
  :bool     => (def (x) (eval-bool (x 0)))
  :break    => (def (x) (eval-break))
  :case     => (def (x) (eval-case x))
  :def      => (def (x) (eval-def x))
  :delete   => (def (x) (eval-delete x))
  :end      => (def (x) (eval-end (x 0)))
  :exists   => (def (x) (eval-exists x))
  :exit     => (def (x) (exit))
  :for      => (def (x) (eval-for x))
  :if       => (def (x) (eval-if x))
  :sub      => (def (x) (eval-sub x))
  :~~       => (def (x) (eval-match x))
  :my       => (def (x) (eval-my x))
  :not      => (def (x) (eval-not (x 0)))
  :next     => (def (x) (eval-next))
  :ok       => (def (x) (eval-ok x))
  :or       => (def (x) (eval-or x))
  :context  => (def (x) (eval-context (x 0)))
  :return   => (def (x) (eval-return (x 0)))
  :rule     => (def (x) (eval-rule x))
  :str      => (def (x) (eval-str x))
  :shift    => (def (x) (eval-shift (x 0)))
  :say      => (def (x) (eval-say (x 0)))
  :type     => (def (x) (eval-type (x 0)))
  :use      => (def (x) (eval-use x))
  :uuid     => (def (x) [:str, (uuid)])
  :while    => (def (x) (eval-while x))
  :<<       => (def (x) (eval-push x))
  :>>       => (def (x) (eval-unshift x)),
  :zip      => (def (x) (eval-zip x))
  :in       => (def (x) (eval-in x))
  })

(def get-token-atom(name)
  (for context in $CONTEXT-Stack
    (if (exists (%ST context) name)
      (my token (%ST context name))
      (return (token 1) if ((token 0) == :rule))))
  (error "token: {name} not defined!"))

(def match-atom($atom $cursor)
  (my $match (_match-atom $atom))
  (my $flag 'ok')
  ($flag = '  ' if (match == false))
  (my $pos ($cursor :Pos))
  (($cursor :Log) << [ $flag $atom $pos ])
  (return $match))

(def _match-atom($atom $cursor)
  (my ($type $value) $atom)
  (case $type
    (when :bool    $atom                         )
    (when :any     (match-any     $value $cursor))
    (when :char    (match-str     $value $cursor))
    (when :str     (match-str     $value $cursor))
    (when :token   (match-token   $value $cursor))
    (when :group   (match-token   $value $cursor))
    (when :branch  (match-branch  $value $cursor))
    (when :lbranch (match-lbranch $value $cursor))
    (when :rept    (match-rept    $value $cursor))
    (when :look    (match-look    $value $cursor))
    (when :strs    (match-strs    $value $cursor))
    (when :chclass (match-chclass $value $cursor))
    (when :alias   (match-alias   $value $cursor))
    (when :action  (match-action  $value $cursor))
    (when :ctoken  (match-ctoken  $value $cursor))
    (when :rtoken  (match-rtoken  $value $cursor))
    (when :gtoken  (match-gtoken  $value $cursor))
    (when :assert  (match-assert  $value $cursor))
    (when :cclass  (match-cclass  $value $cursor))
    (else (error "Unknown atom type: {$type} to match"))))

(def match-ctoken($name $cursor)
  (my $atom (get-token-atom $name))
  (my $match (match-atom $atom $cursor))
  (return (name-match $name $match)))

(def match-rtoken($name, $cursor)
  (my atom (get-token-atom $name))
  (my pos-cache ($cursor :Pos))
  (my match (match-atom atom $cursor))
  (if (is-match match)
    (my $str ($cursor :Str))
    (my $pos ($cursor :Pos))
    (my match-str ($str pos-cache $pos))
    (return match-str))
  (return false))

(def match-alias(ast, $cursor)
  (my (alias-name alias-atom) ast)
  (my match false)
  (if ((alias-atom 0) == :ctoken)
    (my token-name (alias-atom 1))
    (my token-atom (get-token-atom token-name))
    (match = (match-atom token-atom $cursor))
    else
    (match = (match-atom alias-atom $cursor)))
  (return (name-match alias-name match)))

(def match-gtoken($name $cursor)
  (my atoms (get-token-atom $name))
  (my pos-cache ($cursor :Pos))
  (my match (match-atom atoms $cursor))
  (set $cursor :Pos pos-cache)
  (return true if (match == false))
  (return false))

(def match-token(@atoms %cursor)
  (my gather true)
  (for atom in @atoms
    (my match (match-atom atom %cursor))
    (return match if (match == false))
    (gather = (gather-match gather match)))
  (return gather))

(def match-branch(@branch %cursor)
  (my pos-cache (%cursor :Pos))
  (for atom in @branch
    (my match (match-atom atom %cursor))
    (return match if (is-match match))
    (set %cursor :Pos pos-cache))
  (return false))

(def match-lbranch(branch %cursor)
  (my pos-cache (%cursor :Pos))
  (my max-len 0)
  (my max-match false)
  (for atom in branch
    (my match (match-atom atom %cursor))
    (my to-pos (%cursor :Pos))
    (set %cursor :Pos pos-cache)
    (next if (match == false))
    (my match-str-len (to-pos - pos-cache))
    (if (match-str-len >= max-len)
      (max-len = match-str-len)
      (max-len-match = match)))
  (set %cursor :Pos (pos-cache + max-len))
  (return max-len-match))

(def match-strs(strs %cursor)
  (my max-len 0)
  (my max-str false)
  (for str in strs
    (my $len (len str))
    (my $apply-str (apply-char $len %cursor))
    (next if (str != $apply-str))
    (if (len >= max-len)
      (max-len = len)
      (max-str = str)))
  (set %cursor :Pos (max-len + (%cursor :Pos)))
  (return max-str))

(def match-look(look %cursor)
  (my (atom rept look-atom) look)
  (my (gather match-time) [true, 0])
  (my (min-time max-time) rept)
  (if (match-time >= min-time)
    (my match (match-atom look-atom %cursor))
    (if (is-match match)
      (return (gather-match gather match))))
  (while (match-time != max-time)
    (my pos-cache (%cursor :Pos))
    (my match (match-atom atom %cursor))
    (if (match == false)
      (return false if (match-time < min-time))
      (set %cursor :Pos pos-cache)
      (my look-match (match-atom look-atom %cursor))
      (return false if (look-match == false))
      (return (gather-match gather look-match)))
    (match-time += 1)
    (gather = (gather-match gather match))
    (if (match-time >= min-time)
      (my pos-cache (%cursor :Pos))
      (my look-match (match-atom look-atom %cursor))
      (if (is-match look-match)
        (return (gather-match gather look-match)))
      (set %cursor :Pos pos-cache)))
  (return false))

(def match-rept(atom-rept %cursor)
  (my (gather match-time) [true 0])
  (my (atom rept) atom-rept)
  (my (min-time max-time) rept)
  (while (match-time != max-time)
    (my pos-cache (%cursor :Pos))
    (my match (match-atom atom %cursor))
    (if (match == false)
      (return false if (match-time < min-time))
      (set %cursor :Pos pos-cache)
      (return gather)
      else
      (match-time += 1)
      (gather = (gather-match gather match))))
  (return gather))

(def match-action(exprs %cursor)
  (my $atom (eval-atom exprs))
  (return true if ($atom == true))
  (return false if ($atom == false))
  (return false if ($atom == nil))
  (if (($atom 0) == :str)
    (return (match-str ($atom 1) %cursor)))
  (if ((value 0) == :array)
    (return (match-array ($atom 1) %cursor)))
  (error "Not implement parse {($atom 0)}"))

(def match-array(array %cursor)
  (my strs [])
  (for str in array
    (if ((str 0) == :str)
      (strs << (str 1))))
  (return (match-strs strs %cursor)))

(def match-any($dot %cursor)
  (my char (apply-char 1 %cursor))
  (if (1 == (len char))
    (set %cursor :Pos (%cursor :Pos + 1))
    (return char))
  (return false))

(def match-str(str %cursor)
  (my $len (len str))
  (if (str == (apply-char $len %cursor))
    (set %cursor :Pos (%cursor :Pos + $len))
    (return str))
  (return false))

(def match-chclass(atom %cursor)
  (my char (apply-char 1 %cursor))
  (my class-str (chclass-to-str atom))
  (if (char ~~ class-str)
    (set %cursor :Pos (%cursor :Pos + 1))
    (return char))
  (return false))

(def match-cclass(cclass %cursor)
  (my char (apply-char 1 %cursor))
  (if (char ~~ cclass)
    (set %cursor :Pos (%cursor :Pos + 1))
    (return char))
  (return false))

(def match-assert($str %cursor)
  (case $str
    (when '^' (return (0 == (%cursor :Pos))))
    (when '$' (return ((%cursor :Pos) >= (%cursor :Len))))
    (when '^^'
       (return true if ((apply-char -1 %cursor ) ~~ '\n'))
       (return true if ((%cursor :Pos) == 0))
       (return false))
    (when '$$' 
       (return true if ((apply-char 1 %cursor) ~~ '\n'))
       (return true if ((%cursor :Pos) == (%cursor :Len)))
       (return false))
  (else (error "Unknown assert str: {$str}"))))

(def match-rule($rule $match-str)
  (return [] if ((trim match-str) == ''))
  (my %cursor (create-cursor $match-str))
  (in-context $rule)
  (my door-atom (get-token-atom $DOOR))
  (my match (match-atom door-atom %cursor))
  (if (match == false) (error 'Could not match'))
  (out-context grammar)
  (return match))

(def in-context(context-name)
  (if (not (exists %ST $MAIN context-name))
    (set %ST $MAIN context-name [:context, context-name])
    (set %ST context-name {}))
  ($CONTEXT = context-name)
  (context-name >> @CONTEXT-STACK)
  (return [:context, context-name]))

(def out-context(context-name)
  (if ($CONTEXT == context-name)
    (shift @CONTEXT-STACK)
    ($CONTEXT = (@CONTEXT-STACK 0))
    (return [:context, context-name]))
  (error "Could not end {context-name} from {$CONTEXT}"))

(def in-call(context-name)
  (context-name >> @CALL-STACK)
  ($CALL = context-name)
  (if (exists %ST context-name)
    (error "into exists block: {context-name}"))
  (%ST context-name = {})
  (context-name >> @CONTEXT-STACK)
  ($CONTEXT = context-name)
  (return [:context context-name]))

(def out-call(context-name)
  (shift @CALL-STACK)
  ($CALL = (@CALL-STACK 0))
  (if (context-name == $CONTEXT)
    (delete %ST context-name)
    (shift @CONTEXT-STACK)
    (return [:context context-name]))
  (error "out block {context-name} != {$CONTEXT}"))

(def in-block(context-name)
  (if (exists %ST context-name)
    (error "into exists block: {context-name}"))
  (set %ST context-name {})
  (context-name >> @CONTEXT-STACK)
  ($CONTEXT = context-name)
  ($BLOCK = context-name)
  (context-name >> @BLOCK-STACK)
  (return [:context, context-name]))

(def out-block(context-name)
  (if (context-name == $CONTEXT)
    (delete %ST context-name)
    (shift @CONTEXT-STACK)
    (shift @BLOCK-STACK)
    ($CONTEXT = (@CONTEXT-STACK 0))
    (return [:context, context-name]))
  (error "Out block {context-name} != {$CONTEXT}"))

(def eval-local-declare(sym, value)
  (my $name (sym 1))
  (if (exists %ST $CONTEXT $name)
    (error "Have been defined local symbol: {name}"))
  (set %ST $CONTEXT $name value)
  (return sym))

(def eval-multi-local-declare(syms values)
  (return $FALSE if ((len syms) == 0))
  (if (all-is-spp-sym(syms))
    (for sym-value in (zip syms values)
      (my (sym value) sym-value)
      (eval-local-declare sym value))
    (return [:list, syms]))
  (error "only could bind symbol"))

(def eval-sym-assign(sym, value)
  (my $name (sym 1))
  (for context in @CONTEXT-STACK
    (if (exists %ST context $name)
      (set %ST context $name value)
      (return sym)))
  (error "Assign undefied symbol: {name}"))

(def eval-syms-assign(syms, values)
  (for sym-value in (zip syms values)
    (my (sym value) sym-value)
    (eval-sym-assign sym value))
  (return [:list, syms]))

(def to-rule(args)
  (my (grammar-file rule-file) args)
  (my parse-str (read-file grammar-file))
  (my match-ast (match-rule $RULE parse-str))
  (if (is-match match-ast)
    (my opt-ast (opt-atom match-ast))
    (write-file rule-file (to-str opt-ast))
    (return rule-file))
  (error "Could not transfer {grammar-file} to rule"))

(def eval-atoms(atoms)
  (my atoms-array [])
  (for atom in atoms
    (atoms-array << (eval-atom atom)))
  (return atoms-array))

(def eval-atom($atom)
  (my ($type value) $atom)
  (case $type
    (when :exprs  (eval-exprs value))
    (when :sym    (eval-sym value))
    (when :string (eval-string value))
    (when :array  (eval-array value))
    (when :hash   (eval-hash value))
    (when :list   (eval-list value))
    (else (return $atom))))

(def eval-exprs($exprs)
  (my $return-value $TRUE)
  (for $expr in $exprs
    ($return-value = (eval-atom $expr))
    (break if (1 == (%ST $CALL ::return)))
    (break if (1 == (%ST $CONTEXT ::next)))
    (break if (1 == (%ST $CONTEXT ::break))))
  (return $return-value))

(def eval-sym($name)
  (for context in @CONTEXT-STACK
    (if (exists %ST context $name)
      (return (%ST context $name))))
  (return [:sym name]))

(def eval-string(@atoms)
  (my @values (eval-atoms @atoms))
  (my @strs [])
  (for $value in @values
    (if ((first $value) == :str)
      (@strs << ($value 1))
      else
      (@strs << (atom-to-str $value))))
  (return [:str, (join @strs)]))

(def eval-array(atoms)
  (my values [])
  (for atom in atoms
    (values << (eval-atom atom)))
  (return [:array values]))

(def eval-hash(pairs)
  (my hash-value {})
  (for pair in pairs
    (my (key value) (eval-atoms pair))
    (set hash-value key value))
  (return [:hash hash-value]))

(def eval-list(atoms)
  # Operator
  (if ((len atoms) == 3)
    (my op (atoms 1))
    (if (:sym == (first op))
      (my op-name (op 1))
      (if (exists @OP-MAP op-name)
        (my op-call (@OP-MAP op-name))
        (my $args [(first atoms) (last atoms)])
        (return (op-call $args)))))
  # tail if exprs
  (if (2 < (len atoms))
    (if ((atoms -2) == [:sym :if])
      (my cond-expr (atoms -1))
      (if ((eval-bool cond-expr) == $FALSE)
        (return $FALSE))
      (my true-expr (get atoms 0 -3))
      (return (eval-list true-expr))))
  (my first-atom (atoms 0))
  (if (:sym == (first-atom 0))
    (my $name (first-atom 1))
    (if (exists %SPP-MAP $name)
      (my spp-call (%SPP-MAP $name))
      (my $args (rest $atoms))
      (return (spp-call $args)))
    (if (exists %HOST-MAP $name)
      (my host-call (@HOST-MAP $name))
      (my $args (eval-atoms (rest atoms)))
      (my $values (get-atoms-value $args))
      (my return-value (host-call $values))
      (return (value-to-atom return-value))))
  (my first-value (eval-atom first-atom))
  # call other context function
  (if (:context == (first first-value))
    (if (is-dot (atoms 1))
      (my $args (atoms 2 -1))
      (my $context-name (first-value 1))
      (in-context $context-name)
      (my return-value (eval-list $args))
      (out-context $context-name)
      (return return-value)))
  # call user defined function
  (if (:fn == (first-value 0))
    (my $fn-exprs (first-value 1))
    (my $args (eval-atom (rest atoms)))
    (return (call-fn $fn-exprs $args)))
  # call str index
  (my $args (eval-atoms (rest atoms)))
  (if (:str == (first-value 0))
    (my $str-value (last first-value))
    (return (call-str $str-value $args)))
  # call array index
  (if (:array == (first-value 0))
    (return (call-array first-value $args)))
  # call hash index
  (if (:hash == (first-value 0))
    (return (call-hash first-value args)))
  (error "Have not implement ({(first-value 1)} ..)"))

(def call-fn(fn-exprs real-args)
  (my (formal-args exprs) fn-exprs)
  (my $context (uuid))
  (in-call $context)
  (eval-multi-local-declare $formal-args $real-args)
  (my return-value (eval-atom exprs))
  (out-call $context)
  (return return-value))

(def call-str($str $args)
  (if (:int == ($args [0 0]))
    (my index (args [0 1]))
    (if (1 == (len args))
      (my index-char (str index))
      (return [:nil] if (index-char == nil))
      (return [:str index-char]))
    (if (2 == (len args))
      (if (:int == (args [1 0]))
        (my to-index (args [1 1]))
        (if (to-index < 0)
          (my elements (str index -> to-index))
          (return [:nil] if (elements == nil))
          (return [:str elements]))
        (if (to-index > 0)
          (my elements (str index to-index))
          (return [:nil] if (elements == nil))
          (return [:str elements]))))
    (if (3 == (len args))
      (if ((args 1) == [:sym '->'])
        (if ((args [2 0]) == :int)
          (my to-index = (args [2 1]))
          (my elements = (str index -> to-index))
          (return [:nil] if elements == nil)
          (return [:str elements])))))
  (error "String index not implement: {args}"))

(def call-array(array args)
  (my array-value (array 1))
  (if (:int == (args [0 0]))
    (my index (args [0 1]))
    (if (1 == (len args))
      (my index-element (array-value index))
      (return [:nil] if (index-element == nil))
      (return index-element))
    (if (2 == (len args))
      (if (:int == (args [1 0]))
        (my to-index (args [1 1]))
        (if (to-index < 0)
          (my element (array-value index -> to-index))
          (return [:nil] if (element == nil))
          (return [:array elements]))
        (if (to-index > 0)
          (my element (array-value index to-index))
          (return [:nil] if (element == nil))
          (return [:array elements]))))
    (if (3 == (len args))
      (if ([:sym '->'] == (args 1))
        (if (:int == (args [2 0]))
          (my to-index (args [2 1]))
          (my elements = (array-value index -> to-index))
          (return [:nil] if (elements == nil))
          (return [:array elements])))))
  (if (:array == (args [0, 0]))
    (my index-array (args [0, 1]))
    (if ([:int] == (get-atoms-type index-array))
      (my indexs (get-atoms-value index-array))
      (my value array)
      (for index in indexs
        (if (:array == (array 0))
          (value = ((value 1) index))
          (return [:nil] if (value == nil))
          else
          (return [:nil])))
      (return value)))
  (error "Array index have not implement {array} {args}"))

(def call-hash(hash args)
  # (hash key-one key-two = value)
  (if (2 < (len args))
    (if ([:sym '='] == (args 2))
      (return (eval-hash-assign hash args))))
  # (hash key-one key-two)
  (my value hash)
  (for key in args
    (if (:hash == (value 0))
      (value = ((value 1) key))
      (return [:nil] if (value == nil))
      else
      (return [:nil])))
  (return value))

(def eval-ne(atoms)
  (my values (eval-atoms atoms))
  (my first-value (values 0))
  (for value in (rest values)
    (return $FALSE if (value == first-value)))
  (return $TRUE))

(def eval-add(args)
  (return (eval-call-ruby :+ args)))

(def eval-inc(atoms)
  (my sym (atoms 0))
  (if ((sym 0) == :sym)
    (my args (eval-atoms atoms))
    (my add-value (eval-add args))
    (return (eval-sym-assign sym add-value)))
  (error "inc syntax error {(sym 0)}"))

(def eval-sub(atoms)
  (my first-atom (atoms 0))
  (if ((first-atom 0) == :sym)
    (if ((atom [1 0]) == :list)
      (my exprs (comp-fn (rest atoms)))
      (my sub-exprs [:sub exprs])
      (return (eval-sym-assign first-atom sub-exprs))))
  (if ((first-atom 0) == :list)
    (my exprs (comp-fn atoms))
    (return [:sub exprs]))
  (error "(sub .. syntax error ({atoms})"))

(def eval-lt($atoms)
  (my $values (eval-atoms $atoms))
  (if (all-is-spp-int $values)
    (my $first-value ($values [0 1]))
    (for $value in (rest $values)
      (return $FALSE if ($first-value >= ($value 1))))
    (return $TRUE))
  (error "> only implement int"))

(def eval-le($atoms)
  (return $TRUE if (is-spp-false (eval-gt $atoms)))
  (return $FALSE))

(def eval-eq(atoms)
  (my values (eval-atoms atoms))
  (my first-value (values 0))
  (for value in (rest values)
    (return $FALSE if (value != first-value)))
  (return $TRUE))

(def eval-gt($args)
  (my $values (eval-atoms $args))
  (if (all-is-spp-int $values)
    (my $first-num (($values 0) 1))
    (for $num in (rest $values))
      (return $FALSE if ($first-num <= ($num 1)))
    (return $TRUE))
  (error "(>= ..) only implement int"))

(def eval-ge($args)
  (return $TRUE if (is-spp-false (eval-lt $args)))
  (return $FALSE))

(def eval-and(atoms)
  (for atom in atoms
    (if ($FALSE == (eval-bool atom))
      (return $FALSE)))
  (return $TRUE))

(def eval-bool(atom)
  (my value (eval-atom atom))
  (return $FALSE if (value == $NIL))
  (return $FALSE if (value == $FALSE))
  (return $TRUE))

(def eval-break()
  (%ST $BLOCK ::break = 1)
  (return $TRUE))

# (case sym (when :str (do sth)) (else do sth))
(def eval-case(atoms)
  (my case-sym (atoms 0))
  (if ((case-sym 0) != :sym)
    (error "case only accept symbol, but {(case-sym 0)}"))
  (my exprs (rest atoms))
  (my case-value (eval-atom case-sym))
  (for branch in exprs
    (if ((branch 0) != :list)
      (error "Case syntax error: {(atom-to-str branch)}"))
    (my expr (branch 1))
    (if ((expr 0) == [:sym, :when])
      (my cond-atom (expr 1))
      (next if (case-value != cond-atom))
      (my true-exprs (add-exprs (expr 2 -1)))
      (return (eval-atom true-exprs)))
    (if ((expr 0) == [:sym, :else])
      (my true-exprs (add-exprs (expr 1 -1)))
      (return (eval-atom true-exprs))))
  (return $FALSE))

# (context Module)
(def eval-context(atom)
  # (say 'in eval-context()')
  # (say atom)
  (return [:context $CONTEXT] if (atom == []))
  (my context-name (eval-atom atom))
  # (say context-name)
  (if ((context-name 0) in [:sym :context :str])
    (return (in-context (context-name 1))))
  (error "syntax error: (context {atom})"))

(def eval-def(atoms)
  (my first-atom (atoms 0))
  (if ((first-atom 0) == :sym)
    (if ((atom [1 0]) == :list)
      (my exprs (comp-fn (rest atoms)))
      (return (eval-sym-assign first-atom [:fn exprs]))))
  (if ((first-atom 0) == :list)
    (my exprs (comp-fn atoms))
    (return [:fn exprs]))
  (error "(def .. syntax error ({atoms})"))

(def eval-lambda(atoms)
  (if ((len atoms) < 2)
    (error 'define accept at least two argment'))
  (my exprs (rest atoms))
  (if ((len exprs) == 0)
    (error 'define accept at least one exprssion'))
  (my def-exprs (add-exprs exprs))
  (my args (atoms [0 1]))
  (return [[], def-exprs] if ((len args) == 0))
  # (get-atoms-type only could process at least two element
  (if ((get-atoms-type args) == [:sym])
    (return [args, def-exprs]))
  (error "def args should is symbol {args}"))

(def eval-defined($args)
  # (exsts symbol)
  (my $atom ($args 0))
  (if (is-spp-sym $atom)
    (my $sym-name ($atom 1))
    (for $context in @CONTEXT-STACK
       (return $TRUE if (exists %ST $context $sym-name)))
    (return $FALSE)))

(def eval-delete(args)
  (if (is-match-atoms args)
    (my ($atom $key) (eval-atoms args))
    # (delete hash key)
    (if (($atom 0) == :hash)
      (my hash-value ($atom 1))
      (my $new-hash-value [])
      (for $pair in $hash-value
        (next if ($key == ($pair 0)))
        ($new-hash-value << $pair))
      (return [:hash, $new-hash-value]))
    # (delete array element)
    (if (($atom 0) == :array)
      (my array (value 1))
      (return [:nil] if (not (key in array)))
      (delete array key)
      (return [:array, array])))
  # (delete symbol) => undefined
  (if ((len args) == 1)
    (if ((sym 0) == :sym)
      (my $name (sym 1))
      (for context in @CONTEXT-STACK
        (if (exists %ST context $name)
          (delete %ST context $name)
          (return $TRUE)))
      (return [:nil])))
  (error "Not implement delete {sym[0]}"))

(def eval-end($args)
  (my $atom ($args 0))
  (if (is-spp-sym $atom)
    (if ($CONTEXT == ($atom 1))
      (return (out-context $CONTEXT))
      else
      (error "out context is not current context")))
  (error "(end ..) not context {($atom 0)}"))

(def eval-to-i($args)
  (my $atom (eval-atom ($args 0)))
  (if (is-spp-str $atom)
    (my $num ($atom 1))
    (if ($num ~~ '\d+')
      (return [:int (to-i $num)])
      else
        (error "Could not transfer str: {$num} to int")))
  (retrun $atom if (is-spp-int $atom))
  (error "Could not transfer {($atom 0)} to int"))

(def eval-exists($args)
  # (exists hash key)
  (my $atoms (eval-atoms $args))
  (my ($atom $key) $atoms)
  (if (is-spp-hash $atom)
    (return $TRUE if (exists $atom $key))
    (return $FALSE))
  # (exists file-name)
  (if (is-spp-str $atom)
    (return $TRUE if (exists ($atom 1)))
    (return $FALSE)))

# (for x in array (next if (x == 2)))
(def eval-for(atoms)
  (if ((len atoms) < 4)
    (error "(for .. len less 4)"))
  (if ((atoms 1) != [:sym :in])
    (error "for lost <in>"))
  (my var (atoms 0))
  (my array (eval-atom (atoms 2)))
  (my $array-value (array 1))
  (my exprs (atoms 3 -1))
  (if ((var 0) == :sym)
    (if ((array 0) == :array)
      (return (eval-for-array var $array-value exprs))))
  (if ((var 0) == :list)
     (if ((array 0) == :hash)
      (my $pair (var 1))
      (if (all-is-spp-sym $pair)
        (return (eval-for-hash $pair $array-value exprs))))))

(def eval-for-array($var $array $exprs)
  (my $return-value $TRUE)
  (for $element in $array
    (my $context (uuid))
    (eval-local-declare $var $element)
    ($return-value = (eval-exprs $exprs))
    (if ((%ST $CALL ::return) == 1)
      (out-block $context)
      (return $return-value))
    (if ((%ST $CONTEXT ::break) == 1)
     (out-block $context)
     (break))
    (out-block context))
  (return $return-value))

(def eval-for-hash($var-pair, $hash, $exprs)
  (my $return-value $TRUE)
  (for $pair in $hash
    (my $context (uuid))
    (in-block $context)
    (eval-multi-local-declare $var-pair $pair)
    (if ((%ST $CALL ::return) == 1)
      (out-block $context)
      (return $return-value))
    (if ((%ST $CONTEXT ::break) == 1)
     (out-block $context)
     (break))
    (out-block context))
  (return $return-value))

# (if (a > 1) a b c elsif b c d)
(def eval-if(atoms)
  (if ((len atoms) < 2) (error "(if ..) elements < 2"))
  (my cond-expr (atoms 0))
  (my true-atoms [ (atoms 1) ])
  (my $index 2)
  (while ($index < (len atoms))
    (my atom (atoms $index))
    (if (atom == [:sym :elsif])
      (if ((eval-bool cond-expr) == $TRUE)
        (return (eval-exprs true-atoms)))
      (my $if-exprs (atoms ($index + 1) -1))
      (return (eval-if $if-exprs)))
    (if (atom == [:sym :else])
      (if ((eval-bool cond-expr) == $TRUE)
        (return (eval-exprs true-atoms)))
      (my else-atoms (atoms ($index + 1) -1))
      (return (eval-exprs else-atoms))
      else
      (true-atoms << atom)
      (pos += 1)))
  (return $FALSE if ((eval-bool cond-expr) == $FALSE))
  (return (eval-exprs true-atoms)))

(def eval-load($file)
  (if (($file 0) == :str)
    (my $file-name ($file 1))
    (my $parse-str (read-file $file-name))
    (my $match-ast (match-rule $RULE $parse-str))
    (if (is-match $match-ast)
      (return (eval-atom (opt-atom $match-ast)))))
  (error "Load only could accept file name"))

(def eval-match($args)
  (my $atoms (eval-args $args))
  (my (match-str match-rule) $atoms)
  (my $str ($match-str 1))
  (my $rule-str ($rule 1))
  (if ((match-str 0) == :str)
    (if (($match-rule 0) == :str)
      (return $TRUE if ($str ~~ $rule-str))
      (return $FALSE))
    (if ((match-rule 0) == :rule)
      (my %cursor (create-cursor $str))
      (my $match (match-atom ($rule-str %cursor)))
      (return $FALSE if ($match == false))
      (return (value-to-atom $match)))
    (if ((match-rule 0) == :context)
      (my $match (match-rule $rule-str $str))
      (return $FALSE if ($match == false))
      (return (value-to-atom $match))))
  (error "{$str} Could not ~~ {$rule-str}"))

(def eval-my(atoms)
  # (my x)
  (if ((len atoms) == 1)
    (if ((atoms [0 0]) == :sym)
      (my sym (atoms 0))
      (return (add-my-sym sym [:nil])))
    # (my (x y z))
    (if ((atoms [0 0]) == :list)
      (my syms (atoms [0 1]))
      (my values (fill-array (len syms) [:nil]))
      (return (eval-my-bind syms values))))
  # (my x 1)
  (if ((len atoms) == 2)
    (if ((atoms [0 0]) == :sym)
      (my sym (atoms 0))
      (my value (eval-atom (atoms 1)))
      (return (add-my-sym sym value)))
    # (my (x y z) [1 2])
    (if ((atoms [0 0]) == :list)
      (my syms (atoms [0 1]))
      (my array (eval-atom (atoms 1)))
      (if ((array 0) == :array)
        (my values (array 1))
        (return (eval-my-bind syms values)))
      (error "my value not array: {array}")))
  (error "my syntax error: ({get-atoms-str(atoms)})"))

(def eval-next()
  (%ST $BLOCK ::next = 1)
  (return $TRUE))

(def eval-not(atom)
  (return $TRUE if ($FALSE == (eval-bool atom)))
  (return $FALSE))

(def eval-ok(atoms)
  (my (expr expect) atoms)
  (my expr-str (atom-to-str expr))
  (my expect-str (atom-to-str expect))
  (my message-str "{expr-str} == {expect-str}")
  (my expr-get (eval-atom expr))
  (my expect-get (eval-atom expect))
  (@TC += 1)
  (if (expr-get == expect-get)
    (say "ok {@TC} - {message-str}")
    else
    (say "not {@TC} - {message-str}")
    (my $expr-get-str (atom-to-str expr-get))
    (say "get: {expr-get-get} expect: {expect-get}"))
  (return $TRUE))

(def eval-or(atoms)
  (for atom in atoms
    (next if (is-false (eval-atom atom)))
    (return $TRUE))
  (return $FALSE))

(def eval-return($args)
  (my $atom ($args 0))
  (%ST $CALL ::return = 1)
  (return (eval-atom $atom)))

(def eval-rule($args)
  (my $atoms (eval-atoms $args))
  # spp have keyword like: rule rest
  (my ($name $rule) $atoms)
  (if (and (($name 0) == :sym) (($rule 0) == :rule))
    (return (eval-local-declare $name $rule)))
  (error "Syntax error: eval-rule {atoms}"))

(def eval-say($args)
  (my $atom ($args 0))
  (say (atom-to-str (eval-atom $atom)))
  (return $TRUE))

# (hash key-one key-two = value)
(def eval-set(hash, atoms)
  (my hash-value (hash 1))
  (my keys (atoms 0 -3))
  (my value (atoms -1))
  (if (1 == (len keys))
    (hash-value (keys 0) = value)
    (return hash))
  (if (2 == (len keys))
    (if (exists hash-value (keys 0))
      (if (((hash-value (key 0)) 0) == :hash)
        (((hash-value (keys 0)) 1) (keys 1) = value)
        (return hash))
      (error "{hash} key {(keys 0)} is not hash")))
  (error 'Hash assign only support two depth'))

(def eval-shift($args)
  (my $sym ($args 0))
  (if (($sym 0) == :sym)
    (my $array (eval-sym ($sym 1)))
    (my $array-value ($array 1))
    (shift $array-value)
    (return [:array $array-value])))

(def eval-type($args)
  (my $atom ($args 0))
  (my $type (type (eval-atom $atom)))
  (return [:str, $type]))

(def eval-is($args)
  (my $atoms (eval-atoms $args))
  (my ($sym $type) $atoms)
  (my $type-str (type $type))
  (if ($type-str == :str)
    (if ((type $sym) == ($type 1))
       (return $TRUE))
    else
      (return $FALSE))
  (error "could not compare {$type-str}, only accept str"))

(def eval-assign(atoms)
  # (x = 2)
  (my $head-atom (atoms 0))
  (if (($head-atom 0) == :sym)
    (my value (eval-atom (atoms 1)))
    (return (eval-sym-assign $head-atom value)))
  # (x y z) = [1 2 3]
  (if (($head-atom 0) == :list)
    (my $syms ($head-atom 1))
    (my $array (eval-atom (atoms 1)))
    (if (($array 0) == :array)
      (if (all-is-spp-sym $syms)
        (my $values ($array 1))
        (return (eval-syms-assign $syms $values)))))
  (error "assign syntax error: ({atoms})"))

# (while (x > 1) (break if (x == 1)))
(def eval-while(atoms)
  (if ((len atoms) < 2)
    (error 'while accept at least 2 argument'))
  (my guide-expr (atoms 0))
  (my while-exprs (rest atoms))
  (my return-value $TRUE)
  (while (bool (eval-atom guide-expr))
    (my $context (uuid))
    (in-block $context)
    (return-value = (eval-exprs while-exprs))
    (if ((%ST $CALL ::return) == 1)
      (out-block $context)
      (return return-value))
    (if ((%ST $CONTEXT ::break) == 1)
      (out-block $context)
      (break))
    (out-block $context))
  (return return-value))

(def eval-push(atoms)
  (my $eval-atoms (eval-atoms atoms))
  (my ($array, $element) $eval-atoms)
  (if (is-spp-array $array)
    (my $array-value ($array 1))
    ($array-value << $element)
    (return [:array $array-value])))

(def eval-unshift(atoms)
  (my $eval-atoms (eval-atoms atoms))
  (my ($element, $array) $eval-atoms)
  (if (is-spp-array $array)
    (my $array-value ($array 1))
    ($element >> $array-value)
    (return [:array, $array-value])))

(def eval-in($args)
  (my $atoms (eval-atoms $args))
  (my ($element $array) $atoms)
  (if (is-spp-array $array)
    (return $TRUE if ($element in ($array 1)))
    (return $FALSE))
  (error "Only implement in <array>"))

(def spp(spp-file)
  (my spp-str (trim (read-file spp-file)))
  (boot-spp)
  (my $match (match-rule $RULE spp-str))
  (return nil if (is-str $match))
  (if (is-match $match)
    (my opt-ast (opt-atom $match))
    (eval-atom opt-ast))
  (error "syntax error for {spp-file}"))

(def boot-spp()
  (my $rule-file (get-rule-file :spp))
  (my $spp-rule (load-file $rule-file))
  (my $boot-rule (eval-atom $spp-rule))
  (return $TRUE if ($boot-rule == [:context, $Rule]))
  (error "Could not Boot Spp rule"))

(def repl()
  (boot-spp)
  (say "This is Spp REPL, type 'exit' to exit")
  (while 1
    (print ">>> ")
    (my $line (gets))
    (my $str (trim $line))
    (exit if (str == :exit))
    (my match (match-rule $RULE $str))
    (if (is-match match)
      (my opt-ast (opt-atom match))
      (my eval-value (eval-atom opt-ast))
      (say (atom-to-str eval-value))
      else
      (error "syntax error: {str}"))))

(my spp-file (@ARGV 1))

(if spp-file (spp spp-file) else (repl))
