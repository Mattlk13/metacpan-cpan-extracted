#!/usr/bin/perl

use strict;
use warnings;

use Device::AVR::UPDI;
use Getopt::Long;
use List::Util qw( first );

GetOptions(
   'port|P=s' => \( my $PORT = "/dev/ttyUSB0" ),
   'part|p=s' => \( my $PART ),
) or exit 1;

my $updi = Device::AVR::UPDI->new(
   dev => $PORT,
   part => $PART,
);

$updi->init_link->get;

unless( $updi->read_asi_sys_status->get & (1<<3) ) {
   $updi->enable_nvmprog->get;
}

my $sig = $updi->read_signature->get;
if( $updi->partinfo->signature ne $sig ) {
   printf STDERR "Signature %v02X does not match expected %v02X\n",
      $sig, $updi->partinfo->signature;
   exit 1;
}

my @FUSES = @{ $updi->partinfo->fusenames };

foreach( @ARGV ) {
   my ( $name, $value ) = split m/=/, $_;
   my $idx = first { defined $FUSES[$_] and $FUSES[$_] eq $name } 0 .. $#FUSES or
      die "Unrecognised fuse";

   $value = hex $value if $value =~ m/^0x/;
   printf "Setting %s to %x\n", $name, $value;

   $updi->write_fuse( $idx, $value )->get;
}

$updi->request_reset( 1 )->get;
$updi->request_reset( 0 )->get;

__END__

=head1 NAME

F<avr-updi-write-fuses> - write fuse values to an F<AVR> microcontroller over F<UPDI>

=head1 SYNOPSIS

   $ avr-updi-write-fuses -p t814 BODCFG=02

=head1 DESCRIPTION

This program writes fuse values to an F<AVR> microcontroller using a F<UPDI>
interface.

=head1 OPTIONS

=head2 --port, -P DEVICE

Optional. Provides the USB device where the UPDI adapter is connected. If
absent a default of F</dev/ttyUSB0> will apply.

=head2 --part, -p PART

Required. Gives the name of the ATmega or ATtiny chip that is expected. Parts
may be specified in the following ways:

   ATmega4809
   atmega4809
   m4809

   ATtiny814
   attiny814
   t814

Specifically, these are the same forms as recognised by F<avr-gcc>'s C<-mmcu>
option and F<avrdude>'s C<-p> option, for convenience in Makefiles and build
scripts.

=head1 AUTHOR

Paul Evans <leonerd@leonerd.org.uk>
