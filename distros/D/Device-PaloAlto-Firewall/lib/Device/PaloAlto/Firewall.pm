package Device::PaloAlto::Firewall;

use 5.006;
use strict;
use warnings;

our $VERSION = '0.05'; # VERSION - generated by DZP::OurPkgVersion

use Device::PaloAlto::Firewall::Test;

use Moose;
use Modern::Perl;
use LWP::UserAgent;
use HTTP::Request;
use Carp;
use Params::Validate qw(:all);
use URI;
use XML::Twig;
use Memoize qw{memoize unmemoize};

use Data::Dumper;

=head1 NAME

Device::PaloAlto::Firewall - Interact with the Palo Alto firewall API

=head1 VERSION

version 0.05

=cut

=head1 SYNOPSIS

=head1 CONSTRUCTOR


=head1 RETURN VALUES

=cut

has 'user_agent'    => ( is => 'ro', isa => 'LWP::UserAgent', init_arg => undef, default => sub { LWP::UserAgent->new } );
has 'http_request'  => ( is => 'rw', isa => 'HTTP::Request', init_arg => undef, default => sub { HTTP::Request->new } ); 
has 'uri'           => ( is => 'ro', writer => '_uri', required => 1);

has 'username'      => ( is => 'ro', isa => 'Str', required => 1 );
has 'password'      => ( is => 'ro', isa => 'Str', required => 1 );
has '_api_key'       => ( is => 'rw', init_arg => undef, default => undef );

has 'debug'         => ( is => 'rw', isa => 'Bool', default => 0);


sub BUILD {
    my $self = shift;
    
    #URI string gets changed into a URI object 
    my $uri_obj = URI->new($self->uri);
    if (!$uri_obj->has_recognized_scheme) {
        croak "Unrecognised URI passed to constructor";
    }

    #Set the path to API located
    $uri_obj->path("/api/");
    $self->_uri( $uri_obj );

    # Request method is always GET
    $self->http_request->method( 'GET' );

    return;
}

=head1 METHODS

=head2 verify_hostname 

Enables/disables the verification of the peer certificate and hostname if 'https' is used for API calls.

    $fw->verify_hostname(1); Enable TLS peer verification
    $fw->verify_hostname(0); Disable TLS verification

=cut

sub verify_hostname {
    my $self = shift;
    my $verify_bool = shift;
    my $verify_mode = $verify_bool ? 
        0x01        # 'SSL_VERIFY_PEER' 
        :
        0x00;       # 'SSL_VERIFY_NONE'

    $self->user_agent->ssl_opts( verify_hostname => $verify_bool, SSL_verify_mode => $verify_mode );

    return;
}

=head2 optimise 

Enables/disables the local caching of requests and responses to the firewall. This is disabled by default.

    $fw->optimise(1);                           # Enable optimisation
    my $system_info = $fw->system_info();       # API call to retrieve interface information
    $system_info = $fw->system_info();          # Information retrieved from local cache

The first call to C<system_info()> will make an API call to the firewall and cache the result. The second request will retrieve the response from the local cache without making an API call.
Under the covers it uses C<Memoize> to cache the API request call. This means that each function & arguments receive their own cache. For example:
    
    $fw->optimise(1); 
    my $default_vr bgp_peers = $fw->bgp_peers(vrouter => 'default');
    my $other_vr_bgp_peers = $fw->bgp_peers(vrouter => 'other');

Both of these methods would make an API call to the firewall as the arguments differ.

=cut

sub optimise {
    my $self = shift;
    my $bool = shift;
   
    if ($bool) { 
        memoize('Device::PaloAlto::Firewall::_send_request');
    } else {
        unmemoize('Device::PaloAlto::Firewall::_send_request');
    }

    return;
}

=head2 tester

Retrieves a C<Device::PaloAlto::Firewall::Test> object for this firewall.

    use Test::More;
    my $test = Device::PaloAlto::Firewall->new(uri => 'http://remote_pa.domain', username => 'test', password => 'test')->tester();

    ok( $test->interfaces_up(interfaces => ['ethernet1/1']) );

For more information, see the L<Device::PaloAlto::Firewall::Test> documentation.
    
=cut

sub tester {
    my $self = shift;

    return Device::PaloAlto::Firewall::Test->new(firewall => $self);
}


=head2 system_info

Returns system information from the firewall.

    my $system_info = $fw->system_info();
    say "Current Time on Firewall: $system_info->{time}";

=cut

sub system_info {
    my $self = shift;
    my $system_info = $self->_send_request(command => "<show><system><info></info></system></show>");
    return $system_info->{system};
}

=head2 environmentals

Returns information on the system environmentals. This includes the fantray and fans, power supplies and power, temperature. B<Note:> virtual machines don't have any environmental information and won't return any information.

=cut

sub environmentals {
    my $self = shift;

    my $environs = $self->_send_request(command => "<show><system><environmentals></environmentals></system></show>");

    # If there's only one 'entry', we get
    # { $property => { $slot => { 'entry' => { %info } } } }
    #
	# If there's more than one we get:
    # { $property => { $slot => { 'entry' => [ { %info } ] } } }
    #
	# We modify the structure to remove the redundant 'entry' and make sure
	# Single and multiple '%info' hashes are in an arrayref
    # { $property => { $slot => [ { %info } ] } }
									
    for my $property (values %{ $environs }) {
        for my $slot (values %{ $property }) {
            $slot = (ref($slot->{entry}) eq 'HASH') ? [ $slot->{entry} ] : $slot->{entry};
        }
    }

    return $environs;
}

=head2 interfaces

Retrieves interface information.

=cut 

sub interfaces {
    my $self = shift;
    my $interfaces = $self->_send_request(command => "<show><interface>all</interface></show>");
	return $interfaces;
}

=head2 high_availability

Retrieves information on the high availability status of the firewall.

=cut

sub high_availability {
    my $self = shift;
    return $self->_send_request(command => "<show><high-availability><all></all></high-availability></show>");
}

=head2 ntp

Retrieves information on the current synchronisation and reachability of configured NTP peers.

=cut

sub ntp {
    my $self = shift;
    return $self->_send_request(command => "<show><ntp></ntp></show>");
}

=head2 routing_table

Retrives information on the routing table for a particular virtual router. If no C<vrouter> argument is specified it retrieves the 'default' vrouter's routing table.

    my $default_vr_table = $fw->routing_table();
    my $corp_vr_table = $fw->routing_table(vrouter => 'corp');

=cut

sub routing_table {
    my $self = shift;
    my %args = validate(@_,
        {
            vrouter => { default => 'default', type => SCALAR | UNDEF },
        }
    );

    # TODO: Have a look at sanitising the argument passed to the firewall.
    my $routing_table = $self->_send_request(command => "<show><routing><route><virtual-router>$args{vrouter}</virtual-router></route></routing></show>");
	return $routing_table->{entry};
}

=head2 bgp_peers 

Retrieves information on the configured BGP peers for a particular virtual router. If no C<vrouter> argument is specified it retrieves the 'default' vrouter's BGP peers.

    my $default_vr_bgp_peers = $fw->bgp_peers();
    my $corp_vr_bgp_peers = $fw->bgp_peers(vrouter => 'corp');
    

=cut

sub bgp_peers {
    my $self = shift;
    my %args = validate(@_,
        {
            vrouter => { default => 'default', type => SCALAR | UNDEF },
        }
    );

    # TODO: Have a look at sanitising the argument passed to the firewall.
    my $bgp_peer_response = $self->_send_request(command => 
        "<show><routing><protocol><bgp><peer><virtual-router>$args{vrouter}</virtual-router></peer></bgp></protocol></routing></show>"
    );

	return [] if !$bgp_peer_response; # No BGP peers configured.

    return if !defined $bgp_peer_response; 

    # If there's one peer, we get a HASH. Rap it up as a one member array to align with the multiple peer scenario
    if (defined $bgp_peer_response->{entry} && ref $bgp_peer_response->{entry} eq 'HASH') {
        $bgp_peer_response->{entry} = [ $bgp_peer_response->{entry} ];
    }

    return $bgp_peer_response->{entry};
}

=head2 panorama_status

Returns information on the current Panorama runtime status.

=cut

sub panorama_status {
    my $self = shift;

    my $panorama_status = $self->_send_request(command => '<show><panorama-status></panorama-status></show>');

    return [] if !$panorama_status; # No Pa
}


=head2 ip_user_mapping

Returns the ip to user mapping table.

=cut

sub ip_user_mapping {
    my $self = shift;

    my $ip_user_mappings = $self->_send_request(command => '<show><user><ip-user-mapping><all></all></ip-user-mapping></user></show>');

    if (ref $ip_user_mappings->{entry} eq 'HASH') {
        $ip_user_mappings = [ $ip_user_mappings->{entry} ];
    } else {
        $ip_user_mappings = $ip_user_mappings->{entry};
    }

    # Split the user and domain into their own keysL
    IP_USER_MAP:
    for my $user_map (@{ $ip_user_mappings }) {
        if (lc $user_map->{user} eq 'unknown') {
            $user_map->{domain} = 'unknown';
            next IP_USER_MAP;
        }


        # Split on the backslash
        my @domain_and_user = split(m{\\}, $user_map->{user});
        carp "User to IP mapping contains no deliniaton ('\\') between domain and user: $user_map->{user}" if @domain_and_user != 2;
        
        $user_map->{domain} = $domain_and_user[0];
        $user_map->{user} = $domain_and_user[1];
    }

    return $ip_user_mappings;
}


=head2 userid_server_monitor

Returns the state of the servers used to monitor User-ID IP-to-user mappings.

=cut

sub userid_server_monitor {
    my $self = shift;
    my @ret;

    my $server_monitor = $self->_send_request(command => '<show><user><server-monitor><statistics></statistics></server-monitor></user></show>');

    return {} if !$server_monitor;

    # Clean up the output, turning it into an ARRARREF rather than a HASHREF keyed on the server name
    for my $server (keys %{ $server_monitor->{entry} }) {
        $server_monitor->{entry}->{ $server }->{name} = $server;
        push @ret, $server_monitor->{entry}->{ $server };
    }

    return \@ret;
}

sub _send_request {
    my $self = shift;
    my %args = validate(@_,
        {
            command => 1,
        }
    );

    # Is the API key defined? If not, request one.
    if (!defined $self->_api_key) {
        $self->uri->query( "type=keygen&user=".$self->username."&password=".$self->password );
        $self->_debug_print("[REQUEST] ".$self->uri->as_string);
        $self->http_request->uri( $self->uri->as_string );

        # Clear the query
        $self->uri->query(undef);

        my $api_key_response = $self->user_agent->request( $self->http_request );
        my $api_key_struct = $self->_validate_and_return_response( $api_key_response ); 

        return if !$api_key_struct; # Already carped within _validate_and_return_response 

        $self->_api_key( $api_key_struct->{result}->{key} );
    }
   
    $self->uri->query( "type=op&cmd=$args{command}&key=".$self->_api_key );
    $self->http_request->uri( $self->uri->as_string );
    $self->_debug_print("[REQUEST] ".$self->uri->as_string);
    $self->uri->query(undef);

    # Send the request
    my $http_response = $self->user_agent->request( $self->http_request );
    
    my $structure_response = $self->_validate_and_return_response($http_response);
    return (defined $structure_response ? $structure_response->{result} : $structure_response);
}


# _validate_and_return_response($self, $http_response)
#   * Checks for HTTP error codes
#   * Converts from XML to a Perl reference
#   * Checks the API error codes
#   * If successful, returns the reference
#   * If there's an error, carps and returns undef.

sub _validate_and_return_response {
    my $self = shift;
    my $http_response = shift;
    my $xml_parser = XML::Twig->new();

    # Check the HTTP response codes
    if ($http_response->is_error) {
        carp "HTTP Error (".$http_response->code.")";
        return;
    }

    $self->_debug_print("[RESPONSE]: ".$http_response->decoded_content);

    my $response_structure = $xml_parser->safe_parse( $http_response->decoded_content )->simplify();

    # Check the API response codes
    if ($response_structure->{status} eq 'error') {
        if (!defined $response_structure->{code}) {
            carp "Unknown API error";
        } else {
            carp "API Error ($response_structure->{code}) - ".$self->_api_error_to_string($response_structure->{code});
        }
        return;
    }

    return $response_structure;
}


sub _api_error_to_string {
    my $self = shift;
    my $code = shift;

	my %code_map = (
		400 => 'Bad request', 
		403 => 'Forbidden',
		1 => 'Unknown command',
		2 => 'Internal error (2)',
		3 => 'Internal error (3)',
		4 => 'Internal error (4)',
		5 => 'Internal error (5)',
		6 => 'Bad Xpath', 
		7 => 'Object not present', 
		8 => 'Object not unique', 
		10 => 'Reference count not zero', 
		11 => 'Internal error',
		12 => 'Invalid object',
		14 => 'Operation not possible',
		15 => 'Operation denied',
		16 => 'Unauthorized', 
		17 => 'Invalid command',
		18 => 'Malformed', 
		19 => 'Success (19)',
		20 => 'Success (20)',
		21 => 'Internal error',
		22 => 'Session timed out',
	);

    return "" if !defined $code_map{$code};

	return $code_map{$code};
}


sub _debug_print {
    my $self = shift;
    my $debug_msg = shift;
    my $debug_structure = shift;


    print STDERR $debug_msg."\n" if $self->debug == 1;
    print STDERR (Dumper $debug_structure) if $debug_structure;

    return;
}


=head1 AUTHOR

Greg Foletta, C<< <greg at foletta.org> >>

=head1 BUGS

Please report any bugs or feature requests to C<bug-device-paloalto at rt.cpan.org>, or through
the web interface at L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Device-PaloAlto>.  I will be notified, and then you'll
automatically be notified of progress on your bug as I make changes.




=head1 SUPPORT

You can find documentation for this module with the perldoc command.

    perldoc Device::PaloAlto::Firewall


You can also look for information at:

=over 4

=item * RT: CPAN's request tracker (report bugs here)

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Device-PaloAlto>

=item * AnnoCPAN: Annotated CPAN documentation

L<http://annocpan.org/dist/Device-PaloAlto>

=item * CPAN Ratings

L<http://cpanratings.perl.org/d/Device-PaloAlto>

=item * Search CPAN

L<http://search.cpan.org/dist/Device-PaloAlto/>

=back


=head1 ACKNOWLEDGEMENTS


=head1 LICENSE AND COPYRIGHT

Copyright 2017 Greg Foletta.

This program is free software; you can redistribute it and/or modify it
under the terms of the the Artistic License (2.0). You may obtain a
copy of the full license at:

L<http://www.perlfoundation.org/artistic_license_2_0>

Any use, modification, and distribution of the Standard or Modified
Versions is governed by this Artistic License. By using, modifying or
distributing the Package, you accept this license. Do not use, modify,
or distribute the Package, if you do not accept this license.

If your Modified Version has been derived from a Modified Version made
by someone other than you, you are nevertheless required to ensure that
your Modified Version complies with the requirements of this license.

This license does not grant you the right to use any trademark, service
mark, tradename, or logo of the Copyright Holder.

This license includes the non-exclusive, worldwide, free-of-charge
patent license to make, have made, use, offer to sell, sell, import and
otherwise transfer the Package with respect to any patent claims
licensable by the Copyright Holder that are necessarily infringed by the
Package. If you institute patent litigation (including a cross-claim or
counterclaim) against any party alleging that the Package constitutes
direct or contributory patent infringement, then this Artistic License
to you shall terminate on the date that such litigation is filed.

Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER
AND CONTRIBUTORS "AS IS' AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES.
THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, OR NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY
YOUR LOCAL LAW. UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR
CONTRIBUTOR WILL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, OR
CONSEQUENTIAL DAMAGES ARISING IN ANY WAY OUT OF THE USE OF THE PACKAGE,
EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


=cut

1; # End of Device::PaloAlto::Firewall
