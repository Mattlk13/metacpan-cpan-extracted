.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dist::Zilla::Role::ErrorLogger 3pm"
.TH Dist::Zilla::Role::ErrorLogger 3pm "2015-10-26" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dist::Zilla::Role::ErrorLogger \- Have error logging capabilities in your Dist::Zilla plugin
.SH "VERSION"
.IX Header "VERSION"
Version v0.9.0, released on 2015\-10\-26 21:04 \s-1UTC.\s0
.SH "WHAT?"
.IX Header "WHAT?"
\&\f(CW\*(C`Dist\-Zilla\-Role\-ErrorLogger\*(C'\fR is a \f(CW\*(C`Dist::Zilla\*(C'\fR role. It provides \f(CW\*(C`log_error\*(C'\fR, \f(CW\*(C`abort\*(C'\fR, and
\&\f(CW\*(C`abort_if_errors\*(C'\fR methods to consuming plugins.
.PP
This is \f(CW\*(C`Dist::Zilla::Role::ErrorLogger\*(C'\fR role documentation. Read this if you want to
have error logging capabilities in your Dist::Zilla plugin.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    package Dist::Zilla::Plugin::YourPlugin;
\&    use Moose;
\&    use namespace::autoclean;
\&    with \*(AqDist::Zilla::Role::Plugin\*(Aq;
\&    with \*(AqDist::Zilla::Role::ErrorLogger\*(Aq;
\&
\&    sub method {
\&        my $self = shift( @_ );
\&
\&        if ( $cond ) { $self\->log_error( \*(Aqerror message\*(Aq ); };
\&
\&        do_something or $self\->log_error( \*(Aqanother error message\*(Aq );
\&
\&        while ( $cond ) {
\&            do_something_else or $self\->log_error( \*(Aqerror message\*(Aq ) and next;
\&            ...;
\&        };
\&
\&        $self\->log_errors_in_file(
\&            $file,
\&            1 => \*(Aqerror message\*(Aq,           # Error at file line 1.
\&            5 => \*(Aqanother error message\*(Aq,   # Error at file line 5.
\&        );
\&
\&        $self\->abort_if_errors( \*(Aqerrors found\*(Aq );
\&    };
\&
\&    _\|_PACKAGE_\|_\->meta\->make_immutable;
\&    1;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The role extends standard \f(CW\*(C`Dist::Zilla\*(C'\fR logging capabilities with few methods a bit more
convenient for reporting (multiple) errors than brutal \f(CW\*(C`log_fatal\*(C'\fR. See \*(L"\s-1WHY\s0?\*(R" for more
details.
.PP
The role requires \f(CW\*(C`log\*(C'\fR method in the consumer.
.SH "OBJECT ATTRIBUTES"
.IX Header "OBJECT ATTRIBUTES"
.SS "error_count"
.IX Subsection "error_count"
.Vb 1
\&    $int = $self\->error_count;
.Ve
.PP
\&\f(CW\*(C`Int\*(C'\fR, read-only. Number of logged errors (i. e. number of made \f(CW\*(C`log_error\*(C'\fR calls).
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "log_error"
.IX Subsection "log_error"
.Vb 2
\&    $self\->log_error( @items );
\&    $self\->log_error( \e%args, @items );
.Ve
.PP
This method calls \f(CW\*(C`log\*(C'\fR method, passing all the arguments, and increments value of \f(CW\*(C`error_count\*(C'\fR
attribute. The method returns true value, so can be used in following constructs:
.PP
.Vb 4
\&    while ( ... ) {
\&        do_something or $self\->log_error( \*(Aqmessage\*(Aq ) and next;
\&        ...
\&    };
.Ve
.SS "abort"
.IX Subsection "abort"
.Vb 2
\&    $self\->abort( @items );
\&    $self\->abort( \e%args, @items );
.Ve
.PP
This is an attempt to workaround \f(CW\*(C`log_fatal\*(C'\fR
drawback <https://github.com/rjbs/Dist-Zilla/issues/397>: in contrast to \f(CW\*(C`log_fatal\*(C'\fR, \f(CW\*(C`abort\*(C'\fR
guarantees the message (which can be quite long) appears on the screen only once.
.PP
The method log the message (via \f(CW\*(C`log\*(C'\fR), then flush \f(CW\*(C`STDOUT\*(C'\fR, then throws an exception of
\&\f(CW\*(C`Dist::Zilla::Role::ErrorLogger::Exception::Abort\*(C'\fR class (which being stringified gives short
message \f(CW"Aborting...\en"\fR).
.SS "abort_if_error"
.IX Subsection "abort_if_error"
.SS "abort_if_errors"
.IX Subsection "abort_if_errors"
.Vb 2
\&    $self\->abort_if_errors( @items );
\&    $self\->abort_if_errors( \e%args, @items );
.Ve
.PP
If there was any errors (i. e. \f(CW\*(C`error_count\*(C'\fR is greater than zero), the logs all the arguments and
aborts execution. Both actions (logging and aborting) are implemented by calling \f(CW\*(C`abort\*(C'\fR.
.PP
\&\f(CW\*(C`abort_if_error\*(C'\fR is an alias for \f(CW\*(C`abort_if_errors\*(C'\fR.
.SS "log_errors_in_file"
.IX Subsection "log_errors_in_file"
The method intended to report errors against a file. It prints file name (and colon after it), then
prints line-numbered file content annotated by error messages. The method does not print entire
file content, but only error lines with surrounding context (2 lines above and below each error
line).
.PP
.Vb 7
\&    $self\->log_errors_in_file(
\&        $file,
\&        $linenum1 => $message1,
\&        $linenum2 => $message2,
\&        $linenum3 => [ $message3a, $message3b, ... ],
\&        ...
\&    );
.Ve
.PP
\&\f(CW$file\fR should be a \f(CW\*(C`Dist::Zilla\*(C'\fR file (e. g. \f(CW\*(C`Dist::Zilla::File::OnDisk\*(C'\fR,
\&\f(CW\*(C`Dist::Zilla::File::InMemory\*(C'\fR, or does role \f(CW\*(C`Dist::Zilla::Role::File\*(C'\fR).
.PP
Errors are specified by pairs \f(CW\*(C`$linenum => $message\*(C'\fR, where \f(CW$linenum\fR is a number of problem
line (one-based), and \f(CW$message\fR is an error message (\f(CW\*(C`Str\*(C'\fR) or array of messages
(\f(CW\*(C`ArrayRef[Str]\*(C'\fR). Order of errors does not matter usually. However, if errors are associated with
the same line (the same line number may appear multiple times), they will be printed in order of
appearance.
.PP
Zero or negative line numbers, or line numbers beyond the last line are invalid. Messages
associated with invalid line numbers are reported in unspecified way.
.PP
Normally, the method prints all the information by calling \f(CW\*(C`log_error\*(C'\fR method and returns a
positive integer. However, If any invalid line numbers are specified, the method returns negative
integer. If no errors are specified, the method prints "No errors found at \fIfile\fR." by calling
\&\f(CW\*(C`log\*(C'\fR (not \f(CW\*(C`log_error\*(C'\fR!) and returns zero.
.PP
\&\s-1TODO:\s0 Example.
.SH "WHY?"
.IX Header "WHY?"
\&\f(CW\*(C`Dist::Zilla\*(C'\fR limits logging capabilities with 3 logging levels available in plugins through
\&\f(CW\*(C`log_debug\*(C'\fR, \f(CW\*(C`log\*(C'\fR, and \f(CW\*(C`log_fatal\*(C'\fR methods. Debug level messages are turned off by default, the
first fatal message terminates \f(CW\*(C`Dist::Zilla\*(C'\fR. This is simple, but sometimes you may want to report
all the errors, instead of stopping at the first found one. In such a case \f(CW\*(C`log_fatal\*(C'\fR cannot be
used, obviously. There are few alternatives:
.PP
Collect error messages in an array, then report all the errors with single \f(CW\*(C`log_fatal\*(C'\fR call:
.PP
.Vb 7
\&    my @errors;
\&    ...
\&    push( @errors, ... );
\&    ...
\&    if ( @errors ) {
\&        $self\->log_fatal( join( "\en", @errors ) );
\&    };
.Ve
.PP
This works, but current implementation of \f(CW\*(C`log_fatal\*(C'\fR has a disadvantage: it prints the message
twice, so output looks ugly. (See message handling in log_fatal is
suboptimal <https://github.com/rjbs/Dist-Zilla/issues/397>.)
.PP
Another approach is reporting each error immediately with \f(CW\*(C`log\*(C'\fR, counting number of reported
errors, and calling \f(CW\*(C`log_fatal\*(C'\fR once at the end:
.PP
.Vb 8
\&    my $error_count = 0;
\&    ...
\&    $self\->log( \*(Aqerror\*(Aq );
\&    ++ $error_count;
\&    ...
\&    if ( $error_count ) {
\&        $self\->log_fatal( \*(AqAborting...\*(Aq );
\&    };
.Ve
.PP
This works, but incrementing the counter after each \f(CW\*(C`log\*(C'\fR call is boring and error-prone.
\&\f(CW\*(C`Dist\-Zilla\-Role\-ErrorLogger\*(C'\fR role automates it, making plugin code shorter and more readable:
.PP
.Vb 5
\&    with \*(AqDist\-Zilla\-Role\-ErrorLogger\*(Aq;
\&    ...
\&    $self\->log_error( \*(Aqerror\*(Aq );
\&    ...
\&    $self\->abort_if_errors();
.Ve
.SH "NOTES"
.IX Header "NOTES"
All the methods defined in the role log items through the \f(CW\*(C`log\*(C'\fR method. \f(CW\*(C`Dist::Zilla\*(C'\fR takes this
method from \f(CW\*(C`Log::Dispatchouli\*(C'\fR, the latter uses \f(CW\*(C`String::Flogger\*(C'\fR to process the messages. It
means you can use \f(CW\*(C`String::Flogger\*(C'\fR tricks, e. g.:
.PP
.Vb 2
\&    $self\->log_error( [ \*(Aqoops at %s line %d\*(Aq, $file, $line ] );
\&        #   [] are shorter than sprintf.
.Ve
.PP
Also note how \f(CW\*(C`Log::Dispatchouli\*(C'\fR describes the \f(CW\*(C`log\*(C'\fR method:
.PP
.Vb 1
\&    $logger\->log( @messages );
.Ve
.PP
and says:
.PP
.Vb 1
\&    Each message is flogged individually, then joined with spaces.
.Ve
.PP
So beware. A call
.PP
.Vb 1
\&    $self\->log_error( \*(Aqerror 1\*(Aq, \*(Aqerror 2\*(Aq );
.Ve
.PP
logs \fIone\fR message \*(L"error 1 error 2\*(R", \fInot\fR \fItwo\fR messages \*(L"error 1\*(R" and \*(L"error 2\*(R", and bumps
\&\f(CW\*(C`error_count\*(C'\fR by 1, not 2.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Dist::Zilla" 4
.IX Item "Dist::Zilla"
.PD 0
.IP "Dist::Zilla::Role" 4
.IX Item "Dist::Zilla::Role"
.IP "Dist::Zilla::Plugin" 4
.IX Item "Dist::Zilla::Plugin"
.IP "Log::Dispatchouli" 4
.IX Item "Log::Dispatchouli"
.IP "String::Flogger" 4
.IX Item "String::Flogger"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Van de Bugger <van.de.bugger@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2015 Van de Bugger
.PP
License GPLv3+: The \s-1GNU\s0 General Public License version 3 or later
<http://www.gnu.org/licenses/gpl\-3.0.txt>.
.PP
This is free software: you are free to change and redistribute it. There is
\&\s-1NO WARRANTY,\s0 to the extent permitted by law.
