.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dist::Zilla::Role::Hooker 3pm"
.TH Dist::Zilla::Role::Hooker 3pm "2018-03-15" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dist::Zilla::Role::Hooker \- Run Perl code written in your plugin's dist.ini section
.SH "VERSION"
.IX Header "VERSION"
Version v0.8.4, released on 2018\-03\-15 21:44 \s-1UTC.\s0
.SH "WHAT?"
.IX Header "WHAT?"
\&\f(CW\*(C`Dist\-Zilla\-Plugin\-Hook\*(C'\fR (or just \f(CW\*(C`Hook\*(C'\fR) is a set of \f(CW\*(C`Dist\-Zilla\*(C'\fR plugins. Every plugin executes Perl
code inlined into \fIdist.ini\fR at particular stage of build process.
.PP
This is \f(CW\*(C`Hooker\*(C'\fR role documentation. Read this if you are going to hack or extend
\&\f(CW\*(C`Dist\-Zilla\-Plugin\-Hook\*(C'\fR, or use the role in your plugin.
.PP
If you want to write \f(CW\*(C`Dist::Zilla\*(C'\fR plugin directly in \fIdist.ini\fR, read the manual. General
topics like getting source, building, installing, bug reporting and some others are covered in the
\&\fI\s-1README\s0\fR.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Dist\-Zilla\-Plugin\-Hook\*(C'\fR is a set of plugins: \f(CW\*(C`Hook::Init\*(C'\fR, \f(CW\*(C`Hook::BeforeBuild\*(C'\fR, \f(CW\*(C`Hook::GatherFiles\*(C'\fR,
etc. All these plugins are just stubs, they contains almost no code. They just use services
provided by the \f(CW\*(C`Hooker\*(C'\fR role. The role is an engine for all \f(CW\*(C`Hook\*(C'\fR plugins.
.SH "OBJECT ATTRIBUTES"
.IX Header "OBJECT ATTRIBUTES"
.SS "code"
.IX Subsection "code"
Perl code to execute, list of lines (without newline characters).
.PP
\&\f(CW\*(C`ArrayRef[Str]\*(C'\fR, read-only. Default value is empty array (i. e. no code).
.PP
Note: \f(CW\*(C`init_arg\*(C'\fR attribute property set to \*(L".\*(R". In \fIdist.ini\fR file the Perl code should be
specified using this notation:
.PP
.Vb 2
\&    [Hook::Role]
\&        . = XPerl codeX
.Ve
.SH "OBJECT METHODS"
.IX Header "OBJECT METHODS"
.SS "hook"
.IX Subsection "hook"
.Vb 3
\&    $ret = $self\->hook( @args );
\&    @ret = $self\->hook( @args );
\&    $self\->hook( @args );
.Ve
.PP
This is the primary method of the role. The method executes Perl code specified in \f(CW\*(C`code\*(C'\fR
attribute (prepended with \f(CW\*(C`_prologue\*(C'\fR) with string form of \f(CW\*(C`eval\*(C'\fR. The method passes arguments
specified by the caller to the code, and passes the code return value back to the caller. Calling
context (list, scalar, or void) is preserved. The method also hides all the lexical variables
(except the variables documented below) from code. The method intercepts warnings generated in code
and logs them; warnings do not stop executing.
.PP
Following lexical variables are exposed to the code intentionally:
.ie n .IP "@_" 4
.el .IP "\f(CW@_\fR" 4
.IX Item "@_"
\&\f(CW\*(C`hook\*(C'\fR arguments, self-reference is already shifted!
.ie n .IP "$arg" 4
.el .IP "\f(CW$arg\fR" 4
.IX Item "$arg"
The same as \f(CW$_[ 0 ]\fR.
.ie n .IP "$self" 4
.el .IP "\f(CW$self\fR" 4
.IX Item "$self"
.PD 0
.ie n .IP "$plugin" 4
.el .IP "\f(CW$plugin\fR" 4
.IX Item "$plugin"
.PD
Reference to the plugin object executing the code (such as \f(CW\*(C`Hook::Init\*(C'\fR or \f(CW\*(C`Hook::BeforeBuild\*(C'\fR).
.ie n .IP "$dist" 4
.el .IP "\f(CW$dist\fR" 4
.IX Item "$dist"
.PD 0
.ie n .IP "$zilla" 4
.el .IP "\f(CW$zilla\fR" 4
.IX Item "$zilla"
.PD
Reference to \f(CW\*(C`Dist::Zilla\*(C'\fR object, the same as \f(CW\*(C`$self\->zilla\*(C'\fR.
.PP
If code dies, the method logs error message and aborts \f(CW\*(C`Dist::Zilla\*(C'\fR.
.SS "_line_directive"
.IX Subsection "_line_directive"
.Vb 2
\&    $dir = $self\->_line_directive( $filename, $linenumber );
\&    $dir = $self\->_line_directive( $filename );
.Ve
.PP
The method returns Perl line directive, like
.PP
.Vb 1
\&    #line 1 "filename.ext"
.Ve
.PP
The method takes care about quotes. Perl line directive does not allow any quotes (escaped or not)
in filename, so directive
.PP
.Vb 1
\&    #line 1 "\e"Assa\e" project.txt"
.Ve
.PP
will be ignored. To avoid this, \f(CW\*(C`line_directive\*(C'\fR replaces quotes in filename with apostrophes, e.
g.:
.PP
.Vb 1
\&    #line 1 "\*(AqAssa\*(Aq project.txt"
.Ve
.PP
If line number is not specified, 1 will be used.
.SS "_prologue"
.IX Subsection "_prologue"
.Vb 1
\&    @code = $self\->_prologue;
.Ve
.PP
The method returns prologue code.
.PP
Prologue code is extracted from \f(CW\*(C`Dist::Zilla\*(C'\fR plugin named \f(CW\*(C`prologue\*(C'\fR.
.SS "mvp_multivalue_args"
.IX Subsection "mvp_multivalue_args"
The method tells \f(CW\*(C`Dist::Zilla\*(C'\fR that dot (\f(CW\*(C`.\*(C'\fR) is a multi-value option.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Dist::Zilla" 4
.IX Item "Dist::Zilla"
.PD 0
.IP "Dist::Zilla::Role" 4
.IX Item "Dist::Zilla::Role"
.IP "Dist::Zilla::Role::Plugin" 4
.IX Item "Dist::Zilla::Role::Plugin"
.IP "Dist::Zilla::Plugin::Hook::Manual" 4
.IX Item "Dist::Zilla::Plugin::Hook::Manual"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Van de Bugger <van.de.bugger@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2015, 2016, 2018 Van de Bugger
.PP
License GPLv3+: The \s-1GNU\s0 General Public License version 3 or later
<http://www.gnu.org/licenses/gpl\-3.0.txt>.
.PP
This is free software: you are free to change and redistribute it. There is
\&\s-1NO WARRANTY,\s0 to the extent permitted by law.
