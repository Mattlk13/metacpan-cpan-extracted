.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Dist::Zilla::Plugin::Hook::Manual 3pm"
.TH Dist::Zilla::Plugin::Hook::Manual 3pm "2018-03-15" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dist::Zilla::Plugin::Hook::Manual \- "Hook" plugin user manual
.SH "VERSION"
.IX Header "VERSION"
Version v0.8.4, released on 2018\-03\-15 21:44 \s-1UTC.\s0
.SH "WHAT?"
.IX Header "WHAT?"
\&\f(CW\*(C`Dist\-Zilla\-Plugin\-Hook\*(C'\fR (or just \f(CW\*(C`Hook\*(C'\fR) is a set of \f(CW\*(C`Dist\-Zilla\*(C'\fR plugins. Every plugin executes Perl
code inlined into \fIdist.ini\fR at particular stage of build process.
.PP
This is \f(CW\*(C`Hook\*(C'\fR user manual. Read this if you want to write \f(CW\*(C`Dist::Zilla\*(C'\fR plugin directly in \fIdist.ini\fR.
.PP
If you are going to hack or extend \f(CW\*(C`Dist\-Zilla\-Plugin\-Hook\*(C'\fR, read the
\&\f(CW\*(C`Dist::Zilla::Role::Hooker\*(C'\fR module documentation. General topics like
getting source, building, installing, bug reporting and some others are covered in the \fI\s-1README\s0\fR.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In your \fIdist.ini\fR:
.PP
.Vb 9
\&    [Hook/prologue]
\&        . = # Code to be executed before every hook.
\&        . = use autodie \*(Aq:all\*(Aq;
\&        . = use Path::Tiny;
\&    [Hook::Role]
\&        . = # Code of your inline plugin:
\&        . = $self\->log( \*(AqStartingX\*(Aq );
\&        . = # Xarbitrary Perl codeX
\&        . = X
.Ve
.PP
where \fIRole\fR is one of \f(CW\*(C`Hook\*(C'\fR submodules/\f(CW\*(C`Dist::Zilla\*(C'\fR roles, like \f(CW\*(C`BeforeBuild\*(C'\fR,
\&\f(CW\*(C`AfterBuild\*(C'\fR, \f(CW\*(C`FileGatherer\*(C'\fR, \f(CW\*(C`MetaProvider\*(C'\fR etc. See complete list of supported roles in
\&\*(L"List of Modules\*(R".
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Hook\*(C'\fR is a set of plugins, like \f(CW\*(C`Hook::BeforeBuild\*(C'\fR and \f(CW\*(C`Hook::AfterBuild\*(C'\fR.
.PP
Every \f(CW\*(C`Hook\*(C'\fR plugin (except \f(CW\*(C`Hook::Init\*(C'\fR, which is a bit special, see below) consumes a role with
the same name, and implements the method required by the consumed role. When \f(CW\*(C`Dist::Zilla\*(C'\fR invokes
the method, it executes the code specified in the plugin's section of \fIdist.ini\fR.
.PP
An example: \f(CW\*(C`Hook::BeforeBuild\*(C'\fR plugin consumes \f(CW\*(C`BeforeBuild\*(C'\fR role, this role requires
\&\f(CW\*(C`before_build\*(C'\fR method, which is implemented by the plugin. When \f(CW\*(C`Dist::Zilla\*(C'\fR invokes
\&\f(CW\*(C`Hook::BeforeBuild\*(C'\fR's \f(CW\*(C`before_build\*(C'\fR method, it executes the code from the plugin's section of
\&\fIdist.ini\fR, e. g.:
.PP
.Vb 5
\&    name    = Assa
\&    version = 0.001
\&    [Hook::BeforeBuild]
\&        . = $self\->log( [ "Building v%s", $dist\->version ] );
\&    ...
.Ve
.PP
and Perl code inlined into \f(CW\*(C`[Hook::BeforeBuild]\*(C'\fR section of \fIdist.ini\fR prints message \*(L"Building
v0.001\*(R" to the log. Such inlined Perl code is called \*(L"hook\*(R" below.
.PP
The same for all other \f(CW\*(C`Hook\*(C'\fR plugins. Only \f(CW\*(C`Hook::Init\*(C'\fR plugin is a bit special: it implements
\&\f(CW\*(C`BUILD\*(C'\fR method. It has two subsequences. First: there is no need in consuming a role to implement
\&\f(CW\*(C`BUILD\*(C'\fR method (and actually there is no role \f(CW\*(C`Dist::Zilla::Role::Init\*(C'\fR). Second, more important:
\&\f(CW\*(C`BUILD\*(C'\fR method is called at very early stage of the build, immediately after reading
\&\f(CW\*(C`[Hook::Init]\*(C'\fR section of \fIdist.ini\fR. This is useful in some circumstances.
.SS "Predefined Variables"
.IX Subsection "Predefined Variables"
Inlined Perl code can use following predefined variables:
.ie n .IP "@_" 4
.el .IP "\f(CW@_\fR" 4
.IX Item "@_"
Arguments of the method, as provided by \f(CW\*(C`Dist::Zilla\*(C'\fR. Self-reference is already shifted to
\&\f(CW$self\fR (but the first argument is not)!
.ie n .IP "$arg" 4
.el .IP "\f(CW$arg\fR" 4
.IX Item "$arg"
The first argument of the method, the same as \f(CW$_[ 0 ]\fR. If \f(CW\*(C`Dist::Zilla\*(C'\fR does not provide
argument, the variable will be set to \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$plugin" 4
.el .IP "\f(CW$plugin\fR" 4
.IX Item "$plugin"
.PD 0
.ie n .IP "$self" 4
.el .IP "\f(CW$self\fR" 4
.IX Item "$self"
.PD
Reference to the plugin object executing the code.
.ie n .IP "$dist" 4
.el .IP "\f(CW$dist\fR" 4
.IX Item "$dist"
.PD 0
.ie n .IP "$zilla" 4
.el .IP "\f(CW$zilla\fR" 4
.IX Item "$zilla"
.PD
Reference to \f(CW\*(C`Dist::Zilla\*(C'\fR object, the same as \f(CW\*(C`$self\->zilla\*(C'\fR.
.PP
\&\f(CW$self\fR and \f(CW$zilla\fR are \*(L"standard\*(R" variables frequently used in plugin source code. \f(CW$plugin\fR
and \f(CW$dist\fR variables are defined for conformance with template processing plugins
(\f(CW\*(C`GenerateFile\*(C'\fR, \f(CW\*(C`Templates\*(C'\fR, \f(CW\*(C`TemplateFiles\*(C'\fR, \f(CW\*(C`MetaResources::Template\*(C'\fR, etc.). \f(CW$arg\fR is
defined for convenience: in many cases \f(CW\*(C`Dist::Zilla\*(C'\fR passes the only argument to the method (which
usually is a \f(CW\*(C`HashRef\*(C'\fR).
.SS "Arguments and Return Value"
.IX Subsection "Arguments and Return Value"
As described in the previous section, arguments provided by \f(CW\*(C`Dist::Zilla\*(C'\fR are passed to the hook
(through \f(CW$self\fR, \f(CW$arg\fR, and \f(CW@_\fR variables).
.PP
Return value of the hook code is not ignored but passed back to \f(CW\*(C`Dist::Zilla\*(C'\fR. \f(CW\*(C`Dist::Zilla\*(C'\fR, in
turn, often ignores it, but sometimes return value is important, for example, for \*(L"provider\*(R"
plugins: \f(CW\*(C`Hook::VersionProvider\*(C'\fR, \f(CW\*(C`Hook::MetaProvider\*(C'\fR, etc. See documentation on corresponding
roles (e. g. Dist::Zilla::Role::VersionProvider, Dist::Zilla::Role::MetaProvider, etc) for
description of expected method result.
.PP
Passing arguments and return values actually means you can write your own \f(CW\*(C`Dist::Zilla\*(C'\fR plugin
which code is not in an external \f(CW\*(C`.pm\*(C'\fR file but inlined directly to \fIdist.ini\fR. Of course, such
approach is limited. For example, \*(L"inline plugin\*(R" cannot define attributes and methods. Anyway the
approach is quite convenient for small hacks and prototyping which do not require much coding. See
\&\*(L"\s-1EXAMPLES\*(R"\s0 section.
.SS "Prologue"
.IX Subsection "Prologue"
If \fIdist.ini\fR contains section \f(CW\*(C`[Hook/prologue]\*(C'\fR, the code from this section is executed before
every hook. All the predefined variables are available in prologue code too.
.PP
Prologue may be used for loading frequently used modules, or for debugging:
.PP
.Vb 9
\&    [Hook/prologue]
\&        . = use autodie \*(Aq:all\*(Aq;
\&        . = use Path::Tiny;
\&        . = use IPC::System::Simple qw{ capture };
\&        . = $self\->log_debug( \*(Aqbegins\*(Aq );
\&    [Hook::BeforeBuild]
\&        . = # No need in "use autodie" because
\&        . = # it is specified in prologue.
\&        . = system( X );
.Ve
.ie n .SS """ErrorLogger"" Role"
.el .SS "\f(CWErrorLogger\fP Role"
.IX Subsection "ErrorLogger Role"
Every \f(CW\*(C`Hook\*(C'\fR plugin executes Perl code with help from the \f(CW\*(C`Hooker\*(C'\fR role. The latter uses
\&\f(CW\*(C`ErrorLogger\*(C'\fR role internally. As a side effect, \f(CW\*(C`ErrorLogger\*(C'\fR methods are also available to use
in hooks:
.PP
.Vb 4
\&    [Hook::Role]
\&        . = $self\->log_error( X );
\&        . = $self\->abort_if_error( X );
\&        . = $self\->abort( X );
.Ve
.SS "Multiple Hooks of the Same Role"
.IX Subsection "Multiple Hooks of the Same Role"
Use explicit plugin names if you want to have multiple hooks of the same role, e. g.:
.PP
.Vb 4
\&    [Hook::AfterRelease/bump version]
\&        . = my $version = Perl::Version\->new( $dist\->version );
\&        . = $version\->inc_alpha;
\&        . = path( $dist\->root )\->child( \*(AqVERSION\*(Aq )\->spew( $version );
\&
\&    [Hook::AfterRelease/post\-release commit]
\&        . = system( qw{ hg commit \-m Post\-release VERSION Changes } );
\&
\&    [Hook::AfterRelease/push]
\&        . = system( qw{ hg push } );
\&
\&    [Hook::AfterRelease/clean]
\&        . = $zilla\->clean();
.Ve
.SS "List of Modules"
.IX Subsection "List of Modules"
This is the complete list of \f(CW\*(C`Hook\*(C'\fR modules/roles and methods:
.PP
.Vb 10
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- + \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    Module/Role           | Method
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- + \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&    AfterBuild            | after_build
\&    AfterMint             | after_mint
\&    AfterRelease          | after_release
\&    BeforeArchive         | before_archive
\&    BeforeBuild           | before_build
\&    BeforeMint            | before_mint
\&    BeforeRelease         | before_release
\&    FileGatherer          | gather_files
\&    FileMunger            | munge_files
\&    FilePruner            | prune_files
\&    Init                  | BUILD
\&    InstallTool           | setup_installer
\&    LicenseProvider       | provide_license
\&    MetaProvider          | metadata
\&    ModuleMaker           | make_module
\&    NameProvider          | provide_name
\&    PrereqSource          | register_prereqs
\&    ReleaseStatusProvider | provide_release_status
\&    Releaser              | release
\&    VersionProvider       | provide_version
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\- + \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
.Ve
.SH "OPTIONS"
.IX Header "OPTIONS"
.SS "."
.IX Subsection "."
Yes, the only option recognized by \f(CW\*(C`Hook\*(C'\fR modules is \f(CW\*(C`.\*(C'\fR (dot).
.PP
This is multi-value option, i. e. it may be specified multiple time. Each value is a distinct line
of Perl code, e. g.:
.PP
.Vb 3
\&    . = if ( $dist\->is_trial ) {
\&    . =     $self\->log( \*(AqBuilding trial version\*(Aq );
\&    . = };
.Ve
.PP
Beware of caveats, see \*(L"dist.ini Parsing\*(R".
.SH "CAVEATS"
.IX Header "CAVEATS"
.SS "\fIdist.ini\fP Parsing"
.IX Subsection "dist.ini Parsing"
Before code reaches a \f(CW\*(C`Hook\*(C'\fR plugin, it is parsed by \f(CW\*(C`Dist::Zilla\*(C'\fR config file reader (probably,
by \f(CW\*(C`Config::INI::Reader\*(C'\fR). Config file reader seems to strip leading and trailing spaces from each
value, and treat semicolon preceded by a space as a comment starter. Usually it is not a problem,
just put semicolon immediately after statement:
.PP
.Vb 2
\&    . = foo(); bar();       # Ok
\&    . = foo() ; bar() ;     # NOT OK: bar will not be called.
.Ve
.PP
Note that semicolon starts a \fIdist.ini\fR comment even within Perl string:
.PP
.Vb 2
\&    . = $str = "one; two";  # Ok
\&    . = $str = "one ; two"; # NOT OK
.Ve
.PP
And be careful with multi-line strings:
.PP
.Vb 2
\&    . = $str = "first line
\&    . =     indented line"; # Leading spaces will be lost.
.Ve
.SH "WHY?"
.IX Header "WHY?"
There is \f(CW\*(C`Dist::Zilla::Plugin::Run\*(C'\fR on \s-1CPAN\s0 which allows to run Perl code from within
\&\fIdist.ini\fR, why I wrote one more? Let us consider two examples.
.PP
The first one executes external commands:
.PP
.Vb 10
\&    $cat dist.ini
\&    name     = RunShell
\&    abstract = RunShell demo
\&    version  = 0.001_001
\&    [Run::BeforeBuild]
\&        run            = echo "1. begin"
\&        run_if_release = echo "2. release"
\&        run_no_release = echo "3. not release"
\&        run_if_trial   = echo "4. trial"
\&        run_no_trial   = echo "5. not trial"
\&        run            = echo "6. end"
\&    [GenerateFile/Assa.pm]
\&        filename = lib/Assa.pm
\&        content  = package Assa; 1;
\&    [FakeRelease]
\&
\&    $ dzil build
\&    [Run::BeforeBuild] executing: echo "1. begin"
\&    [Run::BeforeBuild] 1. begin
\&    [Run::BeforeBuild] executing: echo "6. end"
\&    [Run::BeforeBuild] 6. end
\&    [Run::BeforeBuild] executing: echo "5. not trial"
\&    [Run::BeforeBuild] 5. not trial
\&    [Run::BeforeBuild] executing: echo "3. not release"
\&    [Run::BeforeBuild] 3. not release
\&    [DZ] beginning to build RunShell
\&    [DZ] writing RunShell in RunShell\-0.001_001
\&    [DZ] building archive with Archive::Tar::Wrapper
\&    [DZ] writing archive to RunShell\-0.001_001\-TRIAL.tar.gz
\&    [DZ] built in RunShell\-0.001_001
.Ve
.PP
Execution order is errX non-linear. Of course there is an explanation why command were executed in
this particular order, but when you are looking at \fIdist.ini\fR it is not obvious. (It is also
unclear why \f(CW\*(C`Run\*(C'\fR consider the build is \fInot\fR trial, but it may be just a bug.)
.PP
Another example executes Perl code:
.PP
.Vb 12
\&    $cat dist.ini
\&    name     = RunPerl
\&    abstract = RunPerl demo
\&    version  = 0.001_001
\&    [Run::BeforeBuild]
\&        eval = my $self = shift( @_ );
\&        eval = my $dist = $self\->zilla;
\&        eval = $self\->log( [ \*(Aq%s v%s\*(Aq, $dist\->name, $dist\->version ] );
\&    [GenerateFile/Assa.pm]
\&        filename = lib/Assa.pm
\&        content  = package Assa; 1;
\&    [FakeRelease]
\&
\&    $ dzil build
\&    [Run::BeforeBuild] evaluating: my $self = shift( @_ );
\&    [Run::BeforeBuild] my $dist = $self\->zilla;
\&    [Run::BeforeBuild] $self\->log( [ \*(Aq0.001_001 v\*(Aq, $dist\->name, $dist\->version ] );
\&    [Run::BeforeBuild] 0.001_001 v
\&    [DZ] beginning to build RunPerl
\&    [DZ] writing RunPerl in RunPerl\-0.001_001
\&    [DZ] building archive with Archive::Tar::Wrapper
\&    [DZ] writing archive to RunPerl\-0.001_001\-TRIAL.tar.gz
\&    [DZ] built in RunPerl\-0.001_001
.Ve
.PP
Look at the last message from \f(CW\*(C`Run::BeforeBuild\*(C'\fR plugin. Surprising? Where is the distribution
name? Why is the character \*(L"v\*(R" printed after version number? Ah! \f(CW%s\fR is a special conversion
specifier which was replaced with \*(L"something retained for backward compatibility\*(R". There is a bunch
of other conversion specifiers: \f(CW%a\fR, \f(CW%d\fR, \f(CW%n\fR,\f(CW%p\fR, \f(CW%t\fR, \f(CW%v\fR, \f(CW%x\fR,X That effectively
means I cannot use printf-like functions and hashes, because every percent will be replaced with
something or cause error \*(L"unknown conversion\*(R".
.PP
Ok, I can. There is (undocumented!) method to avoid it X every percent sign should be doubled:
.PP
.Vb 1
\&    eval = $self\->log( [ \*(Aq%%s v%%s\*(Aq, $dist\->name, $dist\->version ] );
.Ve
.PP
or
.PP
.Vb 1
\&    eval = my %%meta = %%{ $dist\->distmeta };
.Ve
.PP
It is simple, butX this is errX not quite Perl. I cannot just cut-n-paste code from a plugin to
\&\fIdist.ini\fR and back.
.PP
Let me cite a part of \*(L"Philosophy\*(R" section of the great \f(CW\*(C`Text::Template\*(C'\fR module:
.Sp
.RS 4
When people make a template module like this one, they almost always start by inventing a special
syntax for substitutions. For example, they build it so that a string like \f(CW\*(C`%%VAR%%\*(C'\fR is replaced
with the value of \f(CW$VAR\fR. Then they realize the need extra formatting, so they put in some special
syntax for formatting. Then they need a loop, so they invent a loop syntax. Pretty soon they have a
new little template language.
.Sp
This approach has two problems: First, their little language is crippled. If you need to do
something the author hasn't thought of, you lose. Second: Who wants to learn another language? You
already know Perl, so why not use it?
.RE
.PP
Look: \f(CW\*(C`Run\*(C'\fR plugin introduced a bunch of \fIdist.ini\fR options: \f(CW\*(C`run_if_trial\*(C'\fR, \f(CW\*(C`run_no_trial\*(C'\fR
(\s-1BTW,\s0 why not \f(CW\*(C`run_if_not_trial\*(C'\fR?), \f(CW\*(C`run_if_release\*(C'\fR, \f(CW\*(C`run_no_release\*(C'\fR, \f(CW\*(C`eval\*(C'\fR,
\&\f(CW\*(C`censor_commands\*(C'\fR, \f(CW\*(C`fatal_errors\*(C'\fR, \f(CW\*(C`quiet\*(C'\fR; a bunch of \*(L"conversion specifiers\*(R": \f(CW%a\fR, \f(CW%d\fR,
\&\f(CW%n\fR, \f(CW%p\fR, \f(CW%v\fR, \f(CW%t\fR, \f(CW%x\fR, \f(CW%s\fR; and bunch of poorly documented rules. It's \*(L"a little
crippled language\*(R", isn't it?
.PP
Compared to \f(CW\*(C`Run\*(C'\fR, \f(CW\*(C`Hook\*(C'\fR is designed to be minimalistic: It provides only one option, and it
executes only Perl. Of course, when writing a hook you have to keep in mind many rules, but these
are well documented Perl rules and (not so well) \f(CW\*(C`Dist::Zilla\*(C'\fR rules, not rules introduced by
\&\f(CW\*(C`Hook\*(C'\fR.
.PP
All \f(CW\*(C`Run\*(C'\fR features can be easily implemented with hooks in Perl, for example:
.PP
Running external commands:
.PP
.Vb 1
\&    . = system( X );
.Ve
.PP
Making errors in external commands fatal:
.PP
.Vb 2
\&    . = use autodie \*(Aq:all\*(Aq;
\&    . = system( X );
.Ve
.PP
Making errors in Perl code non-fatal:
.PP
.Vb 2
\&    . = use Try::Tiny;
\&    . = try { X };
.Ve
.PP
Checking trial status:
.PP
.Vb 1
\&    . = if ( $dist\->is_trial ) { X };
.Ve
.PP
Checking release build:
.PP
.Vb 1
\&    . = if ( $ENV{ DZIL_RELEASING } ) { X };
.Ve
.PP
The code is a little bit longer than \f(CW\*(C`Run\*(C'\fR counterparts, but it is well-known full-featured Perl.
.PP
What if you need to pass to an external command something the \f(CW\*(C`Run\*(C'\fR authors have not thought of?
For example, abstract or licence name. There are no conversion specifiers for it, so you lose. But
with \f(CW\*(C`Hook\*(C'\fR it is trivial:
.PP
.Vb 1
\&    . = system( X, $dist\->abstract, X, $dist\->license\->name, X );
.Ve
.PP
\&\s-1BTW,\s0 there are two minor (at the first look) \f(CW\*(C`Hook\*(C'\fR features:
.IP "1." 4
Arguments provided by \f(CW\*(C`Dist::Zilla\*(C'\fR are passes to the hook.
.IP "2." 4
Hook return value is passed back to \f(CW\*(C`Dist::Zilla\*(C'\fR.
.PP
These bring a new quality: with \f(CW\*(C`Hook\*(C'\fR you can write inline plugins. For example, a plugin which
reads distribution version from an external file:
.PP
.Vb 2
\&    [Hook::VersionProvider]
\&        . = use Path::Tiny; path( \*(AqVERSION\*(Aq )\->slurp;
.Ve
.PP
(Actually, every hook is an inline plugin.) See more in \*(L"\s-1EXAMPLES\*(R"\s0 in Dist::Zilla::Plugin::Hook::Manual.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Examples below are focused on using \f(CW\*(C`Hook\*(C'\fR, so \fIdist.ini\fR is a primary file in all the examples,
and sometimes is the only file of an example. Example module contains single line \f(CW\*(C`package Assa;
1;\*(C'\fR and generated on-the-fly with \f(CW\*(C`GenerateFile\*(C'\fR plugin.
.SS "\fIDescription\fP Meta Resource"
.IX Subsection "Description Meta Resource"
Distribution meta information contains such items as \fIname\fR, \fIversion\fR, \fIabstract\fR and many
others. All named items are written to \fI\s-1META\s0.json\fR (and maybe to \fI\s-1META\s0.yml\fR) automatically, all
you need is just using \f(CW\*(C`MetaJSON\*(C'\fR and/or \f(CW\*(C`MetaYAML\*(C'\fR plugin(s) in your \fIdist.ini\fR file.
.PP
Meta information may also include \fIdescription\fR X a longer, more complete description of the
distribution. However, \f(CW\*(C`Dist::Zilla\*(C'\fR does not provide option to specify \fIdescription\fR. It could
be easily fixed with \f(CW\*(C`Hook\*(C'\fR, though.
.PP
\&\fIdist.ini\fR file:
.PP
.Vb 10
\&    name     = Description
\&    abstract = Hook demo: Set "description" meta info
\&    version  = v0.0.1
\&    [Hook::MetaProvider/description]    ; <<<=== Look at this
\&        ;   MetaProvider\*(Aqs metadata method must return HashRef (or undef).
\&        ;   Multiple MetaProviders are allowed. Metainfo received from
\&        ;   all providers will be merged by Dist::Zilla. This
\&        ;   MetaProvider provides only description.
\&        ;   See Dist::Zilla::Role::MetaProvider.
\&        . = { description =>
\&        . =     "This is not short one\-line abstract,
\&        . =     but more detailed description,
\&        . =     which spans several lines."
\&        . = }
\&    [GenerateFile/Assa.pm]
\&        filename = lib/Assa.pm
\&        content  = package Assa; 1;
\&    [MetaJSON]
\&    [FakeRelease]
.Ve
.ie n .SS """Test::Version"" adaptive strictness"
.el .SS "\f(CWTest::Version\fP adaptive strictness"
.IX Subsection "Test::Version adaptive strictness"
\&\f(CW\*(C`Test::Version\*(C'\fR is a great plugin. It creates a test which checks modules in distribution: every
module must have \f(CW$VERSION\fR variable defined, and its value must be a valid version string.
There are two notion of \*(L"validity\*(R": \fIlax\fR and \fIstrict\fR. (See \*(L"Regular
Expressions for Version Parsing\*(R" in version::Internals for definitions of lax and strict).
.PP
I want to use strict check:
.PP
.Vb 2
\&    [Test::Version]
\&        is_strict = 1
.Ve
.PP
Unfortunately, this does not work for trial releases: any trial release definitely fails the test,
because strict check does not allow underscore in version string. Thus, before every trial release
I have to reset \f(CW\*(C`is_strict\*(C'\fR option to zero, and return it back to one after release. This is
boring and error-prone. I want to have \*(L"adaptive strictness\*(R": use lax check in case of trial
release and strict check otherwise.
.PP
\&\f(CW\*(C`Test::Version\*(C'\fR maintainer Graham Ollis said: This is a good idea! I'll see if I can implement
it. <https://github.com/plicease/Dist-Zilla-Plugin-Test-Version/issues/5> However, implementation
may take some time. With a little help from \f(CW\*(C`Hook\*(C'\fR, I can easily get achieve adaptive strictness
right now.
.PP
\&\fIdist.ini\fR file:
.PP
.Vb 10
\&    name     = AdaptiveTestVersion
\&    abstract = Hook demo: Test::Version adaptive strictness
\&    version  = 0.001
\&    [GenerateFile/Assa.pm]
\&        filename = lib/Assa.pm
\&        content  = package Assa; 1;
\&    [Test::Version]                         ; <<<=== Look at this
\&        is_strict = 0
\&    [Hook::BeforeBuild/AdaptiveStrictness]  ; <<<=== Look at this
\&        . = my $tv = $zilla\->plugin_named( \*(AqTest::Version\*(Aq );
\&        . = $tv\->{ is_strict } = $dist\->is_trial ? \*(Aq0\*(Aq : \*(Aq1\*(Aq;
\&    [MetaJSON]
\&    [FakeRelease]
.Ve
.SS "Template Variables"
.IX Subsection "Template Variables"
In a distribution, I have to duplicate the same pieces of information again and again. For example,
bug report email and web URLs should be written in \f(CW\*(C`[MetaResources]\*(C'\fR section of \fIdist.ini\fR and in
the documentation, like \fI\s-1BUGS\s0.pod\fR.
.PP
With a help from \f(CW\*(C`Templates\*(C'\fR plugin I can eliminate duplication. If \fI\s-1BUGS\s0.pod\fR is a template,
I can use email and web URLs defined in \fIdist.ini\fR, e. g.:
.PP
.Vb 1
\&    {{$dist\->distmeta\->{resources}\->{bugtracker}\->{mailto};}}
.Ve
.PP
ErrX This works but requires a lot of typing (so it is typo-prone), and looks ugly. With \f(CW\*(C`Hook\*(C'\fR I
can make it not only working, but also elegant. \f(CW\*(C`[Hook::Init]\*(C'\fR section defines few variables in
\&\f(CW\*(C`MY\*(C'\fR package, which can be used in various templates, including documentation and meta resources.
.PP
\&\fIdist.ini\fR file:
.PP
.Vb 10
\&    name     = TemplateVariables
\&    abstract = Hook demo: Define variables for later use in templates.
\&    version  = v0.0.1
\&    [Hook::Init/my vars]                ; <<<=== Look at this
\&        . = package MY;
\&        . = our $name    = $dist\->name;
\&        . = our $bt_mail = "mailto:bug\-$name\e@bt.example.org";
\&        . = our $bt_web  = "https://bt.example.org/display.html?name=$name";
\&        ;   BTW, Hook::BeforeBuild cannot be used here: it works too late,
\&        ;   MetaResources::Template will not see the variables.
\&    [GenerateFile/Assa.pm]
\&        filename = lib/Assa.pm
\&        content  = package Assa; 1;
\&    [GatherDir]
\&    [PruneCruft]
\&    [FileFinder::ByName/BUGS.pod]       ; <<<=== Look at this
\&        file = BUGS.pod
\&    [Templates]                         ; <<<=== Look at this
\&        templates = BUGS.pod
\&    [MetaResources::Template]           ; <<<=== Look at this
\&        bugtracker.mailto = {{$MY::bt_mail}}
\&        bugtracker.web    = {{$MY::bt_web}}
\&        license           = {{$dist\->license\->url}}
\&    [MetaJSON]
\&    [FakeRelease]
.Ve
.PP
\&\fI\s-1BUGS\s0.pod\fR file:
.PP
.Vb 1
\&    =head2 Bugs
\&
\&    The quickest way to report a bug in C<{{$MY::name}}>
\&    is by sending email to {{$MY::bt_mail}}.
\&
\&    Bug tracker can be used via
\&    L<web interface|{{$MY::bt_web}}>.
.Ve
.SS "Version Bumping"
.IX Subsection "Version Bumping"
I want the version of my distribution is bumped automatically after each release, and automatically
assigned version should be trial.
.PP
For example: If I released version \f(CW\*(C`v0.0.1\*(C'\fR, the version of the next release should be \f(CW\*(C`v0.0.1.1\*(C'\fR
(see \f(CW\*(C`Version::Dotted::Semantic\*(C'\fR). When I release \f(CW\*(C`v0.0.1.1\*(C'\fR, the next should be \f(CW\*(C`v0.0.1.2\*(C'\fR, the
next one X \f(CW\*(C`v0.0.1.3\*(C'\fR and so on. When I decide it is time to non-trial release, I will set the
version to \f(CW\*(C`v0.0.2\*(C'\fR manually, release it, and will have automatically bumped version \f(CW\*(C`v0.0.2.1\*(C'\fR
for the next release.
.PP
This is implemented with three plugins: \f(CW\*(C`Hook:VersionProvider\*(C'\fR, \f(CW\*(C`Hook::ReleaseStatusProvider\*(C'\fR,
and \f(CW\*(C`Hook::AfterRelease\*(C'\fR. The first one reads version from external file \fI\s-1VERSION\s0\fR which contains
only version and nothing more (ok, trailing whitespace is allowed) X it simplifies implementation,
because there is no need in parsing \fIdist.ini\fR file. The second plugin lets \f(CW\*(C`Dist::Zilla\*(C'\fR know
release status (trial or stable). The third plugin bumps the version after release, and writes
bumped version back to the \fI\s-1VERSION\s0\fR file.
.PP
\&\fIdist.ini\fR file:
.PP
.Vb 10
\&    name     = VersionBumping
\&    abstract = Hook demo: Bump version after release
\&    [Hook/prologue]                     ; <<<=== Look at this
\&        . = use Version::Dotted::Semantic \*(Aqqv\*(Aq;
\&    [Hook::VersionProvider]             ; <<<=== Look at this
\&        . = $zilla\->root\->child( \*(AqVERSION\*(Aq )\->slurp =~ s{\es*\ez}{}r;
\&    [Hook::ReleaseStatusProvider]       ; <<<=== Look at this
\&        . = qv( $zilla\->version )\->is_trial ? "testing" : "stable";
\&    [GenerateFile/Assa.pm]
\&        filename = lib/Assa.pm
\&        content  = package Assa; 1;
\&    [MetaJSON]
\&    [FakeRelease]
\&    [Hook::AfterRelease/bump version]   ; <<<=== Look at this
\&        . = my $ver = qv( $dist\->version )\->bump( 3 );
\&        . = $zilla\->root\->child( \*(AqVERSION\*(Aq )\->spew( $ver );
\&        . = $self\->log( [ \*(AqThe next release will be %s\*(Aq, "$ver" ] );
.Ve
.PP
\&\fI\s-1VERSION\s0\fR file:
.PP
.Vb 1
\&    v0.0.1
.Ve
.SS "Unwanted Dependencies"
.IX Subsection "Unwanted Dependencies"
\&\f(CW\*(C`Data::Printer\*(C'\fR is a great module, I often use it for debugging. However, sometimes I forget to
remove
.PP
.Vb 1
\&    use DDP;
.Ve
.PP
from the code and make a release with this unwanted dependency. \f(CW\*(C`Hook::BeforeRelease\*(C'\fR checks the
distribution does not have unwanted dependencies. If it does, release will be aborted.
.PP
\&\fIdist.ini\fR file:
.PP
.Vb 10
\&    name     = UnwantedDependencies
\&    abstract = Hook demo: Check the distro does not have unwanted dependencies
\&    version  = v0.0.1
\&    [GenerateFile/Assa.pm]
\&        filename = lib/Assa.pm
\&        content  = package Assa; use DDP; 1;
\&    [AutoPrereqs]
\&    [MetaJSON]
\&    [Hook::BeforeRelease/unwanted deps] ; <<<=== Look at this
\&        . = my @modules = qw{ DDP Data::Printer };  # Unwanted modules.
\&        . = my $prereqs = $dist\->distmeta\->{ prereqs };
\&        . = for my $m ( @modules ) {
\&        . =     for my $s ( qw{ configure develop runtime test } ) {
\&        . =         if ( exists( $prereqs\->{ $s }\->{ requires }\->{ $m } ) ) {
\&        . =             $self\->log_error( [ \*(Aq%s found in %s prereqs\*(Aq, $m, $s ] );
\&        . =         };
\&        . =     };
\&        . = };
\&        . = $self\->abort_if_error( \*(Aqunwanted dependencies found\*(Aq );
\&    [FakeRelease]
.Ve
.ie n .SS "Let ""[=inc::Foo]"" work in Perl v5.26+."
.el .SS "Let \f(CW[=inc::Foo]\fP work in Perl v5.26+."
.IX Subsection "Let [=inc::Foo] work in Perl v5.26+."
Starting from Perl v26.0, \f(CW\*(C`.\*(C'\fR is not included into \f(CW@INC\fR anymore. This breaks \f(CW\*(C`Dist::Zilla\*(C'\fR
syntax for plugins which are located in the distribution source tree, e. g.:
.PP
.Vb 1
\&    [=inc::Foo]
.Ve
.PP
Being run with Perl v5.26+, \f(CW\*(C`dzil\*(C'\fR complains:
.PP
.Vb 1
\&    Required plugin inc::Foo isn\*(Aqt installed.
.Ve
.PP
\&\f(CW\*(C`Dist::Zilla::Plugin::lib\*(C'\fR was created specially for workarounding this issue. (I said
\&\*(L"workarounding\*(R" not \*(L"solving\*(R" because \f(CW\*(C`Dist::Zilla::Plugin::lib\*(C'\fR does not help \f(CW\*(C`dzil authordeps
\&\-\-missing\*(C'\fR to work.)
.PP
The same effect can be achieved with \f(CW\*(C`Hook::Init\*(C'\fR one-liner.
.PP
\&\fIdist.ini\fR file:
.PP
.Vb 8
\&    name     = NoDotInInc
\&    abstract = Hook demo: Let [=inc::Foo] work in Perl v5.26+.
\&    version  = v0.0.1
\&    [Hook::Init]    ; <<<=== Look at this
\&        . = use lib $zilla\->root\->absolute\->stringify;
\&    [=inc::Foo]
\&    [MetaJSON]
\&    [FakeRelease]
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Dist::Zilla" 4
.IX Item "Dist::Zilla"
.PD 0
.IP "Dist::Zilla::Plugin::Run" 4
.IX Item "Dist::Zilla::Plugin::Run"
.IP "Dist::Zilla::Role::Hooker" 4
.IX Item "Dist::Zilla::Role::Hooker"
.IP "Dist::Zilla::Role::ErrorLogger" 4
.IX Item "Dist::Zilla::Role::ErrorLogger"
.IP "Dist::Zilla::Plugin::Hook" 4
.IX Item "Dist::Zilla::Plugin::Hook"
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
Van de Bugger <van.de.bugger@gmail.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2015, 2016, 2018 Van de Bugger
.PP
License GPLv3+: The \s-1GNU\s0 General Public License version 3 or later
<http://www.gnu.org/licenses/gpl\-3.0.txt>.
.PP
This is free software: you are free to change and redistribute it. There is
\&\s-1NO WARRANTY,\s0 to the extent permitted by law.
