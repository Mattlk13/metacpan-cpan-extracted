# Do not edit this file - Generated by Perlito6 9.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito6::Perl5::Runtime;
use Perlito6::Perl5::Prelude;
our $MATCH = Perlito6::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }

    # use v6 
;
    {
    package Perlito6::Match;
        sub new { shift; bless { @_ }, "Perlito6::Match" }
        sub from { $_[0]->{from} };
        sub to { $_[0]->{to} };
        sub str { $_[0]->{str} };
        sub bool { $_[0]->{bool} };
        sub capture { $_[0]->{capture} };
        sub hash { $_[0]->{hash} };
        sub array { $_[0]->{array} };
        sub perl {
            my $self = $_[0];
            return scalar (('Match.new(' . ('from ' . chr(61) . '> ') . Main::perl($self->{from}, ) . (', to ' . chr(61) . '> ') . Main::perl($self->{to}, ) . (', bool ' . chr(61) . '> ') . Main::perl(($self->{bool}->bool()), ) . (', capture ' . chr(61) . '> ') . Main::perl($self->{capture}, ) . (', hash ' . chr(61) . '> ') . Main::perl($self->{hash}, ) . (', array ' . chr(61) . '> ') . Main::perl($self->{array}, ) . (')')))
        };
        sub Bool {
            my $self = $_[0];
            $self->{bool}->Bool()
        };
        sub Str {
            my $self = $_[0];
            die(('TODO'))
        };
        sub scalar {
            my $self = $_[0];
            die(('TODO'))
        };
        sub exists {
            my $self = $_[0];
            die(('TODO'))
        }
    }

;
    {
    package Perlito6::Grammar;
        sub new { shift; bless { @_ }, "Perlito6::Grammar" }
        sub is_newline {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})
})));
            $MATCH
        };
        sub word {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})
})));
            $MATCH
        };
        sub digit {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})
})));
            $MATCH
        };
        sub not_newline {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})
})));
            $MATCH
        };
        sub space {
            my $grammar = $_[0];
            my $str = $_[1];
            my $pos = $_[2];
            (my  $MATCH);
            ($MATCH = Perlito6::Match->new(('str' => $str), ('from' => $pos), ('to' => $pos), ('bool' => 1)));
            (($MATCH)->{bool} = ((do {
    ((my  $pos1) = $MATCH->to());
    (do {
    (('' ne substr($str, $MATCH->to(), 1)) && ((($MATCH)->{to} = (1 + $MATCH->to()))))
})
})));
            $MATCH
        }
    }

;
    {
    package IO;
        sub new { shift; bless { @_ }, "IO" }
        sub slurp {
            die(('stub'))
        }
    }

;
    {
    package Main;
        sub new { shift; bless { @_ }, "Main" }
        sub lisp_dump_object {
            my $class_name = $_[0];
            my $data = $_[1];
            return scalar (($class_name . '( ' . Main::join((bless [ map { Main::perl( $_, , ) } @{( $data )} ], "ARRAY"), ', ') . ' )'))
        }
    }


}

1;
