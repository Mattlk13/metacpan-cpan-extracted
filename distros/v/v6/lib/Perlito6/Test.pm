# Do not edit this file - Generated by Perlito6 9.0
use v5;
use utf8;
use strict;
use warnings;
no warnings ('redefine', 'once', 'void', 'uninitialized', 'misc', 'recursion');
use Perlito6::Perl5::Runtime;
use Perlito6::Perl5::Prelude;
our $MATCH = Perlito6::Match->new();
{
package GLOBAL;
    sub new { shift; bless { @_ }, "GLOBAL" }
    {
    package Perlito6::Test;
        sub new { shift; bless { @_ }, "Perlito6::Test" }
        (my  $num_of_tests_run);
        (my  $num_of_tests_failed);
        (my  $num_of_tests_badpass);
        (my  $num_of_tests_planned);
        (my  $testing_started);
        sub plan {
            my $number_of_tests = $_[0];
            ($testing_started = 1);
            ($num_of_tests_planned = $number_of_tests);
            Main::say(('1..' . $number_of_tests))
        };
        sub ok {
            my $cond = $_[0];
            my $desc = $_[1];
            my $todo = $_[2];
            my $depends = $_[3];
            Perlito6::Test::proclaim($cond, ('ok' . chr(33) . ' ' . $desc), $todo, $depends)
        };
        sub is {
            my $got = $_[0];
            my $expected = $_[1];
            my $desc = $_[2];
            my $todo = $_[3];
            my $depends = $_[4];
            ((my  $test) = ($got eq $expected));
            Perlito6::Test::proclaim($test, ('is' . chr(33) . ' ' . $desc), $todo, $got, $expected, $depends)
        };
        sub is_deeply {
            my $got = $_[0];
            my $expected = $_[1];
            my $desc = $_[2];
            my $todo = $_[3];
            my $depends = $_[4];
            ((my  $got_perl) = Main::perl($got, ));
            ((my  $expected_perl) = Main::perl($expected, ));
            ((my  $test) = (($got_perl eq $expected_perl)));
            Perlito6::Test::proclaim($test, ('is deeply' . chr(33) . ' ' . $desc), $todo, $got_perl, $expected_perl, $depends)
        };
        sub isnt {
            my $got = $_[0];
            my $expected = $_[1];
            my $desc = $_[2];
            my $todo = $_[3];
            my $depends = $_[4];
            ((my  $test) = !((($got eq $expected))));
            Perlito6::Test::proclaim($test, ('isnt' . chr(33) . ' ' . $desc), $todo, $got, $expected, $depends, do {
    (my  $Hash_a = bless {}, 'HASH');
    ($Hash_a->{'negate'} = 1);
    $Hash_a
})
        };
        sub cmp_ok {
            my $got = $_[0];
            my $Code_compare_func = $_[1];
            my $expected = $_[2];
            my $desc = $_[3];
            my $todo = $_[4];
            my $depends = $_[5];
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::cmp_ok not implemented'))
        };
        sub like {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::like not implemented'))
        };
        sub unlike {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::unlike not implemented'))
        };
        sub eval_dies_ok {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::eval_dies_ok not implemented'))
        };
        sub isa_ok {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::isa_ok not implemented'))
        };
        sub use_ok {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::use_ok not implemented'))
        };
        sub throws_ok {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::throws_ok not implemented'))
        };
        sub dies_ok {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::dies_ok not implemented'))
        };
        sub lives_ok {
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::lives_ok not implemented'))
        };
        sub skip {
            my $reason = $_[0];
            my $depends = $_[1];
            Perlito6::Test::proclaim(1, '', ('skip ' . $reason), $depends)
        };
        sub pass {
            my $desc = $_[0];
            Perlito6::Test::proclaim(1, ('pass' . chr(33) . ' ' . $desc))
        };
        sub flunk {
            my $desc = $_[0];
            my $todo = $_[1];
            my $depends = $_[2];
            Perlito6::Test::proclaim(0, ('flunk' . chr(33) . ' ' . $desc), $todo, $depends)
        };
        sub proclaim {
            my $cond = $_[0];
            my $desc = $_[1];
            my $todo = $_[2];
            my $got = $_[3];
            my $expected = $_[4];
            my $depends = $_[5];
            my $negate = $_[6];
            ($testing_started = 1);
            ($num_of_tests_run = ($num_of_tests_run + 1));
            if (($cond)) {
                Main::say(('ok '), $num_of_tests_run)
            }
            else {
                Main::say(('not ok '), $num_of_tests_run);
                Perlito6::Test::report_failure($todo, $got, $expected, $negate)
            };
            return scalar ($cond)
        };
        sub report_failure {
            my $todo = $_[0];
            my $got = $_[1];
            my $expected = $_[2];
            my $negate = $_[3];
            Main::say((chr(35) . chr(35) . chr(35) . ' Perlito6::Test::report_failure not implemented'))
        };
        sub test_ends {
            if ((!($testing_started))) {
                return ()
            };
            if ((!($num_of_tests_planned))) {
                Main::say(('1..' . $num_of_tests_run))
            };
            if ((($num_of_tests_planned != $num_of_tests_run))) {
                Main::say((chr(35) . ' Looks like you planned ' . $num_of_tests_planned . (' tests, but ran ') . $num_of_tests_run))
            };
            if (($num_of_tests_failed)) {
                Main::say((chr(35) . ' Looks like you failed ' . $num_of_tests_failed . (' tests of ') . $num_of_tests_run))
            };
            ($num_of_tests_run = 0);
            ($num_of_tests_failed = 0);
            ($num_of_tests_planned = 0);
            ($testing_started = 0)
        }
    }


}

1;
