=encoding utf-8

=head1 NAME

HTML::Object::XQuery - HTML XQuery Extension

=head1 SYNOPSIS

    use HTML::Object::DOM global_dom => 1;
    use HTML::Object::XQuery;
    my $e = HTML::Object::Element->new || die( HTML::Object::Element->error, "\n" );

=head1 VERSION

    v0.4.0

=head1 DESCRIPTION

This class extends L<HTML::Object::DOM::Element> and provided jQuery-like methods to manipulate and query L<HTML objects|HTML::Object::DOM::Element>. It is very extensive and closely mirrors L<jQuery api|https://api.jquery.com/> with some additional features specific to perl.

By calling C<< use HTML::Object::DOM global_dom => 1; >>, this will instantiate a global DOM mimicking the one on a web page. This, in turns, enables calls such as:

    $("li")->addClass("hello");

Without the need to specify any context like:

    my $p = HTML::Object::DOM->new;
    my $context = $p->parse_file( "/path/to/some/file.html" );
    $("li", $context)->addClass("hello");

Calling C<< use HTML::Object::DOM global_dom => 1; >> also enables the use of the special function C<$()>, which is, normally, not possible in perl.

Since L<HTML::Object::XQuery> extends L<HTML::Object::DOM::Element>, but does not inherit from it, you cannot create a C<HTML::Object::XQuery> object. You can simply load L<HTML::Object::DOM> and then load C<HTML::Object::XQuery> to extend the methods available in L<HTML::Object::DOM::Element>

    use HTML::Object::DOM global_dom => 1;
    use HTML::Object::XQuery;
    # and the rest as usua;
    my $p = HTML::Object::DOM->new;
    my $doc = $p->parse_data( $some_html ) || die( $p->error );
    $('div')->css({ background => 'red' });

=head1 INHERITANCE

    +--------------+     +----------------------------+     +----------------------+
    | HTML::Object | --> | HTML::Object::DOM::Element | --> | HTML::Object::XQuery |
    +--------------+     +----------------------------+     +----------------------+

=head1 METHODS

=head2 add

Create a new object with elements added to the set of matched elements.

This returns a new L<collection element|HTML::Object::Collection>. Contrary to what one could assume, this does not add the elements to the dom, but only to the collection.

The argument to L</add> can be pretty much anything that C<$()> (L</xq>) accepts, including a selector expression, elements objects, or an HTML snippet.

Takes:

=over 4

=item * a selector (e.g. '.some-class'); or

=item * a collection (i.e. one or more elements resulting from a find or equivalent query); or

=item * "HTML fragment to add to the set of matched elements."; or

=item * a selector and a context (i.e. an element object); or

=item * a element object

=back

Returns a new L<HTML::Object::Collection> object.

For example, consider:

    <ul>
      <li>list item 1</li>
      <li>list item 2</li>
      <li>list item 3</li>
    </ul>
    <p>a paragraph</p>

    $( "li" )->add( "p" )->css( "background-color", "red" );

This will select the C<li> tags, then add the C<p> tag to the collection set of elements objects and finally will apply the css change of background colour.

If we pass an HTML snippet as argument, such as:

    $( "li" )->add( "<p id='new'>new paragraph</p>" )
      ->css( "background-color", "red" );

The paragraph will have been created dynamically and added to the set, but is not yet part of the dom until some methods are used to insert it.

    $( "p" )->clone()->add( "<span>Again</span>" )->appendTo( "body" );

B<Note>: To reverse the L</add> you can use C<< $e->not( elements | selector ) >> to remove elements from the collection results, or L</end> to return to the selection before you added.

See L<https://api.jquery.com/add/>

=head2 addClass

Provided with a css class name and this will add it to the current object, which can be either a collection object (L<HTML::Object::Collection>), or an html element (L<HTML::Object::DOM::Element>).

See L<https://api.jquery.com/addClass/>

=head2 after

Insert content, specified by the parameter, after each element in the set of matched elements.

L</after> and L</insertAfter> methods perform the same task. The major difference is in the syntaxâ€”specifically, in the placement of the content and target. With L</after>, the content to be inserted comes from the method's argument: 

    xq(target)->after( contentToBeInserted );

With L</insertAfter>, on the other hand, the content precedes the method and is inserted after the target, which in turn is passed as the L</insertAfter> method's argument:

    xq(contentToBeInserted)->insertAfter(target);

For example, consider the following HTML:

    <div class="container">
      <h2>Greetings</h2>
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>

    my $p = HTML::Object::DOM->new;
    my $doc = $p->parse_data( $html );

Content can be created and then inserted after several elements at once:

    xq( ".inner", $doc )->after( "<p>Test</p>" );

Each inner C<E<lt>divE<gt>> element gets this new content:

    <div class="container">
      <h2>Greetings</h2>
      <div class="inner">Hello</div>
      <p>Test</p>
      <div class="inner">Goodbye</div>
      <p>Test</p>
    </div>

An element in the DOM can also be selected and inserted after another element:

    xq( ".container", $doc )->after( xq( "h2", $doc ) );

If an element selected this way is inserted into a single location elsewhere in the DOM, it will be moved rather than cloned:

    <div class="container">
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>
    <h2>Greetings</h2>

You can also pass a code reference that returns the elements to insert.

    xq( "p", $doc )->after(sub {
      return "<div>" + $_->className + "</div>";
    });

L<https://api.jquery.com/after/>

=head2 ajax

Perform an asynchronous HTTP (Ajax) request.

This takes an url and an optional hash or hash reference of parameters.

This method requires L<HTTP::Promise> version C<0.5.0> or higher to be installed.

The URL can be a contextual URL such as absolute or relative URL provided you have set the value for L<documentURI|HTML::Object::DOM::Document/documentURI> in class L<HTML::Object::DOM::Document>, which is the root element of the DOM. You can access it using the L<getRootNode|HTML::Object::DOM::Node> method.

For example:

    $doc->documentURI = 'https://example.com/some/where';
    my $body = $('body', $doc);
    # The URI will become https://example.com/other/path
    $body->ajax( '/other/path' )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        say "Yeah!";
        # Do some work here...
    });

Below are the options supported, mirroring the ones implemented in jQuery, whenever possible:

=over 4

=item * C<accept>

    $el->ajax( $url,
        accept => 'text/html, text/plain, image/*',
    )->then(sub
    (
        # do something...
    });

String. Set the HTTP C<Accept> header value, such as: C<text/html, text/plain, image/*>

=item * C<accepts>

    $el->ajax( $url,
        accepts => [
            mycustomtype => 'application/x-some-custom-type',
        ],
        converters =>
        {
            mycustomtype => sub
            {
                my $result = shift( @_ );
                # Do Stuff
                return( $newresult );
            },
        },
        dataType => 'mycustomtype',
    )->then(sub
    (
        # do something...
    });

Array reference. This takes an array reference of key-value pairs, with the key being a data type and the value being the MIME-type.

The data type thus defined should also be set with the C<converters> option.

=item * C<async>

    my( $content, $status, $resp, $http ) = $el->ajax( $url,
        async => 0,
    ) || die( $el->error );

Or

    $el->ajax( $url,
        # No need to specify actually, because it defaults to true.
        async => 1,
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $resp, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

Boolean. This defaults to true. This specifies whether the HTTP request is made asynchronously or synchronously.

When the HTTP request is made asynchronously, it returns a L<Promise::Me> object that you can use to chain C<then> and C<catch> methods.

The next C<then> method will receive an L<HTTP::Promise> object

When it is used synchronously, this method will return 4 values: the C<$content>, the C<$status>, the L<HTTP::Promise::Response> object and the L<HTTP object|HTTP::Promise> used.

=item * C<beforeSend>

    $el->ajax( $url,
        beforeSend => sub
        {
            # Receive a HTTP::Promise::Request object
            my $req = shift( @_ );
            # Do some work
            return( $req );
            # Return undef to cancel the query
        },
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $resp, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

This is a pre-request callback function that can be used to modify the L<HTTP::Promise::Request> object, before it is used. Use this to set custom headers, etc. The current L<HTTP::Promise::Request> object is passed as the sole argument to the callback.

Returning false in the beforeSend function will cancel the request. Otherwise, it expects a valid L<HTTP::Promise::Request> object.

Cancelling the request means the resulting values returned will be: an empty string, the status C<abort>, C<undef> (because there is no L<HTTP::Promise::Response> object), and the L<HTTP::Promise> object.

The C<complete> option can accept an array of code reference. Each callback will be called in turn.

=item * C<complete>

A callback as code reference to be called when the request finishes (after success and error callbacks are executed). The callback gets passed three arguments:

=over 8

=item 1. the L<HTTP::Promise::Response> object; and

=item 2. a string categorizing the status of the request (C<success>, C<notmodified>, C<nocontent>, C<error>, C<timeout>, C<abort>, or C<parsererror>); and

=item 3. the L<HTTP::Promise> object

=back

=item * C<contents>

This option is not used.

=item * C<contentType>

String. By default C<application/x-www-form-urlencoded; charset=UTF-8>

When sending data to the server, use this content type. Default is C<application/x-www-form-urlencoded; charset=UTF-8>, which is fine for most cases. If you explicitly pass in a content-type to C<ajax>(), then it is always sent to the server (even if no data is sent). You can pass false to tell this method to not set any content type header.

=item * C<context>

This option is not used.

=item * C<converters>

    $el->ajax( $url,
        converters =>
        {
            "* text" => sub{ return( Module::Generic::Scalar->new( $_[0] ) ); },
            # true
            "text html" => 1,
            "text json" => sub
            {
                my $json = shift( @_ );
                # Do something decoding JSON
                return( $hash_ref );
            },
            "text xml" => sub
            {
                my $xml = shift( @_ );
                # Decode XML
                return( $xml_object );
            },
        },
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

An object containing dataType-to-dataType converters. Each converter's value is a function that returns the transformed value of the response.

=item * C<crossDomain>

This option is not used.

=item * C<data>

C<data> can be an hash reference, a string or an array reference.

Data to be sent to the server. If the HTTP method is one that cannot have an entity body, such as C<GET>, the data is appended to the URL.

When data is an hash reference, this method generates the data string from the hash reference's key/value pairs unless the C<processData> option is set to false. For example, { a: "bc", d: "e,f" } is converted to the string "a=bc&d=e%2Cf". If the value is an array, L<HTTP::Promise> serialises multiple values with same key based on the value of the traditional setting (described below). For example, { a: [1,2] } becomes the string "a%5B%5D=1&a%5B%5D=2" with the default traditional: false setting.

When data is passed as a string it should already be encoded using the correct encoding for C<contentType>, which by default is C<application/x-www-form-urlencoded>.

=item * C<dataFilter>

    $el->ajax( $url,
        dataFilter => sub
        {
            my( $content, $dataType ) = @_;
            # Do some processing on the $content
            return( $new_content );
        },
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

A callback code reference to be used to handle the raw response data of HTTP response. This is a pre-filtering function to sanitise the response. You should return the sanitized data. The function accepts two arguments: The raw data returned from the server and the C<dataType> parameter.

=item * C<dataType>

The type of data that you are expecting back from the server. If none is specified, this method will try to infer it based on the MIME type of the response. The available types (and the result passed as the first argument to your success callback) are:

=over 8

=item * C<xml>

    Returns a XML document that can be processed via jQuery.

=item * C<html>

    Returns HTML as plain text; included script tags are evaluated when inserted in the DOM.

=item * C<script>

    Evaluates the response as JavaScript and returns it as plain text. Disables caching by appending a query string parameter, _=[TIMESTAMP], to the URL unless the cache option is set to true. Note: This will turn POSTs into GETs for remote-domain requests. Prior to jQuery 3.5.0, unsuccessful HTTP responses with a script Content-Type were still executed.

=item * C<json>:

Evaluates the response as JSON and returns a JavaScript object. Cross-domain "json" requests that have a callback placeholder, e.g. ?callback=?, are performed using JSONP unless the request includes jsonp: false in its request options. The JSON data is parsed in a strict manner; any malformed JSON is rejected and a parse error is thrown. As of jQuery 1.9, an empty response is also rejected; the server should return a response of null or {} instead. (See json.org for more information on proper JSON formatting.)

=item * C<jsonp>

Loads in a JSON block using JSONP. Adds an extra "?callback=?" to the end of your URL to specify the callback. Disables caching by appending a query string parameter, "_=[TIMESTAMP]", to the URL unless the cache option is set to true.

=item * C<text>

A plain text string.

=item * C<multiple, space-separated values>

This method can convert a C<dataType> from what it received in the C<Content-Type> header to what you require. For example, if you want a text response to be treated as XML, use C<text xml> for the C<dataType>. You can also make a C<JSONP> request, have it received as text, and interpreted by this method as XML: C<jsonp text xml>. Similarly, a shorthand string such as C<jsonp xml> will first attempt to convert from jsonp to xml, and, failing that, convert from jsonp to text, and then from text to xml.

=back

=item * C<error>

A callback code reference to be called if the request fails. The callback receives three arguments:

=over 8

=item 1. the L<HTTP::Promise::Request> object;

=item 2. a string describing the type of error that occurred; and

=item 3. an optional exception object, if one occurred.

=back

Possible values for the second argument (besides null) are C<timeout>, C<error>, C<abort>, and C<parsererror>. When an HTTP error occurs, C<errorThrown> receives the textual portion of the HTTP status, such as C<Not Found> or C<Internal Server Error>. (in HTTP/2 it may instead be an empty string). The C<error> setting can accept an array of callbacks. Each callback will be called in turn.

=item * C<global>

B<This option is not used.>

Boolean.

Whether to trigger global Ajax event handlers for this request. The default is true. Set to false to prevent the global handlers like ajaxStart or ajaxStop from being triggered. This can be used to control various Ajax Events.

=item * C<headers>

An object of additional header key/value pairs to send along with requests using the L<HTTP::Promise> object. The header C<X-Requested-With: XMLHttpRequest> is always added, but its default XMLHttpRequest value can be changed here. Values in the headers setting can also be overwritten from within the beforeSend function.

=item * C<ifModified>

    $el->ajax( $url,
        ifModified =>
        {
            since => 1714023492,
            etag => '33a64df551425fcc55e4d42a148795d9f25f89d4',
            # or, explicitly specifying weak algorithm, which is superflous since it is
            # the default used in the HTTP protocol for If-None-Match
            # etag => 'W/"33a64df551425fcc55e4d42a148795d9f25f89d4"',
        },
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

This takes an hash reference with possible key C<since> and C<etag>

This allows the request to be successful only if the response has changed since the last request. This is done by checking the C<Last-Modified> header. Default value is false, ignoring the header.

If C<since> is provided with a value of a 10 digits integer, it will be used to issue a C<If-Modified-Since> HTTP header.

If C<etag> is provided with a value of alphanumeric characters and C<_> and C<->, this will be used to issue an HTTP header C<If-None-Match>

=item * C<isLocal>

This option is not used.

=item * C<jsonp>

This option is not used.

=item * C<jsonpCallback>

This option is not used.

=item * C<method>

This takes a string specifying the HTTP method to use for the request. Supported values are: C<GET>, C<HEAD>, C<OPTIONS>, C<PATCH>, C<POST>, C<PUT>. The value is case-insensitive.

=item * C<mimeType>

    # Will issue a Content-Type: application/json
    $el->ajax( $url,
        mimeType => 'application/json',
        data =>
        {
            client_id => 1234567,
            created_on => 1714023492,
        },
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

A mime type to override the HTTP mime type.

=item * C<password>

    my $url = "https://john:helloworld@example.com/some/where";
    $el->ajax( $url )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

would result in:

    GET /some/where HTTP/1.1
    Host: example.com
    Authorization: Basic am9objpoZWxsb3dvcmxk

Or

    my $url = "https://example.com/some/where";
    $el->ajax( $url,
        username => 'john',
        password => 'helloworld',
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

would yield identical result

A password to be used with the HTTP request in response to an HTTP access authentication request.

This is to be used in conjonction with the C<username> option. This will result in an HTTP header such as C<Authorization: Basic am9objpoZWxsb3dvcmxk>

You can also provide it as part of the URL, and it will be removed from the URL before the HTTP request is made.

=item * C<processData>

The way the data is handled depends on their nature, i.e. whether it is an hash reference, or an array reference or a regular string.

By default, data passed in to the data option as an hash reference or array reference (technically, anything other than a string) will be processed and transformed into a query string, fitting to the default content-type C<application/x-www-form-urlencoded>. If you want to send a DOMDocument, or other non-processed data, set this option to false.

=item * C<scriptAttrs>

This option is not used.

Original jQuery documentation states:

Defines an object with additional attributes to be used in a C<script> or C<jsonp> request. The key represents the name of the attribute and the value is the attribute's value. If this object is provided it will force the use of a script-tag transport. For example, this can be used to set C<nonce>, C<integrity>, or C<crossorigin> attributes to satisfy Content Security Policy requirements.

=item * C<scriptCharset>

This option is not used.

Original jQuery documentation states:

Only applies when the C<script> transport is used. Sets the charset attribute on the script tag used in the request. Used when the character set on the local page is not the same as the one on the remote script. Alternatively, the C<charset> attribute can be specified in C<scriptAttrs> instead, which will also ensure the use of the C<script> transport.

=item * C<statusCode>

An hash reference of numeric HTTP codes and callback code reference to be called when the response has the corresponding code. For example, the following will alert when the response status is a 404:

    $el->ajax( $url,
        statusCode:
        {
            404 => sub
            {
                warn( "page not found" );
            }
        }
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

If the request is successful, the status code callbacks take the same parameters as the C<success> callback, i.e. C<$content>, C<$status>, L<HTTP::Promise::Response> object, L<HTTP::Promise> object; if it results in an error (including 3xx redirect), they take the same parameters as the C<error> callback, i.e. L<HTTP::Promise::Request> object, C<$status>, C<$errorthrown>.

=item * C<success>

    $el->ajax( $url,
        success => sub
        {
            my( $content, $status, $resp_object ) = @_;
            # Do something
        },
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

Or

    $el->ajax( $url,
        success => [
            sub
            {
                my( $content, $status, $http_object ) = @_;
                # Do something
            },
            # another callback
            sub
            {
                my( $content, $status, $http_object ) = @_;
                # Do something else
            },
            # and you can add more callbacks
        ],
    )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $content, $status, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "An error occurred: ", $err->message;
    });

A function to be called if the request succeeds. The function gets passed four arguments:

=over 8

=item 1. The data returned from the server, formatted according to the dataType parameter or the dataFilter callback function, if specified;

=item 2. a string describing the status; and

=item 3. the L<HTTP::Promise::Response> object; and

=item 4. the L<HTTP::Promise> object.

=back

The success setting can accept an array of callbacks. Each callback will be called in turn. This is an Ajax Event.

=item * C<timeout>

Set a timeout for the request. The value can be in seconds (an integer) or milliseconds using fractional number such as 0.25 for 250 milliseconds. See L<select|perlfunc/select>

A value of 0 means there will be no timeout. The timeout period starts at the point the C<ajax> call is made; if several other requests are in progress and the browser has no connections available, it is possible for a request to time out before it can be sent.

=item * C<traditional>

This option is not used.

Original jQuery documentation states:

Set this to true if you wish to use the traditional style of L<param serialization|https://api.jquery.com/jQuery.param/>.

=item * C<type>

An alias for C<method>.

=item * C<url>

A string containing the URL to which the request is sent. This will override the C<$url> argument passed to the C<ajax> method.

=item * C<username>

A username to be used with the HTTP request in response to an HTTP access authentication request.

This is to be used in conjonction with the C<password> option. This will result in an HTTP header such as C<Authorization: Basic am9objpoZWxsb3dvcmxk>

You can also provide it as part of the URL, and it will be removed from the URL before the HTTP request is made.

=item * C<xhr>

Callback code reference for creating the L<HTTP::Promise::Request> object. Override to provide your own implementation for L<HTTP::Promise::Request>.

This will override all parameters provided to instantiate a new L<HTTP::Promise::Request> object. It expects a L<HTTP::Promise::Request> object in return, or will return an error.

=item * C<xhrFields>

This option is not used.

Original jQuery documentation states:

An object of fieldName-fieldValue pairs to set on the native XHR object. For example, you can use it to set C<withCredentials> to true for cross-domain requests if needed.

=back

L<https://api.jquery.com/jQuery.ajax/>

See the L<load method|/load>>

=head2 ajaxSetup

B<This is still a work in progress>

L<https://api.jquery.com/jQuery.ajaxSetup/>

=head2 append

This method inserts the specified content as the last child of each element in the collection (To insert it as the first child, use L</prepend>).

It takes the following possible arguments:

=over 4

=item * an html string

=item * an array reference of html strings

=item * an L<HTML::Object::DOM::Element> object

=item * code reference

Will be executed to retrieve the string

=back

For example:

    <h2>Greetings</h2>
    <div class="container">
        <div class="inner">Hello</div>
        <div class="inner">Goodbye</div>
    </div>

This will create content and insert it into several elements at once:

    $( ".inner" )->append( "<p>Test</p>" );

Each inner <div> element gets this new content, such as:

    <h2>Greetings</h2>
    <div class="container">
        <div class="inner">
            Hello
            <p>Test</p>
        </div>
        <div class="inner">
            Goodbye
            <p>Test</p>
        </div>
    </div>

You can also select an element on the page and insert it into another:

    $( ".container" )->append( $( "h2" ) );

If an element selected this way is inserted into a single location elsewhere in the DOM, it will be moved into the target (not cloned):

    <div class="container">
        <div class="inner">Hello</div>
        <div class="inner">Goodbye</div>
        <h2>Greetings</h2>
    </div>

B<Important>: If there is more than one target element, however, cloned copies of the inserted element will be created for each target except for the last one.

=head3 Additional Arguments

Similar to other content-adding methods such as L</prepend> and L</before>, L</append> also supports passing in multiple arguments as input. Supported input includes L<HTML elements|HTML::Object::DOM::Element>, L<collection objects|HTML::Object::Collection>, HTML strings, and arrays of L<HTML elements|HTML::Object::DOM::Element>.

For example, the following will insert two new <div>s and an existing <div> as the last three child nodes of the body:

    my $newdiv1 = $( "<div id='object1'></div>" ),
    my $newdiv2 = $doc->createElement( "div" ),
    my $existingdiv1 = $doc->getElementById( "foo" );
    
    $( "body" )->append( $newdiv1, [ newdiv2, existingdiv1 ] );

L<https://api.jquery.com/append/>

=head2 appendTo

Same as L</append>, except that instead of using the current object, the current object is appended to the object specified.

L<https://api.jquery.com/appendTo/>

=head2 attr

If more than 1 values are provided, it will set the attributes with their keys and associated values.

If only one parameter is provided, this will return the corresponding value.

L<https://api.jquery.com/attr/>

=head2 before

L</before> and L</insertBefore> methods perform the same task. The major difference is in the syntaxâ€”specifically, in the placement of the content and target. With L</before>, the content to be inserted comes from the method's argument: 

    xq($target)->before( $contentToBeInserted )

With L</insertBefore>, on the other hand, the content precedes the method and is inserted before the target, which in turn is passed as the L</insertBefore> method's argument:

    xq($contentToBeInserted)->insertBefore( $target );

    <div class="container">
      <h2>Greetings</h2>
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>

    my $p = HTML::Object::DOM->new;
    my $doc = $p->parse_data( $html );

You can create content and insert it before several elements at once:

    xq( ".inner", $doc )->before( "<p>Test</p>" );

Each inner E<lt>divE<gt> element gets this new content:

    <div class="container">
      <h2>Greetings</h2>
      <p>Test</p>
      <div class="inner">Hello</div>
      <p>Test</p>
      <div class="inner">Goodbye</div>
    </div>

You can also select an element on the page and insert it before another:

    xq( ".container", $doc )->before( xq( "h2", $doc ) );

If an element selected this way is inserted into a single location elsewhere in the DOM, it will be moved before the target (not cloned):

    <h2>Greetings</h2>
    <div class="container">
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>

L<https://api.jquery.com/before/>

=head2 closest

Takes a selector; or a selector and an L<HTML::Object::DOM::Element> as a context; or a L<HTML::Object::DOM::Element> object "Given a jQuery object that represents a set of DOM elements, the .closest() method searches through these elements and their ancestors in the DOM tree and constructs a new jQuery object from the matching elements."

It returns a L<HTML::Object::Collection> object.

L<https://api.jquery.com/closest/>

=head2 cmp

Comparison operator between objects

=head2 contains

    $el->contains( $other_element ); # returns true or false
    $el->contains( $container, $other_element );

If 2 arguments are provided, the first one is the DOM element, a.k.a. the C<container>, that may contain the other element, and the second is the DOM element, a.k.a. the C<contained>, that may be contained by (a descendant of) the other element.

If only 1 argument is provided, the C<container> is the current element, and it checks to see if the DOM element provided, a.k.a. the C<contained>, is a descendant of the current element.

The C<contains()> method returns true (1) if the C<contained> element is a descendant of the C<container> element, whether it is a direct child or nested more deeply. Otherwise, it returns false (0). Only L<element nodes|HTML::Object::DOM::Element> are supported; if the C<contained> element is a L<text|HTML::Object::DOM::Text> or L<comment node|HTML::Object::DOM::Comment>, C<contains()> will return false (0).

If an error occurred, it sets an L<error object|HTML::Object::Exception> and returns C<undef> in scalar context, or an empty list in list context.

Example:

    $el->contains( $document->documentElement, $document->body ); # true
    $el->contains( $document->body, $document->documentElement ); # false

=head2 contents

Get the children of each element in the set of matched elements, including L<text|HTML::Object::DOM::Text>, L<space|HTML::Object::DOM::Space> and L<comment|HTML::Object::DOM::Comment> nodes.

Given an object that represents a set of DOM elements, the C<.contents()> method allows us to search through the immediate children of these elements in the DOM tree and construct a new object from the matching elements.

Under jQuery, the C<.contents()> and C<.children()> methods are similar, except that the former includes text nodes and comment nodes as well as HTML elements in the resulting jQuery object. However, under L<HTML::Object>, both are identical and they both return all children including, text, space and comment elements.

Example:

    <div class="container">
        Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed
        do eiusmod tempor incididunt ut labore et dolore magna aliqua.
        <br><br>
        Ut enim ad minim veniam, quis nostrud exercitation ullamco
        laboris nisi ut aliquip ex ea commodo consequat.
        <br><br>
        Duis aute irure dolor in reprehenderit in voluptate velit
        esse cillum dolore eu fugiat nulla pariatur.
    </div>

    use HTML::Object::DOM::Node; # import TEXT_NODE
    $('.container')
        ->contents()
        ->filter(sub
        {
            return $_->nodeType == TEXT_NODE;
            # or
            # return $_->nodeType == 3;
        })
        ->wrap( "<p></p>" )
        # Revert back to $('.container')
        ->end()
        ->filter( "br" )
        ->remove();

would become:

    <div class="container">
        <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed
        do eiusmod tempor incididunt ut labore et dolore magna aliqua.</p>
        <p>Ut enim ad minim veniam, quis nostrud exercitation ullamco
        laboris nisi ut aliquip ex ea commodo consequat.</p>
        <p>Duis aute irure dolor in reprehenderit in voluptate velit
        esse cillum dolore eu fugiat nulla pariatur.</p>
    </div>

Another example:

    <p>Hello <a href="https://johnresig.com/">John</a>, how are you doing?</p>
 
    $('p')
        ->contents()
        ->filter(sub
        {
            return( $_->nodeType !== 1 );
        })
        ->wrap( '<b></b>' );

would yield something like:

B<Hello> L<John|https://johnresig.com/>B<, how are you doing?>

=head2 css

Takes a property name; or an array reference of one or more css properties; or a property name and a value; or a property name and a function; or an hash reference of property name-value pairs

This wil set the css attribute for that element.

=head2 css_cache_check

Provided with some data and this will check the checksum to re-use the cache or not.

It returns an empty string when no cache can be re-used.

=head2 css_cache_store

Provided with some css data for this element and this will cache it.

=head2 data

Provided with a name and some value and this will set the C<data> attribute for this element or collection of elements accordingly.

If the data provided is an hash reference, each key-value pair will be added as data attribute to the element of the collection of elements.

If only a name is provided, with no value, this will return the corresponding value.

For example:

    $('body')->data( "foo", 52 );
    $('body')->data( "bar", { isManual => $true } );
    $('body')->data( { baz: [ 1, 2, 3 ] } );
    $('body')->data( "foo" ); # 52
    $('body')->data(); # { foo: 52, bar => { isManual => true }, baz => [ 1, 2, 3 ] }

Unlike the jQuery equivalent, this method affects directly the attributes of the elements.

Under jQuery, using data only sets the data for the given element without creating the related attributes.

L<https://api.jquery.com/data/>

=head2 detach

Detach the current element or the collection of elements and return the current object.

Detach concretely means remove the element or elements from its parent and set the C<parent> value for each element to C<undef>

L<https://api.jquery.com/detach/>

=head2 each

    xq('.some-thing')->each(sub
    {
        my( $i, $e ) = @_;
        # do something
    });

Takes a code reference which receives the element position and element object as parameter.

It returns the current object it was called with.

L<https://api.jquery.com/each/>

=head2 empty

This will empty the current element or collection of elements. This mean there will be no children elements anymore.

L<https://api.jquery.com/empty/>

=head2 end

Sets or gets an L<HTML::Object::DOM::Element> object.

This is useful to get back to a given element context.

For example, given this HTML chunk:

    <ul class="first">
        <li class="foo">list item 1</li>
        <li>list item 2</li>
        <li class="bar">list item 3</li>
    </ul>
    <ul class="second">
        <li class="foo">list item 1</li>
        <li>list item 2</li>
        <li class="bar">list item 3</li>
    </ul>

    $('ul.first')
        ->find( '.foo' )
        ->css( 'background-color', 'red' )
        ->end()
    ->find( '.bar' )
    ->css( 'background-color', 'green' );

This chain searches for items with the class C<foo> within the first list only and turns their backgrounds red. Then C<end()> returns the object to its state before the call to L<find()|/find>, so the second L<find()|/find> looks for '.bar' inside C<< <ul class="first"> >>, not just inside that list's C<< <li class="foo"> >>, and turns the matching elements' backgrounds green. The net result is that items 1 and 3 of the first list have a colored background, and none of the items from the second list do.

Another example:

    <p><span>Hello</span>, how are you?</p>

Selects all paragraphs, finds span elements inside these, and reverts the selection back to the paragraphs.

    $('p')
        ->find( "span" )
        ->end()
        ->css( 'border', '2px red solid' );

This would result in having the entire paragraph block with a red square line enclosing.

L<https://api.jquery.com/end/>

=head2 eq

Returns the children elements matching the value provided.

This calls L</children>, which returns an L<Module::Generic::Array> object and calls L<Module::Generic::Array/index> with the value provided.

L<https://api.jquery.com/eq/>

=head2 even

Returns a new collection of elements whose position is an even number

L<https://api.jquery.com/even/>

=head2 exists

Provided an C<xpath> and this will check if the current object exists in the C<xpath> provided.

=head2 filter

Takes a selector; or
function with arguments are element position (starting from 0) and the element itself, expecting a true value in return; or
an array of element objects; or
an element object;

L<https://api.jquery.com/filter/>

=head2 find

Takes a selector; or
Element object

L<https://api.jquery.com/find/>

=head2 find_xpath

Provided with an C<xpath> value and this will find and return all matches.

=head2 findnodes

Provided with an C<xpath> value and this will find and return all nodes.

=head2 findnodes_as_string

Provided with an C<xpath> value and this will find and return all nodes as string.

=head2 findnodes_as_strings

Same as L</findnodes_as_string>, but plural

Provided with an C<xpath> value and this will find and return all nodes as strings.

=head2 findvalue

Provided with an C<xpath> value and this will find and return node value.

=head2 findvalues

Same as L</findvalue>, but plural

Provided with an C<xpath> value and this will find and return nodes value.

=head2 first

Returns the first element of the collection if the object is a collection, or the element itself.

L<https://api.jquery.com/first/>

=head2 get

There are 2 possibilities: the element is a collection or not.

=over 4

=item 1. If this is a L<collection|HTML::DOM::Collection>:

If an integer representing an array index is provided, this retrieves the element at the given offset.

If no integer is provided, this returns all the collection elements and returns a new L<array object|Module::Generic::Array>

=item 2. If this is an L<element object|HTML::Object::DOM::Element>:

This returns the current object, irrespective of any index value provided, since it is the only one available.

=back

The C<.get()> method grants access to the DOM nodes underlying each L<collection object|HTML::Object::Collection>. If the value of index is out of bounds, such as being less than the negative number of elements or equal to or greater than the number of elements, it returns C<undef>, just like when accessing a regular perl array would. 

For example:

    <ul>
        <li id="foo">foo</li>
        <li id="bar">bar</li>
    </ul>

With an index specified, C<.get( $index )> retrieves a single element:

    $('li')->get(0);

Since the index is zero-based, the first list item is returned, i.e.:

    <li id="foo">foo<</li>

A negative index is counted from the end of the matched set, thus in this example it would return the last item in the list:

    $('li')->get(-1);

This would return:

    <li id="bar">bar</li>

    say $('li')->get(-1)->nodeName; # li

When no C<index> is provided, this returns an L<array object|Module::Generic::Array>:

    <ul>
        <li id="foo">foo</li>
        <li id="bar">bar</li>
    </ul>

    $('li')->get();

All of the matched DOM nodes are returned by this call, contained in an L<array object|Module::Generic::Array>:

    [<li id="foo">foo</li>, <li id="bar">bar</li>]

L<https://api.jquery.com/get/>

=head2 getDataJson

    <div data-options='{"customer_id": 123, "issued_on": 1713832131}'></div>
    # or, URI encoded
    <div data-options="%7B%22customer_id%22%3A%20123%2C%20%22issued_on%22%3A%201713832131%7D"></div>
    my $elem = $('[data-options]', $doc);
    my $ref = $elem->getDataJson( 'options' );

This method takes the name of the data attribute for the element it is being called on, and returns an hash reference of the JSON data stored.

If this is called on a L<collection|HTML::Object::Collection>, then it will use the first element in the collection.

Once the JSON decoded, its associated hash reference will be saved in place so that following calls returns it much faster.

If there is no data, it returns an empty hash, but if there is an error, such as decoding the JSON data, then it will set an L<exception object|HTML::Object::Exception> and return C<undef> in scalar context, or an empty list in list context.

=head2 getJSON

    $el->getJSON( $url )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $hash_ref, $status, $resp, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "Oh no: $err";
    });

or, with both the data and the success callback specified:

    $el->getJSON( $url, {
        client_id => 1234567,
        tag => 'something',
    }, sub
    {
        # or an array reference depending on the JSON data structure
        my( $hash_ref, $status, $resp, $http ) = @_;
        # Do something
    })->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $hash_ref, $status, $resp, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "Oh no: $err";
    });

or, with the success callback first, then the data to be sent:

    $el->getJSON( $url, sub
    {
        # or an array reference depending on the JSON data structure
        my( $hash_ref, $status, $resp, $http ) = @_;
        # Do something
    },
    {
        client_id => 1234567,
        tag => 'something',
    })->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $hash_ref, $status, $resp, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "Oh no: $err";
    });

or, with just the data provided. You can also just provide the success callback instead:

    $el->getJSON( $url, 
    {
        client_id => 1234567,
        tag => 'something',
    })->then(sub
    {
        my( $resolve, $reject ) = @$_;
        my( $hash_ref, $status, $resp, $http ) = @_;
        # Do something
    })->catch(sub
    {
        my $err = shift( @_ );
        say "Oh no: $err";
    });

Load JSON-encoded data from the server using a GET HTTP request.

This takes an URL, an optional data that can be an hash reference, an array reference or a regular string, an optional success callback code reference. The URL is the first argument, but the C<data> and C<success> arguments can be in any order.

The URL can be a C<file://> URI, and you can even use contextual URL such as absolute or relative URL provided you have set the value for L<documentURI|HTML::Object::DOM::Document/documentURI> in class L<HTML::Object::DOM::Document>, which is the root element of the DOM. You can access it using the L<getRootNode|HTML::Object::DOM::Node> method.

For example:

    $doc->documentURI = 'https://example.com/some/where';
    my $body = $('body', $doc);
    # The URI will become https://example.com/other/path
    $body->getJSON( '/other/path.json' )->then(sub
    {
        my( $resolve, $reject ) = @$_;
        say "Yeah!";
        # Do some work here...
    });

This is a shorthand Ajax method, which is equivalent to:

    $el->ajax({
        dataType => "json",
        url      => $url,
        data     => $data,
        success  => $success
    });

Returns a L<Promise::Me> object.

This method requires L<HTTP::Promise> version C<0.5.0> or higher to be installed.

Data that is sent to the server is appended to the URL as a query string.
If the value of the data parameter is a plain object, it is converted to a string and url-encoded before it is appended to the URL.

Most implementations will specify a success handler:

    use Class::Array;
    $el->getJSON( "ajax/test.json", sub
    {
        my $data = shift( @_ );
        my $items = Class::Array->new([]);
        Class::Array->new( $data )->each(sub
        {
            my( $key, $val ) = @_;
            $items->push( "<li id='" . $key . "'>" . $val . "</li>" );
        });
        
        $( "<ul/>", 
        {
            class => 'my-new-list',
            html -> $items->join( '' )
        })->appendTo( 'body' );
    });

This example, of course, relies on the structure of the JSON file:

    {
        "one": "Singular sensation",
        "two": "Beady little eyes",
        "three": "Little birds pitch by my doorstep"
    }

Using this structure, the example loops through the requested data, builds an unordered list, and appends it to the body.

The C<success> callback is passed the returned data, which is typically an hash reference or array reference as defined by the JSON structure and parsed using the L<JSON/decode> method. It is also passed the text status of the response and the L<HTTP::Promise::Response> object.

C<getJSON>() implements the L<Promise|Promise::Me> interface, giving it all the properties, methods, and behavior of a Promise, namely L<Promise::Me/then> and L<Promise::Me/catch>

It is different from the jQuery interface that implements the methods C<done>, C<fail> and C<always>

    my $promise = $el->getJSON( 'example.json', sub
    {
        say( "success" );
    })->then(sub
    {
        say( "second success" );
    })->catch(sub
    {
        say( "error" );
    });

Example:

Loads the four most recent pictures of Mount Rainier from the Flickr JSONP API.

    my $html = <<EOT+
    <!doctype html>
    <html lang="en">
        <head>
            <meta charset="utf-8">
            <title>getJSON demo</title>
            <style>
            img {
                height: 100px;
                float: left;
            }
            </style>
        </head>
        <body>
            <div id="images"></div>
        </body>
    </html>
    EOT

    my $p = HTML::Parser->new;
    my $doc = $p->parse( $html ) || die( $p->error );
    my $body = $('body', $doc);
    use Class::Array;

    my $flickerAPI = 'https://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?';
    $body->getJSON( $flickerAPI, 
    {
        tags => "mount rainier",
        tagmode => "any",
        format => "json",
    })->then(sub
    {
        my $data = shift( @_ );
        Class::Array->new( $data->items )->each(sub
        {
            my( $i, $item ) = @_;
            $( '<img>' )->attr( 'src', $item->{media}->{m} )->appendTo( '#images' );
            if( $i === 3 )
            {
                return(0);
            }
        });
    });

Load the JSON data from test.js and access a name from the returned JSON data.

    $body->getJSON( 'test.js', sub
    {
        my $json = shift( @_ );
        say( "JSON Data: " . $json->{users}->[3]->{name} );
    });

Load the JSON data from test.js, passing along additional data, and access a name from the returned JSON data. If an error occurs, report an error message instead.

    $body->getJSON( 'test.js', { name => 'John', time => '2pm' } )->then(sub
    {
        my $json = shift( @_ );
        say( "JSON Data: " . $json->{users}->[3]->{name} );
    })->catch(sub
    {
        my( $resp, $textStatus, $error ) = @_;
        my $err = $textStatus . ", " . $error;
        say( "Request Failed: " . $err );
    });

head2 has

L</has> method constructs a new L<HTML::Object::Collection> object from a subset of the original object on which it is called, and that only includes elements with descendants that match the given selector.

Letâ€™s say you wanted to find all paragraphs that have links in them. Youâ€™d use:

    my $paragraphs = $xq('p', $doc);
    my $paragraphsWithLinks = $paragraphs->has('a');

The difference with the L</find> method[1], is that rather than returning a subset of the object on which it is called, returns a L<HTML::Object::Collection> object representing the elements that match the given selector that are descendants of the original object.

So, similar to the above example, instead of selecting paragraphs that have links in them, we instead get the links themselves that are inside paragraphs:

    my $paragraphs = $xq('p', $doc); 
    my $linksInParagraphs = $paragraphs->find('a');

[1] Paraphrasing the explanation provided by L<Andy Farrell|https://www.quora.com/What-is-the-difference-between-has-and-find-in-jQuery>

See also L</children>, L</filter>, L</find>

L<https://api.jquery.com/has/>

=head2 hasClass

Provided with a css class name and this will returns true if the current element has this class, or false otherwise.

L<https://api.jquery.com/hasClass/>

=head2 hide

This is roughly equivalent to calling L</css>( "display", "none" ), except that the value of the display property is saved in the object's internal data cache so that display can later be restored to its initial value. If an element has a display value of inline and is hidden then shown, it will once again be displayed inline.

It takes 1 or 2 argument. THe first one originally in jQuery is either a timer in millisecond or an easing effect or some option hash, but since none of this has any effect under perl, the first argument is ignored.

    $elem->hide( $hash_ref, sub{ $_->show() });

However, if there is only one argument and it is a code reference, it is used.

    $elem->hide( sub{ $_->show() });

The optional second argument is a code reference (a callback) that will be called passing it the element object.

It returns the object used to call this method in the first place.

    $elem->hide->show(); # Kind of meaningless, but hey this is an example

L<https://api.jquery.com/hide/>

=head2 html

When no argument is provided, this returns the html string of its content for element object, or the html string of the content of the first object if this is a collection object, i.e. a L<HTML::Object::Collection> object.

    my $html_string = $element->html();
    # or, here this is a collection object
    xq('body', $doc)->html();
    # or if this is a single html element object
    xq('body', $doc)->first->html();

When an argument is provided, it takes either some html data as a string, or a code reference.

In the case of a code reference, it is called with the element position, starting at 0 and the old html data string. It expects in returns either:

=over 4

=item 1. an empty or undefined value, in which case the current element will have its content emptied using L</empty>

=item 2. some html data, in which case it is parsed using L<HTML::Object::DOM/parse_data> and the object found are used to replace the content of the current element object.

=item 3. an L<HTML::Object::DOM::Element> object whose content elements will be used in replacement of the content of the current object

=back

Quoting jQuery documentation, for example, consider this html:

    <div class="demo-container">
      <div class="demo-box">Demonstration Box</div>
    </div>

Assuming this html is stored in a variable C<$html>:

    my $p = HTML::Object::DOM->new;
    my $doc = $p->parse_data( $html ) || die( $p->error, "\n" );

The content of <div class="demo-container"> can be set like this:

    xq( "div.demo-container", $doc )
      ->html( "<p>All new content. <em>You bet!</em></p>" );

That line of code will replace everything inside C<E<lt>div class="demo-container"E<gt>>:

    <div class="demo-container">
      <p>All new content. <em>You bet!</em></p>
    </div>

Or

    xq( "div.demo-container", $doc )->html(sub {
      my $emphasis = "<em>" + $xq( "p", $doc )->length + " paragraphs!</em>";
      return "<p>All new content for " + emphasis + "</p>";
    });

Afer the html value is set, it returns the object it was called with.

To set the content of a E<lt>scriptE<gt> element, which does not contain HTML, use the L</text> method and not L</html>.

L<https://api.jquery.com/html/>

=head2 index

Search for a given element from among the matched elements.

When no argument is provided, the return value is an integer indicating the position of the element, starting from 0, within its parent.

If L</index> is called on a collection of elements (i.e. a L<HTML::Object::Collection> object) and an element object (L<HTML::Object::DOM::Element>) is provided as argument, L</index> returns an integer indicating the position of the provided element relative to the original collection.

This would behave as a complementary operation to L</get>, which accepts an index and returns a element object. Under jQuery, L</get> would return DOM element, but there is no such thing in this perl context.

If a selector string is passed as an argument, L</index> returns an integer indicating the position of the first element within the object relative to the elements matched by the selector. If the element is not found, C<-1> will be returned.

For example, consider the following html:

    <ul>
      <li id="foo">foo</li>
      <li id="bar">bar</li>
      <li id="baz">baz</li>
    </ul>

    my $p = HTML::Object::DOM->new;
    my $document = $p->parse_data( $html );

If we retrieve one of the three list items (for example, through one of the element object's functions), L</index> can search for this list item within the set of matched elements:

    my $listItem = $document->getElementById( "bar" );
    say( "Index: " + xq( "li", $document )->index( $listItem ) );

We get back the zero-based position of the list item:

    Index: 1

Note that if a collection object (L<HTML::Object::Collection>) is used as the L</index> method's argument and it contains more than one element, the first element within that collection will be used.

If we use a string as the L</index> method's argument, it is interpreted as a selector string. The first element among the L<HTML::Object::Collection|collection> object's matched elements which also matches this selector is located. If the object is just one L<HTML::Object::DOM::Element> object, the selector is tested against it.

    my $listItem = xq( "#bar", $document );
    say( "Index: " + $listItem->index( "li" ) );

Or, using a single L<HTML::Object::DOM::Element>, the same will check against that element alone.

    my $element = xq( "#bar", $document )->first();
    say( "Index: " + $listItem->index( "li" ) );

Without any arguments, L</index> will return the position of the first element, if this is a L<HTML::Object::Collection|collection object>, in relation to its siblings, or the position of the element itself if this is just an L<HTML::Object::DOM::Element>

    say( "Index: " + xq( "#bar", $document )->index() );

L<https://api.jquery.com/index/>

=head2 insertAfter

Insert every element in the set of matched elements after the target.

The target can be one of a selector, an element object (L<HTML::Object::DOM::Element>), an array of elements objects, or an HTML string.

if the current object is a collection, all of its elements contained will be inserted after the target.

If the current object is just an L<HTML::Object::DOM::Element> object, it will be moved (not copied) after the target.

L</after> and L</insertAfter> perform the same task. The major difference is in the syntaxâ€”specifically, in the placement of the content and target. With L</after>, the object used to call the method is the container after which the content is inserted. While with L</insertAfter>, it is the opposite.

For example, consider the following HTML:

    <div class="container">
      <h2>Greetings</h2>
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>

    my $p = HTML::Object::DOM->new;
    my $doc = $p->parse_data( $html );

We can create content and insert it after several elements at once:

    xq( "<p>Test</p>", $doc )->insertAfter( ".inner" );

Each inner C<E<le>divE<gt>> element gets this new content:

    <div class="container">
      <h2>Greetings</h2>
      <div class="inner">Hello</div>
      <p>Test</p>
      <div class="inner">Goodbye</div>
      <p>Test</p>
    </div>

We can also select an element on the page and insert it after another:

    xq( "h2", $doc )->insertAfter( xq( ".container", $doc ) );

If an element selected this way is inserted into a single location elsewhere in the DOM, it will be moved after the target (not cloned) and a new set consisting of the inserted element is returned:

    <div class="container">
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>
    <h2>Greetings</h2>

If there is more than one target element, however, cloned copies of the inserted element will be created for each target after the first, and that new set (the original element plus clones) is returned.

L<https://api.jquery.com/insertAfter/>

=head2 insertBefore

Insert every element in the set of matched elements before the target.

The target can be one of a selector, an element object (L<HTML::Object::DOM::Element>), an array of elements objects, or an HTML string.

if the current object is a collection, all of its elements contained will be inserted before the target.

If the current object is just an L<HTML::Object::DOM::Element> object, it will be moved (not copied) before the target.

L</before> and L</insertBefore> perform the same task. The major difference is in the syntaxâ€”specifically, in the placement of the content and target. With L</before>, the object used to call the method is the container before which the content is inserted. While with L</insertBefore>, it is the opposite.

For example, consider the following HTML:

    <div class="container">
      <h2>Greetings</h2>
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>

    my $p = HTML::Object::DOM->new;
    my $doc = $p->parse_data( $html );

We can create content and insert it before several elements at once:

    xq( "<p>Test</p>", $doc )->insertBefore( ".inner" );

Each inner C<E<le>divE<gt>> element gets this new content:

    <div class="container">
      <h2>Greetings</h2>
      <p>Test</p>
      <div class="inner">Hello</div>
      <p>Test</p>
      <div class="inner">Goodbye</div>
    </div>

We can also select an element on the page and insert it before another:

    xq( "h2", $doc )->insertBefore( xq( ".container", $doc ) );

If an element selected this way is inserted into a single location elsewhere in the DOM, it will be moved before the target (not cloned) and a new set consisting of the inserted element is returned:

    <h2>Greetings</h2>
    <div class="container">
      <div class="inner">Hello</div>
      <div class="inner">Goodbye</div>
    </div>

If there is more than one target element, however, cloned copies of the inserted element will be created for each target after the first, and that new set (the original element plus clones) is returned.

L<https://api.jquery.com/insertBefore/>

=head2 is

Check the current matched set of elements against a selector, L<HTML::Object::DOM::Element|element object>, L<HTML::Object::Collection|a collection of element> or a code reference and return true if at least one of these elements matches the given arguments.

Unlike other filtering methods, L</is> does not create a new object. Instead, it allows you to test the contents of an object (element or collection) without modification.

Suppose you have a list, with two of its items containing a child element:

    <ul>
      <li>list <strong>item 1</strong></li>
      <li><span>list item 2</span></li>
      <li>list item 3</li>
    </ul>

    my $p = HTML::Object::DOM->new;
    my $doc = $p->parse_data( $html ) || die( $p->error );

You can check if an object is one of the C<li>'s like:

    if( $elem->is( 'li' ) )
    {
        # Make the background red
        $elem->css( "background-color", "red" );
    }

L</is> can also evaluate expressions related to elements based on a code reference rather than a selector. For each element, if the code reference returns true, L</is> returns true as well. For example, given a somewhat more involved HTML snippet:

    <ul>
      <li><strong>list</strong> item 1 - one strong tag</li>
      <li><strong>list</strong> item <strong>2</strong> -
        two <span>strong tags</span></li>
      <li>list item 3</li>
      <li>list item 4</li>
      <li>list item 5</li>
    </ul>

C<$li> here is an element that you have defined earlier in your code.

    my $isWithTwo = $li->is(sub {
        return xq( "strong", $_ )->length == 2;
    });
    if( $isWithTwo ) 
    {
        $li->css( "background-color", "green" );
    } 
    else
    {
        $li->css( "background-color", "red" );
    }

Or

    <form>
      <input type="checkbox">
    </form>
    <div></div>

    my $isFormParent = xq( "input[type='checkbox']", $doc )->parent()->is( "form" );
    xq( "div", $doc )->text( "isFormParent = " + $isFormParent );

Checks against an existing collection of alternating list elements. Blue, alternating list elements set background to yellow while others turn red.

    <ul id="browsers">
      <li>Chrome</li>
      <li>Safari</li>
      <li>Firefox</li>
      <li>Opera</li>
    </ul>
 
    my $alt = xq( "#browsers li:nth-child(2n)", $doc )->css( "background", "#0ff" );
    my $li = xq( "li" );
    if( $li->is( $alt ) )
    {
        $li->css( "background", "yellow" );
    }
    else
    {
        $li->css( "background", "red" );
    }

See L<https://api.jquery.com/is/>

=head2 isa_collection

Returns true if the current element is a L<HTML::Object::Collection> object, or false otherwise.

=head2 isArray

C<isArray()> returns a boolean indicating whether the value provided is an array.

See L<https://api.jquery.com/jQuery.isArray/>

=head2 length

Returns the number of children if the current element is a collection, or 1 if the current element is an element.

=head2 load

    $e->load( $uri );
    # or
    $e->load( $uri, { key1 => value1, key2 => value2 } );
    # or
    $e->load( $uri, $callback_subroutine );
    # or
    $e->load( $uri, { key1 => value1, key2 => value2 }, $callback_subroutine );

The callback function receives 3 arguments: C<$responseContent>, C<$textStatus> and C<$responseObject>

This method fetches data from the given C<uri> and, when a successful response is detected (i.e. when C<textStatus> is C<success> or C<notmodified>), L</load> sets the HTML contents of the matched elements to the returned data. This means that most uses of the method can be quite simple:

    $( "#result" )->load( "https://example.com/some/test.html" );

The URL can be a C<file://> URI, and you can even use contextual URL such as absolute or relative URL provided you have set the value for L<documentURI|HTML::Object::DOM::Document/documentURI> in class L<HTML::Object::DOM::Document>, which is the root element of the DOM. You can access it using the L<getRootNode|HTML::Object::DOM::Node> method.

For example:

    $doc->documentURI = 'https://example.com/some/where';
    my $body = $('body', $doc);
    # The URI will become https://example.com/other/path
    $body->load( '/other/path', sub
    {
        my( $data, $textStatus, $httpResponse ) = @_;
        say "Yeah!";
        # Do some work here...
    });

Upon error, be it internal, or when the returned http code is not a 2XX code, C<$textStatus> is set to C<error>

If no element is matched by the selector â€” in this case, if the document does not contain an element with C<id="result"> â€” the http request will not be sent.

It returns the current element object upon success, or upon error, sets an L<error|Module::Generic/error> and returns undef.

This methods uses L<LWP::UserAgent> to do the work and it must be installed as well as L<URI>, or else this method will return an error.

The C<uri> provided must be an absolute URI, or L<LWP::UserAgent> will return an error.

=head3 Callback subroutine

If a callback subroutine is provided, it is executed after post-processing of the HTML with L<HTML::Object::DOM> and insertion of the HTML element objects have been performed. The callback is fired once for each element in the object collection, and C<$_> is set to each L<element object|HTML::Object::DOM::Element> in turn.

    $( "#result" )->load( "/somewhere/test.html", sub
    {
        print( "Load was performed.\n" );
    });

The C<$responseObject> is a L<HTTP::Response> object.

The C<$responseContent> is an utf8 decoded (i.e. perl internal utf8) text string.

=head3 Request method

The C<POST> method is used if data is provided as an hash reference; otherwise, C<GET> is assumed.

=head3 Loading page fragments

This method makes it possible to specify a portion of the remote document to be inserted. This is achieved with a special syntax for the uri parameter. If one or more space characters are included in the string, the portion of the string following the first space is assumed to be a C<selector> that determines the content to be loaded. For example:

    $( "#result" )->load( "/somewhere/test.html #container" );

Upon execution, this method retrieves the content of C</somewhere/test.html>, but then L<HTML::Object::DOM> parses the returned document to find the element with an ID of container. This element, along with its contents, is inserted into the element with an ID of result, and the rest of the retrieved document is discarded.

For example, given the following HTML document:

    <!DOCTYPE html>
    <html lang="en-GB">
        <head>
            <meta charset="utf-8" />
            <title>load demo</title>
            <meta name="generator" content="BBEdit 13.5" />
        </head>
        <body>
            <b>Projects:</b>
            <ol id="new-projects"></ol>
        </body>
    </html>

We could do:

    use HTML::Object::DOM;
    use Module::Generic::File qw( file );
    my $parser = HTML::Object::DOM->new;
    my $doc = $parser->parse( $html ) || die( $parser->error );
    HTML::Object::DOM->set_dom( $doc );
    my $part = file( "./resources/load.html" );
    my $uri  = $part->uri; # e.g. file:///home/joe/www/resources/load.html
    $( "#new-projects" )->load( "$uri #projects li" );

This would make the following change to the html:

    <ol id="new-projects"><li>jQuery</li><li>jQuery UI</li><li>jQuery Mobile</li><li>QUnit</li><li>Sizzle</li></ol>

=head3 Error handling

If an error occurs, the C<$textStatus> would be set to C<error>, which you can check as follows:

$( "#success" ).load( "https://example.org/not-here.html", sub
{
    my( $content, $status, $resp ) = @_;
    if( $status == "error" )
    {
        my $msg = "Sorry but there was an error: ";
        $( "#error" )->html( $msg . $resp->code . " " . $resp->message );
    }
});

See also L<jQuery documentation on load|https://api.jquery.com/load>

=head2 map

Provided with a code reference, and this will execute on each of the children.

=head2 matches

Provided with a C<xpath> and this will return all matching nodes.

=head2 name

Sets or gets the C<name> attribute.

=head2 new_attribute

Provided with an hash or hash reference of parameters, and this will return a new L<HTML::Object::DOM::Attribute> object by passing it the parameters.

=head2 new_collection

Provided with an hash or hash reference of parameters, and this will return a new L<HTML::Object::Collection> object by passing it the parameters.

=head2 new_parser

This will return a new L<HTML::Object::DOM> object.

=head2 new_root

Provided with an hash or hash reference of parameters, and this will return a new L<HTML::Object::DOM::Root> object by passing it the parameters.

=head2 not

Takes a selector expression; or
a element object; or
a collection of elements; or
an array of element objects to match against the set.

It returns all elements that do not match.

L<https://api.jquery.com/not/>

=head2 odd

Returns a new collection of elements whose position is an even number

L<https://api.jquery.com/odd/>

=head2 prepend

Takes html string (start with <tag...), text object (HTML::Object::DOM::Text), array or element object
or alternatively a code reference that returns the above

L<https://api.jquery.com/prepend/>

=head2 prependTo

L<https://api.jquery.com/prependTo/>

=head2 promise

Provided with a code reference to be executed asynchronously and this will return a L<Promise::Me> object.

    my $p = $e->promise(sub
    {
       # Some regular code here
    })->then(sub
    {
       my $res = shift( @_ ); # return value from the code executed above
       # more processing...
    })->then(sub
    {
       my $more = shift( @_ ); # return value from the previous then
       # more processing...
    })->catch(sub
    {
       my $exception = shift( @_ ); # error that occured is caught here
    })->finally(sub
    {
       # final processing
    })->then(sub
    {
       # A last then may be added after finally
    };

=head2 remove

If the current object is a collection, this will remove all of its children. Otherwise, if this is an element, it will simply remove it.

You can also provide an C<xpath> as an argument and the matching nodes will be removed.

=head2 removeAttr

Provided with an attribute name and this will remove it from the collection if the current element is a collection, or from the current element itself if it is a L<HTML::Parser::Element> object.

It returns the current object.

L<https://api.jquery.com/removeAttr/>

=head2 removeClass

Provided with a class name and this will remove it from the current element or the current collection.

L<https://api.jquery.com/removeClass/>

=head2 replaceWith

Takes html string, array of elements, an element (including a collection object) or a code reference and this will replace the current element with the new element.

L<https://api.jquery.com/replaceWith/>

=head2 set_namespace

Set the new namespace for the current node.

=head2 show

Since this is a perl context, this only set the inline css 1) back to its previous value,
if any; or 2) remove the display property if there was no previous value set.

Any parameter provided will be ignored

See the hide() method for its alter ego.

L<https://api.jquery.com/show/>

=head2 string_value

Returns L</value> if the current element is comment node. Otherwise, returns L</as_text>

=head2 tagname

Returns the tag name for the current element.

=head2 text

When no argument is provided, this returns the combined text contents, as a L<scalar object|Module::Generic::Scalar> of each element in the set of matched elements, including their descendants.

    my $text = $element->text();
    # or, here this is a collection object
    xq('body', $doc)->text();
    # or if this is a single html element object
    xq('body', $doc)->first->text();

When an argument is provided, it takes either some text data as a string, or a code reference.

In the case of a code reference, it is called with the element position, starting at 0 and the old text data string. It expects in returns either:

=over 4

=item 1. an empty or undefined value, in which case the current element will have its content emptied using L</empty>

=item 2. some text data, and the content of the current element object will be replaced.

=back

Be mindful that this method will add the data as is, and will not treat it as HTML if some were provided. Thus, if some HTML were provided, it would be escaped in order to be rendered properly.

Quoting jQuery documentation, for example, consider this html:

    <div class="demo-container">
        <div class="demo-box">Demonstration Box</div>
        <ul>
            <li>list item 1</li>
            <li>list <strong>item</strong> 2</li>
        </ul>
    </div>

The code C<< $( "div.demo-container" )->text( "<p>This is a test.</p>" ); >> will produce the following DOM output:

    <div class="demo-container">
        &lt;p&gt;This is a test.&lt;/p&gt;
    </div>

It will appear on a rendered page as though the tags were exposed, like this:

    <p>This is a test</p>

The C<text()> method cannot be used on input elements. For input field text, use the C<val()> method.

Afer the text value is set, it returns the object it was called with.

L<https://api.jquery.com/text/>

=head2 toggleClass

Takes a class name; or
class name and state (true or false); or
array of class names; or
array of class names and a state; or
a code reference called with the index position of the current class and its name. Returns a space separated list of classes or an array

L<https://api.jquery.com/toggleClass/>

=head2 to_number

Returns a new L<HTML::Object::DOM::Number> object by passing it the current node value (L</getValue>)

=head2 toString

Returns the current node value as L</as_xml>

=head2 uniqueSort

The C<uniqueSort()> function searches through an L<xQuery|HTML::Object::XQuery> object, sorting it in document order, and removing any duplicate nodes. A node is considered a duplicate if it is the exact same node as one already in the xQuery object; two different nodes with identical attributes are not considered to be duplicates. This method only works on xQuery objects consisting of DOM elements.

For example:

    <div>There are 6 divs in this document.</div>
    <div></div>
    <div class="dup"></div>
    <div class="dup"></div>
    <div class="dup"></div>
    <div></div>

    my $divs = $('div')->get();
    # Add 3 elements of class dup too (they are divs)
    $divs = $divs->concat( $('.dup')->get() );

    # Create a jQuery object from `divs`.
    my $elems = $($divs);
    say "Pre-uniqueSort there are " . $elems->length . " elements in the collection.";
    # Pre-uniqueSort there are 9 elements in the collection.
    $elems = $elems->uniqueSort();
    say "Post-uniqueSort there are " . $elems->length . " elements in the collection.";
    # Post-uniqueSort there are 6 elements in the collection.

L<https://api.jquery.com/uniqueSort/>

=head2 wrap

Wrap an HTML structure around each element in the set of matched elements.

It takes either a wrapping element or a code reference serving as a callback.

A wrapping element is either a selector, element, HTML string, or L<collection object|HTML::Object::Collection> specifying the structure to wrap around the matched elements. When you pass a L<collection object|HTML::Object::Collection> containing more than one element, or a selector matching more than one element, the first element will be used.

A callback code reference returns the HTML content, a selector or L<collection object|HTML::Object::Collection> to wrap around the matched elements. The callback receives the index position of the element in the set as an argument. Within the function, this refers to the current element in the set.
The value returned by the callback will be cloned before it is used.

The C<wrap()> method can take any string or object that could be passed to the C<$()> factory function (also accessible as C<xk()> to specify a DOM structure. This structure may be nested several levels deep, but should contain only one inmost element. A copy of this structure will be wrapped around each of the elements in the set of matched elements. This method returns the original set of elements for chaining purposes.

For example:

    <div class="container">
        <div class="inner">Hello</div>
        <div class="inner">Goodbye</div>
    </div>

    $('.inner')->wrap( '<div class="new"></div>' );

The new C<< <div> >> element is created on the fly and added to the DOM. The result is a new C<< <div> >> wrapped around each matched element:

    <div class="container">
        <div class="new">
            <div class="inner">Hello</div>
        </div>
        <div class="new">
            <div class="inner">Goodbye</div>
        </div>
    </div>

The second version of this method allows us to instead specify a callback code reference. This callback code reference will be called once for every matched element; it should return a L<DOM element|HTML::Object::DOM::Element>, L<collection object|HTML::Object::Collection>, or HTML snippet in which to wrap the corresponding element. For example:

    $('.inner')->wrap(sub
    {
        return( '<div class="' . $_->text() . '"></div>' );
    });

This will cause each C<< <div> >> to have a class corresponding to the text it wraps:

    <div class="container">
        <div class="Hello">
            <div class="inner">Hello</div>
        </div>
        <div class="Goodbye">
            <div class="inner">Goodbye</div>
        </div>
    </div>

L<https://api.jquery.com/wrap/#wrap-wrappingElement>

=head2 xp

Returns an already instantiated L<XML::XPathEngine> object, or instantiate one and returns it.

=head2 xq

Ref: <https://api.jquery.com/Types/#jQuery>

    xq( '#myId', $document )
    xq( '<div />', { id => 'Pouec', class => 'Hello' } );
    xq( '<html><head><title>Hello world</title></head><body>Hello!</body></html>' );
    xq();

=head1 CLASS FUNCTIONS

=head2 clearQueue

Does not do anything. Returns the current object for chaining.

L<https://api.jquery.com/clearQueue/>

=head2 data

Store arbitrary data associated with the specified element and/or return the value that was set.

It takes, the L<element object|HTML::Object::DOM::Element>, they key and an optional value.

    xQuery->data( $document->body, "foo", 52 );
    xQuery->data( $document->body, "bar", "test" );

or

    use HTML::Object xquery => 1;
    $.data( $document->body, "foo", 52 );
    $.data( $document->body, "bar", "test" );

In accessor mode:

    say( xQuery->data( $document->body, "foo" ) );
    say( xQuery->data( $document->body ) );

The above lines alert the data values that were set on the body element. If nothing was set on that element, an empty string is returned.

=head2 dequeue

Does not do anything. Returns the current object for chaining.

L<https://api.jquery.com/dequeue/>

=head2 each

Quoting from L<jQuery documentation|>:

A generic iterator function, which can be used to seamlessly iterate over both hash reference and array references. Arrays and array-like objects with a length property (such as a function's arguments object) are iterated by numeric index, from 0 to length-1. Other objects are iterated via their named properties.

If the value is an array reference, the callback will be called for each element of the array, and passing it two arguments: the index value (0-based), and the value.

For example:

    $.each([ 52, 97 ], sub
    {
        my( $index, $value ) = @_;
        say( $index . ': ' . $value );
    });

This produces two messages:

    0: 52
    1: 97

If the value is an hash reference, the callback will be called for each element of the hash keys, and passing it two arguments: the current key and its value.

For example:

    my $ref = {
        flammable => "inflammable",
        duh => "no duh"
    };
    $.each( $ref, sub
    {
        my( $key, $value ) = @_;
        say( $key . ': ' . $value );
    });

Once again, this produces two messages:

    flammable: inflammable
    duh: no duh

We can break the $.each() loop at a particular iteration by making the callback function return 0 (false). Simply returning C<undef> will not work. Returning non-false is the same as a continue statement in a for loop; it will skip immediately to the next iteration.

For example:

    my $arr = [ "one", "two", "three", "four", "five" ];
    jQuery.each( $arr, sub
    {
        my( $i, $val ) = @_;
        $( '#' . $val )->text( 'Mine is ' . val . '.' );

        # Will stop running after "three"
        return( $val ne 'three' ? 1 : 0 );
    });

L<https://api.jquery.com/jQuery.each/>

=head2 extend

Merge the contents of two or more hash reference together into the first hash reference.

When two or more hash reference arguments are supplied to C<$.extend()>, properties from all of the hash reference are added to the target hash reference. Arguments that are C<undef> are ignored.

Keep in mind that the target hash reference (first argument) will be modified, and will also be returned from C<$.extend()>. If, however, you want to preserve both of the original hash references, you can do so by passing an empty hash reference as the target:

    my $ref = $.extend({}, $hash1, $hash2);

The merge performed by C<$.extend()> is not recursive by default; if a property of the first obhash referenceject is itself an hash reference or an array reference, it will be completely overwritten by a property with the same key in the second or subsequent hash reference. The values are not merged. This can be seen in the example below by examining the value of C<banana>. However, by passing C<true> (1) for the first function argument, hash references will be recursively merged.

In jQuery, passing C<false> for the first argument is not supported, but in our version, it is.

On a C<deep> extend, data will be cloned using L<Clone>

Returns an hash reference upon success, or upon error, sets an L<error object|HTML::Object::Exception> and returns C<undef> in scalar context and an empty list in list context.

Example:

Merge two objects, modifying the first.

    my $hash1 = 
    {
        apple => 0,
        banana => { weight => 52, price => 100 },
        cherry => 97,
    };
    my $hash2 = 
    {
        banana => { price => 200 },
        durian => 100,
    };

    # Merge $hash2 into $hash1
    $.extend( $hash1, $hash2 );

This would become:

    {
        apple => 0,
        banana => { price => 200 },
        cherry => 97,
        durian => 100,
    }

Merge two objects recursively, modifying the first.

    my $hash1 = 
    {
        apple => 0,
        banana => { weight => 52, price => 100 },
        cherry => 97,
    };
    my $hash2 = 
    {
        banana => { price => 200 },
        durian => 100,
    };
    
    // Merge object2 into object1, recursively
    $.extend( $true, $hash1, $hash2 );

This would become:

    {
        apple => 0,
        banana => { price => 200, weight => 52 },
        cherry => 97,
        durian => 100,
    }

Merge defaults and options, without modifying the defaults. This is a common plugin development pattern.

    my $defaults = { validate => 0, limit => 5, name => "foo" };
    my $options = { validate => 1, name => "bar" };
    
    # Merge defaults and options, without modifying defaults
    my $settings = $.extend( {}, $defaults, $options );

This would become:

    # $defaults (unchanged):
    { limit => 5, name => "foo", validate => 0 }
    # $options (unchanged):
    { name => "bar", validate => 1 }
    # resulting $settings:
    { limit => 5, name => "bar", validate => 1 }

L<https://api.jquery.com/jQuery.extend/>

=head2 grep

    my $array2 = $.grep( $array => 'something' );
    my $array2 = $.grep( $array => qr/something/ );
    my $array2 = $.grep( $array => sub
    {
        /^something$/
    });
    # or
    my $list = $.grep( $array => sub
    {
        my( $val, $index ) = @_;
        $val =~ /^something$/i && $index > 2;
    });
    # Returns the elements not matching by passing a false value as the last argument
    my $array2 = $.grep( $array => 'something', 1 );
    my $array2 = $.grep( $array => qr/something/, 1 );
    my $array2 = $.grep( $array => sub
    {
        /^something$/
    }, 1);

Of course, you could as easily create an L<array object|Module::Generic::Array>, and use the L<grep method|Module::Generic::Array/grep> directly, such as:

    use Module::Generic::Array;
    my $a = Module::Generic::Array->new( [qw( cat dog something camel )] );
    # returns an array object in scalar context
    my $list = $a->grep( 'something' );
    my $list = $a->grep( qr/something/ );
    my $list = $a->grep(sub
    {
        /^something$/i
    });
    # or
    my $list = $a->grep(sub
    {
        my( $val, $index ) = @_;
        $val =~ /^something$/i && $index > 2;
    });
    # get all the elements NOT matching
    my $list = $a->grep( 'something', 0 );
    my $list = $a->grep( qr/something/, 0 );
    my $list = $a->grep(sub
    {
        /^something$/i
    }, 0);

Finds the elements of an array which satisfy a filter function. The original array is not affected.

It takes 2 to 3 arguments:

=over 4

=item 1. C<array>

The array-like object to search through.

=item 2. C<callback>

The code reference to process each item against. The first argument to the function is the item, and the second argument is the index. The function should return a boolean value.

=item 3. C<invert> (optional)

If C<invert> is false (0), or not provided, then the function returns an L<array object|Module::Generic::Array> consisting of all elements for which C<callback> returns true. If C<invert> is true, then the function returns an L<array object|Module::Generic::Array> consisting of all elements for which C<callback> returns false.

Example:

Filters the original array of numbers leaving that are not 5 and have an index greater than 4. Then it removes all 9s.

    my $arr = [ 1, 9, 3, 8, 6, 1, 5, 9, 4, 7, 3, 8, 6, 9, 1 ];
    my $arr2 = xQuery->grep( $arr, sub
    {
        my( $n, $i ) = @_;
        return( $n != 5 && $i > 4 );
    });
    # yields: 1, 9, 4, 7, 3, 8, 6, 9, 1

    my $arr2 = xQuery->grep( $arr, sub
    {
        my( $a ) = @_;
        return( $a != 9 );
    });
    # yields: 1, 4, 7, 3, 8, 6, 1

Filter an array of numbers to include only numbers bigger then zero:

    my $arr2 = $.grep( [ 0, 1, 2 ], sub
    {
        my( $n, $i ) = @_;
        return( $n > 0 );
    });
    # yields: 1, 2

=back

L<https://api.jquery.com/jQuery.grep/>

=head2 inArray

Search for a specified value within an array and return its index (or -1 if not found).

It takes 2 to 3 arguments:

=over 4

=item 1. C<value>

The value to search for.

This can be a string, or a regular expression object.

=item 2. C<array>

An array through which to search.

=item 3. C<fromIndex>

The index of the array at which to begin the search. The default is 0, which will search the whole array.

=back

The C<$.inArray()> method is similar to L<index()|perlfunc/index> method in that it returns C<-1> when it does not find a match. If the first element within the array matches value, C<$.inArray()> returns C<0>.

Because C<0> is construed as equal to false (i.e. 0 == false, but 0 !== false), to check for the presence of value within array, you need to check if it is not equal to (or greater than) C<-1>.

Contrary to the jQuery original function, and due to Perl's nature, the comparison between values is B<not> strict. The following will return C<2> (not C<-1> as it would in jQuery) because a number is being searched in an array of strings, and perl converts it automatically:

    $.inArray( 5 + 5, [ "8", "9", "10", 10 . '' ] );

For example:

    my $arr = [ 4, "Pete", 8, "John" ];

    say '"John" found at ', xQuery->inArray( "John", $arr );
    # yields: "John" found at 3
    say '4 found at ', xQuery->inArray( 4, $arr );
    # yields: 4 found at 0
    say '"Karl" not found, so ', xQuery->inArray( "Karl", $arr );
    # yields: "Karl" not found, so -1
    say '"Pete" is in the array, but not at or after index 2, so ', xQuery->inArray( "Pete", $arr, 2 );
    # yields: "Pete" is in the array, but not at or after index 2, so -1

L<https://api.jquery.com/jQuery.inArray/>

=head2 isArray

Determine whether the argument is an array.

C<$.isArray()> takes a value and returns true if the value is an array reference or even an array object, and false otherwise.

For example:

    $.isArray([]);
    # yields a true value

L<https://api.jquery.com/jQuery.isArray/>

=head2 isEmptyObject

Check to see if an hash reference (a.k.a. C<object> in JavaScript) is empty (contains no properties).

The argument should always be a plain hash reference, and not a blessed hash. To determine if an hash reference is a plain hash reference, use C<$.isPlainObject()>

For example:

    jQuery->isEmptyObject({}); # true
    jQuery->isEmptyObject({ foo => "bar" }); # false

L<https://api.jquery.com/jQuery.isEmptyObject/>

=head2 isFunction

Determines if its argument is callable as a function, meaning it is either a function name, or a code reference.

For example:

    sub stub {}
    my $objs = [
        sub{},
        { x => 15, y => 20 },
        undef,
        'stub',
        'sub',
    ];

    xQuery->each( $objs, sub
    {
        my $i = shift( @_ );
        my $isFunc = xQuery->isFunction( $objs->[$i] );
        say "xQuery->isFunction( \$objs->[$i] ) = ", ( $isFunc ? 'true' : 'false' );
    });

This would yield:

    xQuery->isFunction( $objs->[0] ) = true
    xQuery->isFunction( $objs->[1] ) = false
    xQuery->isFunction( $objs->[2] ) = false
    xQuery->isFunction( $objs->[3] ) = true
    xQuery->isFunction( $objs->[4] ) = false

L<https://api.jquery.com/jQuery.isFunction/>

=head2 isNumeric

Determines whether its argument represents a number.

The C<$.isNumeric()> method checks whether its argument represents a numeric value. If so, it returns true. Otherwise it returns false. The argument can be of any type.

For example:

    # true (numeric)
    $.isNumeric( "-10" );
    $.isNumeric( "0" );
    $.isNumeric( 0xFF );
    $.isNumeric( "0xFF" );
    $.isNumeric( "8e5" );
    $.isNumeric( "3.1415" );
    $.isNumeric( +10 );
    $.isNumeric( 0144 );
    # Yes, under perl, nan and Inf are considered a number. Don't believe me? Try:
    # perl -MScalar::Util=looks_like_number -lE 'say looks_like_number("nan")'
    $.isNumeric( NaN );
    $.isNumeric( Inf );
     
    # false (non-numeric)
    $.isNumeric( "-0x42" );
    $.isNumeric( "7.2acdgs" );
    $.isNumeric( "" );
    $.isNumeric( {} );
    $.isNumeric( true );
    $.isNumeric( undef );

L<https://api.jquery.com/jQuery.isNumeric/>

=head2 isPlainObject

Check to see if an object is a plain hash reference, and not a blessed one.

For example:

    xQuery->isPlainObject({}) # true
    xQuery->isPlainObject( "test" ) # false

L<https://api.jquery.com/jQuery.isPlainObject/>

=head2 isWindow

Determine whether the argument is a L<window|HTML::Object::DOM::Window>.

Normally, this is used, under jQuery to determine if it is operating against a browser window (such as the current window or an iframe). However, since this is perl, this is merely used to determine if the given value is a L<window object|HTML::Object::DOM::Window> or not.

For example:

    my $window = HTML::Object::DOM::Window->new;
    $.isWindow( $window ); # true

L<https://api.jquery.com/jQuery.isWindow/>

=head2 makeArray

Many methods, both in xQuery and in L<HTML::Object::XQuery> class in general, return objects that are array-like. For example, the xQuery (jQuery) factory function C<$()> returns an L<array object|Module::Generic::Array> that has many of the properties of an array.

Note that after the conversion, any special features the array object had (such as the L<xQuery|HTML::Object::XQuery> methods in our example) will no longer be present. The object is now a plain array reference.

For example:

    <!DOCTYPE html>
    <html lang="en-GB">
        <head>
            <meta charset="utf-8" />
            <title></title>
        </head>
        <body>
            <div>First</div>
            <div>Second</div>
            <div>Third</div>
            <div>Fourth</div>
        </body>
    </html>

    my $elems = $('div');
    my $arr = xQuery->makeArray( $elems );
    my $arr2 = $arr->reverse();
    $(arr2)->appendTo( $document->body );

This would yield:

    Fourth
    Third
    Second
    First

=head2 map

Translate all items in an array reference or hash reference to a new L<array object|Module::Generic::Array> of items that is returned.

It takes an array reference or an hash reference and a code reference as a callback.

The callback will be called for each item in the array reference and 2 arguments will be passed:

=over 4

=item 1. current value

=item 2. position in the array reference for array reference, or the current hash key for hash reference

=back

The callback can return:

=over 4

=item * the translated value, which will be mapped to the resulting array

    $.map( $array, sub
    {
        return( $one_value );
    });

=item * C<undef>, to remove the item

    $.map( $array, sub
    {
        return;
        # or
        return( undef );
    });

=item * an array or an array reference of values, which will be flattened into the full array

    $.map( $array, sub
    {
        return( [1, 2, 3] );
    });
    # same
    $.map( $array, sub
    {
        return( 1, 2, 3 );
    });

=back

Do not alter the array reference or hash reference provided while running C<$.map>, or it might lead to unpredictable results. See L<perl each manual section|perlfunc/each> for more details.

Example:

Using C<$.map()> to change the values of an array reference:

    my $arr = [ "a", "b", "c", "d", "e" ];
    say join( ", ", @$arr );
    
This would yield:

    a, b, c, d, e

    # or you can also use $.map
    $arr = xQuery->map( $arr, sub
    {
        my( $n, $i ) = @_;
        return( uc( $n ) . $i );
    });
    say join( ", ", @$arr );

This would yield:

    A0, B1, C2, D3, E4
    
    $arr = $.map( $arr, sub
    {
        my( $a ) = @_;
        return( $a . $a );
    });
    say join( ", ", @$arr );

This would yield:

    A0A0, B1B1, C2C2, D3D3, E4E4

Map the original array to a new one and add 4 to each value:

    $arr = $.map( [ 0, 1, 2 ], sub
    {
        my( $n ) = @_;
        return( $n + 4 );
    });
    say join( ", ", @$arr );

The resulting array reference would be:

    4, 5, 6

Map the original array to a new one, adding 1 to each value if it is bigger then zero and removing it if not:

    $arr = $.map( [ 0, 1, 2 ], sub
    {
        my( $n ) = @_;
        return( $n > 0 ? $n + 1 : undef );
    });
    say join( ", ", @$arr );

The resulting array reference would be:

    2, 3

Map the original array to a new one; each element is added with its original value and the value plus one:

    $arr = $.map( [ 0, 1, 2 ], sub
    {
        my( $n ) = @_;
        return( [ $n, $n + 1 ] );
        # You can also return as a list
        # return( $n, $n + 1 );
    });
    say join( ", ", @$arr );

The resulting array reference would be:

    0, 1, 1, 2, 2, 3

Map the original hash reference to a new array reference and double each value:

    my $dimensions = { width => 10, height => 15, length => 20 };
    $arr = $.map( $dimensions, sub
    {
        my( $value, $key ) = @_;
        return( $value * 2 );
    });
    say join( ", ", @$arr );

The resulting array reference would be:

    [20, 30, 40]

However, the problem in this example, is that, because the order in which the hash reference keys are processed, is not guaranteed by perl, the order of the values of the resulting array reference may also vary.

If the order is important to you, you might want to consider using L<Tie::IxHash> as mentioned in this L<perl FAQ|https://perldoc.perl.org/perlfaq4#How-can-I-make-my-hash-remember-the-order-I-put-elements-into-it?>

    use Tie::IxHash;
    
    tie my %dimensions, 'Tie::IxHash';
    %dimensions = ( width => 10, height => 15, length => 20 );
    $arr = $.map( \%dimensions, sub
    {
        my( $value, $key ) = @_;
        return( $value * 2 );
    });
    say join( ", ", @$arr );

The resulting array reference would always B<predictably> be:

    [20, 30, 40]

Map an hash reference's keys to an array:

    my $dimensions = { width => 10, height => 15, length => 20 };
    my $keys = $.map( $dimensions, sub
    {
        my( $value, $key ) = @_;
        return( $key );
    });
    say join( ", ", @$keys );

The resulting array reference would be:

    ["width", "height", "length"]

Augment the resulting array by returning an array inside the function:

    my $array = [ 0, 1, 52, 97 ];
    $array = $.map( $array, sub
    {
        my( $a, $index ) = @_;
        return( [ $a - 45, $index ] );
        # You can also return as a list
        # return( $a - 45, $index );
    });
    say join( ", ", @$array );

The resulting array reference would be:

    [ -45, 0, -44, 1, 7, 2, 52, 3]

L<https://api.jquery.com/jQuery.map/>

See also L<https://api.jquery.com/map/> for the other C<map> method used directly on a xquery object, such as:

    $('div')->map(sub
    {
        # something
    });

More details on this method upper in the L</METHODS> section.

=head2 merge

Merge the contents of two arrays together into the first array and returns the first array reference modified.

The C<$.merge()> operation forms an array reference that contains all elements from the two array references. The orders of items in the arrays are preserved, with items from the second array appended. The C<$.merge()> function is destructive. It alters the length and numeric index properties of the first object to include items from the second.

If you need the original first array, make a copy of it before calling C<$.merge()>. Fortunately, C<$.merge()> itself can be used for this duplication:

    my $newArray = $.merge([], $oldArray);

This shortcut creates a new, empty array and merges the contents of C<$oldArray> into it, effectively cloning the array.

Examples:

Merges two arrays, altering the first argument:

    $.merge( [ 0, 1, 2 ], [ 2, 3, 4 ] );

This yields:

    [ 0, 1, 2, 2, 3, 4 ]

Merges two arrays, altering the first argument.

    $.merge( [ 3, 2, 1 ], [ 4, 3, 2 ] );

This yields:

[ 3, 2, 1, 4, 3, 2 ]

Merges two arrays, but uses a copy, so the original is not altered:

    my $first  = [ "a", "b", "c" ];
    my $second = [ "d", "e", "f" ];
    $.merge( $.merge( [], $first ), $second );

This yields:

    [ "a", "b", "c", "d", "e", "f" ]

L<https://api.jquery.com/jQuery.merge/>

=head2 noop

An empty function that returns C<undef> in scalar context or an empty list in list context.

You can use this empty function when you wish to pass around a function that will do nothing.

L<https://api.jquery.com/jQuery.noop/>

=head2 now

Return a L<DateTime object|DateTime> representing the current time and that stringifies to the number of seconds since epoch, resulting into the equivalent of L<perlfunc/time>

Under jQuery, this is an alias for C<Date.now()>

    my $time = $.now();
    say $time; # 1714619232
    say $time->epoch; # 1714619232
    say $time->iso8601; # 2024-05-02T03:07:12

L<https://api.jquery.com/jQuery.now/>

=head2 parseHTML

Parses a string and returns an L<array object|Module::Generic::Array> of  L<nodesHTML::Object::DOM::Element>. In jQuery, this parses a string into an array of DOM nodes.

This method render all trailing or leading text (even if they are just whitespaces). To prevent trailing and leading whitespaces from being converted to L<space nodes|HTML::Object::DOM::Space> you can pass the HTML string through L<jQuery.trim|/trim>.

Under jQuery, this method takes 3 parameters (HTML string, a context document, and C<keepScripts>), but since the last 2 have no bearing under perl, this method only takes a single argument: an HTML string.

For example:

    my $str = "hello, <b>my name is</b> xQuery.";
    my $html = $.parseHTML( $str );
    my $nodeNames = [];

    # Gather the parsed HTML's node names
    $.each( $html, sub
    {
        my( $i, $el ) = @_;
        $nodeNames->[$i] = el->nodeName;
    }) || die( $xQuery::ERROR );
    
    say $nodeNames->join( ', ' );

This yields:

    #text, B, #text

L<https://api.jquery.com/jQuery.parseHTML/>

=head2 parseJSON

Takes a well-formed JSON string and returns the resulting value, which could be a string, a number, a boolean, an array reference or an hash reference.

Passing in a malformed JSON string results in an error being returned, which can be retrieved with C<$xQuery::ERROR>. For example, the following are all invalid JSON strings:

=over 4

=item * "{test: 1}" (test does not have double quotes around it).

=item * "{'test': 1}" ('test' is using single quotes instead of double quotes).

=item * "'test'" ('test' is using single quotes instead of double quotes).

=item * ".1" (a number must start with a digit; "0.1" would be valid).

=item * "undefined" (undefined cannot be represented in a JSON string; null, however, can be).

=item * "NaN" (NaN cannot be represented in a JSON string; direct representation of Infinity is also not permitted).

=back

The JSON standard does not permit "control characters" such as a tab or newline. An example like C<< $.parseJSON( '{ "testing":"1\t2\n3" }' ) >> will result in an error, because the JSON parser converts the string's tab and newline escapes into literal tab and newline; doubling the backslashes like "1\\t2\\n3" yields expected results. This problem is often seen when injecting JSON into a JavaScript file from a server-side language such as PHP.

For details on the JSON format, see https://json.org/.

For example:

    my $ref = $.parseJSON( '{ "name": "John" }' );
    say( $ref->{name} eq 'John' );

L<https://api.jquery.com/jQuery.parseJSON/>

=head2 parseXML

Parses a string into an L<XML document|XML::LibXML::Document> and returns it.

This requires the module L<XML::LibXML> to be installed.

C<xQuery.parseXML> uses L<XML::LibXML> to create a valid L<XML document|XML::LibXML::Document>. This document is returned, and this is all. Unlike the jQuery interface, B<you cannot pass> this object to L<HTML::Object::XQuery>, such as:

    my $doc = $.parseXML( $str ) || die( $xQuery::ERROR );
    my $xml = $($doc);
    my $title = $xml->find( 'title' );

Maybe in the future, I will implement it.

L<https://api.jquery.com/jQuery.parseXML/>

=head2 proxy

This method is deprecated in jQuery

=head2 queue

This method is unsupported with no meaning under perl.

=head2 removeData

Remove a previously-stored piece of data and returns C<undef> in scalar context and an empty list in list context.

This C<$.removeData()> method takes an L<element object|HTML::Object::DOM::Element> and a name, and removes values that were previously set using C<$.data()>. When called with the name of a key, C<$.removeData()> deletes that particular value; when called with no arguments, all values are removed.

For example:

    my $div = $('<div />');
    say $div->data( 'test1' );
    $.data( $div, 'test1', 'VALUE-1' );
    $.data( $div, 'test2', 'VALUE-2' );
    say $.data( $div, 'test1' );
    $.removeData( $div, 'test1' );
    say $.data( $div, 'test1' );
    say $.data( $div, 'test2' );

This would yield:

    undef
    VALUE-1
    undef
    VALUE-2

=head2 trim

Remove the whitespace from the beginning and end of a string provided.

The C<$.trim()> function removes all newlines, spaces (including non-breaking spaces), and tabs from the beginning and end of the supplied string. If these whitespace characters occur in the middle of the string, they are preserved.

For example:

    my $str = "         lots of spaces before and after         ";
    say "'", $.trim($str), "'";

This yields:

    'lots of spaces before and after'

=head2 type

Determine the data type of a value, i.e.:

=over 4

=item * C<undef> for undefined

=item * C<hash> for hash reference

=item * C<array> for array reference

=item * C<number> for number

=item * C<boolean> for boolean objects, such as L<Module::Generic::Boolean>, L<JSON::PP::Boolean>

=item * C<date> for L<DateTime objects|DateTime>

=item * C<error> for L<Module::Generic::Exception>, L<Error>, L<Throwable::Error>

=item * C<regexp> for C<Regexp> object, such as C<qr/test/>

=item * C<string> for anything else.

=back

L<https://api.jquery.com/jQuery.type/>

=head2 unique

Sorts an array of DOM elements, in place, with the duplicates removed. Note that, unlike its jQuery counterpart, this does work on any value, not just arrays of DOM elements.

It returns a new L<array object|Module::Generic::Array> of unique elements.

L<https://api.jquery.com/jQuery.unique/>

=head2 uniqueSort

The C<$.uniqueSort()> function searches through an array or an array-like object of L<DOM elements|HTML::Object::DOM::Element>, sorting the array or array object, and removing any duplicate nodes. A node is considered a duplicate if it is the exact same node as one already in the input; two different nodes with identical attributes are not considered to be duplicates. This function only works on regular arrays or L<array objects|Module::Generic::Array> of L<DOM elements|HTML::Object::DOM::Element>, not on strings or numbers.

It returns a new L<array object|Module::Generic::Array> of unique and sorted elements. The results are always returned in document order.

This uses L<John Resig algorithm|https://johnresig.com/blog/comparing-document-position/> for sorting document nodes.

L<https://api.jquery.com/jQuery.uniqueSort/>

=head1 PRIVATE METHODS

=head2 _append_prepend

Called by L</append> and L</prepend> to do the heavy work.

=head2 _append_prepend_to

Takes html string; or
selector; or
element object; or
array of objects; or
collection

"If there is more than one target element, however, cloned copies of the inserted element will be created for each target except the last, and that new set (the original element plus clones) is returned."

Called by L</append_to> and L</prepend_to> to do the heavy work.

=head2 _before_after

Takes html string (start with <tag...), text object (HTML::Object::DOM::Text), array or element object
or alternatively a code reference that returns the above

=head2 _child_as_object

called on a parent, with a child as second argument and its rank as third
returns the child if it is already an element, or
a new HTML::Object::DOM::Text element if it is a plain string

=head2 _compare

Takes another element and compares the current one to it. Returns true if they are the same, false otherwise.

It achieves this by check if the current element L<HTML::Object::Element/eid> is same, of if the element is a collection it check it is of the same size and the other element is among the collection.

=head2 _css_object

If argument is provided, pass a L<CSS::Object::Builder::Rule> object

If no argument is provided, get a L<CSS::Object::Builder::Rule> of the inline css, if any at all.

Returns undef if no css attribute is set yet.

=head2 _css_builder

Returns a new L<CSS*:Object> object using the format set to L<CSS::Object::Format::Inline>.

=head2 _insert_before_after

Takes selector, html, element or array

    xq( '<p>Test</p>' )->insertBefore( xq( '.inner', $doc ) );
    $elem->insertBefore( '.inner' );

=head2 _is_html

Returns true if the data provided looks like html, or false otherwise.

=head2 _is_same_node

Returns true if the current element and the provided element have he same L</eid>t

=head2 _xpath_value

Returns the C<xpath> value fot the current element

=head1 ERROR HANDLING

Methods in this package returns C<undef> either because no value is available, or because an error occurred

You can find out about an error after a method call by calling L<error|Module::Generic/error>, such as:

    # Try to change the tag name
    my $rv = $e->tag( $something );
    die( $e->error ) if( !defined( $rv ) );

But keep in mind that an undefined value returned does not necessarily means there was an error. Consider:

    my $div = $('<div />', { class => 'hello' });
    my $id = $div->attr( 'id' );

C<$id> will be undefined because there is no 'id' attribute set, and this is not an error.

If you are using the L<global dom feature|HTML::Object::DOM/set_dom>, you can get the posible errors like this:

    $('#someId')->load( '/some/where.html' ) || die( HTML::Object::DOM->error );

L<HTML::Object::DOM/error> is guaranteed to be set upon error. You can also get the global variable C<$HTML::Object::DOM::ERROR>

If you prefer, you can choose to make every error fatal and catch them with a try-catch implementation like L<Nice::Try>

    use HTML::Object::DOM
    $HTML::Object::DOM::FATAL_ERROR = 1;
    # or
    use HTML::Object::DOM fatal_error => 1;
    use Nice::Try;

    try
    {
        # Try to change the tag name
        $e->tag( $something );
    }
    catch( $ex )
    {
        die( "Could not change the tag name: ", $ex->message );
    }

Or, if you wanted to filter the exception by class:

    try
    {
        # Try to change the tag name
        $e->tag( $something );
    }
    catch( HTML::Object::Exception $ex )
    {
        die( "An HTML::Object::DOM error occurred: ", $ex->message );
    }
    catch( $ex )
    {
        die( "Caught an exception: $ex\n" );
    }

Note that L<HTML::Object::Exception> object has stringification capability so you can embed it in a string:

    die( "Could not change the tag name: $ex\n" );

=head1 TODO

=head2 addBack

L<https://api.jquery.com/addBack/>

=head1 AUTHOR

Jacques Deguest E<lt>F<jack@deguest.jp>E<gt>

=head1 SEE ALSO

L<HTML::Object::DOM>, L<HTML::Object::DOM::Attribute>, L<HTML::Object::DOM::Boolean>, L<HTML::Object::DOM::Closing>, L<HTML::Object::DOM::Collection>, L<HTML::Object::DOM::Comment>, L<HTML::Object::DOM::Declaration>, L<HTML::Object::DOM::Document>, L<HTML::Object::DOM::Element>, L<HTML::Object::Exception>, L<HTML::Object::DOM::Literal>, L<HTML::Object::DOM::Number>, L<HTML::Object::DOM::Root>, L<HTML::Object::DOM::Space>, L<HTML::Object::DOM::Text>, L<HTML::Object::XQuery>

=head1 COPYRIGHT & LICENSE

Copyright (c) 2021 DEGUEST Pte. Ltd.

All rights reserved

This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=cut
