.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Glib::OptionGroup 3"
.TH Glib::OptionGroup 3 "2019-03-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Glib::OptionGroup \-  group of options for command line option parsing
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my ($verbose, $source, $filenames) = (\*(Aq\*(Aq, undef, []);
\&
\&  my $entries = [
\&    { long_name => \*(Aqverbose\*(Aq,
\&      short_name => \*(Aqv\*(Aq,
\&      arg_type => \*(Aqnone\*(Aq,
\&      arg_value => \e$verbose,
\&      description => \*(Aqbe verbose\*(Aq },
\&
\&    { long_name => \*(Aqsource\*(Aq,
\&      short_name => \*(Aqs\*(Aq,
\&      arg_type => \*(Aqstring\*(Aq,
\&      arg_value => \e$source,
\&      description => \*(Aqset the source\*(Aq,
\&      arg_description => \*(Aqsource\*(Aq },
\&
\&    [ \*(Aqfilenames\*(Aq, \*(Aqf\*(Aq, \*(Aqfilename\-array\*(Aq, \e$filenames ],
\&  ];
\&
\&  my $context = Glib::OptionContext\->new (\*(Aq\- urgsify your life\*(Aq);
\&  $context\->add_main_entries ($entries, \*(AqC\*(Aq);
\&  $context\->parse ();
\&
\&  # $verbose, $source, and $filenames are now updated according to the
\&  # command line options given
.Ve
.SH "HIERARCHY"
.IX Header "HIERARCHY"
.Vb 2
\&  Glib::Boxed
\&  +\-\-\-\-Glib::OptionGroup
.Ve
.SH "METHODS"
.IX Header "METHODS"
.SS "optioncontext = Glib::OptionContext\->\fBnew\fP ($parameter_string)"
.IX Subsection "optioncontext = Glib::OptionContext->new ($parameter_string)"
.IP "\(bu" 4
\&\f(CW$parameter_string\fR (string)
.SS "optiongroup = Glib::OptionGroup\->\fBnew\fP (key => value, ...)"
.IX Subsection "optiongroup = Glib::OptionGroup->new (key => value, ...)"
Creates a new option group from the given key-value pairs.  The valid keys are
name, description, help_description, and entries.  The first three specify
strings while the last one, entries, specifies an array reference of option
entries.  Example:
.PP
.Vb 5
\&  my $group = Glib::OptionGroup\->new (
\&                name => \*(Aqurgs\*(Aq,
\&                description => \*(AqUrgs Urgs Urgs\*(Aq,
\&                help_description => \*(AqHelp with Urgs\*(Aq,
\&                entries => \e@entries);
.Ve
.PP
An option entry is a hash reference like this:
.PP
.Vb 7
\&  { long_name => \*(Aqverbose\*(Aq,
\&    short_name => \*(Aqv\*(Aq,
\&    flags => [qw/reverse hidden in\-main/],
\&    arg_type => \*(Aqnone\*(Aq,
\&    arg_value => \e$verbose,
\&    description => \*(Aqverbose desc.\*(Aq,
\&    arg_description => \*(Aqverbose arg desc.\*(Aq }
.Ve
.PP
Of those keys only long_name, arg_type, and arg_value are required.  So this is
a valid option entry too:
.PP
.Vb 3
\&  { long_name => \*(Aqpackage\-names\*(Aq,
\&    arg_type => \*(Aqstring\-array\*(Aq,
\&    arg_value => \e$package_names }
.Ve
.PP
For convenience, option entries can also be specified as array references
containing long_name, short_name, arg_type, and arg_value:
.PP
.Vb 1
\&  [ \*(Aqfilenames\*(Aq, \*(Aqf\*(Aq, \*(Aqfilename\-array\*(Aq, \e$filenames ]
.Ve
.PP
If you don't want an option to have a short name, specify undef for it:
.PP
.Vb 1
\&  [ \*(Aqfilenames\*(Aq, undef, \*(Aqfilename\-array\*(Aq, \e$filenames ]
.Ve
.ie n .SS "$context\->\fBadd_group\fP ($group)"
.el .SS "\f(CW$context\fP\->\fBadd_group\fP ($group)"
.IX Subsection "$context->add_group ($group)"
.IP "\(bu" 4
\&\f(CW$group\fR (Glib::OptionGroup)
.ie n .SS "$context\->\fBadd_main_entries\fP ($entries, $translation_domain)"
.el .SS "\f(CW$context\fP\->\fBadd_main_entries\fP ($entries, \f(CW$translation_domain\fP)"
.IX Subsection "$context->add_main_entries ($entries, $translation_domain)"
.IP "\(bu" 4
\&\f(CW$entries\fR (scalar) reference to an array of option entries
.IP "\(bu" 4
\&\f(CW$translation_domain\fR (string)
.ie n .SS "boolean = $context\->\fBget_help_enabled\fP"
.el .SS "boolean = \f(CW$context\fP\->\fBget_help_enabled\fP"
.IX Subsection "boolean = $context->get_help_enabled"
.ie n .SS "$context\->\fBset_help_enabled\fP ($help_enabled)"
.el .SS "\f(CW$context\fP\->\fBset_help_enabled\fP ($help_enabled)"
.IX Subsection "$context->set_help_enabled ($help_enabled)"
.IP "\(bu" 4
\&\f(CW$help_enabled\fR (boolean)
.ie n .SS "boolean = $context\->\fBget_ignore_unknown_options\fP"
.el .SS "boolean = \f(CW$context\fP\->\fBget_ignore_unknown_options\fP"
.IX Subsection "boolean = $context->get_ignore_unknown_options"
.ie n .SS "$context\->\fBset_ignore_unknown_options\fP ($ignore_unknown)"
.el .SS "\f(CW$context\fP\->\fBset_ignore_unknown_options\fP ($ignore_unknown)"
.IX Subsection "$context->set_ignore_unknown_options ($ignore_unknown)"
.IP "\(bu" 4
\&\f(CW$ignore_unknown\fR (boolean)
.ie n .SS "optiongroup = $context\->\fBget_main_group\fP"
.el .SS "optiongroup = \f(CW$context\fP\->\fBget_main_group\fP"
.IX Subsection "optiongroup = $context->get_main_group"
.ie n .SS "$context\->\fBset_main_group\fP ($group)"
.el .SS "\f(CW$context\fP\->\fBset_main_group\fP ($group)"
.IX Subsection "$context->set_main_group ($group)"
.IP "\(bu" 4
\&\f(CW$group\fR (Glib::OptionGroup)
.ie n .SS "boolean = $context\->\fBparse\fP"
.el .SS "boolean = \f(CW$context\fP\->\fBparse\fP"
.IX Subsection "boolean = $context->parse"
This method works directly on \fI\f(CI@ARGV\fI\fR.
.PP
May croak with a Glib::Error in $@ on failure.
.ie n .SS "$group\->\fBset_translate_func\fP ($func, $data=undef)"
.el .SS "\f(CW$group\fP\->\fBset_translate_func\fP ($func, \f(CW$data\fP=undef)"
.IX Subsection "$group->set_translate_func ($func, $data=undef)"
.IP "\(bu" 4
\&\f(CW$func\fR (scalar)
.IP "\(bu" 4
\&\f(CW$data\fR (scalar)
.ie n .SS "$group\->\fBset_translation_domain\fP ($domain)"
.el .SS "\f(CW$group\fP\->\fBset_translation_domain\fP ($domain)"
.IX Subsection "$group->set_translation_domain ($domain)"
.IP "\(bu" 4
\&\f(CW$domain\fR (string)
.SH "ENUMS AND FLAGS"
.IX Header "ENUMS AND FLAGS"
.SS "enum Glib::OptionArg"
.IX Subsection "enum Glib::OptionArg"
.IP "\(bu" 4
\&'none' / 'G_OPTION_ARG_NONE'
.IP "\(bu" 4
\&'string' / 'G_OPTION_ARG_STRING'
.IP "\(bu" 4
\&'int' / 'G_OPTION_ARG_INT'
.IP "\(bu" 4
\&'callback' / 'G_OPTION_ARG_CALLBACK'
.IP "\(bu" 4
\&'filename' / 'G_OPTION_ARG_FILENAME'
.IP "\(bu" 4
\&'string\-array' / 'G_OPTION_ARG_STRING_ARRAY'
.IP "\(bu" 4
\&'filename\-array' / 'G_OPTION_ARG_FILENAME_ARRAY'
.IP "\(bu" 4
\&'double' / 'G_OPTION_ARG_DOUBLE'
.IP "\(bu" 4
\&'int64' / 'G_OPTION_ARG_INT64'
.SS "flags Glib::OptionFlags"
.IX Subsection "flags Glib::OptionFlags"
.IP "\(bu" 4
\&'hidden' / 'G_OPTION_FLAG_HIDDEN'
.IP "\(bu" 4
\&'in\-main' / 'G_OPTION_FLAG_IN_MAIN'
.IP "\(bu" 4
\&'reverse' / 'G_OPTION_FLAG_REVERSE'
.IP "\(bu" 4
\&'no\-arg' / 'G_OPTION_FLAG_NO_ARG'
.IP "\(bu" 4
\&'filename' / 'G_OPTION_FLAG_FILENAME'
.IP "\(bu" 4
\&'optional\-arg' / 'G_OPTION_FLAG_OPTIONAL_ARG'
.IP "\(bu" 4
\&'noalias' / 'G_OPTION_FLAG_NOALIAS'
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib, Glib::Boxed
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2011 by the gtk2\-perl team.
.PP
This software is licensed under the \s-1LGPL.\s0  See Glib for a full notice.
