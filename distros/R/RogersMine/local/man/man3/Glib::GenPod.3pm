.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Glib::GenPod 3"
.TH Glib::GenPod 3 "2019-02-05" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Glib::GenPod \- POD generation utilities for Glib\-based modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Glib::GenPod;
\&
\& # use the defaults:
\& xsdoc2pod ($xsdocparse_output_file, $destination_dir);
\&
\& # or take matters into your own hands
\& require $xsdocparse_output_file;
\& foreach my $package (sort keys %$data) {
\&     print "=head1 NAME\en\en$package\en\en";
\&     print "=head1 METHODS\en\en" . podify_methods ($package) . "\en\en";
\& }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module includes several utilities for creating pod for xs-based Perl
modules which build on the Glib module's foundations.  The most important bits
are the logic to convert the data structures created by xsdocparse.pl to
describe xsubs and pods into method docs, with call signatures and argument
descriptions, and converting C type names into Perl type names.  The rest of
the module is mostly boiler-plate code to format and pretty-print information
that may be queried from the Glib type system.
.PP
To make life easy for module maintainers, we also include a do-it-all function,
\&\fBxsdoc2pod()\fR, which does pretty much everything for you.  All of the pieces it
uses are publically usable, so you can do whatever you like if you don't like
the default output.
.SH "DOCUMENTING THE XS FILES"
.IX Header "DOCUMENTING THE XS FILES"
All of the information used as input to the methods included here comes from
the \s-1XS\s0 files of your project, and is extracted by Glib::ParseXSDoc's
\&\f(CW\*(C`xsdocparse\*(C'\fR.  This function creates an file containing Perl code that may be
eval'd or require'd to recreate the parsed data structures, which are a list of
pods from the verbatim C portion of the \s-1XS\s0 file (the xs api docs), and a hash
of the remaining data, keyed by package name, and including the pods and xsubs
read from the rest of each \s-1XS\s0 file following the first \s-1MODULE\s0 line.
.PP
Several custom \s-1POD\s0 directives are recognized in the XSubs section.  Note that
each one is sought as a paragraph starter, and must follow a \f(CW\*(C`=cut\*(C'\fR directive.
.IP "=for object Package::Name" 4
.IX Item "=for object Package::Name"
All xsubs and pod from here until the next object directive or \s-1MODULE\s0 line
will be placed under the key '\fIPackage::Name\fR' in xsdocparse's data
structure.  Everything from this line to the next \f(CW\*(C`=cut\*(C'\fR is included as a
description \s-1POD.\s0
.IP "=for object Package::Name (Other::Package::Name)" 4
.IX Item "=for object Package::Name (Other::Package::Name)"
Generate \s-1POD\s0 in \fIPackage::Name\fR but for the package \fIOther::Package::Name\fR.
This is useful if you want \s-1POD\s0 to appear in a different namespace but still
want the automatically generated hierarchy, signal and property listing,
etc. from the original namespace.  For example:
.Sp
.Vb 2
\&  =for object Gnome2::PanelApplet::main (Gnome2::PanelApplet)
\&  =cut
.Ve
.Sp
This will create Gnome2/PanelApplet/main.pod containing the automatically
generated documentation for Gnome2::PanelApplet (hierarchy, signals, etc.) plus
the method listing from the current \s-1XS\s0 file.
.IP "=for enum Package::Name" 4
.IX Item "=for enum Package::Name"
.PD 0
.IP "=for flags Package::Name" 4
.IX Item "=for flags Package::Name"
.PD
This causes xsdoc2pod to call \f(CW\*(C`podify_values\*(C'\fR on \fIPackage::Name\fR when
writing the pod for the current package (as set by an object directive or
\&\s-1MODULE\s0 line).  Any text in this paragraph, to the next \f(CW\*(C`=cut\*(C'\fR, is included
in that section.
.IP "=for deprecated_by Package::Name" 4
.IX Item "=for deprecated_by Package::Name"
Used to add a deprecation warning, indicating \fIPackage::Name\fR as an
alternative way to achieve the same functionality.  There may be any number
these in each package.
.IP "=for see_also some_thing_to_see" 4
.IX Item "=for see_also some_thing_to_see"
Used to add extra see alsos onto the end of the parents, if any, for a given
object.  Anything following the space behind see_also up to the end of the
line will be placed onto the list of \*(L"see also\*(R"s.  There may be any number of
these in each package.
.IP "=for apidoc" 4
.IX Item "=for apidoc"
.PD 0
.IP "=for apidoc Full::Symbol::name" 4
.IX Item "=for apidoc Full::Symbol::name"
.PD
Paragraphs of this type document xsubs, and are associated with the xsubs
by xsdocparse.pl.  If the full symbol name is not included, the paragraph
must be attached to the xsub declaration (no blank lines between \f(CW\*(C`=cut\*(C'\fR and
the xsub).
.Sp
Within the apidoc PODs, we recognize a few special directives (the \*(L"for\es+\*(R"
is optional on these):
.RS 4
.IP "=for signature ..." 4
.IX Item "=for signature ..."
Override the generated call signature with the ... text.  If you include
multiple signature directives, they will all be used.  This is handy when
you want to change the return type or list different ways to invoke an
overloaded method, like this:
.Sp
.Vb 1
\& =for apidoc
\&
\& =signature bool Class\->foo
\&
\& =signature ($thing, @other) = $object\->foo ($it, $something)
\&
\& Text in here is included in the generated documentation.
\& You can actually include signature and arg directives
\& at any point in this pod \-\- they are stripped after.
\& In fact, any pod is valid in here, until the =cut.
\&
\& =cut
\& void foo (...)
\&     PPCODE:
\&        /* crazy code follows */
.Ve
.IP "=for arg name (type) description" 4
.IX Item "=for arg name (type) description"
.PD 0
.IP "=for arg name description" 4
.IX Item "=for arg name description"
.PD
The arg directive adds or overrides an argument description.  The
description text is optional, as is the type specification (the part
in parentheses).  If you want to hide an argument, specify \f(CW\*(C`_\|_hide_\|_\*(C'\fR
as its type.  The arg name does \fInot\fR need to include a sigil,
as dollar signs will be added.  \s-1FIXME\s0 what about @ for lists?
.RE
.RS 4
.Sp
Also, we honor a couple of \*(L"modifiers\*(R" on the =for apidoc line, following the
symbol name, if present:
.IP "\- _\|_hide_\|_" 4
.IX Item "- __hide__"
Do not document this xsub.  This is handy in certain situations, e.g., for
private functions.  \s-1DESTROY\s0 always has this turned on, for example.
.IP "\- _\|_gerror_\|_" 4
.IX Item "- __gerror__"
This function or method can generate a Glib::Error exception.
.IP "\- _\|_function_\|_" 4
.IX Item "- __function__"
Generate a function-style signature for this xsub.  The default is to
generate method-style signatures.
.IP "\- _\|_deprecated_\|_" 4
.IX Item "- __deprecated__"
This function or method is deprecated and should not be used in newly written
code.
.RE
.RS 4
.Sp
(These are actually handled by Glib::ParseXSDoc, but we list them here
because, well, they're an important part of how you document the \s-1XS\s0 files.)
.RE
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "xsdoc2pod ($datafile, $outdir='blib/lib', index=undef)" 4
.el .IP "xsdoc2pod ($datafile, \f(CW$outdir\fR='blib/lib', index=undef)" 4
.IX Item "xsdoc2pod ($datafile, $outdir='blib/lib', index=undef)"
Given a \fI\f(CI$datafile\fI\fR containing the output of xsdocparse.pl, create in 
\&\fI\f(CI$outdir\fI\fR a pod file for each package, containing everything we can think
of for that module.  Output is controlled by the \f(CW\*(C`=for object\*(C'\fR directives
and such in the source code.
.Sp
If you don't want each package to create a separate pod file, then use
this function's code as a starting point for your own pretty-printer.
.IP "add_types (@filenames)" 4
.IX Item "add_types (@filenames)"
Parse the given \fI\f(CI@filenames\fI\fR for entries to add to the \f(CW%basic_types\fR used
for C type name to Perl package name mappings of types that are not registered
with the Glib type system.  The file format is dead simple: blank lines are
ignored; /#.*$/ is stripped from each line as comments; the first token on
each line is considered to be a C type name, and the remaining tokens are the
description of that type.  For example, a valid file may look like this:
.Sp
.Vb 3
\&  # a couple of special types
\&  FooBar      Foo::Bar
\&  Frob        localized frobnicator
.Ve
.Sp
C type decorations such as \*(L"const\*(R" and \*(L"*\*(R" are implied (do not include them),
and the _ornull variant is handled for you.
.ie n .IP "$string = podify_properties ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_properties ($packagename)" 4
.IX Item "$string = podify_properties ($packagename)"
Pretty-print the object properties owned by the Glib::Object derivative
\&\fI\f(CI$packagename\fI\fR and return the text as a string.  Returns undef if there
are no properties or \fI\f(CI$package\fI\fR is not a Glib::Object.
.ie n .IP "$string = podify_child_properties ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_child_properties ($packagename)" 4
.IX Item "$string = podify_child_properties ($packagename)"
Pretty-print the child properties owned by the Gtk2::Container derivative
\&\fI\f(CI$packagename\fI\fR and return the text as a string.  Returns undef if there are
no child properties or \fI\f(CI$package\fI\fR is not a Gtk2::Container or similar class
with a \f(CW\*(C`list_child_properties()\*(C'\fR method.
.ie n .IP "$string = podify_style_properties ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_style_properties ($packagename)" 4
.IX Item "$string = podify_style_properties ($packagename)"
Pretty-print the style properties owned by the Gtk2::Widget derivative
\&\fI\f(CI$packagename\fI\fR and return the text as a string.  Returns undef if there are
no style properties or \fI\f(CI$package\fI\fR is not a Gtk2::Widget or similar class
with a \f(CW\*(C`list_style_properties()\*(C'\fR method.
.ie n .IP "$string = podify_values ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_values ($packagename)" 4
.IX Item "$string = podify_values ($packagename)"
List and pretty-print the values of the GEnum or GFlags type \fI\f(CI$packagename\fI\fR,
and return the text as a string.  Returns undef if \fI\f(CI$packagename\fI\fR isn't an
enum or flags type.
.ie n .IP "$string = podify_signals ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_signals ($packagename)" 4
.IX Item "$string = podify_signals ($packagename)"
Query, list, and pretty-print the signals associated with \fI\f(CI$packagename\fI\fR.
Returns the text as a string, or undef if there are no signals or
\&\fI\f(CI$packagename\fI\fR is not a Glib::Object derivative.
.ie n .IP "$string = podify_deprecated_by ($packagename, @deprecated_by)" 4
.el .IP "\f(CW$string\fR = podify_deprecated_by ($packagename, \f(CW@deprecated_by\fR)" 4
.IX Item "$string = podify_deprecated_by ($packagename, @deprecated_by)"
Creates a deprecation warning for \f(CW$packagename\fR, suggesting using the items
inside \f(CW@deprecated_by\fR instead.
.ie n .IP "$string = podify_pods ($pods, $position)" 4
.el .IP "\f(CW$string\fR = podify_pods ($pods, \f(CW$position\fR)" 4
.IX Item "$string = podify_pods ($pods, $position)"
Helper function to allow specific placement of generic pod within the auto
generated pages. Pod sections starting out with =for position \s-1XXX,\s0 where \s-1XXX\s0
is one of the following will be placed at a specified position. In the case of
pod that is to be placed after a particular section that doesn't exist, that
pod will be still be placed there.
.Sp
This function is called at all of the specified points through out the process
of generating pod for a page. Any pod matching the \fIposition\fR passed will be
returned, undef if no matches were found.  If \fIposition\fR is undef all pods
without specific position information will be returned. \fIpods\fR is a reference
to an array of pod hashes.
.RS 4
.IP "\(bu" 4
\&\s-1SYNOPSIS\s0
.Sp
After the \s-1NAME\s0 section
.IP "\(bu" 4
\&\s-1DESCRIPTION\s0
.Sp
After the \s-1SYNOPSIS\s0 section.
.IP "\(bu" 4
post_hierarchy
.Sp
After the \s-1HIERARCHY\s0 section.
.IP "\(bu" 4
post_interfaces
.Sp
After the \s-1INTERFACE\s0 section.
.IP "\(bu" 4
post_methods
.Sp
After the \s-1METHODS\s0 section.
.IP "\(bu" 4
post_properties
.Sp
After the \s-1PROPERTIES\s0 section.
.IP "\(bu" 4
post_signals
.Sp
After the \s-1SIGNALS\s0 section.
.IP "\(bu" 4
post_enums
.Sp
After the \s-1ENUMS AND FLAGS\s0 section.
.IP "\(bu" 4
\&\s-1SEE_ALSO\s0
.Sp
Replacing the autogenerated \s-1SEE ALSO\s0 section completely.
.IP "\(bu" 4
\&\s-1COPYRIGHT\s0
.Sp
Replacing the autogenerated \s-1COPYRIGHT\s0 section completely.
.RE
.RS 4
.RE
.ie n .IP "$string = podify_ancestors ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_ancestors ($packagename)" 4
.IX Item "$string = podify_ancestors ($packagename)"
Pretty-prints the ancestry of \fI\f(CI$packagename\fI\fR from the Glib type system's
point of view.  This uses Glib::Type\->list_ancestors; see that function's
docs for an explanation of why that's different from looking at \f(CW@ISA\fR.
.Sp
Returns the new text as a string, or undef if \fI\f(CI$packagename\fI\fR is not a
registered GType.
.ie n .IP "$string = podify_interfaces ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_interfaces ($packagename)" 4
.IX Item "$string = podify_interfaces ($packagename)"
Pretty-print the list of GInterfaces that \fI\f(CI$packagename\fI\fR implements.
Returns the text as a string, or undef if the type implements no interfaces.
.ie n .IP "$string = podify_methods ($packagename)" 4
.el .IP "\f(CW$string\fR = podify_methods ($packagename)" 4
.IX Item "$string = podify_methods ($packagename)"
Call \f(CW\*(C`xsub_to_pod\*(C'\fR on all the xsubs under the key \fI\f(CI$packagename\fI\fR in the
data extracted by xsdocparse.pl.
.Sp
Returns the new text as a string, or undef if there are no xsubs in
\&\fI\f(CI$packagename\fI\fR.
.ie n .IP "$string = podify_see_alsos (@entries)" 4
.el .IP "\f(CW$string\fR = podify_see_alsos (@entries)" 4
.IX Item "$string = podify_see_alsos (@entries)"
Creates a list of links to be placed in the \s-1SEE ALSO\s0 section of the page.
Returns undef if nothing is in the input list.
.ie n .IP "$string = get_copyright" 4
.el .IP "\f(CW$string\fR = get_copyright" 4
.IX Item "$string = get_copyright"
Returns a string that will/should be placed on each page.  You can control
the text of this string by calling the class method \fIset_copyright\fR.
.Sp
If no text has been set, we will attempt to create one for you, using what
has been passed to \fIset_year\fR, \fIset_authors\fR, and \fIset_main_mod\fR.  The
year defaults to the current year, the authors default to
\&'The Gtk2\-Perl Team', and the main mod is empty by default.  You want the
main mod to be set to the main module of your extension for the \s-1SEE ALSO\s0
section, and on the assumption that a decent license notice can be found in
that module's doc, we point the reader there.
.Sp
So, in general, you will want to specify at least one of these, so that you
don't credit your work to us under the \s-1LGPL.\s0
.Sp
To set them do something similar to the following in the first part of your
postamble section in Makefile.PL.  All occurrences of <br> in the copyright
are replaced with newlines, to make it easier to put in a multi-line string.
.Sp
.Vb 1
\&  POD_SET=Glib::GenPod::set_copyright(qq{Copyright 1999 team\-foobar<br>LGPL});
.Ve
.Sp
\&\fBGlib::MakeHelper::postamble_docs_full()\fR does this sort of thing for you.
.SS "Helpers"
.IX Subsection "Helpers"
.ie n .IP "$perl_type = convert_type ($ctypestring)" 4
.el .IP "\f(CW$perl_type\fR = convert_type ($ctypestring)" 4
.IX Item "$perl_type = convert_type ($ctypestring)"
Convert a C type name to a Perl type name.
.Sp
Uses \f(CW%Glib::GenPod::basic_types\fR to look for some known basic types,
and uses Glib::Type\->package_from_cname to look up the registered
package corresponding to a C type name.  If no suitable mapping can
be found, this just returns the input string.
.ie n .IP "$string = xsub_to_pod ($xsub, $sigprefix='')" 4
.el .IP "\f(CW$string\fR = xsub_to_pod ($xsub, \f(CW$sigprefix\fR='')" 4
.IX Item "$string = xsub_to_pod ($xsub, $sigprefix='')"
Convert an xsub hash into a string of pod describing it.  Includes the
call signature, argument listing, and description, honoring special
switches in the description pod (arg and signature overrides).
.ie n .IP "$string = compile_signature ($xsub)" 4
.el .IP "\f(CW$string\fR = compile_signature ($xsub)" 4
.IX Item "$string = compile_signature ($xsub)"
Given an xsub hash, return a string with the call signature for that
xsub.
.ie n .IP "$string = fixup_arg_name ($name)" 4
.el .IP "\f(CW$string\fR = fixup_arg_name ($name)" 4
.IX Item "$string = fixup_arg_name ($name)"
Prepend a $ to anything that's not the literal ellipsis string '...'.
.IP "fixup_default" 4
.IX Item "fixup_default"
Mangle default parameter values from C to Perl values.  Mostly, this
does \s-1NULL\s0 => undef.
.IP "convert_arg_type" 4
.IX Item "convert_arg_type"
C type to Perl type conversion for argument types.
.IP "convert_return_type_to_name" 4
.IX Item "convert_return_type_to_name"
C type to Perl type conversion suitable for return types.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib::ParseXSDoc
.SH "AUTHORS"
.IX Header "AUTHORS"
muppet bashed out the xsub signature generation in a few hours on a wednesday
night when band practice was cancelled at the last minute; he and ross
mcfarland hacked this module together via irc and email over the next few days.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2003\-2004, 2010\-2013 by the gtk2\-perl team
.PP
This library is free software; you can redistribute it and/or modify
it under the terms of the Lesser General Public License (\s-1LGPL\s0).  For
more information, see http://www.fsf.org/licenses/lgpl.txt
