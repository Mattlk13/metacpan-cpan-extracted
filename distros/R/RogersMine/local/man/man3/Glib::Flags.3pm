.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Glib::Flags 3"
.TH Glib::Flags 3 "2019-03-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Glib::Flags \-  methods and overloaded operators for flags
.SH "HIERARCHY"
.IX Header "HIERARCHY"
.Vb 1
\&  Glib::Flags
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Glib maps flag and enum values to the nicknames strings provided by the
underlying C libraries.  Representing flags this way in Perl is an interesting
problem, which Glib solves by using some cool overloaded operators.
.PP
The functions described here actually do the work of those overloaded
operators.  See the description of the flags operators in the \*(L"This Is
Now That\*(R" section of Glib for more info.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "scalar = $class\->\fBnew\fP ($a)"
.el .SS "scalar = \f(CW$class\fP\->\fBnew\fP ($a)"
.IX Subsection "scalar = $class->new ($a)"
.IP "\(bu" 4
\&\f(CW$a\fR (scalar)
.PP
Create a new flags object with given bits.  This is for use from a
subclass, it's not possible to create a \f(CW\*(C`Glib::Flags\*(C'\fR object as such.
For example,
.PP
.Vb 2
\&    my $f1 = Glib::ParamFlags\->new (\*(Aqreadable\*(Aq);
\&    my $f2 = Glib::ParamFlags\->new ([\*(Aqreadable\*(Aq,\*(Aqwritable\*(Aq]);
.Ve
.PP
An object like this can then be used with the overloaded operators.
.ie n .SS "scalar = $a\->\fBall\fP ($b, $swap)"
.el .SS "scalar = \f(CW$a\fP\->\fBall\fP ($b, \f(CW$swap\fP)"
.IX Subsection "scalar = $a->all ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (scalar)
.ie n .SS "aref = $f\->\fBas_arrayref\fP"
.el .SS "aref = \f(CW$f\fP\->\fBas_arrayref\fP"
.IX Subsection "aref = $f->as_arrayref"
Return the bits of \f(CW$f\fR as a reference to an array of strings, like
['flagbit1','flagbit2'].  This is the overload function for \f(CW\*(C`@{}\*(C'\fR,
ie. arrayizing \f(CW$f\fR.  You can call it directly as a method too.
.PP
Note that @$f gives the bits as a list, but as_arrayref gives an arrayref.
If an arrayref is what you want then the method style
\&\fBsomefunc()\fR\->as_arrayref can be more readable than [@{\fBsomefunc()\fR}].
.ie n .SS "bool = $f\->\fBbool\fP"
.el .SS "bool = \f(CW$f\fP\->\fBbool\fP"
.IX Subsection "bool = $f->bool"
Return 1 if any bits are set in \f(CW$f\fR, or 0 if none are set.  This is the
overload for \f(CW$f\fR in boolean context (like \f(CW\*(C`if\*(C'\fR, etc).  You can call it
as a method to get a true/false directly too.
.ie n .SS "integer = $a\->\fBeq\fP ($b, $swap)"
.el .SS "integer = \f(CW$a\fP\->\fBeq\fP ($b, \f(CW$swap\fP)"
.IX Subsection "integer = $a->eq ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (integer)
.ie n .SS "integer = $a\->\fBge\fP ($b, $swap)"
.el .SS "integer = \f(CW$a\fP\->\fBge\fP ($b, \f(CW$swap\fP)"
.IX Subsection "integer = $a->ge ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (integer)
.ie n .SS "scalar = $a\->\fBintersect\fP ($b, $swap)"
.el .SS "scalar = \f(CW$a\fP\->\fBintersect\fP ($b, \f(CW$swap\fP)"
.IX Subsection "scalar = $a->intersect ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (scalar)
.ie n .SS "integer = $a\->\fBne\fP ($b, $swap)"
.el .SS "integer = \f(CW$a\fP\->\fBne\fP ($b, \f(CW$swap\fP)"
.IX Subsection "integer = $a->ne ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (integer)
.ie n .SS "scalar = $a\->\fBsub\fP ($b, $swap)"
.el .SS "scalar = \f(CW$a\fP\->\fBsub\fP ($b, \f(CW$swap\fP)"
.IX Subsection "scalar = $a->sub ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (scalar)
.ie n .SS "scalar = $a\->\fBunion\fP ($b, $swap)"
.el .SS "scalar = \f(CW$a\fP\->\fBunion\fP ($b, \f(CW$swap\fP)"
.IX Subsection "scalar = $a->union ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (scalar)
.ie n .SS "scalar = $a\->\fBxor\fP ($b, $swap)"
.el .SS "scalar = \f(CW$a\fP\->\fBxor\fP ($b, \f(CW$swap\fP)"
.IX Subsection "scalar = $a->xor ($b, $swap)"
.IP "\(bu" 4
\&\f(CW$b\fR (scalar)
.IP "\(bu" 4
\&\f(CW$swap\fR (scalar)
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2011 by the gtk2\-perl team.
.PP
This software is licensed under the \s-1LGPL.\s0  See Glib for a full notice.
