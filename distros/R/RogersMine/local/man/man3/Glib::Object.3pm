.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Glib::Object 3"
.TH Glib::Object 3 "2019-03-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Glib::Object \-  Bindings for GObject
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
GObject is the base object class provided by the gobject library.  It provides
object properties with a notification system, and emittable signals.
.PP
Glib::Object is the corresponding Perl object class.  Glib::Objects are
represented by blessed hash references, with a magical connection to the
underlying C object.
.SS "get and set"
.IX Subsection "get and set"
Some subclasses of \f(CW\*(C`Glib::Object\*(C'\fR override \f(CW\*(C`get\*(C'\fR and \f(CW\*(C`set\*(C'\fR with methods
more useful to the subclass, for example \f(CW\*(C`Gtk2::TreeModel\*(C'\fR getting and
setting row contents.
.PP
This is usually done when the subclass has no object properties.  Any object
properties it or a further subclass does have can always be accessed with
\&\f(CW\*(C`get_property\*(C'\fR and \f(CW\*(C`set_property\*(C'\fR (together with \f(CW\*(C`find_property\*(C'\fR and
\&\f(CW\*(C`list_properties\*(C'\fR to enquire about them).
.PP
Generic code for any object subclass can use the names \f(CW\*(C`get_property\*(C'\fR and
\&\f(CW\*(C`set_property\*(C'\fR to be sure of getting the object properties as such.
.SH "HIERARCHY"
.IX Header "HIERARCHY"
.Vb 1
\&  Glib::Object
.Ve
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "object = $class\->\fBnew\fP (...)"
.el .SS "object = \f(CW$class\fP\->\fBnew\fP (...)"
.IX Subsection "object = $class->new (...)"
.IP "\(bu" 4
\&... (list) key/value pairs, property values to set on creation
.PP
Instantiate a Glib::Object of type \fI\f(CI$class\fI\fR.  Any key/value pairs in
\&\fI...\fR are used to set properties on the new object; see \f(CW\*(C`set\*(C'\fR.
This is designed to be inherited by Perl-derived subclasses (see
Glib::Object::Subclass), but you can actually use it to create
any GObject-derived type.
.ie n .SS "scalar = Glib::Object\->\fBnew_from_pointer\fP ($pointer, $noinc=FALSE)"
.el .SS "scalar = Glib::Object\->\fBnew_from_pointer\fP ($pointer, \f(CW$noinc\fP=FALSE)"
.IX Subsection "scalar = Glib::Object->new_from_pointer ($pointer, $noinc=FALSE)"
.IP "\(bu" 4
\&\f(CW$pointer\fR (unsigned) a C pointer value as an integer.
.IP "\(bu" 4
\&\f(CW$noinc\fR (boolean) if true, do not increase the GObject's reference count when creating the Perl wrapper.  this typically means that when the Perl wrapper will own the object.  in general you don't want to do that, so the default is false.
.PP
Create a Perl Glib::Object reference for the C object pointed to by \fI\f(CI$pointer\fI\fR.
You should need this \fIvery\fR rarely; it's intended to support foreign objects.
.PP
\&\s-1NOTE:\s0 the cast from arbitrary integer to GObject may result in a core dump without
warning, because the type-checking macro \fBG_OBJECT()\fR attempts to dereference the
pointer to find a GTypeClass structure, and there is no portable way to validate
the pointer.
.ie n .SS "unsigned = $object\->\fBget_data\fP ($key)"
.el .SS "unsigned = \f(CW$object\fP\->\fBget_data\fP ($key)"
.IX Subsection "unsigned = $object->get_data ($key)"
.IP "\(bu" 4
\&\f(CW$key\fR (string)
.PP
Fetch the integer stored under the object data key \fI\f(CI$key\fI\fR.  These values do not
have types; type conversions must be done manually.  See \f(CW\*(C`set_data\*(C'\fR.
.ie n .SS "$object\->\fBset_data\fP ($key, $data)"
.el .SS "\f(CW$object\fP\->\fBset_data\fP ($key, \f(CW$data\fP)"
.IX Subsection "$object->set_data ($key, $data)"
.IP "\(bu" 4
\&\f(CW$key\fR (string)
.IP "\(bu" 4
\&\f(CW$data\fR (scalar)
.PP
GObject provides an arbitrary data mechanism that assigns unsigned integers
to key names.  Functionality overlaps with the hash used as the Perl object
instance, so we strongly recommend you use hash keys for your data storage.
The GObject data values cannot store type information, so they are not safe
to use for anything but integer values, and you really should use this method
only if you know what you are doing.
.ie n .SS "pspec or undef = $object_or_class_name\->\fBfind_property\fP ($name)"
.el .SS "pspec or undef = \f(CW$object_or_class_name\fP\->\fBfind_property\fP ($name)"
.IX Subsection "pspec or undef = $object_or_class_name->find_property ($name)"
.IP "\(bu" 4
\&\f(CW$name\fR (string)
.PP
Find the definition of object property \fI\f(CI$name\fI\fR for \fI\f(CI$object_or_class_name\fI\fR.
Return \f(CW\*(C`undef\*(C'\fR if no such property.  For
the returned data see Glib::Object::list_properties.
.ie n .SS "$object\->\fBfreeze_notify\fP"
.el .SS "\f(CW$object\fP\->\fBfreeze_notify\fP"
.IX Subsection "$object->freeze_notify"
Stops emission of \*(L"notify\*(R" signals on \fI\f(CI$object\fI\fR. The signals are queued
until \f(CW\*(C`thaw_notify\*(C'\fR is called on \fI\f(CI$object\fI\fR.
.ie n .SS "$object\->\fBget\fP (...)"
.el .SS "\f(CW$object\fP\->\fBget\fP (...)"
.IX Subsection "$object->get (...)"
.IP "\(bu" 4
\&... (list) list of property names
.PP
Alias for \f(CW\*(C`get_property\*(C'\fR (see \*(L"get and set\*(R" above).
.ie n .SS "$object\->\fBset\fP (key => $value, ...)"
.el .SS "\f(CW$object\fP\->\fBset\fP (key => \f(CW$value\fP, ...)"
.IX Subsection "$object->set (key => $value, ...)"
.IP "\(bu" 4
\&... (list) key/value pairs
.PP
Alias for \f(CW\*(C`set_property\*(C'\fR (see \*(L"get and set\*(R" above).
.ie n .SS "list = $object_or_class_name\->\fBlist_properties\fP"
.el .SS "list = \f(CW$object_or_class_name\fP\->\fBlist_properties\fP"
.IX Subsection "list = $object_or_class_name->list_properties"
List all the object properties for \fI\f(CI$object_or_class_name\fI\fR; returns them as
a list of hashes, containing these keys:
.IP "name" 4
.IX Item "name"
The name of the property
.IP "type" 4
.IX Item "type"
The type of the property
.IP "owner_type" 4
.IX Item "owner_type"
The type that owns the property
.IP "descr" 4
.IX Item "descr"
The description of the property
.IP "flags" 4
.IX Item "flags"
The Glib::ParamFlags of the property
.ie n .SS "$object\->\fBnotify\fP ($property_name)"
.el .SS "\f(CW$object\fP\->\fBnotify\fP ($property_name)"
.IX Subsection "$object->notify ($property_name)"
.IP "\(bu" 4
\&\f(CW$property_name\fR (string)
.PP
Emits a \*(L"notify\*(R" signal for the property \fI\f(CI$property\fI\fR on \fI\f(CI$object\fI\fR.
.ie n .SS "gpointer = $object\->\fBget_pointer\fP"
.el .SS "gpointer = \f(CW$object\fP\->\fBget_pointer\fP"
.IX Subsection "gpointer = $object->get_pointer"
Complement of \f(CW\*(C`new_from_pointer\*(C'\fR.
.ie n .SS "$object\->\fBget_property\fP (...)"
.el .SS "\f(CW$object\fP\->\fBget_property\fP (...)"
.IX Subsection "$object->get_property (...)"
Fetch and return the values for the object properties named in \fI...\fR.
.ie n .SS "$object\->\fBset_property\fP (key => $value, ...)"
.el .SS "\f(CW$object\fP\->\fBset_property\fP (key => \f(CW$value\fP, ...)"
.IX Subsection "$object->set_property (key => $value, ...)"
Set object properties.
.ie n .SS "unsigned = $object_or_class_name\->\fBsignal_add_emission_hook\fP ($detailed_signal, $hook_func, $hook_data=undef)"
.el .SS "unsigned = \f(CW$object_or_class_name\fP\->\fBsignal_add_emission_hook\fP ($detailed_signal, \f(CW$hook_func\fP, \f(CW$hook_data\fP=undef)"
.IX Subsection "unsigned = $object_or_class_name->signal_add_emission_hook ($detailed_signal, $hook_func, $hook_data=undef)"
.IP "\(bu" 4
\&\f(CW$detailed_signal\fR (string) of the form \*(L"signal\-name::detail\*(R"
.IP "\(bu" 4
\&\f(CW$hook_func\fR (subroutine)
.IP "\(bu" 4
\&\f(CW$hook_data\fR (scalar)
.PP
Add an emission hook for a signal.  The hook will be called for any emission
of that signal, independent of the instance.  This is possible only for
signals which don't have the \f(CW\*(C`G_SIGNAL_NO_HOOKS\*(C'\fR flag set.
.PP
The \fI\f(CI$hook_func\fI\fR should be reference to a subroutine that looks something
like this:
.PP
.Vb 6
\&  sub emission_hook {
\&      my ($invocation_hint, $parameters, $hook_data) = @_;
\&      # $parameters is a reference to the @_ to be passed to
\&      # signal handlers, including the instance as $parameters\->[0].
\&      return $stay_connected;  # boolean
\&  }
.Ve
.PP
This function returns an id that can be used with \f(CW\*(C`remove_emission_hook\*(C'\fR.
.PP
Since 1.100.
.ie n .SS "list = $instance\->\fBsignal_chain_from_overridden\fP (...)"
.el .SS "list = \f(CW$instance\fP\->\fBsignal_chain_from_overridden\fP (...)"
.IX Subsection "list = $instance->signal_chain_from_overridden (...)"
.IP "\(bu" 4
\&... (list)
.PP
Chain up to an overridden class closure; it is only valid to call this from
a class closure override.
.PP
Translation: because of various details in how GObjects are implemented,
the way to override a virtual method on a GObject is to provide a new \*(L"class
closure\*(R", or default handler for a signal.  This happens when a class is
registered with the type system (see Glib::Type::register and
Glib::Object::Subclass).  When called from inside such an override, this
method runs the overridden class closure.  This is equivalent to calling
\&\f(CW$self\fR\->SUPER::$method (@_) in normal Perl objects.
.ie n .SS "unsigned = $instance\->\fBsignal_connect\fP ($detailed_signal, $callback, $data=undef)"
.el .SS "unsigned = \f(CW$instance\fP\->\fBsignal_connect\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data\fP=undef)"
.IX Subsection "unsigned = $instance->signal_connect ($detailed_signal, $callback, $data=undef)"
.IP "\(bu" 4
\&\f(CW$detailed_signal\fR (string)
.IP "\(bu" 4
\&\f(CW$callback\fR (subroutine)
.IP "\(bu" 4
\&\f(CW$data\fR (scalar) arbitrary data to be passed to each invocation of \fIcallback\fR
.PP
Register \fIcallback\fR to be called on each emission of \fI\f(CI$detailed_signal\fI\fR.
Returns an identifier that may be used to remove this handler with
\&\f(CW\*(C`$object\->signal_handler_disconnect\*(C'\fR.
.ie n .SS "unsigned = $instance\->\fBsignal_connect_after\fP ($detailed_signal, $callback, $data=undef)"
.el .SS "unsigned = \f(CW$instance\fP\->\fBsignal_connect_after\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data\fP=undef)"
.IX Subsection "unsigned = $instance->signal_connect_after ($detailed_signal, $callback, $data=undef)"
.IP "\(bu" 4
\&\f(CW$detailed_signal\fR (string)
.IP "\(bu" 4
\&\f(CW$callback\fR (scalar)
.IP "\(bu" 4
\&\f(CW$data\fR (scalar)
.PP
Like \f(CW\*(C`signal_connect\*(C'\fR, except that \fI\f(CI$callback\fI\fR will be run after the default
handler.
.ie n .SS "unsigned = $instance\->\fBsignal_connect_swapped\fP ($detailed_signal, $callback, $data=undef)"
.el .SS "unsigned = \f(CW$instance\fP\->\fBsignal_connect_swapped\fP ($detailed_signal, \f(CW$callback\fP, \f(CW$data\fP=undef)"
.IX Subsection "unsigned = $instance->signal_connect_swapped ($detailed_signal, $callback, $data=undef)"
.IP "\(bu" 4
\&\f(CW$detailed_signal\fR (string)
.IP "\(bu" 4
\&\f(CW$callback\fR (scalar)
.IP "\(bu" 4
\&\f(CW$data\fR (scalar)
.PP
Like \f(CW\*(C`signal_connect\*(C'\fR, except that \fI\f(CI$data\fI\fR and \fI\f(CI$object\fI\fR will be swapped
on invocation of \fI\f(CI$callback\fI\fR.
.ie n .SS "retval = $object\->\fBsignal_emit\fP ($name, ...)"
.el .SS "retval = \f(CW$object\fP\->\fBsignal_emit\fP ($name, ...)"
.IX Subsection "retval = $object->signal_emit ($name, ...)"
.IP "\(bu" 4
\&\f(CW$name\fR (string) the name of the signal
.IP "\(bu" 4
\&... (list) any arguments to pass to handlers.
.PP
Emit the signal \fIname\fR on \fI\f(CI$object\fI\fR.  The number and types of additional
arguments in \fI...\fR are determined by the signal; similarly, the presence
and type of return value depends on the signal being emitted.
.ie n .SS "$ihint = $instance\->\fBsignal_get_invocation_hint\fP"
.el .SS "\f(CW$ihint\fP = \f(CW$instance\fP\->\fBsignal_get_invocation_hint\fP"
.IX Subsection "$ihint = $instance->signal_get_invocation_hint"
Get a reference to a hash describing the innermost signal currently active
on \f(CW$instance\fR.  Returns undef if no signal emission is active.  This
invocation hint is the same object passed to signal emission hooks, and
contains these keys:
.IP "signal_name" 4
.IX Item "signal_name"
The name of the signal being emitted.
.IP "detail" 4
.IX Item "detail"
The detail passed on for this emission.  For example, a \f(CW\*(C`notify\*(C'\fR signal will
have the property name as the detail.
.IP "run_type" 4
.IX Item "run_type"
The current stage of signal emission, one of \*(L"run-first\*(R", \*(L"run-last\*(R", or
\&\*(L"run-cleanup\*(R".
.ie n .SS "$object\->\fBsignal_handler_block\fP ($handler_id)"
.el .SS "\f(CW$object\fP\->\fBsignal_handler_block\fP ($handler_id)"
.IX Subsection "$object->signal_handler_block ($handler_id)"
.IP "\(bu" 4
\&\f(CW$handler_id\fR (unsigned)
.ie n .SS "$object\->\fBsignal_handler_disconnect\fP ($handler_id)"
.el .SS "\f(CW$object\fP\->\fBsignal_handler_disconnect\fP ($handler_id)"
.IX Subsection "$object->signal_handler_disconnect ($handler_id)"
.IP "\(bu" 4
\&\f(CW$handler_id\fR (unsigned)
.ie n .SS "boolean = $object\->\fBsignal_handler_is_connected\fP ($handler_id)"
.el .SS "boolean = \f(CW$object\fP\->\fBsignal_handler_is_connected\fP ($handler_id)"
.IX Subsection "boolean = $object->signal_handler_is_connected ($handler_id)"
.IP "\(bu" 4
\&\f(CW$handler_id\fR (unsigned)
.ie n .SS "$object\->\fBsignal_handler_unblock\fP ($handler_id)"
.el .SS "\f(CW$object\fP\->\fBsignal_handler_unblock\fP ($handler_id)"
.IX Subsection "$object->signal_handler_unblock ($handler_id)"
.IP "\(bu" 4
\&\f(CW$handler_id\fR (unsigned)
.ie n .SS "integer = $instance\->\fBsignal_handlers_block_by_func\fP ($func, $data=undef)"
.el .SS "integer = \f(CW$instance\fP\->\fBsignal_handlers_block_by_func\fP ($func, \f(CW$data\fP=undef)"
.IX Subsection "integer = $instance->signal_handlers_block_by_func ($func, $data=undef)"
.IP "\(bu" 4
\&\f(CW$func\fR (subroutine) function to block
.IP "\(bu" 4
\&\f(CW$data\fR (scalar) data to match, ignored if undef
.ie n .SS "integer = $instance\->\fBsignal_handlers_disconnect_by_func\fP ($func, $data=undef)"
.el .SS "integer = \f(CW$instance\fP\->\fBsignal_handlers_disconnect_by_func\fP ($func, \f(CW$data\fP=undef)"
.IX Subsection "integer = $instance->signal_handlers_disconnect_by_func ($func, $data=undef)"
.IP "\(bu" 4
\&\f(CW$func\fR (subroutine) function to block
.IP "\(bu" 4
\&\f(CW$data\fR (scalar) data to match, ignored if undef
.ie n .SS "integer = $instance\->\fBsignal_handlers_unblock_by_func\fP ($func, $data=undef)"
.el .SS "integer = \f(CW$instance\fP\->\fBsignal_handlers_unblock_by_func\fP ($func, \f(CW$data\fP=undef)"
.IX Subsection "integer = $instance->signal_handlers_unblock_by_func ($func, $data=undef)"
.IP "\(bu" 4
\&\f(CW$func\fR (subroutine) function to block
.IP "\(bu" 4
\&\f(CW$data\fR (scalar) data to match, ignored if undef
.ie n .SS "scalar = $object_or_class_name\->\fBsignal_query\fP ($name)"
.el .SS "scalar = \f(CW$object_or_class_name\fP\->\fBsignal_query\fP ($name)"
.IX Subsection "scalar = $object_or_class_name->signal_query ($name)"
.IP "\(bu" 4
\&\f(CW$name\fR (string)
.PP
Look up information about the signal \fI\f(CI$name\fI\fR on the instance type
\&\fI\f(CI$object_or_class_name\fI\fR, which may be either a Glib::Object or a package
name.
.PP
See also \f(CW\*(C`Glib::Type::list_signals\*(C'\fR, which returns the same kind of
hash refs as this does.
.PP
Since 1.080.
.ie n .SS "$object_or_class_name\->\fBsignal_remove_emission_hook\fP ($signal_name, $hook_id)"
.el .SS "\f(CW$object_or_class_name\fP\->\fBsignal_remove_emission_hook\fP ($signal_name, \f(CW$hook_id\fP)"
.IX Subsection "$object_or_class_name->signal_remove_emission_hook ($signal_name, $hook_id)"
.IP "\(bu" 4
\&\f(CW$signal_name\fR (string)
.IP "\(bu" 4
\&\f(CW$hook_id\fR (unsigned)
.PP
Remove a hook that was installed by \f(CW\*(C`add_emission_hook\*(C'\fR.
.PP
Since 1.100.
.ie n .SS "$instance\->\fBsignal_stop_emission_by_name\fP ($detailed_signal)"
.el .SS "\f(CW$instance\fP\->\fBsignal_stop_emission_by_name\fP ($detailed_signal)"
.IX Subsection "$instance->signal_stop_emission_by_name ($detailed_signal)"
.IP "\(bu" 4
\&\f(CW$detailed_signal\fR (string)
.ie n .SS "$object\->\fBthaw_notify\fP"
.el .SS "\f(CW$object\fP\->\fBthaw_notify\fP"
.IX Subsection "$object->thaw_notify"
Reverts the effect of a previous call to \f(CW\*(C`freeze_notify\*(C'\fR. This causes all
queued \*(L"notify\*(R" signals on \fI\f(CI$object\fI\fR to be emitted.
.SS "boolean = Glib::Object\->\fBset_threadsafe\fP ($threadsafe)"
.IX Subsection "boolean = Glib::Object->set_threadsafe ($threadsafe)"
.IP "\(bu" 4
\&\f(CW$threadsafe\fR (boolean)
.PP
Enables/disables threadsafe gobject tracking. Returns whether or not tracking
will be successful and thus whether using perl ithreads will be possible.
.ie n .SS "$object\->\fBtie_properties\fP ($all=FALSE)"
.el .SS "\f(CW$object\fP\->\fBtie_properties\fP ($all=FALSE)"
.IX Subsection "$object->tie_properties ($all=FALSE)"
.IP "\(bu" 4
\&\f(CW$all\fR (boolean) if \s-1FALSE\s0 (or omitted) tie only properties for this object's class, if \s-1TRUE\s0 tie the properties of this and all parent classes.
.PP
A special method available to Glib::Object derivatives, it uses perl's tie
facilities to associate hash keys with the properties of the object. For
example:
.PP
.Vb 4
\&  $button\->tie_properties;
\&  # equivilent to $button\->set (label => \*(AqHello World\*(Aq);
\&  $button\->{label} = \*(AqHello World\*(Aq;
\&  print "the label is: ".$button\->{label}."\en";
.Ve
.PP
Attempts to write to read-only properties will croak, reading a write-only
property will return '[write\-only]'.
.PP
Care must be taken when using tie_properties with objects of types created with
Glib::Object::Subclass as there may be clashes with existing hash keys that
could cause infinite loops. The solution is to use custom property get/set
functions to alter the storage locations of the properties.
.SH "SIGNALS"
.IX Header "SIGNALS"
.IP "\fBnotify\fR (Glib::Object, Glib::ParamSpec)" 4
.IX Item "notify (Glib::Object, Glib::ParamSpec)"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Glib
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2003\-2011 by the gtk2\-perl team.
.PP
This software is licensed under the \s-1LGPL.\s0  See Glib for a full notice.
