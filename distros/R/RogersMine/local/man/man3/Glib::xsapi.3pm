.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Glib::xsapi 3"
.TH Glib::xsapi 3 "2019-03-03" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Glib::xsapi \- internal API reference for GPerl.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <gperl.h>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the binding developer's \s-1API\s0 reference for GPerl, automatically
generated from the xs source files.  This header defines the public
interface for use when creating new Perl language bindings for GLib-based C
libraries.
.PP
gperl.h includes for you all the headers needed for writing XSUBs 
(\s-1EXTERN\s0.h, perl.h, and \s-1XSUB\s0.h), as well as all of GLib (via glib\-object.h).
.SH "API"
.IX Header "API"
.SS "Miscellaneous"
.IX Subsection "Miscellaneous"
Various useful utilities defined in Glib.xs.
.IP "\s-1GPERL_CALL_BOOT\s0(name)" 4
.IX Item "GPERL_CALL_BOOT(name)"
call the boot code of a module by symbol rather than by name.
.Sp
in a perl extension which uses several xs files but only one pm, you
need to bootstrap the other xs files in order to get their functions
exported to perl.  if the file has \s-1MODULE\s0 = Foo::Bar, the boot symbol
would be boot_Foo_\|_Bar.
.IP "void _gperl_call_XS (pTHX_ void (*subaddr) (pTHX_ \s-1CV\s0 *), \s-1CV\s0 * cv, \s-1SV\s0 ** mark);" 4
.IX Item "void _gperl_call_XS (pTHX_ void (*subaddr) (pTHX_ CV *), CV * cv, SV ** mark);"
never use this function directly.  see \f(CW\*(C`GPERL_CALL_BOOT\*(C'\fR.
.Sp
for the curious, this calls a perl sub by function pointer rather than
by name; call_sv requires that the xsub already be registered, but we
need this to call a function which will register xsubs.  this is an
evil hack and should not be used outside of the \s-1GPERL_CALL_BOOT\s0 macro.
it's implemented as a function to avoid code size bloat, and exported
so that extension modules can pull the same trick.
.IP "gpointer gperl_alloc_temp (int nbytes)" 4
.IX Item "gpointer gperl_alloc_temp (int nbytes)"
Allocate and return a pointer to an \fInbytes\fR\-long, zero-initialized,
temporary buffer that will be reaped at the next garbage collection sweep.
This is handy for allocating things that need to be alloc'ed before a croak
(since croak doesn't return and give you the chance to free them).  The
trick is that the memory is allocated in a mortal perl scalar.  See the
perl online manual for notes on using this technique.
.Sp
Do \fBnot\fR under any circumstances attempt to call \fBg_free()\fR, \fBfree()\fR, or any
other deallocator on this pointer, or you will crash the interpreter.
.IP "gchar *gperl_filename_from_sv (\s-1SV\s0 *sv)" 4
.IX Item "gchar *gperl_filename_from_sv (SV *sv)"
Return a localized version of the filename in the sv, using
g_filename_from_utf8 (and consequently this function might croak). The
memory is allocated using gperl_alloc_temp.
.IP "\s-1SV\s0 *gperl_sv_from_filename (const gchar *filename)" 4
.IX Item "SV *gperl_sv_from_filename (const gchar *filename)"
Convert the filename into an utf8 string as used by gtk/glib and perl.
.IP "gboolean gperl_str_eq (const char * a, const char * b);" 4
.IX Item "gboolean gperl_str_eq (const char * a, const char * b);"
Compare a pair of ascii strings, considering '\-' and '_' to be equivalent.
Used for things like enum value nicknames and signal names.
.IP "guint gperl_str_hash (gconstpointer key)" 4
.IX Item "guint gperl_str_hash (gconstpointer key)"
Like \fBg_str_hash()\fR, but considers '\-' and '_' to be equivalent.
.IP "GPerlArgv * gperl_argv_new ()" 4
.IX Item "GPerlArgv * gperl_argv_new ()"
Creates a new Perl argv object whose members can then be passed to functions
that request argc and argv style arguments.
.Sp
If the called function(s) modified argv, you can call gperl_argv_update to
update Perl's \f(CW@ARGV\fR in the same way.
.Sp
Remember to call gperl_argv_free when you're done.
.IP "void gperl_argv_update (GPerlArgv *pargv)" 4
.IX Item "void gperl_argv_update (GPerlArgv *pargv)"
Updates \f(CW@ARGV\fR to resemble the stored argv array.
.IP "void gperl_argv_free (GPerlArgv *pargv)" 4
.IX Item "void gperl_argv_free (GPerlArgv *pargv)"
Frees any resources associated with \fIpargv\fR.
.IP "char * gperl_format_variable_for_output (\s-1SV\s0 * sv)" 4
.IX Item "char * gperl_format_variable_for_output (SV * sv)"
Formats the variable stored in \fIsv\fR for output in error messages.  Like
\&\fBSvPV_nolen()\fR, but ellipsizes real strings (i.e., not stringified references)
at 20 chars to trim things down for error messages.
.IP "gboolean gperl_sv_is_defined (\s-1SV\s0 *sv)" 4
.IX Item "gboolean gperl_sv_is_defined (SV *sv)"
Checks the \s-1SV\s0 \fIsv\fR for definedness just like Perl's \fI\f(BIdefined()\fI\fR would do.
Most importantly, it correctly handles \*(L"magical\*(R" SVs, unlike bare \fISvOK\fR.
It's also NULL-safe.
.IP "void gperl_hv_take_sv (\s-1HV\s0 *hv, const char *key, size_t key_length, \s-1SV\s0 *sv)" 4
.IX Item "void gperl_hv_take_sv (HV *hv, const char *key, size_t key_length, SV *sv)"
Tries to store \fIsv\fR in \fIhv\fR.  Decreases \fIsv\fR's reference count if something
goes wrong.
.SS "GError Exception Objects"
.IX Subsection "GError Exception Objects"
GError is a facility for propagating run-time error / exception information
around in C, which is a language without native support for exceptions.
GError uses a simple error code, usually defined as an enum.  Since the
enums will overlap, GError includes the GQuark corresponding to a particular
error \*(L"domain\*(R" to tell you which error codes will be used.  There's also a
string containing a specific error message.  The strings are arbitrary, and
may be translated, but the domains and codes are definite.
.PP
Perl has native support for exceptions, using \f(CW\*(C`eval\*(C'\fR as \*(L"try\*(R", \f(CW\*(C`croak\*(C'\fR or
\&\f(CW\*(C`die\*(C'\fR as \*(L"throw\*(R", and \f(CW\*(C`if ($@)\*(C'\fR as \*(L"catch\*(R".  \f(CW$@\fR may, in fact, be
any scalar, including blessed objects.
.PP
So, GPerl maps GLib's GError to Perl exceptions.
.PP
Since, as we described above, error messages are not guaranteed to be unique
everywhere, we need to support the use of the error domains and codes.
The obvious choice here is to use exception objects; however, to support
blessed exception objects, we must perform a little bit of black magic in
the bindings.   There is no built-in association between an error domain
quark and the GType of the corresponding error code enumeration, so the
bindings supply both of these when specifying the name of the package into
which to bless exceptions of this domain.  All GError-based exceptions 
derive from Glib::Error, of course, and this base class provides all of the
functionality, including stringification.
.PP
All you'll really ever need to do is register error domains with
\&\f(CW\*(C`gperl_register_error_domain\*(C'\fR, and throw errors with \f(CW\*(C`gperl_croak_gerror\*(C'\fR.
.IP "void gperl_register_error_domain (GQuark domain, GType error_enum, const char * package)" 4
.IX Item "void gperl_register_error_domain (GQuark domain, GType error_enum, const char * package)"
Tell the bindings to bless GErrors with error\->domain == \fIdomain\fR into
\&\fIpackage\fR, and use \fIerror_enum\fR to find the nicknames for the error codes.
This will call \f(CW\*(C`gperl_set_isa\*(C'\fR on \fIpackage\fR to add \*(L"Glib::Error\*(R" to
\&\fIpackage\fR's \f(CW@ISA\fR.
.Sp
\&\fIdomain\fR may not be 0, and \fIpackage\fR may not be \s-1NULL\s0; what would be the 
point?  \fIerror_enum\fR may be 0, in which case you'll get no fancy stringified
error values.
.IP "\s-1SV\s0 * gperl_sv_from_gerror (GError * error)" 4
.IX Item "SV * gperl_sv_from_gerror (GError * error)"
You should rarely, if ever, need to call this function.  This is what turns
a GError into a Perl object.
.IP "gperl_gerror_from_sv (\s-1SV\s0 * sv, GError ** error)" 4
.IX Item "gperl_gerror_from_sv (SV * sv, GError ** error)"
You should rarely need this function.  This parses a perl data structure into
a GError.  If \fIsv\fR is undef (or the empty string), sets *\fIerror\fR to \s-1NULL,\s0
otherwise, allocates a new GError with \f(CW\*(C`g_error_new_literal()\*(C'\fR and writes
through \fIerror\fR; the caller is responsible for calling \f(CW\*(C`g_error_free()\*(C'\fR.
(\fBgperl_croak_gerror()\fR does this, for example.)
.IP "void gperl_croak_gerror (const char * ignored, GError * err)" 4
.IX Item "void gperl_croak_gerror (const char * ignored, GError * err)"
Croak with an exception based on \fIerr\fR.  \fIerr\fR may not be \s-1NULL.\s0  \fIignored\fR
exists for backward compatibility, and is, well, ignored.  This function
calls \fBcroak()\fR, which does not return.
.Sp
Since \fBcroak()\fR does not return, this function handles the magic behind 
not leaking the memory associated with the #GError.  To use this you'd
do something like
.Sp
.Vb 5
\& PREINIT:
\&   GError * error = NULL;
\& CODE:
\&   if (!funtion_that_can_fail (something, &error))
\&      gperl_croak_gerror (NULL, error);
.Ve
.Sp
It's just that simple!
.SS "GLog"
.IX Subsection "GLog"
GLib has a message logging mechanism which it uses for the \fBg_return_if_fail()\fR
assertion macros, etc.; it's really versatile and allows you to set various
levels to be fatal and whatnot.  Libraries use these for various types of
message reporting.
.PP
These functions let you reroute those messages from Perl.  By default, 
the warning, critical, and message levels go through perl's \fBwarn()\fR, and
fatal ones go through \fBcroak()\fR.  [i'm not sure that these get to \fBcroak()\fR
before GLib \fBabort()\fRs on them...]
.IP "gint gperl_handle_logs_for (const gchar * log_domain)" 4
.IX Item "gint gperl_handle_logs_for (const gchar * log_domain)"
Route all g_logs for \fIlog_domain\fR through gperl's log handling.  You'll
have to register domains in each binding submodule, because there's no way
we can know about them down here.
.Sp
And, technically, this traps all the predefined log levels, not any of
the ones you (or your library) may define for yourself.
.SS "GType / GEnum / GFlags"
.IX Subsection "GType / GEnum / GFlags"
.IP "void gperl_register_fundamental (GType gtype, const char * package)" 4
.IX Item "void gperl_register_fundamental (GType gtype, const char * package)"
register a mapping between \fIgtype\fR and \fIpackage\fR.  this is for \*(L"fundamental\*(R"
types which have no other requirements for metadata storage, such as GEnums,
GFlags, or real GLib fundamental types like G_TYPE_INT, G_TYPE_FLOAT, etc.
.IP "void gperl_register_fundamental_alias (GType gtype, const char * package)" 4
.IX Item "void gperl_register_fundamental_alias (GType gtype, const char * package)"
Makes \fIpackage\fR an alias for \fItype\fR.  This means that the package name
specified by \fIpackage\fR will be mapped to \fItype\fR by
\&\fIgperl_fundamental_type_from_package\fR, but
\&\fIgperl_fundamental_package_from_type\fR won't map \fItype\fR to \fIpackage\fR.  This
is useful if you want to change the canonical package name of a type while
preserving backwards compatibility with code which uses \fIpackage\fR to specify
\&\fItype\fR.
.Sp
In order for this to make sense, another package name should be registered for
\&\fItype\fR with \fIgperl_register_fundamental\fR or
\&\fIgperl_register_fundamental_full\fR.
.IP "GPerlValueWrapperClass" 4
.IX Item "GPerlValueWrapperClass"
Specifies the vtable that is to be used to convert fundamental types to and
from Perl variables.
.Sp
.Vb 5
\&  typedef struct _GPerlValueWrapperClass GPerlValueWrapperClass;
\&  struct _GPerlValueWrapperClass {
\&          GPerlValueWrapFunc   wrap;
\&          GPerlValueUnwrapFunc unwrap;
\&  };
.Ve
.Sp
The members are function pointers, each of which serves a specific purpose:
.RS 4
.IP "GPerlValueWrapFunc" 4
.IX Item "GPerlValueWrapFunc"
Turns \fIvalue\fR into an \s-1SV.\s0  The caller assumes ownership of the \s-1SV.\s0  \fIvalue\fR
is not to be modified.
.Sp
.Vb 1
\&  typedef SV*  (*GPerlValueWrapFunc)   (const GValue * value);
.Ve
.IP "GPerlValueUnwrapFunc" 4
.IX Item "GPerlValueUnwrapFunc"
Turns \fIsv\fR into its fundamental representation and stores the result in the
pre-configured \fIvalue\fR.  \fIvalue\fR must not be overwritten; instead one of the
various \f(CW\*(C`g_value_set_*()\*(C'\fR functions must be used or the \f(CW\*(C`value\->data\*(C'\fR
pointer must be modified directly.
.Sp
.Vb 2
\&  typedef void (*GPerlValueUnwrapFunc) (GValue       * value,
\&                                        SV           * sv);
.Ve
.RE
.RS 4
.RE
.IP "void gperl_register_fundamental_full (GType gtype, const char * package, GPerlValueWrapperClass * wrapper_class)" 4
.IX Item "void gperl_register_fundamental_full (GType gtype, const char * package, GPerlValueWrapperClass * wrapper_class)"
Like gperl_register_fundamental, registers a mapping between \fIgtype\fR and
\&\fIpackage\fR.  In addition, this also installs the function pointers in
\&\fIwrapper_class\fR as the handlers for the type.  See GPerlValueWrapperClass.
.Sp
\&\fIgperl_register_fundamental_full\fR does not copy the contents of
\&\fIwrapper_class\fR \*(-- it assumes that \fIwrapper_class\fR is statically allocated
and that it will be valid for the whole lifetime of the program.
.IP "GType gperl_fundamental_type_from_package (const char * package)" 4
.IX Item "GType gperl_fundamental_type_from_package (const char * package)"
look up the GType corresponding to a \fIpackage\fR registered by
\&\fBgperl_register_fundamental()\fR.
.IP "const char * gperl_fundamental_package_from_type (GType gtype)" 4
.IX Item "const char * gperl_fundamental_package_from_type (GType gtype)"
look up the package corresponding to a \fIgtype\fR registered by
\&\fBgperl_register_fundamental()\fR.
.IP "GPerlValueWrapperClass * gperl_fundamental_wrapper_class_from_type (GType gtype)" 4
.IX Item "GPerlValueWrapperClass * gperl_fundamental_wrapper_class_from_type (GType gtype)"
look up the wrapper class corresponding to a \fIgtype\fR that has previously been
registered with \fBgperl_register_fundamental_full()\fR.
.IP "gboolean gperl_try_convert_enum (GType gtype, \s-1SV\s0 * sv, gint * val)" 4
.IX Item "gboolean gperl_try_convert_enum (GType gtype, SV * sv, gint * val)"
return \s-1FALSE\s0 if \fIsv\fR can't be mapped to a valid member of the registered
enum type \fIgtype\fR; otherwise, return \s-1TRUE\s0 write the new value to the
int pointed to by \fIval\fR.
.Sp
you'll need this only in esoteric cases.
.IP "gint gperl_convert_enum (GType type, \s-1SV\s0 * val)" 4
.IX Item "gint gperl_convert_enum (GType type, SV * val)"
croak if \fIval\fR is not part of \fItype\fR, otherwise return corresponding value
.IP "\s-1SV\s0 * gperl_convert_back_enum_pass_unknown (GType type, gint val)" 4
.IX Item "SV * gperl_convert_back_enum_pass_unknown (GType type, gint val)"
return a scalar containing the nickname of the enum value \fIval\fR, or the
integer value of \fIval\fR if \fIval\fR is not a member of the enum \fItype\fR.
.IP "\s-1SV\s0 * gperl_convert_back_enum (GType type, gint val)" 4
.IX Item "SV * gperl_convert_back_enum (GType type, gint val)"
return a scalar which is the nickname of the enum value val, or croak if
val is not a member of the enum.
.IP "gboolean gperl_try_convert_flag (GType type, const char * val_p, gint * val)" 4
.IX Item "gboolean gperl_try_convert_flag (GType type, const char * val_p, gint * val)"
like \fBgperl_try_convert_enum()\fR, but for GFlags.
.IP "gint gperl_convert_flag_one (GType type, const char * val)" 4
.IX Item "gint gperl_convert_flag_one (GType type, const char * val)"
croak if \fIval\fR is not part of \fItype\fR, otherwise return corresponding value.
.IP "gint gperl_convert_flags (GType type, \s-1SV\s0 * val)" 4
.IX Item "gint gperl_convert_flags (GType type, SV * val)"
collapse a list of strings to an integer with all the correct bits set,
croak if anything is invalid.
.IP "\s-1SV\s0 * gperl_convert_back_flags (GType type, gint val)" 4
.IX Item "SV * gperl_convert_back_flags (GType type, gint val)"
convert a bitfield to a list of strings.
.SS "Inheritance management"
.IX Subsection "Inheritance management"
.IP "void gperl_set_isa (const char * child_package, const char * parent_package)" 4
.IX Item "void gperl_set_isa (const char * child_package, const char * parent_package)"
tell perl that \fIchild_package\fR inherits \fIparent_package\fR, after whatever else
is already there.  equivalent to \f(CW\*(C`push @{$parent_package}::ISA, $child_package;\*(C'\fR
.IP "void gperl_prepend_isa (const char * child_package, const char * parent_package)" 4
.IX Item "void gperl_prepend_isa (const char * child_package, const char * parent_package)"
tell perl that \fIchild_package\fR inherits \fIparent_package\fR, but before whatever
else is already there.  equivalent to \f(CW\*(C`unshift @{$parent_package}::ISA, $child_package;\*(C'\fR
.IP "GType gperl_type_from_package (const char * package)" 4
.IX Item "GType gperl_type_from_package (const char * package)"
Look up the GType associated with \fIpackage\fR, regardless of how it was
registered.  Returns 0 if no mapping can be found.
.IP "const char * gperl_package_from_type (GType gtype)" 4
.IX Item "const char * gperl_package_from_type (GType gtype)"
Look up the name of the package associated with \fIgtype\fR, regardless of how it
was registered.  Returns \s-1NULL\s0 if no mapping can be found.
.SS "Boxed type support for \s-1SV\s0"
.IX Subsection "Boxed type support for SV"
In order to allow GValues to hold perl SVs we need a GBoxed wrapper.
.IP "\s-1GPERL_TYPE_SV\s0" 4
.IX Item "GPERL_TYPE_SV"
Evaluates to the GType for SVs.  The bindings register a mapping between
\&\s-1GPERL_TYPE_SV\s0 and the package 'Glib::Scalar' with \fBgperl_register_boxed()\fR.
.IP "\s-1SV\s0 * gperl_sv_copy (\s-1SV\s0 * sv)" 4
.IX Item "SV * gperl_sv_copy (SV * sv)"
implemented as \f(CW\*(C`newSVsv (sv)\*(C'\fR.
.IP "void gperl_sv_free (\s-1SV\s0 * sv)" 4
.IX Item "void gperl_sv_free (SV * sv)"
implemented as \f(CW\*(C`SvREFCNT_dec (sv)\*(C'\fR.
.SS "\s-1UTF\-8\s0 strings with gchar"
.IX Subsection "UTF-8 strings with gchar"
By convention, gchar* is assumed to point to \s-1UTF8\s0 string data,
and char* points to ascii string data.  Here we define a pair of
wrappers for the boilerplate of upgrading Perl strings.  They
are implemented as functions rather than macros, because comma
expressions in macros are not supported by all compilers.
.PP
These functions should be used instead of newSVpv and SvPV_nolen
in all cases which deal with gchar* types.
.IP "gchar * SvGChar (\s-1SV\s0 * sv)" 4
.IX Item "gchar * SvGChar (SV * sv)"
extract a \s-1UTF8\s0 string from \fIsv\fR.
.IP "\s-1SV\s0 * newSVGChar (const gchar * str)" 4
.IX Item "SV * newSVGChar (const gchar * str)"
copy a \s-1UTF8\s0 string into a new \s-1SV.\s0  if str is \s-1NULL,\s0 returns &PL_sv_undef.
.SS "64 bit integers"
.IX Subsection "64 bit integers"
On 32 bit machines and even on some 64 bit machines, perl's \s-1IV/UV\s0 data type can
only hold 32 bit values.  The following functions therefore convert 64 bit
integers to and from Perl strings if normal \s-1IV/UV\s0 conversion does not suffice.
.IP "gint64 SvGInt64 (\s-1SV\s0 *sv)" 4
.IX Item "gint64 SvGInt64 (SV *sv)"
Converts the string in \fIsv\fR to a signed 64 bit integer.  If appropriate, uses
\&\f(CW\*(C`SvIV\*(C'\fR instead.
.IP "\s-1SV\s0 * newSVGInt64 (gint64 value)" 4
.IX Item "SV * newSVGInt64 (gint64 value)"
Creates a \s-1PV\s0 from the signed 64 bit integer in \fIvalue\fR.  If appropriate, uses
\&\f(CW\*(C`newSViv\*(C'\fR instead.
.IP "guint64 SvGUInt64 (\s-1SV\s0 *sv)" 4
.IX Item "guint64 SvGUInt64 (SV *sv)"
Converts the string in \fIsv\fR to an unsigned 64 bit integer.  If appropriate,
uses \f(CW\*(C`SvUV\*(C'\fR instead.
.IP "\s-1SV\s0 * newSVGUInt64 (guint64 value)" 4
.IX Item "SV * newSVGUInt64 (guint64 value)"
Creates a \s-1PV\s0 from the unsigned 64 bit integer in \fIvalue\fR.  If appropriate,
uses \f(CW\*(C`newSVuv\*(C'\fR instead.
.SS "GBoxed"
.IX Subsection "GBoxed"
.IP "GPerlBoxedWrapperClass" 4
.IX Item "GPerlBoxedWrapperClass"
Specifies the vtable of functions to be used for bringing boxed types in
and out of perl.  The structure is defined like this:
.Sp
.Vb 6
\& typedef struct _GPerlBoxedWrapperClass GPerlBoxedWrapperClass;
\& struct _GPerlBoxedWrapperClass {
\&          GPerlBoxedWrapFunc    wrap;
\&          GPerlBoxedUnwrapFunc  unwrap;
\&          GPerlBoxedDestroyFunc destroy;
\& };
.Ve
.Sp
The members are function pointers, each of which serves a specific purpose:
.RS 4
.IP "GPerlBoxedWrapFunc" 4
.IX Item "GPerlBoxedWrapFunc"
turn a boxed pointer into an \s-1SV.\s0  gtype is the type of the boxed pointer,
and package is the package to which that gtype is registered (the lookup
has already been done for you at this point).  if own is true, the wrapper
is responsible for freeing the object; if it is false, some other code 
owns the object and you must \s-1NOT\s0 free it.
.Sp
.Vb 4
\& typedef SV*      (*GPerlBoxedWrapFunc)    (GType        gtype,
\&                                            const char * package,
\&                                            gpointer     boxed,
\&                                            gboolean     own);
.Ve
.IP "GPerlBoxedUnwrapFunc" 4
.IX Item "GPerlBoxedUnwrapFunc"
turn an \s-1SV\s0 into a boxed pointer.  like GPerlBoxedWrapFunc, gtype and package
are the registered type pair, already looked up for you (in the process of
finding the proper wrapper class).  sv is the sv to unwrap.
.Sp
.Vb 3
\& typedef gpointer (*GPerlBoxedUnwrapFunc)  (GType        gtype,
\&                                            const char * package,
\&                                            SV         * sv);
.Ve
.IP "GPerlBoxedDestroyFunc" 4
.IX Item "GPerlBoxedDestroyFunc"
this will be called by Glib::Boxed::DESTROY, when the wrapper is destroyed.
it is a hook that allows you to destroy an object owned by the wrapper;
note, however, that you will have had to keep track yourself of whether
the object was to be freed.
.Sp
.Vb 1
\& typedef void     (*GPerlBoxedDestroyFunc) (SV         * sv);
.Ve
.RE
.RS 4
.RE
.IP "void gperl_register_boxed (GType gtype, const char * package, GPerlBoxedWrapperClass * wrapper_class)" 4
.IX Item "void gperl_register_boxed (GType gtype, const char * package, GPerlBoxedWrapperClass * wrapper_class)"
Register a mapping between the GBoxed derivative \fIgtype\fR and \fIpackage\fR.  The
specified, \fIwrapper_class\fR will be used to wrap and unwrap objects of this
type; you may pass \s-1NULL\s0 to use the default wrapper (the same one returned by
\&\fBgperl_default_boxed_wrapper_class()\fR).
.Sp
In normal usage, the standard opaque wrapper supplied by the library is
sufficient and correct.  In some cases, however, you want a boxed type to map
directly to a native perl type; for example, some struct may be more
appropriately represented as a hash in perl.  Since the most necessary place
for this conversion to happen is in \fBgperl_value_from_sv()\fR and
\&\fBgperl_sv_from_value()\fR, the only reliable and robust way to implement this 
is a hook into \fBgperl_get_boxed_check()\fR and \fBgperl_new_boxed()\fR; that is
exactly the purpose of \fIwrapper_class\fR.  See \f(CW\*(C`GPerlBoxedWrapperClass\*(C'\fR.
.Sp
\&\fIgperl_register_boxed\fR does not copy the contents of \fIwrapper_class\fR \*(-- it
assumes that \fIwrapper_class\fR is statically allocated and that it will be valid
for the whole lifetime of the program.
.IP "void gperl_register_boxed_alias (GType gtype, const char * package)" 4
.IX Item "void gperl_register_boxed_alias (GType gtype, const char * package)"
Makes \fIpackage\fR an alias for \fItype\fR.  This means that the package name
specified by \fIpackage\fR will be mapped to \fItype\fR by
\&\fIgperl_boxed_type_from_package\fR, but \fIgperl_boxed_package_from_type\fR won't
map \fItype\fR to \fIpackage\fR.  This is useful if you want to change the canonical
package name of a type while preserving backwards compatibility with code which
uses \fIpackage\fR to specify \fItype\fR.
.Sp
In order for this to make sense, another package name should be registered for
\&\fItype\fR with \fIgperl_register_boxed\fR.
.IP "void gperl_register_boxed_synonym (GType registered_gtype, GType synonym_gtype)" 4
.IX Item "void gperl_register_boxed_synonym (GType registered_gtype, GType synonym_gtype)"
Registers \fIsynonym_gtype\fR as a synonym for \fIregistered_gtype\fR.  All boxed
objects of type \fIsynonym_gtype\fR will then be treated as if they were of type
\&\fIregistered_gtype\fR, and \fIgperl_boxed_package_from_type\fR will return the
package associated with \fIregistered_gtype\fR.
.Sp
\&\fIregistered_gtype\fR must have been registered with \fIgperl_register_boxed\fR
already.
.IP "GType gperl_boxed_type_from_package (const char * package)" 4
.IX Item "GType gperl_boxed_type_from_package (const char * package)"
Look up the GType associated with package \fIpackage\fR.  Returns 0 if \fItype\fR is
not registered.
.IP "const char * gperl_boxed_package_from_type (GType type)" 4
.IX Item "const char * gperl_boxed_package_from_type (GType type)"
Look up the package associated with GBoxed derivative \fItype\fR.  Returns \s-1NULL\s0 if
\&\fItype\fR is not registered.
.IP "GPerlBoxedWrapperClass * gperl_default_boxed_wrapper_class (void)" 4
.IX Item "GPerlBoxedWrapperClass * gperl_default_boxed_wrapper_class (void)"
get a pointer to the default wrapper class; handy if you want to use
the normal wrapper, with minor modifications.  note that you can just
pass \s-1NULL\s0 to \fBgperl_register_boxed()\fR, so you really only need this in
fringe cases.
.IP "\s-1SV\s0 * gperl_new_boxed (gpointer boxed, GType gtype, gboolean own)" 4
.IX Item "SV * gperl_new_boxed (gpointer boxed, GType gtype, gboolean own)"
Export a GBoxed derivative to perl, according to whatever
GPerlBoxedWrapperClass is registered for \fIgtype\fR.  In the default
implementation, this means wrapping an opaque perl object around the pointer
to a small wrapper structure which stores some metadata, such as whether
the boxed structure should be destroyed when the wrapper is destroyed
(controlled by \fIown\fR; if the wrapper owns the object, the wrapper is in
charge of destroying it's data).
.Sp
This function might end up calling other Perl code, so if you use it in \s-1XS\s0 code
for a generic GType, make sure the stack pointer is set up correctly before the
call, and restore it after the call.
.IP "\s-1SV\s0 * gperl_new_boxed_copy (gpointer boxed, GType gtype)" 4
.IX Item "SV * gperl_new_boxed_copy (gpointer boxed, GType gtype)"
Create a new copy of \fIboxed\fR and return an owner wrapper for it.
\&\fIboxed\fR may not be \s-1NULL.\s0  See \f(CW\*(C`gperl_new_boxed\*(C'\fR.
.IP "gpointer gperl_get_boxed_check (\s-1SV\s0 * sv, GType gtype)" 4
.IX Item "gpointer gperl_get_boxed_check (SV * sv, GType gtype)"
Extract the boxed pointer from a wrapper; croaks if the wrapper \fIsv\fR is not
blessed into a derivative of the expected \fIgtype\fR.  Does not allow undef.
.SS "GObject"
.IX Subsection "GObject"
To deal with the intricate interaction of the different reference-counting
semantics of Perl objects versus GObjects, the bindings create a combined
PerlObject+GObject, with the GObject's pointer in magic attached to the Perl
object, and the Perl object's pointer in the GObject's user data.  Thus it's
not really a \*(L"wrapper\*(R", but we refer to it as one, because \*(L"combined Perl
object + GObject\*(R" is a cumbersome and confusing mouthful.
.PP
GObjects are represented as blessed hash references.  The GObject user data
mechanism is not typesafe, and thus is used only for unsigned integer values;
the Perl-level hash is available for any type of user data.  The combined
nature of the wrapper means that data stored in the hash will stick around as
long as the object is alive.
.PP
Since the C pointer is stored in attached magic, the C pointer is not available
to the Perl developer via the hash object, so there's no need to worry about
breaking it from perl.
.PP
Propers go to Marc Lehmann for dreaming most of this up.
.IP "void gperl_register_object (GType gtype, const char * package)" 4
.IX Item "void gperl_register_object (GType gtype, const char * package)"
tell the GPerl type subsystem what Perl package corresponds with a given
GObject by GType.  automagically sets up @\fIpackage\fR::ISA for you.
.Sp
note that \f(CW@ISA\fR will not be created for gtype until gtype's parent has
been registered.  if you are experiencing strange problems with a class'
\&\f(CW@ISA\fR not being set up, change the order in which you register them.
.IP "void gperl_register_object_alias (GType gtype, const char * package)" 4
.IX Item "void gperl_register_object_alias (GType gtype, const char * package)"
Makes \fIpackage\fR an alias for \fItype\fR.  This means that the package name
specified by \fIpackage\fR will be mapped to \fItype\fR by
\&\fIgperl_object_type_from_package\fR, but \fIgperl_object_package_from_type\fR won't
map \fItype\fR to \fIpackage\fR.  This is useful if you want to change the canonical
package name of a type while preserving backwards compatibility with code which
uses \fIpackage\fR to specify \fItype\fR.
.Sp
In order for this to make sense, another package name should be registered for
\&\fItype\fR with \fIgperl_register_object\fR.
.IP "void gperl_register_sink_func (GType gtype, GPerlObjectSinkFunc func)" 4
.IX Item "void gperl_register_sink_func (GType gtype, GPerlObjectSinkFunc func)"
Tell \fBgperl_new_object()\fR to use \fIfunc\fR to claim ownership of objects derived
from \fIgtype\fR.
.Sp
\&\fBgperl_new_object()\fR always refs a GObject when wrapping it for the first time.
To have the Perl wrapper claim ownership of a GObject as part of
\&\fBgperl_new_object()\fR, you unref the object after ref'ing it. however, different
GObject subclasses have different ways to claim ownership; for example,
GtkObject simply requires you to call \fBgtk_object_sink()\fR.  To make this concept
generic, this function allows you to register a function to be called when then
wrapper should claim ownership of the object.  The \fIfunc\fR registered for a
given \fItype\fR will be called on any object for which \f(CW\*(C`g_type_isa
(G_TYPE_OBJECT (object), type)\*(C'\fR succeeds.
.Sp
If no sinkfunc is found for an object, \fBg_object_unref()\fR will be used.
.Sp
Even though GObjects don't need sink funcs, we need to have them in Glib
as a hook for upstream objects.  If we create a GtkObject (or any
other type of object which uses a different way to claim ownership) via
Glib::Object\->new, any upstream wrappers, such as \fBgtk2perl_new_object()\fR, will
\&\fBnot\fR be called.  Having a sink func facility down here enables us always to
do the right thing.
.IP "void gperl_object_set_no_warn_unreg_subclass (GType gtype, gboolean nowarn)" 4
.IX Item "void gperl_object_set_no_warn_unreg_subclass (GType gtype, gboolean nowarn)"
In versions 1.00 through 1.10x of Glib, the bindings required all types
to be registered ahead of time.  Upon encountering an unknown type, the
bindings would emit a warning to the effect of \*(L"unknown type 'Foo';
representing as first known parent type 'Bar'\*(R".  However, for some
types, such as GtkStyle or GdkGC, the actual object returned is an
instance of a child type of a private implementation (e.g., a theme
engine (\*(L"BlueCurveStyle\*(R") or gdk backend (\*(L"GdkGCX11\*(R")); we neither can
nor should have registered names for these types.  Therefore, it is
possible to tell the bindings not to warn about these unregistered
subclasses, and simply represent them as the parent type.
.Sp
With 1.12x, the bindings will automatically register unknown classes
into the namespace Glib::Object::_Unregistered to avoid possible
breakage resulting from unknown ancestors of known children.  To
preserve the old registered-as-unregistered behavior, the value
installed by this function is used to prevent the _Unregistered mapping
for such private backend classes.
.Sp
Note: this assumes \fIgtype\fR has already been registered with
\&\fBgperl_register_object()\fR.
.IP "const char * gperl_object_package_from_type (GType gtype)" 4
.IX Item "const char * gperl_object_package_from_type (GType gtype)"
Get the package corresponding to \fIgtype\fR.  If \fIgtype\fR is not a GObject
or GInterface, returns \s-1NULL.\s0  If \fIgtype\fR is not registered to a package
name, a new name of the form \f(CW\*(C`Glib::Object::_Unregistered::$c_type_name\*(C'\fR
will be created, used to register the class, and then returned.
.IP "\s-1HV\s0 * gperl_object_stash_from_type (GType gtype)" 4
.IX Item "HV * gperl_object_stash_from_type (GType gtype)"
Get the stash corresponding to \fIgtype\fR; returns \s-1NULL\s0 if \fIgtype\fR is
not registered.  The stash is useful for \f(CW\*(C`bless\*(C'\fRing.
.IP "GType gperl_object_type_from_package (const char * package)" 4
.IX Item "GType gperl_object_type_from_package (const char * package)"
Inverse of \fBgperl_object_package_from_type()\fR,  returns 0 if \fIpackage\fR
is not registered.
.IP "\s-1SV\s0 * gperl_new_object (GObject * object, gboolean own)" 4
.IX Item "SV * gperl_new_object (GObject * object, gboolean own)"
Use this function to get the perl part of a GObject.  If \fIobject\fR
has never been seen by perl before, a new, empty perl object will
be created and added to a private key under \fIobject\fR's qdata.  If
\&\fIobject\fR already has a perl part, a new reference to it will be
created. The gobject + perl object together form a combined object that
is properly refcounted, i.e. both parts will stay alive as long as at
least one of them is alive, and only when both perl object and gobject are
no longer referenced will both be freed.
.Sp
The perl object will be blessed into the package corresponding to the GType
returned by calling \fBG_OBJECT_TYPE()\fR on \fIobject\fR; if that class has not
been registered via \fBgperl_register_object()\fR, this function will emit a
warning to that effect (with \fBwarn()\fR), and attempt to bless it into the
first known class in the object's ancestry.  Since Glib::Object is
already registered, you'll get a Glib::Object if you are lazy, and thus
this function can fail only if \fIobject\fR isn't descended from GObject,
in which case it croaks.  (In reality, if you pass a non-GObject to this
function, you'll be lucky if you don't get a segfault, as there's not
really a way to trap that.)  In practice these warnings can be unavoidable,
so you can use \fBgperl_object_set_no_warn_unreg_subclass()\fR to quell them
on a class-by-class basis.
.Sp
However, when perl code is calling a GObject constructor (any function
which returns a new GObject), call \fBgperl_new_object()\fR with \fIown\fR set to
\&\f(CW%TRUE\fR; this will cause the first matching sink function to be called
on the GObject to claim ownership of that object, so that it will be
destroyed when the perl object goes out of scope. The default sink func
is \fBg_object_unref()\fR; other types should supply the proper function;
e.g., GtkObject should use \fBgtk_object_sink()\fR here.
.Sp
Returns the blessed perl object, or #&PL_sv_undef if object was #NULL.
.IP "GObject * gperl_get_object (\s-1SV\s0 * sv)" 4
.IX Item "GObject * gperl_get_object (SV * sv)"
retrieve the GObject pointer from a Perl object.  Returns \s-1NULL\s0 if \fIsv\fR is not
linked to a GObject.
.Sp
Note, this one is not safe \*(-- in general you want to use
\&\fBgperl_get_object_check()\fR.
.IP "GObject * gperl_get_object_check (\s-1SV\s0 * sv, GType gtype);" 4
.IX Item "GObject * gperl_get_object_check (SV * sv, GType gtype);"
croaks if \fIsv\fR is undef or is not blessed into the package corresponding
to \fIgtype\fR.  use this for bringing parameters into xsubs from perl.
Returns the same as \fBgperl_get_object()\fR (provided it doesn't croak first).
.IP "\s-1SV\s0 * gperl_object_check_type (\s-1SV\s0 * sv, GType gtype)" 4
.IX Item "SV * gperl_object_check_type (SV * sv, GType gtype)"
Essentially the same as \fBgperl_get_object_check()\fR.
.Sp
This croaks if the types aren't compatible.
.IP "typedef GObject GObject_noinc" 4
.IX Item "typedef GObject GObject_noinc"
.PD 0
.IP "typedef GObject GObject_ornull" 4
.IX Item "typedef GObject GObject_ornull"
.IP "newSVGObject(obj)" 4
.IX Item "newSVGObject(obj)"
.IP "newSVGObject_noinc(obj)" 4
.IX Item "newSVGObject_noinc(obj)"
.IP "SvGObject(sv)" 4
.IX Item "SvGObject(sv)"
.IP "SvGObject_ornull(sv)" 4
.IX Item "SvGObject_ornull(sv)"
.PD
.SS "GValue"
.IX Subsection "GValue"
GValue is GLib's generic value container, and it is because of GValue that the
run time type handling of GObject parameters and GClosure marshaling can
function, and most usages of these functions will be from those two points.
.PP
Client code will run into uses for \fBgperl_sv_from_value()\fR and
\&\fBgperl_value_from_sv()\fR when trying to convert lists of parameters into GValue
arrays and the like.
.IP "gboolean gperl_value_from_sv (GValue * value, \s-1SV\s0 * sv)" 4
.IX Item "gboolean gperl_value_from_sv (GValue * value, SV * sv)"
set a \fIvalue\fR from a whatever is in \fIsv\fR.  \fIvalue\fR must be initialized 
so the code knows what kind of value to coerce out of \fIsv\fR.
.Sp
Return value is always \s-1TRUE\s0; if the code knows how to perform the conversion,
it croaks.  (The return value is for backward compatibility.) In reality,
this really ought to always succeed; a failed conversion should be considered
a bug or unimplemented code!
.IP "\s-1SV\s0 * gperl_sv_from_value (const GValue * value)" 4
.IX Item "SV * gperl_sv_from_value (const GValue * value)"
Coerce whatever is in \fIvalue\fR into a perl scalar and return it.
.Sp
Croaks if the code doesn't know how to perform the conversion.
.Sp
Might end up calling other Perl code.  So if you use this function in \s-1XS\s0 code
for a generic GType, make sure the stack pointer is set up correctly before the
call, and restore it after the call.
.SS "GClosure / GPerlClosure"
.IX Subsection "GClosure / GPerlClosure"
GPerlClosure is a wrapper around the gobject library's GClosure with
special handling for marshalling perl subroutines as callbacks.
This is specially tuned for use with GSignal and stuff like io watch,
timeout, and idle handlers.
.PP
For generic callback functions, which need parameters but do not get
registered with the type system, this is sometimes overkill.  See
GPerlCallback, below.
.IP "GClosure * gperl_closure_new (\s-1SV\s0 * callback, \s-1SV\s0 * data, gboolean swap)" 4
.IX Item "GClosure * gperl_closure_new (SV * callback, SV * data, gboolean swap)"
Create and return a new GPerlClosure.  \fIcallback\fR and \fIdata\fR will be copied
for storage; \fIcallback\fR must not be \s-1NULL.\s0  If \fIswap\fR is \s-1TRUE,\s0 \fIdata\fR will be
swapped with the instance during invocation (this is used to implement
\&\fBg_signal_connect_swapped()\fR).
.Sp
If compiled under a thread-enabled perl, the closure will be created and
marshaled in such a way as to ensure that the same interpreter which created
the closure will be used to invoke it.
.IP "GClosure * gperl_closure_new_with_marshaller (\s-1SV\s0 * callback, \s-1SV\s0 * data, gboolean swap, GClosureMarshal marshaller)" 4
.IX Item "GClosure * gperl_closure_new_with_marshaller (SV * callback, SV * data, gboolean swap, GClosureMarshal marshaller)"
Like \f(CW\*(C`gperl_closure_new\*(C'\fR, but uses a caller-supplied marshaller.  This is
provided for use in those sticky circumstances when you just can't do it 
any other way; in general, you want to use the default marshaller, which you
get if you provide \s-1NULL\s0 for \fImarshaller\fR.
.Sp
If you use you own marshaller, you need to take care of everything yourself,
including swapping the instance and data if \f(CW\*(C`GPERL_CLOSURE_SWAP_DATA
(closure)\*(C'\fR is true, calling \f(CW\*(C`gperl_run_exception_handlers\*(C'\fR if \s-1ERRSV\s0 is true
after invoking the perl sub, and ensuring that you properly use the
\&\f(CW\*(C`marshal_data\*(C'\fR parameter as the perl interpreter when \s-1PERL_IMPLICIT_CONTEXT\s0 is
defined.  See the implementation of the default marshaller,
\&\f(CW\*(C`gperl_closure_marshal\*(C'\fR, in Glib/GClosure.xs for inspiration.
.SS "GPerlCallback"
.IX Subsection "GPerlCallback"
generic callback functions usually get invoked directly, and are not passed
parameter lists as GValues.  we could very easily wrap up such generic
callbacks with something that converts the parameters to GValues and then
channels everything through GClosure, but this has two problems:  1) the above
implementation of GClosure is tuned to marshalling signal handlers, which
always have an instance object, and 2) it's more work than is strictly
necessary.
.PP
additionally, generic callbacks aren't always kind to the GClosure paradigm.
.PP
so, here's GPerlCallback, which is designed specifically to run generic
callback functions.  it reads parameters off the C stack and converts them into
parameters on the perl stack.  (it uses the GValue to/from \s-1SV\s0 mechanism to do
so, but doesn't allocate any temps on the heap.)  the callback object itself
stores the parameter type list.
.PP
unfortunately, since the data element is always last, but the number of
arguments is not known until we have the callback object, we can't pass
gperl_callback_invoke directly to functions requiring a callback; you'll have
to write a proxy callback which calls gperl_callback_invoke.
.IP "GPerlCallback * gperl_callback_new (\s-1SV\s0 * func, \s-1SV\s0 * data, gint n_params, GType param_types[], GType return_type)" 4
.IX Item "GPerlCallback * gperl_callback_new (SV * func, SV * data, gint n_params, GType param_types[], GType return_type)"
Create and return a new GPerlCallback; use gperl_callback_destroy when you are
finished with it.
.Sp
\&\fIfunc\fR: perl subroutine to call.  this \s-1SV\s0 will be copied, so don't worry about
reference counts.  must \fBnot\fR be #NULL.
.Sp
\&\fIdata\fR: scalar to pass to \fIfunc\fR in addition to all other arguments.  the \s-1SV\s0
will be copied, so don't worry about reference counts.  may be #NULL.
.Sp
\&\fIn_params\fR: the number of elements in \fIparam_types\fR.
.Sp
\&\fIparam_types\fR: the #GType of each argument that should be passed from the
invocation to \fIfunc\fR.  may be #NULL if \fIn_params\fR is zero, otherwise it must
be \fIn_params\fR elements long or nasty things will happen.  this array will be
copied; see \fBgperl_callback_invoke()\fR for how it is used.
.Sp
\&\fIreturn_type\fR: the #GType of the return value, or 0 if the function has void
return.
.IP "void gperl_callback_destroy (GPerlCallback * callback)" 4
.IX Item "void gperl_callback_destroy (GPerlCallback * callback)"
Dispose of \fIcallback\fR.
.IP "void gperl_callback_invoke (GPerlCallback * callback, GValue * return_value, ...)" 4
.IX Item "void gperl_callback_invoke (GPerlCallback * callback, GValue * return_value, ...)"
Marshall the variadic parameters according to \fIcallback\fR's param_types, and
then invoke \fIcallback\fR's subroutine in scalar context, or void context if the
return type is G_TYPE_VOID.  If \fIreturn_value\fR is not \s-1NULL,\s0 then value
returned (if any) will be copied into \fIreturn_value\fR.
.Sp
A typical callback handler would look like this:
.Sp
.Vb 10
\&  static gint
\&  real_c_callback (Foo * f, Bar * b, int a, gpointer data)
\&  {
\&          GPerlCallback * callback = (GPerlCallback*)data;
\&          GValue return_value = {0,};
\&          gint retval;
\&          g_value_init (&return_value, callback\->return_type);
\&          gperl_callback_invoke (callback, &return_value,
\&                                 f, b, a);
\&          retval = g_value_get_int (&return_value);
\&          g_value_unset (&return_value);
\&          return retval;
\&  }
.Ve
.SS "Exception Handling"
.IX Subsection "Exception Handling"
Like Event, Tk, and most other callback-using, event-based perl modules,
Glib traps exceptions that happen in callbacks.  To enable your code to
do something about these exceptions, Glib stores a list of exception
handlers which will be called on the trapped exceptions.  This is
completely distinct from the \f(CW$SIG\fR{_\|_DIE_\|_} mechanism provided by Perl
itself, for various reasons (not the least of which is that the Perl
docs and source code say that \f(CW$SIG\fR{_\|_DIE_\|_} is intended for running as
the program is about to exit, and other behaviors may be removed in the
future (apparently a source of much debate on p5p)).
.IP "int gperl_install_exception_handler (GClosure * closure)" 4
.IX Item "int gperl_install_exception_handler (GClosure * closure)"
Install a GClosure to be executed when \fBgperl_closure_invoke()\fR traps an
exception.  The closure should return boolean (\s-1TRUE\s0 if the handler should
remain installed) and expect to receive a perl scalar.  This scalar will be
a private copy of \s-1ERRSV\s0 ($@) which the handler can mangle to its heart's
content.
.Sp
The return value is an integer id tag that may be passed to
\&\fBgperl_removed_exception_handler()\fR.
.IP "void gperl_remove_exception_handler (guint tag)" 4
.IX Item "void gperl_remove_exception_handler (guint tag)"
Remove the exception handler identified by \fItag\fR, as returned by
\&\fBgperl_install_exception_handler()\fR.  If \fItag\fR cannot be found, this
does nothing.
.Sp
\&\s-1WARNING:\s0  this function locks a global data structure, so do \s-1NOT\s0 call
it recursively.  also, calling this from within an exception handler will
result in a deadlock situation.  if you want to remove your handler just
have it return \s-1FALSE.\s0
.IP "void gperl_run_exception_handlers (void)" 4
.IX Item "void gperl_run_exception_handlers (void)"
Invoke whatever exception handlers are installed.  You will need this if
you have written a custom marshaler.  Uses the value of the global \s-1ERRSV.\s0
.SS "GSignal"
.IX Subsection "GSignal"
.IP "void gperl_signal_set_marshaller_for (GType instance_type, char * detailed_signal, GClosureMarshal marshaller)" 4
.IX Item "void gperl_signal_set_marshaller_for (GType instance_type, char * detailed_signal, GClosureMarshal marshaller)"
You need this function only in rare cases, usually as workarounds for bad
signal parameter types or to implement writable arguments.  Use the given
\&\fImarshaller\fR to marshal all handlers for \fIdetailed_signal\fR on
\&\fIinstance_type\fR.  \f(CW\*(C`gperl_signal_connect\*(C'\fR will look for marshallers
registered here, and apply them to the GPerlClosure it creates for the given
callback being connected.
.Sp
A canonical form of \fIdetailed_signal\fR will be used so that \fImarshaller\fR is
applied for all possible spellings of the signal name.
.Sp
Use the helper macros in gperl_marshal.h to help write your marshaller
function.  That header, which is installed with the Glib module but not
#included through gperl.h, includes commentary and examples which you
should follow closely to avoid nasty bugs.  Use the Source, Luke.
.Sp
\&\s-1WARNING:\s0 Bend over backwards and turn your head around 720 degrees before
attempting to write a GPerlClosure marshaller without using the macros in
gperl_marshal.h.  If you absolutely cannot use those macros, be certain to
understand what those macros do so you can get the semantics correct, and
keep your code synchronized with them, or you may miss very important
bugfixes.
.IP "gulong gperl_signal_connect (\s-1SV\s0 * instance, char * detailed_signal, \s-1SV\s0 * callback, \s-1SV\s0 * data, GConnectFlags flags)" 4
.IX Item "gulong gperl_signal_connect (SV * instance, char * detailed_signal, SV * callback, SV * data, GConnectFlags flags)"
The actual workhorse behind GObject::signal_connect, the binding for
g_signal_connect, for use from within \s-1XS.\s0  This creates a \f(CW\*(C`GPerlClosure\*(C'\fR
wrapper for the given \fIcallback\fR and \fIdata\fR, and connects that closure to the
signal named \fIdetailed_signal\fR on the given GObject \fIinstance\fR.  This is only
good for named signals.  \fIflags\fR is the same as for \fBg_signal_connect()\fR.
\&\fIdata\fR may be \s-1NULL,\s0 but \fIcallback\fR must not be.
.Sp
Returns the id of the installed callback.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBperlapi\fR\|(1), \fBperlguts\fR\|(1), GLib Reference Manual, \fBGlib\fR\|(3pm), \fBGlib::devel\fR\|(3pm).
.SH "AUTHORS"
.IX Header "AUTHORS"
This file was automatically generated from the source code of the Glib module,
which is maintained by the gtk2\-perl team.
.SH "LICENSE"
.IX Header "LICENSE"
Copyright (C) 2003 by the gtk2\-perl team (see the file \s-1AUTHORS\s0 for the
full list)
.PP
This library is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Library General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at your option) any
later version.
.PP
This library is distributed in the hope that it will be useful, but \s-1WITHOUT ANY
WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A
PARTICULAR PURPOSE.\s0  See the \s-1GNU\s0 Library General Public License for more
details.
.PP
You should have received a copy of the \s-1GNU\s0 Library General Public License along
with this library; if not, write to the Free Software Foundation, Inc., 
51 Franklin Street, Fifth Floor, Boston, \s-1MA 02110\-1301 USA.\s0
