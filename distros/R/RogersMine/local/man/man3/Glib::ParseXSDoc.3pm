.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Glib::ParseXSDoc 3"
.TH Glib::ParseXSDoc 3 "2019-02-05" "perl v5.28.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Glib::ParseXSDoc \- Parse POD and XSub declarations from XS files.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the heart of an automatic \s-1API\s0 reference documentation system for
XS-based Perl modules.  \s-1FIXME\s0 more info here!!
.PP
\&\s-1FIXME\s0 document recognized \s-1POD\s0 directives and the output data structures
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "xsdocparse (@filenames)" 4
.IX Item "xsdocparse (@filenames)"
Parse xs files for xsub signatures and pod.  Writes to standard output a
data structure suitable for eval'ing in another Perl script, describing
all the stuff found.  The output contains three variables:
.RS 4
.ie n .IP "$xspods = \s-1ARRAYREF\s0" 4
.el .IP "\f(CW$xspods\fR = \s-1ARRAYREF\s0" 4
.IX Item "$xspods = ARRAYREF"
array of pods found in the verbatim C portion of the \s-1XS\s0 file, listed in the
order found.  These are assumed to pertain to the \s-1XS/C\s0 api, not the Perl api.
Any \f(CW\*(C`=for apidoc\*(C'\fR paragraphs following an \f(CW\*(C`=object\*(C'\fR paragraphs in the
verbatim sections are stripped (as are the \f(CW\*(C`=object\*(C'\fR paragraphs), and will
appear instead in \f(CW\*(C`$data\->{$package}{pods}\*(C'\fR.
.ie n .IP "$data = \s-1HASHREF\s0" 4
.el .IP "\f(CW$data\fR = \s-1HASHREF\s0" 4
.IX Item "$data = HASHREF"
big hash keyed by package name (as found in the \s-1MODULE\s0 line), containing under
each key a hash with all the xsubs and pods in that package, in the order
found.  Packages are consolidated across multiple files.
.RE
.RS 4
.Sp
\&\s-1FYI,\s0 this creates a new parser and calls \f(CW\*(C`parse_file\*(C'\fR on it for each
input filename; then calls \f(CW\*(C`swizzle_pods\*(C'\fR to ensure that any
\&\f(CW\*(C`=for apidoc name\*(C'\fR pods are matched up with their target xsubs; and
finally calls Data::Dumper to write the data to stdout.  So, if you want
to get finer control over how the output is created, or keep all the data
in-process, now you know how.  :\-)
.RE
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$Glib::ParseXSDoc::verbose" 4
.el .IP "\f(CW$Glib::ParseXSDoc::verbose\fR" 4
.IX Item "$Glib::ParseXSDoc::verbose"
If true, this causes the parser to be verbose.
.ie n .IP "$parser = Glib::ParseXSDoc\->new" 4
.el .IP "\f(CW$parser\fR = Glib::ParseXSDoc\->new" 4
.IX Item "$parser = Glib::ParseXSDoc->new"
Create a new xsub parser.
.ie n .IP "string = $parser\->package" 4
.el .IP "string = \f(CW$parser\fR\->package" 4
.IX Item "string = $parser->package"
Get the current package name.  Falls back to the module name.  Will be undef
if the parser hasn't reached the first \s-1MODULE\s0 line.
.ie n .IP "\s-1HASHREF\s0 = $parser\->pkgdata" 4
.el .IP "\s-1HASHREF\s0 = \f(CW$parser\fR\->pkgdata" 4
.IX Item "HASHREF = $parser->pkgdata"
The data hash corresponding to the current package, honoring the most recently
encountered \f(CW\*(C`=for object\*(C'\fR directive.  Ensures that it exists.
Returns a reference to the member of the main data structure, so modifications
are permanent and useful.
.ie n .IP "$parser\->parse_file (filename)" 4
.el .IP "\f(CW$parser\fR\->parse_file (filename)" 4
.IX Item "$parser->parse_file (filename)"
Parse one xs file.  Stores all the collected data in \fI\f(CI$parser\fI\fR's internal
data structures.
.ie n .IP "$parser\->swizzle_pods" 4
.el .IP "\f(CW$parser\fR\->swizzle_pods" 4
.IX Item "$parser->swizzle_pods"
Match \f(CW\*(C`=for apidoc\*(C'\fR pods to xsubs.
.ie n .IP "$parser\->preprocess_pods" 4
.el .IP "\f(CW$parser\fR\->preprocess_pods" 4
.IX Item "$parser->preprocess_pods"
Honor the \f(CW\*(C`_\|_hide_\|_\*(C'\fR and \f(CW\*(C`_\|_function_\|_\*(C'\fR directives in \f(CW\*(C`=for apidoc\*(C'\fR lines.
.Sp
We look for the strings anywhere, but you'll typically have it at the end of
the line, e.g.:
.Sp
.Vb 2
\&  =for apidoc symname _\|_hide_\|_        for detached blocks
\&  =for apidoc _\|_hide_\|_                for attached blocks
\&
\&  =for apidoc symname _\|_function_\|_    for functions rather than methods
\&  =for apidoc _\|_function_\|_            for functions rather than methods
.Ve
.ie n .IP "bool = $parser\->is_module_line ($line)" 4
.el .IP "bool = \f(CW$parser\fR\->is_module_line ($line)" 4
.IX Item "bool = $parser->is_module_line ($line)"
Analyze \fI\f(CI$line\fI\fR to see if it contains an \s-1XS MODULE\s0 directive.  If so, returns
true after setting the \fI\f(CI$parser\fI\fR's \fImodule\fR, \fIpackage\fR, and \fIprefix\fR
accordingly.
.ie n .IP "$pod = $parser\->slurp_pod_paragraph ($firstline, $term_regex=/^=cut\es*/)" 4
.el .IP "\f(CW$pod\fR = \f(CW$parser\fR\->slurp_pod_paragraph ($firstline, \f(CW$term_regex\fR=/^=cut\es*/)" 4
.IX Item "$pod = $parser->slurp_pod_paragraph ($firstline, $term_regex=/^=cuts*/)"
Slurp up \s-1POD\s0 lines from \fI\f(CI$filehandle\fI\fR from here to the next
\&\fI\f(CI$term_regex\fI\fR or \s-1EOF.\s0  Since you probably already read a
line to determine that we needed to start a pod, you can pass
that first line to be included.
.ie n .IP "$xsub = $parser\->parse_xsub (\e@lines)" 4
.el .IP "\f(CW$xsub\fR = \f(CW$parser\fR\->parse_xsub (\e@lines)" 4
.IX Item "$xsub = $parser->parse_xsub (@lines)"
.PD 0
.ie n .IP "$xsub = $parser\->parse_xsub (@lines)" 4
.el .IP "\f(CW$xsub\fR = \f(CW$parser\fR\->parse_xsub (@lines)" 4
.IX Item "$xsub = $parser->parse_xsub (@lines)"
.PD
Parse an xsub header, in the form of a list of lines,
into a data structure describing the xsub.  That includes
pulling out the argument types, aliases, and code type.
.Sp
Without artificial intelligence, we cannot reliably 
determine anything about the types or number of parameters
returned from xsubs with \s-1PPCODE\s0 bodies.
.Sp
\&\s-1OUTLIST\s0 parameters are pulled from the args list and put
into an \*(L"outlist\*(R" key.  \s-1IN_OUTLIST\s0 parameters are put into
both.
.Sp
Data type names are not mangled at all.
.Sp
Note that the method can take either a list of lines or a reference to a
list of lines.  The flat list form is provided for compatibility; the
reference form is preferred, to avoid duplicating a potentially large list
of strings.
.ie n .IP "$parser\->clean_out_empty_pods" 4
.el .IP "\f(CW$parser\fR\->clean_out_empty_pods" 4
.IX Item "$parser->clean_out_empty_pods"
Looks through the data member of the parser and removes any keys (and
associated values) when no pod, enums, and xsubs exist for the package.
.SH "AUTHOR"
.IX Header "AUTHOR"
muppet <scott at asofyet dot org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2003, 2004 by muppet
.PP
This library is free software; you can redistribute it and/or modify it under
the terms of the \s-1GNU\s0 Library General Public License as published by the Free
Software Foundation; either version 2.1 of the License, or (at your option) any
later version.
.PP
This library is distributed in the hope that it will be useful, but \s-1WITHOUT ANY
WARRANTY\s0; without even the implied warranty of \s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A
PARTICULAR PURPOSE.\s0  See the \s-1GNU\s0 Library General Public License for more
details.
.PP
You should have received a copy of the \s-1GNU\s0 Library General Public License along
with this library; if not, write to the Free Software Foundation, Inc., 
51 Franklin Street, Fifth Floor, Boston, \s-1MA 02110\-1301 USA.\s0
