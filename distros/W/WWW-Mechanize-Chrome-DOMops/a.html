<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>WWW::Mechanize::Chrome::DOMops - Operations on the DOM loaded in Chrome</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:andreas@piglet.(none)" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#EXPORT">EXPORT</a></li>
  <li><a href="#SUBROUTINES-METHODS">SUBROUTINES/METHODS</a>
    <ul>
      <li><a href="#find-params">find($params)</a></li>
      <li><a href="#zap-params">zap($params)</a></li>
      <li><a href="#WWW::Mechanize::Chrome::DOMops::VERBOSE_DOMops">$WWW::Mechanize::Chrome::DOMops::VERBOSE_DOMops</a></li>
    </ul>
  </li>
  <li><a href="#ELEMENT-SELECTORS">ELEMENT SELECTORS</a></li>
  <li><a href="#CREATING-THE-MECH-OBJECT">CREATING THE MECH OBJECT</a></li>
  <li><a href="#DEPENDENCIES">DEPENDENCIES</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#CODING-CONDITIONS">CODING CONDITIONS</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#DEDICATIONS">DEDICATIONS</a></li>
  <li><a href="#ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</a></li>
  <li><a href="#LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>WWW::Mechanize::Chrome::DOMops - Operations on the DOM loaded in Chrome</p>

<h1 id="VERSION">VERSION</h1>

<p>Version 0.03</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>This module provides a set of tools to operate on the DOM of the provided <a>WWW::Mechanize::Chrome</a> object. Currently, supported operations are:</p>

<ul>

<li><p><code>find()</code> : finds HTML elements,</p>

</li>
<li><p><code>zap()</code> : deletes HTML elements.</p>

</li>
</ul>

<p>Both <code>find()</code> and <code>zap()</code> return some information from each match and its descendents (like <code>tag</code>, <code>id</code> etc.). This information can be tweaked by the caller. <code>find()</code> and <code>zap()</code> optionally execute javascript code on each match and its descendents and can return back data.</p>

<p>The selection of the HTML elements in the DOM can be done in various ways:</p>

<ul>

<li><p>by <b>CSS selector</b>,</p>

</li>
<li><p>by <b>tag</b>,</p>

</li>
<li><p>by <b>class</b>.</p>

</li>
<li><p>by <b>id</b>,</p>

</li>
<li><p>by <b>name</b>.</p>

</li>
</ul>

<p>There is more information about this in section <a href="#ELEMENT-SELECTORS">&quot;ELEMENT SELECTORS&quot;</a>.</p>

<p>Here are some usage scenaria:</p>

<pre><code>    use WWW::Mechanize::Chrome::DOMops qw/zap find VERBOSE_DOMops/;

    # increase verbosity: 0, 1, 2, 3
    $WWW::Mechanize::Chrome::VERBOSE_DOMops = 3;

    # First, create a mech object and load a URL on it
    # Note: you need google-chrome binary installed in your system!
    my $mechobj = WWW::Mechanize::Chrome-&gt;new();
    $mechobj-&gt;get(&#39;https://www.bbbbbbbbb.com&#39;);

    # find elements in the DOM, select by id, tag, name, or 
    # by CSS selector.
    my $ret = find({
       &#39;mech-obj&#39; =&gt; $mechobj,
       # find elements whose class is in the provided
       # scalar class name or array of class names
       &#39;element-class&#39; =&gt; [&#39;slanted-paragraph&#39;, &#39;class2&#39;, &#39;class3&#39;],
       # *OR* their tag is this:
       &#39;element-tag&#39; =&gt; &#39;p&#39;,
       # *OR* their name is this:
       &#39;element-name&#39; =&gt; [&#39;aname&#39;, &#39;name2&#39;],
       # *OR* their id is this:
       &#39;element-id&#39; =&gt; [&#39;id1&#39;, &#39;id2&#39;],
       # *OR* just provide a CSS selector and get done with it already
       # the best choice
       &#39;element-cssselector&#39; =&gt; &#39;a-css-selector&#39;,
       # specifies that we should use the union of the above sets
       # hence the *OR* in above comment
       &#39;||&#39; =&gt; 1,
       # this says to find all elements whose class
       # is such-and-such AND element tag is such-and-such
       # &#39;&amp;&amp;&#39; =&gt; 1 means to calculate the INTERSECTION of all
       # individual matches.

       # build the information sent back from each match
       &#39;element-information-from-matched&#39; =&gt; &lt;&lt;&#39;EOJ&#39;,
// begin JS code to extract information from each match and return it
// back as a hash
const r = htmlElement.hasAttribute(&quot;role&quot;)
  ? htmlElement.getAttribute(&quot;role&quot;) : &quot;&lt;no role present&gt;&quot;
;
return {&quot;tag&quot; : htmlElement.tagName, &quot;id&quot; : htmlElement.id, &quot;role&quot; : r};
EOJ
       # optionally run javascript code on all those elements matched
       &#39;find-cb-on-matched&#39; =&gt; [
         {
           &#39;code&#39; =&gt;&lt;&lt;&#39;EOJS&#39;,
  // the element to operate on is &#39;htmlElement&#39;
  console.log(&quot;operating on this element &quot;+htmlElement.tagName);
  // this is returned back in the results of find() under
  // key &quot;cb-results&quot;-&gt;&quot;find-cb-on-matched&quot;
  return 1;
EOJS
           &#39;name&#39; =&gt; &#39;func1&#39;
         }, {...}
       ],
       # optionally run javascript code on all those elements
       # matched AND THEIR CHILDREN too!
       &#39;find-cb-on-matched-and-their-children&#39; =&gt; [
         {
           &#39;code&#39; =&gt;&lt;&lt;&#39;EOJS&#39;,
  // the element to operate on is &#39;htmlElement&#39;
  console.log(&quot;operating on this element &quot;+htmlElement.tagName);
  // this is returned back in the results of find() under
  // key &quot;cb-results&quot;-&gt;&quot;find-cb-on-matched&quot; notice the complex data
  return {&quot;abc&quot;:&quot;123&quot;,{&quot;xyz&quot;:[1,2,3]}};
EOJS
           &#39;name&#39; =&gt; &#39;func2&#39;
         }
       ],
       # optionally ask it to create a valid id for any HTML
       # element returned which does not have an id.
       # The text provided will be postfixed with a unique
       # incrementing counter value 
       &#39;insert-id-if-none&#39; =&gt; &#39;_prefix_id&#39;,
       # or ask it to randomise that id a bit to avoid collisions
       &#39;insert-id-if-none-random&#39; =&gt; &#39;_prefix_id&#39;,

       # optionally, also output the javascript code to a file for debugging
       &#39;js-outfile&#39; =&gt; &#39;output.js&#39;,
    });


    # Delete an element from the DOM
    $ret = zap({
       &#39;mech-obj&#39; =&gt; $mechobj,
       &#39;element-id&#39; =&gt; &#39;paragraph-123&#39;
    });

    # Mass murder:
    $ret = zap({
       &#39;mech-obj&#39; =&gt; $mechobj,
       &#39;element-tag&#39; =&gt; [&#39;div&#39;, &#39;span&#39;, &#39;p&#39;],
       &#39;||&#39; =&gt; 1, # the union of all those matched with above criteria
    });

    # error handling
    if( $ret-&gt;{&#39;status&#39;} &lt; 0 ){ die &quot;error: &quot;.$ret-&gt;{&#39;message&#39;} }
    # status of -3 indicates parameter errors,
    # -2 indicates that eval of javascript code inside the mech object
    # has failed (syntax errors perhaps, which could have been introduced
    # by user-specified callback
    # -1 indicates that javascript code executed correctly but
    # failed somewhere in its logic.

    print &quot;Found &quot; . $ret-&gt;{&#39;status&#39;} . &quot; matches which are: &quot;
    # ... results are in $ret-&gt;{&#39;found&#39;}-&gt;{&#39;first-level&#39;}
    # ... and also in $ret-&gt;{&#39;found&#39;}-&gt;{&#39;all-levels&#39;}
    # the latter contains a recursive list of those
    # found AND ALL their children</code></pre>

<h1 id="EXPORT">EXPORT</h1>

<p>the sub to find element(s) in the DOM</p>

<pre><code>find()</code></pre>

<p>the sub to delete element(s) from the DOM</p>

<pre><code>zap()</code></pre>

<p>and the flag to denote verbosity (default is 0, no verbosity)</p>

<pre><code>$WWW::Mechanize::Chrome::DOMops::VERBOSE_DOMops</code></pre>

<h1 id="SUBROUTINES-METHODS">SUBROUTINES/METHODS</h1>

<h2 id="find-params">find($params)</h2>

<p>It finds HTML elements in the DOM currently loaded on the parameters-specified <a>WWW::Mechanize::Chrome</a> object. The parameters are:</p>

<ul>

<li><p><code>mech-obj</code> : user must supply a <a>WWW::Mechanize::Chrome</a>, this is required. See section <a href="#CREATING-THE-MECH-OBJECT">&quot;CREATING THE MECH OBJECT&quot;</a> for an example of creating the mech object with some parameters (which work for me) and javascript console output propagated on to perl&#39;s output.</p>

</li>
<li><p><code>element-information-from-matched</code> : optional javascript code to be run on each HTML element matched in order to construct the information data whih is returned back. If none specified the following default will be used, which returns tagname and id:</p>

<pre><code>// the matched element is provided in htmlElement
return {&quot;tag&quot; : htmlElement.tagName, &quot;id&quot; : htmlElement.id};</code></pre>

<p>Basically the code is expected to be the <b>body of a function</b> which accepts one parameter: <code>htmlElement</code> (that is the element matched). That means it <b>must not have</b> the function preamble (function name, signature, etc.). Neither it must have the postamble, which is the end-block curly bracket. This piece of code <b>must return a HASH</b>. The code can thow exceptions which will be caught (because the code is run within a try-catch block) and the error message will be propagated to the perl code with status of -1.</p>

</li>
<li><p><code>insert-id-if-none</code> : some HTML elements simply do not have an id (e.g. <code>&lt;p</code>&gt;). If any of these elements is matched, its tag and its id (empty string) will be returned. By specifying this parameter (as a string, e.g. <code>_replacing_empty_ids</code>) all such elements matched will have their id set to <code>_replacing_empty_ids_X</code> where X is an incrementing counter value starting from a random number. By running <code>find()</code> more than once on the same on the same DOM you are risking having the same ID. So provide a different prefix every time. Or use <code>insert-id-if-none-random</code>, see below.</p>

</li>
<li><p><code>insert-id-if-none-random</code> : each time <code>find()</code> is called a new random base id will be created formed by the specified prefix (as with <code>insert-id-if-none</code>) plus a long random string plus the incrementing counter, as above. This is supposed to be better at avoiding collisions but it can not guarantee it. If you are setting <code>rand()</code>&#39;s seed to the same number before you call <code>find()</code> then you are guaranteed to have collisions.</p>

</li>
<li><p><code>find-cb-on-matched</code> : an array of user-specified javascript code to be run on each element matched in the order the elements are returned and in the order of the javascript code in the specified array. Each item of the array is a hash with keys <code>code</code> and <code>name</code>. The former contains the code to be run assuming that the html element to operate on is named <code>htmlElement</code>. The code must end with a <code>return</code> statement which will be recorded and returned back to perl code. The code can thow exceptions which will be caught (because the callback is run within a try-catch block) and the error message will be propagated to the perl code with status of -1. Basically the code is expected to be the <b>body of a function</b> which accepts one parameter: <code>htmlElement</code> (that is the element matched). That means it <b>must not have</b> the function preamble (function name, signature, etc.). Neither it must have the postamble, which is the end-block curly bracket.</p>

<p>Key <code>name</code> is just for making this process more descriptive and will be printed on log messages and returned back with the results. <code>name</code> can contain any characters. Here is an example:</p>

<pre><code>&#39;find-cb-on-matched&#39; : [
  {
    # this returns a complex data type
    &#39;code&#39; =&gt; &#39;console.log(&quot;found id &quot;+htmlElement.id); return {&quot;a&quot;:&quot;1&quot;,&quot;b&quot;:&quot;2&quot;};&#39;
    &#39;name&#39; =&gt; &#39;func1&#39;
  },
  {
    &#39;code&#39; =&gt; &#39;console.log(&quot;second func: found id &quot;+htmlElement.id); return 1;&#39;
    &#39;name&#39; =&gt; &#39;func2&#39;
  },
]</code></pre>

</li>
<li><p><code>find-cb-on-matched-and-their-children</code> : exactly the same as <code>find-cb-on-matched</code> but it operates on all those HTML elements matched and also all their children and children of children etc.</p>

</li>
<li><p><code>js-outfile</code> : optionally save the javascript code (which is evaluated within the mech object) to a file.</p>

</li>
<li><p><code>element selectors</code> are covered in section <a href="#ELEMENT-SELECTORS">&quot;ELEMENT SELECTORS&quot;</a>.</p>

</li>
</ul>

<p><b>JAVASCRIPT HELPERS</b></p>

<p>There is one javascript function available to all user-specified callbacks:</p>

<ul>

<li><p><code>getAllChildren(anHtmlElement)</code> : it returns back an array of HTML elements which are the children (at any depth) of the given <code>anHtmlElement</code>.</p>

</li>
</ul>

<p><b>RETURN VALUE</b>:</p>

<p>The returned value is a hashref with at least a <code>status</code> key which is greater or equal to zero in case of success and denotes the number of matched HTML elements. Or it is -3, -2 or -1 in case of errors:</p>

<ul>

<li><p><code>-3</code> : there is an error with the parameters passed to this sub.</p>

</li>
<li><p><code>-2</code> : there is a syntax error in the javascript code to be evaluated by the mech object with something like <code>$mech_obj-</code>eval()&gt;. Most likely this syntax error is with user-specified callback code. Note that all the javascript code to be evaluated is dumped to stderr by increasing the verbosity. But also it can be saved to a local file for easier debugging by supplying the <code>js-outfile</code> parameter to <code>find()</code> or <code>zap()</code>.</p>

</li>
<li><p><code>-1</code> : there is a logical error while running the javascript code. For example a division by zero etc. This can be both in the callback code as well as in the internal javascript code for edge cases not covered by my tests. Please report these. Note that all the javascript code to be evaluated is dumped to stderr by increasing the verbosity. But also it can be saved to a local file for easier debugging by supplying the <code>js-outfile</code> parameter to <code>find()</code> or <code>zap()</code>.</p>

</li>
</ul>

<p>If <code>status</code> is not negative, then this is success and its value denotes the number of matched HTML elements. Which can be zero or more. In this case the returned hash contains this</p>

<pre><code>&quot;found&quot; =&gt; {
  &quot;first-level&quot; =&gt; [
    {
      &quot;tag&quot; =&gt; &quot;NAV&quot;,
      &quot;id&quot; =&gt; &quot;nav-id-1&quot;
    }
  ],
  &quot;all-levels&quot; =&gt; [
    {
      &quot;tag&quot; =&gt; &quot;NAV&quot;,
      &quot;id&quot; =&gt; &quot;nav-id-1&quot;
    },
    {
      &quot;id&quot; =&gt; &quot;li-id-2&quot;,
      &quot;tag&quot; =&gt; &quot;LI&quot;
    },
  ]
}</code></pre>

<p>Key <code>first-level</code> contains those items matched directly while key <code>all-levels</code> contains those matched directly as well as those matched because they are descendents (direct or indirect) of each matched element.</p>

<p>Each item representing a matched HTML element has two fields: <code>tag</code> and <code>id</code>. Beware of missing <code>id</code> or use <code>insert-id-if-none</code> or <code>insert-id-if-none-random</code> to fill in the missing ids.</p>

<p>If <code>find-cb-on-matched</code> or <code>find-cb-on-matched-and-their-children</code> were specified, then the returned result contains this additional data:</p>

<pre><code>&quot;cb-results&quot; =&gt; {
   &quot;find-cb-on-matched&quot; =&gt; [
     [
       {
         &quot;name&quot; =&gt; &quot;func1&quot;,
         &quot;result&quot; =&gt; {
           &quot;a&quot; =&gt; 1,
           &quot;b&quot; =&gt; 2
         }
       }
     ],
     [
       {
         &quot;result&quot; =&gt; 1,
         &quot;name&quot; =&gt; &quot;func2&quot;
       }
     ]
   ],
   &quot;find-cb-on-matched-and-their-children&quot; =&gt; ...
 },</code></pre>

<p><code>find-cb-on-matched</code> and/or <code>find-cb-on-matched-and-their-children</code> will be present depending on whether corresponding value in the input parameters was specified or not. Each of these contain the return result for running the callback on each HTML element in the same order as returned under key <code>found</code>.</p>

<p>HTML elements allows for missing <code>id</code>. So field <code>id</code> can be empty unless caller set the <code>insert-id-if-none</code> input parameter which will create a unique id for each HTML element matched but with missing id. These changes will be saved in the DOM. When this parameter is specified, the returned HTML elements will be checked for duplicates because now all of them have an id field. Therefore, if you did not specify this parameter results may contain duplicate items and items with empty id field. If you did specify this parameter then some elements of the DOM (those matched by our selectors) will have their missing id created and saved in the DOM.</p>

<p>Another implication of using this parameter when running it twice or more with the same value is that you can get same ids. So, always supply a different value to this parameter if run more than once on the same DOM.</p>

<h2 id="zap-params">zap($params)</h2>

<p>It removes HTML element(s) from the DOM currently loaded on the parameters-specified <a>WWW::Mechanize::Chrome</a> object. The params are exactly the same as with <a href="#find-params">&quot;find($params)&quot;</a> except that <code>insert-id-if-none</code> is ignored.</p>

<p><code>zap()</code> is implemented as a <code>find()</code> with an additional callback for all elements matched in the first level (not their children) as:</p>

<pre><code>&#39;find-cb-on-matched&#39; =&gt; {
  &#39;code&#39; =&gt; &#39;htmlElement.parentNode.removeChild(htmlElement); return 1;&#39;,
  &#39;name&#39; =&gt; &#39;_thezapper&#39;
 };</code></pre>

<p><b>RETURN VALUE</b>:</p>

<p>Return value is exactly the same as with <a href="#find-params">&quot;find($params)&quot;</a></p>

<h2 id="WWW::Mechanize::Chrome::DOMops::VERBOSE_DOMops">$WWW::Mechanize::Chrome::DOMops::VERBOSE_DOMops</h2>

<p>Set this upon loading the module to <code>0, 1, 2, 3</code> to increase verbosity. <code>0</code> implies no verbosity.</p>

<h1 id="ELEMENT-SELECTORS">ELEMENT SELECTORS</h1>

<p><code>Element selectors</code> are how one selects HTML elements from the DOM. There are 5 ways to select HTML elements: by id, class, tag, name or via a CSS selector. Multiple selectors can be specified as well as multiple criteria in each selector (e.g. multiple class names in a <code>element-class</code> selector). The results from each selector are combined into a list of unique HTML elements (BEWARE of missing id fields) by means of UNION or INTERSECTION of the individual matches</p>

<p>These are the valid selectors:</p>

<ul>

<li><p><code>element-class</code> : find DOM elements matching this class name</p>

</li>
<li><p><code>element-tag</code> : find DOM elements matching this element tag</p>

</li>
<li><p><code>element-id</code> : find DOM element matching this element id</p>

</li>
<li><p><code>element-name</code> : find DOM element matching this element name</p>

</li>
<li><p><code>element-cssselector</code> : find DOM element matching this CSS selector</p>

</li>
</ul>

<p>And one of these two must be used to combine the results into a final list</p>

<dl>

<dt id="Intersection.-When-set-to-1-the-result-is-the-intersection-of-all-individual-results.-Meaning-that-an-element-will-make-it-to-the-final-list-if-it-was-matched-by-every-selector-specified.-This-is-the-default"><code>&amp;&amp;</code> : Intersection. When set to 1 the result is the intersection of all individual results. Meaning that an element will make it to the final list if it was matched by every selector specified. This is the default.</dt>
<dd>

</dd>
<dt id="Union.-When-set-to-1-the-result-is-the-union-of-all-individual-results.-Meaning-that-an-element-will-make-it-to-the-final-list-if-it-was-matched-by-at-least-one-of-the-selectors-specified"><code>||</code> : Union. When set to 1 the result is the union of all individual results. Meaning that an element will make it to the final list if it was matched by at least one of the selectors specified.</dt>
<dd>

</dd>
</dl>

<h1 id="CREATING-THE-MECH-OBJECT">CREATING THE MECH OBJECT</h1>

<p>The mech (<a>WWW::Mechanize::Chrome</a>) object must be supplied to the functions in this module. It must be created by the caller. This is how I do it:</p>

<pre><code>use WWW::Mechanize::Chrome;
use Log::Log4perl qw(:easy);
Log::Log4perl-&gt;easy_init($ERROR);

my %default_mech_params = (
    headless =&gt; 1,
#   log =&gt; $mylogger,
    launch_arg =&gt; [
            &#39;--window-size=600x800&#39;,
            &#39;--password-store=basic&#39;, # do not ask me for stupid chrome account password
#           &#39;--remote-debugging-port=9223&#39;,
#           &#39;--enable-logging&#39;, # see also log above
            &#39;--disable-gpu&#39;,
            &#39;--no-sandbox&#39;,
            &#39;--ignore-certificate-errors&#39;,
            &#39;--disable-background-networking&#39;,
            &#39;--disable-client-side-phishing-detection&#39;,
            &#39;--disable-component-update&#39;,
            &#39;--disable-hang-monitor&#39;,
            &#39;--disable-save-password-bubble&#39;,
            &#39;--disable-default-apps&#39;,
            &#39;--disable-infobars&#39;,
            &#39;--disable-popup-blocking&#39;,
    ],
);

my $mech_obj = eval {
    WWW::Mechanize::Chrome-&gt;new(%default_mech_params)
};
die $@ if $@;

# This transfers all javascript code&#39;s console.log(...)
# messages to perl&#39;s warn()
# we need to keep $console var in scope!
my $console = $mech_obj-&gt;add_listener(&#39;Runtime.consoleAPICalled&#39;, sub {
      warn
          &quot;js console: &quot;
        . join &quot;, &quot;,
          map { $_-&gt;{value} // $_-&gt;{description} }
          @{ $_[0]-&gt;{params}-&gt;{args} };
    })
;

# and now fetch a page
my $URL = &#39;...&#39;;
my $retmech = $mech_obj-&gt;get($URL);
die &quot;failed to fetch $URL&quot; unless defined $retmech;
$mech_obj-&gt;sleep(1); # let it settle
# now the mech object has loaded the URL and has a DOM hopefully.
# You can pass it on to find() or zap() to operate on the DOM.</code></pre>

<h1 id="DEPENDENCIES">DEPENDENCIES</h1>

<p>This module depends on <a>WWW::Mechanize::Chrome</a> which, in turn, depends on the <code>google-chrome</code> executable be installed on the host computer. See <a>WWW::Mechanize::Chrome::Install</a> on how to install the executable.</p>

<p>Test scripts (which create there own mech object) will detect the absence of <code>google-chrome</code> binary and exit gracefully, meaning the test passes. But with a STDERR message to the user. Who will hopefully notice it and proceed to <code>google-chrome</code> installation. In any event, this module will be installed with or without <code>google-chrome</code>.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Andreas Hadjiprocopis, <code>&lt;bliako at cpan.org&gt;</code></p>

<h1 id="CODING-CONDITIONS">CODING CONDITIONS</h1>

<p>This code was written under extreme climate conditions of 44 Celsius. Keep packaging those vegs in kilos of plastic wrappers, keep obsolidating our perfectly good hardware, keep inventing new consumer needs and brainwash them down our throats, in short <b>Crack Deep the Roof Beam, Capitalism</b>.</p>

<h1 id="BUGS">BUGS</h1>

<p>Please report any bugs or feature requests to <code>bug-www-mechanize-chrome-domops at rt.cpan.org</code>, or through the web interface at <a href="https://rt.cpan.org/NoAuth/ReportBug.html?Queue=WWW-Mechanize-Chrome-DOMops">https://rt.cpan.org/NoAuth/ReportBug.html?Queue=WWW-Mechanize-Chrome-DOMops</a>. I will be notified, and then you&#39;ll automatically be notified of progress on your bug as I make changes.</p>

<h1 id="SUPPORT">SUPPORT</h1>

<p>You can find documentation for this module with the perldoc command.</p>

<pre><code>perldoc WWW::Mechanize::Chrome::DOMops</code></pre>

<p>You can also look for information at:</p>

<ul>

<li><p>RT: CPAN&#39;s request tracker (report bugs here)</p>

<p><a href="https://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW-Mechanize-Chrome-DOMops">https://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW-Mechanize-Chrome-DOMops</a></p>

</li>
<li><p>AnnoCPAN: Annotated CPAN documentation</p>

<p><a href="http://annocpan.org/dist/WWW-Mechanize-Chrome-DOMops">http://annocpan.org/dist/WWW-Mechanize-Chrome-DOMops</a></p>

</li>
<li><p>CPAN Ratings</p>

<p><a href="https://cpanratings.perl.org/d/WWW-Mechanize-Chrome-DOMops">https://cpanratings.perl.org/d/WWW-Mechanize-Chrome-DOMops</a></p>

</li>
<li><p>Search CPAN</p>

<p><a href="https://metacpan.org/release/WWW-Mechanize-Chrome-DOMops">https://metacpan.org/release/WWW-Mechanize-Chrome-DOMops</a></p>

</li>
</ul>

<h1 id="DEDICATIONS">DEDICATIONS</h1>

<p>Almaz</p>

<h1 id="ACKNOWLEDGEMENTS">ACKNOWLEDGEMENTS</h1>

<p><a>CORION</a> for publishing <a>WWW::Mechanize::Chrome</a> and all its contributors.</p>

<h1 id="LICENSE-AND-COPYRIGHT">LICENSE AND COPYRIGHT</h1>

<p>Copyright 2019 Andreas Hadjiprocopis.</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the the Artistic License (2.0). You may obtain a copy of the full license at:</p>

<p><a href="http://www.perlfoundation.org/artistic_license_2_0">http://www.perlfoundation.org/artistic_license_2_0</a></p>

<p>Any use, modification, and distribution of the Standard or Modified Versions is governed by this Artistic License. By using, modifying or distributing the Package, you accept this license. Do not use, modify, or distribute the Package, if you do not accept this license.</p>

<p>If your Modified Version has been derived from a Modified Version made by someone other than you, you are nevertheless required to ensure that your Modified Version complies with the requirements of this license.</p>

<p>This license does not grant you the right to use any trademark, service mark, tradename, or logo of the Copyright Holder.</p>

<p>This license includes the non-exclusive, worldwide, free-of-charge patent license to make, have made, use, offer to sell, sell, import and otherwise transfer the Package with respect to any patent claims licensable by the Copyright Holder that are necessarily infringed by the Package. If you institute patent litigation (including a cross-claim or counterclaim) against any party alleging that the Package constitutes direct or contributory patent infringement, then this Artistic License to you shall terminate on the date that such litigation is filed.</p>

<p>Disclaimer of Warranty: THE PACKAGE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS &quot;AS IS&#39; AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES. THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT ARE DISCLAIMED TO THE EXTENT PERMITTED BY YOUR LOCAL LAW. UNLESS REQUIRED BY LAW, NO COPYRIGHT HOLDER OR CONTRIBUTOR WILL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING IN ANY WAY OUT OF THE USE OF THE PACKAGE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>


</body>

</html>


