.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Python 3"
.TH Python 3 "2021-04-05" "perl v5.32.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Python \- Encapuslate python objects
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Python qw(getattr list);
\&
\&    # constructors
\&    $list = list(1..10);
\&
\&    # accessor
\&    if (my $foo = getattr($o, "foo")) {
\&        # ...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Python\*(C'\fR is an interpreted, interactive, object-oriented programming
language programming language created by Guido van Rossum
(www.python.org).  This manpage describe the perl interface to python
data managed by an embedded Python interpreter.
.PP
The \f(CW\*(C`Python::\*(C'\fR namespace contain various functions to construct,
modify and examine python objects.  Python objects themselves are
wrapped up in instances of the perl class \f(CW\*(C`Python::Object\*(C'\fR.
.SS "Constructors"
.IX Subsection "Constructors"
The following object constructor functions are provided.  They all
return \f(CW\*(C`Python::Object\*(C'\fR instances.  Usually one will not have to
construct \f(CW\*(C`Python::Object\*(C'\fRs directly since they are constructed
implicitly when python data is passed to perl either as perl function
arguments or as the return values from calls into python.
.ie n .IP "$o = object($something);" 4
.el .IP "\f(CW$o\fR = object($something);" 4
.IX Item "$o = object($something);"
The \fBobject()\fR constructor will first make a python object of whatever
perl data is passed in and then return a Python::Object wrapper for
it.  A call like:
.Sp
.Vb 1
\&  $o = object("$something")
.Ve
.Sp
will make sure you produce a string object.
.ie n .IP "$o = int( \s-1INT\s0 )" 4
.el .IP "\f(CW$o\fR = int( \s-1INT\s0 )" 4
.IX Item "$o = int( INT )"
This will make a new integer object.
.ie n .IP "$o = long( \s-1STRING_OF_DIGITS\s0 )" 4
.el .IP "\f(CW$o\fR = long( \s-1STRING_OF_DIGITS\s0 )" 4
.IX Item "$o = long( STRING_OF_DIGITS )"
This will make a new long integer object.  Long integers can grow to
arbitrary size (bignum).
.ie n .IP "$o = float( \s-1NUMBER\s0 )" 4
.el .IP "\f(CW$o\fR = float( \s-1NUMBER\s0 )" 4
.IX Item "$o = float( NUMBER )"
This will make a new float object.
.ie n .IP "$o = complex( \s-1NUMBER, NUMBER\s0 )" 4
.el .IP "\f(CW$o\fR = complex( \s-1NUMBER, NUMBER\s0 )" 4
.IX Item "$o = complex( NUMBER, NUMBER )"
This will make a new complex object with the given \fIreal\fR and \fIimag\fR
parts.
.ie n .IP "$o = list( \s-1ELEM,...\s0 )" 4
.el .IP "\f(CW$o\fR = list( \s-1ELEM,...\s0 )" 4
.IX Item "$o = list( ELEM,... )"
This will make a new list object initialized with the elements passed
in as separate arguments to the constructor function.
.ie n .IP "$o = tuple( \s-1ELEM,...\s0 )" 4
.el .IP "\f(CW$o\fR = tuple( \s-1ELEM,...\s0 )" 4
.IX Item "$o = tuple( ELEM,... )"
This will make a new tuple object initialized with the elements passed
in as separate arguments to the constructor function.
.ie n .IP "$o = dict( \s-1KEY\s0 => \s-1VALUE,...\s0 );" 4
.el .IP "\f(CW$o\fR = dict( \s-1KEY\s0 => \s-1VALUE,...\s0 );" 4
.IX Item "$o = dict( KEY => VALUE,... );"
This will make a new dictionary object.  Initial items are extracted
as pairs from the argument list.
.SS "Python functions"
.IX Subsection "Python functions"
The following functions with mostly identical behaviour to the
corresponding python builtins are available.  These functions will
croak if the \f(CW$o\fR argument is not a \f(CW\*(C`Python::Object\*(C'\fR instance.
.ie n .IP "getattr($o, $name)" 4
.el .IP "getattr($o, \f(CW$name\fR)" 4
.IX Item "getattr($o, $name)"
.PD 0
.ie n .IP "hasattr($o, $name)" 4
.el .IP "hasattr($o, \f(CW$name\fR)" 4
.IX Item "hasattr($o, $name)"
.ie n .IP "setattr($o, $name => $value)" 4
.el .IP "setattr($o, \f(CW$name\fR => \f(CW$value\fR)" 4
.IX Item "setattr($o, $name => $value)"
.ie n .IP "delattr($o, $name)" 4
.el .IP "delattr($o, \f(CW$name\fR)" 4
.IX Item "delattr($o, $name)"
.PD
These functions provide access to the attributes of an object.
.ie n .IP "cmp($o1, $o2)" 4
.el .IP "cmp($o1, \f(CW$o2\fR)" 4
.IX Item "cmp($o1, $o2)"
Compares the two objects and returns \-1, 0 or 1 if \f(CW$o\fR is less, equal
or greater than \f(CW$o2\fR respectively.
.IP "id($o)" 4
.IX Item "id($o)"
Returns a number which will be different for different objects.
.IP "hash($o)" 4
.IX Item "hash($o)"
This return the hash value of the object.
.IP "len($o)" 4
.IX Item "len($o)"
This return the length of the object.
.IP "type($o)" 4
.IX Item "type($o)"
Returns the corresponsding type object.
.IP "str($o)" 4
.IX Item "str($o)"
Returns a stringified representation of the object.
.Sp
Overloaded as perl stringify operator.
.IP "repr($o)" 4
.IX Item "repr($o)"
Returns a possibly different stringified representation of the object
that tries be valid python syntax.
.IP "exec($string, [$globals, [$locals]);" 4
.IX Item "exec($string, [$globals, [$locals]);"
Executes a bit of python code.  The global and local namespace to use
during execution can be passed in as dictionary objects.  If omitted
they default to the _\|_main_\|_ namespace.
.IP "eval($string, [$globals, [$locals]);" 4
.IX Item "eval($string, [$globals, [$locals]);"
Returns the value of the expression given as first argument.  The
global and local namespace can be overridden like for exec.
.IP "apply($o, \e@args, \e%keywords)" 4
.IX Item "apply($o, @args, %keywords)"
This will invoke the object with the given arguments.  The \e@args
argument can be a perl array reference, undef or some python sequence.  The
\&\e%keywords argument can be a perl hash reference, undef or a python
directory.
.ie n .IP "funcall($o, @args)" 4
.el .IP "funcall($o, \f(CW@args\fR)" 4
.IX Item "funcall($o, @args)"
This will invoke the object with the given arguments if it is
callable.  Similar to \fBapply()\fR, but arguments are not passed as a
single list reference argument.
.ie n .IP "Import( $module )" 4
.el .IP "Import( \f(CW$module\fR )" 4
.IX Item "Import( $module )"
Loads the module and returns a reference to it.  Notice that this
function is spelled with a capital \*(L"i\*(R".  (The reason is that perl
already use \*(L"import\*(R" for something else.)
.ie n .IP "raise($type, $value)" 4
.el .IP "raise($type, \f(CW$value\fR)" 4
.IX Item "raise($type, $value)"
Raise a python exception of the specific type.  References to Python's
standard exception types can be obtained from the \f(CW\*(C`Python::Err\*(C'\fR
namespace.  E.g.:
.Sp
.Vb 1
\&  Python::raise(Python::Err::TypeError, "\*(Aqfoo\*(Aq wanted here");
.Ve
.SS "Python \s-1API\s0 functions"
.IX Subsection "Python API functions"
The following functions that map the Python internal C \s-1API\s0 are made
available.
.ie n .IP "PyObject_GetItem($o, $key)" 4
.el .IP "PyObject_GetItem($o, \f(CW$key\fR)" 4
.IX Item "PyObject_GetItem($o, $key)"
.PD 0
.ie n .IP "PyObject_SetItem($o, $key, $value)" 4
.el .IP "PyObject_SetItem($o, \f(CW$key\fR, \f(CW$value\fR)" 4
.IX Item "PyObject_SetItem($o, $key, $value)"
.ie n .IP "PyObject_DelItem($o, $key)" 4
.el .IP "PyObject_DelItem($o, \f(CW$key\fR)" 4
.IX Item "PyObject_DelItem($o, $key)"
.PD
These methods provide access to the items of objects that implement
the sequence or the mapping interface.  These function also have
aliases named \fBgetitem()\fR, \fBsetitem()\fR and \fBdelitem()\fR after the pattern
established by the corresponding {get,set,del}\fBattr()\fR calls.
.IP "PyObject_IsTrue($o)" 4
.IX Item "PyObject_IsTrue($o)"
This return a boolean value for the object.
.Sp
Overloaded as boolean test operator.
.SS "Type check functions"
.IX Subsection "Type check functions"
The following functions determine if the object is of the given type.
If \f(CW$o\fR is not a reference to a \f(CW\*(C`Python::Object\*(C'\fR instance, then these
all return \s-1FALSE.\s0
.IP "PyCallable_Check($o)" 4
.IX Item "PyCallable_Check($o)"
Return \s-1TRUE\s0 if the object is callable.
.IP "PyNumber_Check($o);" 4
.IX Item "PyNumber_Check($o);"
Return \s-1TRUE\s0 if the object provide the number interface.
.IP "PySequence_Check($o)" 4
.IX Item "PySequence_Check($o)"
Return \s-1TRUE\s0 if the object provide the sequence interface.
.IP "PyMapping_Check($o)" 4
.IX Item "PyMapping_Check($o)"
Return \s-1TRUE\s0 if the object provide the mapping interface.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
(C) 2000\-2001 ActiveState
.PP
This code is distributed under the same terms as Perl; you can
redistribute it and/or modify it under the terms of either the \s-1GNU\s0
General Public License or the Artistic License.
.PP
\&\s-1THIS SOFTWARE IS PROVIDED BY ACTIVESTATE\s0 `\s-1AS IS\s0'' \s-1AND ANY EXPRESSED OR
IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.\s0  \s-1IN NO EVENT SHALL ACTIVESTATE OR ITS CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES\s0 (\s-1INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES\s0; \s-1LOSS OF USE, DATA, OR PROFITS\s0; \s-1OR
BUSINESS INTERRUPTION\s0) \s-1HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\s0 (\s-1INCLUDING NEGLIGENCE
OR OTHERWISE\s0) \s-1ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
python, perl, Python::Object, Python::Err, perlmodule
