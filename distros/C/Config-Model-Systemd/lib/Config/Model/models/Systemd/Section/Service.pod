# PODNAME: Config::Model::models::Systemd::Section::Service
# ABSTRACT:  Configuration class Systemd::Section::Service

=encoding utf8

=head1 NAME

Config::Model::models::Systemd::Section::Service - Configuration class Systemd::Section::Service

=head1 DESCRIPTION

Configuration classes used by L<Config::Model>

A unit configuration file whose name ends in
.service encodes information about a process
controlled and supervised by systemd.

This man page lists the configuration options specific to
this unit type. See
L<systemd.unit(5)>
for the common options of all unit configuration files. The common
configuration items are configured in the generic
C<[Unit]> and C<[Install]>
sections. The service specific configuration options are
configured in the C<[Service]> section.

Additional options are listed in
L<systemd.exec(5)>,
which define the execution environment the commands are executed
in, and in
L<systemd.kill(5)>,
which define the way the processes of the service are terminated,
and in
L<systemd.resource-control(5)>,
which configure resource control settings for the processes of the
service.

If a service is requested under a certain name but no unit
configuration file is found, systemd looks for a SysV init script
by the same name (with the .service suffix
removed) and dynamically creates a service unit from that script.
This is useful for compatibility with SysV. Note that this
compatibility is quite comprehensive but not 100%. For details
about the incompatibilities, see the Incompatibilities
with SysV document.
This configuration class was generated from systemd documentation.
by L<parse-man.pl|https://github.com/dod38fr/config-model-systemd/contrib/parse-man.pl>


=head1 Elements

=head2 CPUAccounting

Turn on CPU usage accounting for this unit. Takes a
boolean argument. Note that turning on CPU accounting for
one unit will also implicitly turn it on for all units
contained in the same slice and for all its parent slices
and the units contained therein. The system default for this
setting may be controlled with
C<DefaultCPUAccounting> in
L<systemd-system.conf(5)>. I< Optional. Type boolean.  > 

=head2 CPUWeight

Assign the specified CPU time weight to the processes executed, if the unified control group hierarchy
is used on the system. These options take an integer value and control the C<cpu.weight>
control group attribute. The allowed range is 1 to 10000. Defaults to 100. For details about this control
group attribute, see cgroup-v2.txt and sched-design-CFS.txt.
The available CPU time is split up among all units within one slice relative to their CPU time weight.

While C<StartupCPUWeight> only applies to the startup phase of the system,
C<CPUWeight> applies to normal runtime of the system, and if the former is not set also to
the startup phase. Using C<StartupCPUWeight> allows prioritizing specific services at
boot-up differently than during normal runtime.

Implies C<CPUAccounting=true>.

These settings replace C<CPUShares> and C<StartupCPUShares>. I< Optional. Type integer.  > 

=over 4

=item upstream_default value :

100

=back



=head2 StartupCPUWeight

Assign the specified CPU time weight to the processes executed, if the unified control group hierarchy
is used on the system. These options take an integer value and control the C<cpu.weight>
control group attribute. The allowed range is 1 to 10000. Defaults to 100. For details about this control
group attribute, see cgroup-v2.txt and sched-design-CFS.txt.
The available CPU time is split up among all units within one slice relative to their CPU time weight.

While C<StartupCPUWeight> only applies to the startup phase of the system,
C<CPUWeight> applies to normal runtime of the system, and if the former is not set also to
the startup phase. Using C<StartupCPUWeight> allows prioritizing specific services at
boot-up differently than during normal runtime.

Implies C<CPUAccounting=true>.

These settings replace C<CPUShares> and C<StartupCPUShares>. I< Optional. Type integer.  > 

=over 4

=item upstream_default value :

100

=back



=head2 CPUQuota

Assign the specified CPU time quota to the processes executed. Takes a percentage value, suffixed with
"%". The percentage specifies how much CPU time the unit shall get at maximum, relative to the total CPU time
available on one CPU. Use values > 100% for allotting CPU time on more than one CPU. This controls the
C<cpu.max> attribute on the unified control group hierarchy and
C<cpu.cfs_quota_us> on legacy. For details about these control group attributes, see cgroup-v2.txt and sched-design-CFS.txt.

Example: C<CPUQuota=20%> ensures that the executed processes will never get more than
20% CPU time on one CPU.

Implies C<CPUAccounting=true>. I< Optional. Type uniline.  > 

=head2 MemoryAccounting

Turn on process and kernel memory accounting for this
unit. Takes a boolean argument. Note that turning on memory
accounting for one unit will also implicitly turn it on for
all units contained in the same slice and for all its parent
slices and the units contained therein. The system default
for this setting may be controlled with
C<DefaultMemoryAccounting> in
L<systemd-system.conf(5)>. I< Optional. Type boolean.  > 

=head2 MemoryLow

Specify the best-effort memory usage protection of the executed processes in this unit. If the memory
usages of this unit and all its ancestors are below their low boundaries, this unit's memory won't be
reclaimed as long as memory can be reclaimed from unprotected units.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the
system. This controls the C<memory.low> control group attribute. For details about this
control group attribute, see cgroup-v2.txt.

Implies C<MemoryAccounting=true>.

This setting is supported only if the unified control group hierarchy is used and disables
C<MemoryLimit>. I< Optional. Type uniline.  > 

=head2 MemoryHigh

Specify the high limit on memory usage of the executed processes in this unit. Memory usage may go
above the limit if unavoidable, but the processes are heavily slowed down and memory is taken away
aggressively in such cases. This is the main mechanism to control memory usage of a unit.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the
system. If assigned the
special value C<infinity>, no memory limit is applied. This controls the
C<memory.high> control group attribute. For details about this control group attribute, see
cgroup-v2.txt.

Implies C<MemoryAccounting=true>.

This setting is supported only if the unified control group hierarchy is used and disables
C<MemoryLimit>. I< Optional. Type uniline.  > 

=head2 MemoryMax

Specify the absolute limit on memory usage of the executed processes in this unit. If memory usage
cannot be contained under the limit, out-of-memory killer is invoked inside the unit. It is recommended to
use C<MemoryHigh> as the main control mechanism and use C<MemoryMax> as the
last line of defense.

Takes a memory size in bytes. If the value is suffixed with K, M, G or T, the specified memory size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. Alternatively, a
percentage value may be specified, which is taken relative to the installed physical memory on the system. If
assigned the special value C<infinity>, no memory limit is applied. This controls the
C<memory.max> control group attribute. For details about this control group attribute, see
cgroup-v2.txt.

Implies C<MemoryAccounting=true>.

This setting replaces C<MemoryLimit>. I< Optional. Type uniline.  > 

=head2 MemorySwapMax

Specify the absolute limit on swap usage of the executed processes in this unit.

Takes a swap size in bytes. If the value is suffixed with K, M, G or T, the specified swap size is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes (with the base 1024), respectively. If assigned the
special value C<infinity>, no swap limit is applied. This controls the
C<memory.swap.max> control group attribute. For details about this control group attribute,
see cgroup-v2.txt.

Implies C<MemoryAccounting=true>.

This setting is supported only if the unified control group hierarchy is used and disables
C<MemoryLimit>. I< Optional. Type uniline.  > 

=head2 TasksAccounting

Turn on task accounting for this unit. Takes a
boolean argument. If enabled, the system manager will keep
track of the number of tasks in the unit. The number of
tasks accounted this way includes both kernel threads and
userspace processes, with each thread counting
individually. Note that turning on tasks accounting for one
unit will also implicitly turn it on for all units contained
in the same slice and for all its parent slices and the
units contained therein. The system default for this setting
may be controlled with
C<DefaultTasksAccounting> in
L<systemd-system.conf(5)>. I< Optional. Type boolean.  > 

=head2 TasksMax

Specify the maximum number of tasks that may be created in the unit. This ensures that the number of
tasks accounted for the unit (see above) stays below a specific limit. This either takes an absolute number
of tasks or a percentage value that is taken relative to the configured maximum number of tasks on the
system.  If assigned the special value C<infinity>, no tasks limit is applied. This controls
the C<pids.max> control group attribute. For details about this control group attribute, see
pids.txt.

Implies C<TasksAccounting=true>. The
system default for this setting may be controlled with
C<DefaultTasksMax> in
L<systemd-system.conf(5)>. I< Optional. Type uniline.  > 

=head2 IOAccounting

Turn on Block I/O accounting for this unit, if the unified control group hierarchy is used on the
system. Takes a boolean argument. Note that turning on block I/O accounting for one unit will also implicitly
turn it on for all units contained in the same slice and all for its parent slices and the units contained
therein. The system default for this setting may be controlled with C<DefaultIOAccounting>
in
L<systemd-system.conf(5)>.

This setting replaces C<BlockIOAccounting> and disables settings prefixed with
C<BlockIO> or C<StartupBlockIO>. I< Optional. Type boolean.  > 

=head2 IOWeight

Set the default overall block I/O weight for the executed processes, if the unified control group
hierarchy is used on the system. Takes a single weight value (between 1 and 10000) to set the default block
I/O weight. This controls the C<io.weight> control group attribute, which defaults to
100. For details about this control group attribute, see cgroup-v2.txt.  The available I/O
bandwidth is split up among all units within one slice relative to their block I/O weight.

While C<StartupIOWeight> only applies
to the startup phase of the system,
C<IOWeight> applies to the later runtime of
the system, and if the former is not set also to the startup
phase. This allows prioritizing specific services at boot-up
differently than during runtime.

Implies C<IOAccounting=true>.

These settings replace C<BlockIOWeight> and C<StartupBlockIOWeight>
and disable settings prefixed with C<BlockIO> or C<StartupBlockIO>. I< Optional. Type uniline.  > 

=head2 StartupIOWeight

Set the default overall block I/O weight for the executed processes, if the unified control group
hierarchy is used on the system. Takes a single weight value (between 1 and 10000) to set the default block
I/O weight. This controls the C<io.weight> control group attribute, which defaults to
100. For details about this control group attribute, see cgroup-v2.txt.  The available I/O
bandwidth is split up among all units within one slice relative to their block I/O weight.

While C<StartupIOWeight> only applies
to the startup phase of the system,
C<IOWeight> applies to the later runtime of
the system, and if the former is not set also to the startup
phase. This allows prioritizing specific services at boot-up
differently than during runtime.

Implies C<IOAccounting=true>.

These settings replace C<BlockIOWeight> and C<StartupBlockIOWeight>
and disable settings prefixed with C<BlockIO> or C<StartupBlockIO>. I< Optional. Type uniline.  > 

=head2 IODeviceWeight

Set the per-device overall block I/O weight for the executed processes, if the unified control group
hierarchy is used on the system. Takes a space-separated pair of a file path and a weight value to specify
the device specific weight value, between 1 and 10000. (Example: "/dev/sda 1000"). The file path may be
specified as path to a block device node or as any other file, in which case the backing block device of the
file system of the file is determined. This controls the C<io.weight> control group
attribute, which defaults to 100. Use this option multiple times to set weights for multiple devices. For
details about this control group attribute, see cgroup-v2.txt.

Implies C<IOAccounting=true>.

This setting replaces C<BlockIODeviceWeight> and disables settings prefixed with
C<BlockIO> or C<StartupBlockIO>. I< Optional. Type uniline.  > 

=head2 IOReadBandwidthMax

Set the per-device overall block I/O bandwidth maximum limit for the executed processes, if the unified
control group hierarchy is used on the system. This limit is not work-conserving and the executed processes
are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of a file
path and a bandwidth value (in bytes per second) to specify the device specific bandwidth. The file path may
be a path to a block device node, or as any other file in which case the backing block device of the file
system of the file is used. If the bandwidth is suffixed with K, M, G, or T, the specified bandwidth is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the C<io.max> control
group attributes. Use this option multiple times to set bandwidth limits for multiple devices. For details
about this control group attribute, see cgroup-v2.txt.

Implies C<IOAccounting=true>.

These settings replace C<BlockIOReadBandwidth> and
C<BlockIOWriteBandwidth> and disable settings prefixed with C<BlockIO> or
C<StartupBlockIO>. I< Optional. Type uniline.  > 

=head2 IOWriteBandwidthMax

Set the per-device overall block I/O bandwidth maximum limit for the executed processes, if the unified
control group hierarchy is used on the system. This limit is not work-conserving and the executed processes
are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of a file
path and a bandwidth value (in bytes per second) to specify the device specific bandwidth. The file path may
be a path to a block device node, or as any other file in which case the backing block device of the file
system of the file is used. If the bandwidth is suffixed with K, M, G, or T, the specified bandwidth is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the C<io.max> control
group attributes. Use this option multiple times to set bandwidth limits for multiple devices. For details
about this control group attribute, see cgroup-v2.txt.

Implies C<IOAccounting=true>.

These settings replace C<BlockIOReadBandwidth> and
C<BlockIOWriteBandwidth> and disable settings prefixed with C<BlockIO> or
C<StartupBlockIO>. I< Optional. Type uniline.  > 

=head2 IOReadIOPSMax

Set the per-device overall block I/O IOs-Per-Second maximum limit for the executed processes, if the
unified control group hierarchy is used on the system. This limit is not work-conserving and the executed
processes are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of
a file path and an IOPS value to specify the device specific IOPS. The file path may be a path to a block
device node, or as any other file in which case the backing block device of the file system of the file is
used. If the IOPS is suffixed with K, M, G, or T, the specified IOPS is parsed as KiloIOPS, MegaIOPS,
GigaIOPS, or TeraIOPS, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 1K"). This controls the C<io.max> control
group attributes. Use this option multiple times to set IOPS limits for multiple devices. For details about
this control group attribute, see cgroup-v2.txt.

Implies C<IOAccounting=true>.

These settings are supported only if the unified control group hierarchy is used and disable settings
prefixed with C<BlockIO> or C<StartupBlockIO>. I< Optional. Type uniline.  > 

=head2 IOWriteIOPSMax

Set the per-device overall block I/O IOs-Per-Second maximum limit for the executed processes, if the
unified control group hierarchy is used on the system. This limit is not work-conserving and the executed
processes are not allowed to use more even if the device has idle capacity.  Takes a space-separated pair of
a file path and an IOPS value to specify the device specific IOPS. The file path may be a path to a block
device node, or as any other file in which case the backing block device of the file system of the file is
used. If the IOPS is suffixed with K, M, G, or T, the specified IOPS is parsed as KiloIOPS, MegaIOPS,
GigaIOPS, or TeraIOPS, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 1K"). This controls the C<io.max> control
group attributes. Use this option multiple times to set IOPS limits for multiple devices. For details about
this control group attribute, see cgroup-v2.txt.

Implies C<IOAccounting=true>.

These settings are supported only if the unified control group hierarchy is used and disable settings
prefixed with C<BlockIO> or C<StartupBlockIO>. I< Optional. Type uniline.  > 

=head2 DeviceAllow

Control access to specific device nodes by the
executed processes. Takes two space-separated strings: a
device node specifier followed by a combination of
C<r>, C<w>,
C<m> to control
reading, writing,
or creation of the specific device node(s) by the unit
(mknod), respectively. This controls
the C<devices.allow> and
C<devices.deny> control group
attributes. For details about these control group
attributes, see devices.txt.

The device node specifier is either a path to a device
node in the file system, starting with
/dev/, or a string starting with either
C<char-> or C<block->
followed by a device group name, as listed in
/proc/devices. The latter is useful to
whitelist all current and future devices belonging to a
specific device group at once. The device group is matched
according to file name globbing rules, you may hence use the
C<*> and C<?>
wildcards. Examples: /dev/sda5 is a
path to a device node, referring to an ATA or SCSI block
device. C<char-pts> and
C<char-alsa> are specifiers for all pseudo
TTYs and all ALSA sound devices,
respectively. C<char-cpu/*> is a specifier
matching all CPU related device groups. I< Optional. Type list of uniline.  > 

=head2 DevicePolicy


Control the policy for allowing device access:
I< Optional. Type enum. choice: 'auto', 'closed', 'strict'.  > 

=head2 Slice

The name of the slice unit to place the unit
in. Defaults to system.slice for all
non-instantiated units of all unit types (except for slice
units themselves see below). Instance units are by default
placed in a subslice of system.slice
that is named after the template name.

This option may be used to arrange systemd units in a
hierarchy of slices each of which might have resource
settings applied.

For units of type slice, the only accepted value for
this setting is the parent slice. Since the name of a slice
unit implies the parent slice, it is hence redundant to ever
set this parameter directly for slice units.

Special care should be taken when relying on the default slice assignment in templated service units
that have C<DefaultDependencies=no> set, see
L<systemd.service(5)>, section
"Automatic Dependencies" for details. I< Optional. Type uniline.  > 

=head2 Delegate

Turns on delegation of further resource control
partitioning to processes of the unit. For unprivileged
services (i.e. those using the C<User>
setting), this allows processes to create a subhierarchy
beneath its control group path. For privileged services and
scopes, this ensures the processes will have all control
group controllers enabled. I< Optional. Type uniline.  > 

=head2 CPUShares

Assign the specified CPU time share weight to the processes executed. These options take an integer
value and control the C<cpu.shares> control group attribute. The allowed range is 2 to
262144. Defaults to 1024. For details about this control group attribute, see sched-design-CFS.txt.
The available CPU time is split up among all units within one slice relative to their CPU time share
weight.

While C<StartupCPUShares> only applies to the startup phase of the system,
C<CPUShares> applies to normal runtime of the system, and if the former is not set also to
the startup phase. Using C<StartupCPUShares> allows prioritizing specific services at
boot-up differently than during normal runtime.

Implies C<CPUAccounting=true>.

These settings are deprecated. Use C<CPUWeight> and
C<StartupCPUWeight> instead. I< Optional. Type integer.  > 

=over 4

=item upstream_default value :

1024

=back



=head2 StartupCPUShares

Assign the specified CPU time share weight to the processes executed. These options take an integer
value and control the C<cpu.shares> control group attribute. The allowed range is 2 to
262144. Defaults to 1024. For details about this control group attribute, see sched-design-CFS.txt.
The available CPU time is split up among all units within one slice relative to their CPU time share
weight.

While C<StartupCPUShares> only applies to the startup phase of the system,
C<CPUShares> applies to normal runtime of the system, and if the former is not set also to
the startup phase. Using C<StartupCPUShares> allows prioritizing specific services at
boot-up differently than during normal runtime.

Implies C<CPUAccounting=true>.

These settings are deprecated. Use C<CPUWeight> and
C<StartupCPUWeight> instead. I< Optional. Type integer.  > 

=over 4

=item upstream_default value :

1024

=back



=head2 MemoryLimit

Specify the limit on maximum memory usage of the executed processes. The limit specifies how much
process and kernel memory can be used by tasks in this unit. Takes a memory size in bytes. If the value is
suffixed with K, M, G or T, the specified memory size is parsed as Kilobytes, Megabytes, Gigabytes, or
Terabytes (with the base 1024), respectively. Alternatively, a percentage value may be specified, which is
taken relative to the installed physical memory on the system. If assigned the special value
C<infinity>, no memory limit is applied. This controls the
C<memory.limit_in_bytes> control group attribute. For details about this control group
attribute, see memory.txt.

Implies C<MemoryAccounting=true>.

This setting is deprecated. Use C<MemoryMax> instead. I< Optional. Type uniline.  > 

=head2 BlockIOAccounting

Turn on Block I/O accounting for this unit, if the legacy control group hierarchy is used on the
system. Takes a boolean argument. Note that turning on block I/O accounting for one unit will also implicitly
turn it on for all units contained in the same slice and all for its parent slices and the units contained
therein. The system default for this setting may be controlled with
C<DefaultBlockIOAccounting> in
L<systemd-system.conf(5)>.

This setting is deprecated. Use C<IOAccounting> instead. I< Optional. Type boolean.  > 

=head2 BlockIOWeight

Set the default overall block I/O weight for the executed processes, if the legacy control
group hierarchy is used on the system. Takes a single weight value (between 10 and 1000) to set the default
block I/O weight. This controls the C<blkio.weight> control group attribute, which defaults to
500. For details about this control group attribute, see blkio-controller.txt.
The available I/O bandwidth is split up among all units within one slice relative to their block I/O
weight.

While C<StartupBlockIOWeight> only
applies to the startup phase of the system,
C<BlockIOWeight> applies to the later runtime
of the system, and if the former is not set also to the
startup phase. This allows prioritizing specific services at
boot-up differently than during runtime.

Implies
C<BlockIOAccounting=true>.

These settings are deprecated. Use C<IOWeight> and C<StartupIOWeight>
instead. I< Optional. Type uniline.  > 

=head2 StartupBlockIOWeight

Set the default overall block I/O weight for the executed processes, if the legacy control
group hierarchy is used on the system. Takes a single weight value (between 10 and 1000) to set the default
block I/O weight. This controls the C<blkio.weight> control group attribute, which defaults to
500. For details about this control group attribute, see blkio-controller.txt.
The available I/O bandwidth is split up among all units within one slice relative to their block I/O
weight.

While C<StartupBlockIOWeight> only
applies to the startup phase of the system,
C<BlockIOWeight> applies to the later runtime
of the system, and if the former is not set also to the
startup phase. This allows prioritizing specific services at
boot-up differently than during runtime.

Implies
C<BlockIOAccounting=true>.

These settings are deprecated. Use C<IOWeight> and C<StartupIOWeight>
instead. I< Optional. Type uniline.  > 

=head2 BlockIODeviceWeight

Set the per-device overall block I/O weight for the executed processes, if the legacy control group
hierarchy is used on the system. Takes a space-separated pair of a file path and a weight value to specify
the device specific weight value, between 10 and 1000. (Example: "/dev/sda 500"). The file path may be
specified as path to a block device node or as any other file, in which case the backing block device of the
file system of the file is determined. This controls the C<blkio.weight_device> control group
attribute, which defaults to 1000. Use this option multiple times to set weights for multiple devices. For
details about this control group attribute, see blkio-controller.txt.

Implies
C<BlockIOAccounting=true>.

This setting is deprecated. Use C<IODeviceWeight> instead. I< Optional. Type uniline.  > 

=head2 BlockIOReadBandwidth

Set the per-device overall block I/O bandwidth limit for the executed processes, if the legacy control
group hierarchy is used on the system. Takes a space-separated pair of a file path and a bandwidth value (in
bytes per second) to specify the device specific bandwidth. The file path may be a path to a block device
node, or as any other file in which case the backing block device of the file system of the file is used. If
the bandwidth is suffixed with K, M, G, or T, the specified bandwidth is parsed as Kilobytes, Megabytes,
Gigabytes, or Terabytes, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the
C<blkio.throttle.read_bps_device> and C<blkio.throttle.write_bps_device>
control group attributes. Use this option multiple times to set bandwidth limits for multiple devices. For
details about these control group attributes, see blkio-controller.txt.

Implies
C<BlockIOAccounting=true>.

These settings are deprecated. Use C<IOReadBandwidthMax> and
C<IOWriteBandwidthMax> instead. I< Optional. Type uniline.  > 

=head2 BlockIOWriteBandwidth

Set the per-device overall block I/O bandwidth limit for the executed processes, if the legacy control
group hierarchy is used on the system. Takes a space-separated pair of a file path and a bandwidth value (in
bytes per second) to specify the device specific bandwidth. The file path may be a path to a block device
node, or as any other file in which case the backing block device of the file system of the file is used. If
the bandwidth is suffixed with K, M, G, or T, the specified bandwidth is parsed as Kilobytes, Megabytes,
Gigabytes, or Terabytes, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the
C<blkio.throttle.read_bps_device> and C<blkio.throttle.write_bps_device>
control group attributes. Use this option multiple times to set bandwidth limits for multiple devices. For
details about these control group attributes, see blkio-controller.txt.

Implies
C<BlockIOAccounting=true>.

These settings are deprecated. Use C<IOReadBandwidthMax> and
C<IOWriteBandwidthMax> instead. I< Optional. Type uniline.  > 

=head2 WorkingDirectory

Takes a directory path relative to the service's root directory specified by
C<RootDirectory>, or the special value C<~>. Sets the working directory for
executed processes. If set to C<~>, the home directory of the user specified in
C<User> is used. If not set, defaults to the root directory when systemd is running as a
system instance and the respective user's home directory if run as user. If the setting is prefixed with the
C<-> character, a missing working directory is not considered fatal. If
C<RootDirectory> is not set, then C<WorkingDirectory> is relative to the root
of the system running the service manager.  Note that setting this parameter might result in additional
dependencies to be added to the unit (see above). I< Optional. Type uniline.  > 

=head2 RootDirectory

Takes a directory path relative to the host's root directory (i.e. the root of the system
running the service manager). Sets the root directory for executed processes, with the L<chroot(2)> system
call. If this is used, it must be ensured that the process binary and all its auxiliary files are available in
the chroot() jail. Note that setting this parameter might result in additional
dependencies to be added to the unit (see above).

The C<PrivateUsers> setting is particularly useful in conjunction with
C<RootDirectory>. For details, see below. I< Optional. Type uniline.  > 

=head2 User

Set the UNIX user or group that the processes are executed as, respectively. Takes a single
user or group name, or numeric ID as argument. For system services (services run by the system service manager,
i.e. managed by PID 1) and for user services of the root user (services managed by root's instance of
systemd --user), the default is C<root>, but C<User> may be
used to specify a different user. For user services of any other user, switching user identity is not
permitted, hence the only valid setting is the same user the user's service manager is running as. If no group
is set, the default group of the user is used. This setting does not affect commands whose command line is
prefixed with C<+>. I< Optional. Type uniline.  > 

=head2 Group

Set the UNIX user or group that the processes are executed as, respectively. Takes a single
user or group name, or numeric ID as argument. For system services (services run by the system service manager,
i.e. managed by PID 1) and for user services of the root user (services managed by root's instance of
systemd --user), the default is C<root>, but C<User> may be
used to specify a different user. For user services of any other user, switching user identity is not
permitted, hence the only valid setting is the same user the user's service manager is running as. If no group
is set, the default group of the user is used. This setting does not affect commands whose command line is
prefixed with C<+>. I< Optional. Type uniline.  > 

=head2 DynamicUser

Takes a boolean parameter. If set, a UNIX user and group pair is allocated dynamically when the
unit is started, and released as soon as it is stopped. The user and group will not be added to
/etc/passwd or /etc/group, but are managed transiently during
runtime. The L<nss-systemd(8)>
glibc NSS module provides integration of these dynamic users/groups into the system's user and group
databases. The user and group name to use may be configured via C<User> and
C<Group> (see above). If these options are not used and dynamic user/group allocation is
enabled for a unit, the name of the dynamic user/group is implicitly derived from the unit name. If the unit
name without the type suffix qualifies as valid user name it is used directly, otherwise a name incorporating a
hash of it is used. If a statically allocated user or group of the configured name already exists, it is used
and no dynamic user/group is allocated. Dynamic users/groups are allocated from the UID/GID range
61184…65519. It is recommended to avoid this range for regular system or login users.  At any point in time
each UID/GID from this range is only assigned to zero or one dynamically allocated users/groups in
use. However, UID/GIDs are recycled after a unit is terminated. Care should be taken that any processes running
as part of a unit for which dynamic users/groups are enabled do not leave files or directories owned by these
users/groups around, as a different unit might get the same UID/GID assigned later on, and thus gain access to
these files or directories. If C<DynamicUser> is enabled, C<RemoveIPC>,
C<PrivateTmp> are implied. This ensures that the lifetime of IPC objects and temporary files
created by the executed processes is bound to the runtime of the service, and hence the lifetime of the dynamic
user/group. Since /tmp and /var/tmp are usually the only
world-writable directories on a system this ensures that a unit making use of dynamic user/group allocation
cannot leave files around after unit termination. Moreover C<ProtectSystem=strict> and
C<ProtectHome=read-only> are implied, thus prohibiting the service to write to arbitrary file
system locations. In order to allow the service to write to certain directories, they have to be whitelisted
using C<ReadWritePaths>, but care must be taken so that UID/GID recycling doesn't
create security issues involving files created by the service. Use C<RuntimeDirectory> (see
below) in order to assign a writable runtime directory to a service, owned by the dynamic user/group and
removed automatically when the unit is terminated. Defaults to off. I< Optional. Type boolean.  > 

=head2 SupplementaryGroups

Sets the supplementary Unix groups the
processes are executed as. This takes a space-separated list
of group names or IDs. This option may be specified more than
once, in which case all listed groups are set as supplementary
groups. When the empty string is assigned, the list of
supplementary groups is reset, and all assignments prior to
this one will have no effect. In any way, this option does not
override, but extends the list of supplementary groups
configured in the system group database for the
user. This does not affect commands prefixed with C<+>. I< Optional. Type list of uniline.  > 

=head2 RemoveIPC

Takes a boolean parameter. If set, all System V and POSIX IPC objects owned by the user and
group the processes of this unit are run as are removed when the unit is stopped. This setting only has an
effect if at least one of C<User>, C<Group> and
C<DynamicUser> are used. It has no effect on IPC objects owned by the root user. Specifically,
this removes System V semaphores, as well as System V and POSIX shared memory segments and message queues. If
multiple units use the same user or group the IPC objects are removed when the last of these units is
stopped. This setting is implied if C<DynamicUser> is set. I< Optional. Type boolean.  > 

=head2 Nice

Sets the default nice level (scheduling
priority) for executed processes. Takes an integer between -20
(highest priority) and 19 (lowest priority). See
L<setpriority(2)>
for details. I< Optional. Type integer.  > 

=head2 OOMScoreAdjust

Sets the adjustment level for the
Out-Of-Memory killer for executed processes. Takes an integer
between -1000 (to disable OOM killing for this process) and
1000 (to make killing of this process under memory pressure
very likely). See proc.txt
for details. I< Optional. Type integer.  > 

=head2 IOSchedulingClass

Sets the I/O scheduling class for executed
processes. Takes an integer between 0 and 3 or one of the
strings C<none>, C<realtime>,
C<best-effort> or C<idle>. See
L<ioprio_set(2)>
for details. I< Optional. Type enum. choice: '0', '1', '2', '3', 'none', 'realtime', 'best-effort', 'idle'.  > 

=head2 IOSchedulingPriority

Sets the I/O scheduling priority for executed
processes. Takes an integer between 0 (highest priority) and 7
(lowest priority). The available priorities depend on the
selected I/O scheduling class (see above). See
L<ioprio_set(2)>
for details. I< Optional. Type integer.  > 

=head2 CPUSchedulingPolicy

Sets the CPU scheduling policy for executed
processes. Takes one of
C<other>,
C<batch>,
C<idle>,
C<fifo> or
C<rr>. See
L<sched_setscheduler(2)>
for details. I< Optional. Type enum. choice: 'other', 'batch', 'idle', 'fifo', 'rr'.  > 

=head2 CPUSchedulingPriority

Sets the CPU scheduling priority for executed
processes. The available priority range depends on the
selected CPU scheduling policy (see above). For real-time
scheduling policies an integer between 1 (lowest priority) and
99 (highest priority) can be used. See
L<sched_setscheduler(2)>
for details. I< Optional. Type uniline.  > 

=head2 CPUSchedulingResetOnFork

Takes a boolean argument. If true, elevated
CPU scheduling priorities and policies will be reset when the
executed processes fork, and can hence not leak into child
processes. See
L<sched_setscheduler(2)>
for details. Defaults to false. I< Optional. Type boolean.  > 

=head2 CPUAffinity

Controls the CPU affinity of the executed
processes. Takes a list of CPU indices or ranges separated by
either whitespace or commas. CPU ranges are specified by the
lower and upper CPU indices separated by a dash.
This option may be specified more than once, in which case the
specified CPU affinity masks are merged. If the empty string
is assigned, the mask is reset, all assignments prior to this
will have no effect. See
L<sched_setaffinity(2)>
for details. I< Optional. Type list of uniline.  > 

=head2 UMask

Controls the file mode creation mask. Takes an
access mode in octal notation. See
L<umask(2)>
for details. Defaults to 0022. I< Optional. Type uniline.  > 

=head2 Environment

Sets environment variables for executed
processes. Takes a space-separated list of variable
assignments. This option may be specified more than once, in
which case all listed variables will be set. If the same
variable is set twice, the later setting will override the
earlier setting. If the empty string is assigned to this
option, the list of environment variables is reset, all prior
assignments have no effect. Variable expansion is not
performed inside the strings, however, specifier expansion is
possible. The $ character has no special meaning. If you need
to assign a value containing spaces to a variable, use double
quotes (") for the assignment.

Example:

    Environment="VAR1=word1 word2" VAR2=word3 "VAR3=$word 5 6"

gives three variables C<VAR1>,
C<VAR2>, C<VAR3>
with the values C<word1 word2>,
C<word3>, C<$word 5 6>.

See
L<environ(7)>
for details about environment variables. I< Optional. Type list of uniline.  > 

=head2 EnvironmentFile

Similar to C<Environment> but
reads the environment variables from a text file. The text
file should contain new-line-separated variable assignments.
Empty lines, lines without an C<=> separator,
or lines starting with ; or # will be ignored,
which may be used for commenting. A line ending with a
backslash will be concatenated with the following one,
allowing multiline variable definitions. The parser strips
leading and trailing whitespace from the values of
assignments, unless you use double quotes (").

The argument passed should be an absolute filename or
wildcard expression, optionally prefixed with
C<->, which indicates that if the file does
not exist, it will not be read and no error or warning message
is logged. This option may be specified more than once in
which case all specified files are read. If the empty string
is assigned to this option, the list of file to read is reset,
all prior assignments have no effect.

The files listed with this directive will be read
shortly before the process is executed (more specifically,
after all processes from a previous unit state terminated.
This means you can generate these files in one unit state, and
read it with this option in the next).

Settings from these
files override settings made with
C<Environment>. If the same variable is set
twice from these files, the files will be read in the order
they are specified and the later setting will override the
earlier setting. I< Optional. Type list of uniline.  > 

=head2 PassEnvironment

Pass environment variables from the systemd system
manager to executed processes. Takes a space-separated list of variable
names. This option may be specified more than once, in which case all
listed variables will be set. If the empty string is assigned to this
option, the list of environment variables is reset, all prior
assignments have no effect. Variables that are not set in the system
manager will not be passed and will be silently ignored.

Variables passed from this setting are overridden by those passed
from C<Environment> or
C<EnvironmentFile>.

Example:

    PassEnvironment=VAR1 VAR2 VAR3

passes three variables C<VAR1>,
C<VAR2>, C<VAR3>
with the values set for those variables in PID1.

See
L<environ(7)>
for details about environment variables. I< Optional. Type list of uniline.  > 

=head2 StandardInput

Controls where file descriptor 0 (STDIN) of
the executed processes is connected to. Takes one of
C<null>,
C<tty>,
C<tty-force>,
C<tty-fail>,
C<socket> or
C<fd>.

If C<null> is selected, standard input
will be connected to /dev/null, i.e. all
read attempts by the process will result in immediate
EOF.

If C<tty> is selected, standard input is
connected to a TTY (as configured by
C<TTYPath>, see below) and the executed
process becomes the controlling process of the terminal. If
the terminal is already being controlled by another process,
the executed process waits until the current controlling
process releases the terminal.

C<tty-force> is similar to
C<tty>, but the executed process is forcefully
and immediately made the controlling process of the terminal,
potentially removing previous controlling processes from the
terminal.

C<tty-fail> is similar to
C<tty> but if the terminal already has a
controlling process start-up of the executed process
fails.

The C<socket> option is only valid in
socket-activated services, and only when the socket
configuration file (see
L<systemd.socket(5)>
for details) specifies a single socket only. If this option is
set, standard input will be connected to the socket the
service was activated from, which is primarily useful for
compatibility with daemons designed for use with the
traditional
L<inetd(8)>
daemon.

The C<fd> option connects
the input stream to a single file descriptor provided by a socket unit.
A custom named file descriptor can be specified as part of this option,
after a C<:> (e.g. C<fd:foobar>).
If no name is specified, C<stdin> is assumed
(i.e. C<fd> is equivalent to C<fd:stdin>).
At least one socket unit defining such name must be explicitly provided via the
C<Sockets> option, and file descriptor name may differ
from the name of its containing socket unit.
If multiple matches are found, the first one will be used.
See C<FileDescriptorName> in
L<systemd.socket(5)>
for more details about named descriptors and ordering.

This setting defaults to
C<null>. I< Optional. Type enum. choice: 'null', 'tty', 'tty-force', 'tty-fail', 'socket', 'fd'.  > 

=head2 StandardOutput

Controls where file descriptor 1 (STDOUT) of
the executed processes is connected to. Takes one of
C<inherit>,
C<null>,
C<tty>,
C<journal>,
C<syslog>,
C<kmsg>,
C<journal+console>,
C<syslog+console>,
C<kmsg+console>,
C<socket> or
C<fd>.

C<inherit> duplicates the file descriptor
of standard input for standard output.

C<null> connects standard output to
/dev/null, i.e. everything written to it
will be lost.

C<tty> connects standard output to a tty
(as configured via C<TTYPath>, see below). If
the TTY is used for output only, the executed process will not
become the controlling process of the terminal, and will not
fail or wait for other processes to release the
terminal.

C<journal> connects standard output with
the journal which is accessible via
L<journalctl(1)>.
Note that everything that is written to syslog or kmsg (see
below) is implicitly stored in the journal as well, the
specific two options listed below are hence supersets of this
one.

C<syslog> connects standard output to the
L<syslog(3)>
system syslog service, in addition to the journal. Note that
the journal daemon is usually configured to forward everything
it receives to syslog anyway, in which case this option is no
different from C<journal>.

C<kmsg> connects standard output with the
kernel log buffer which is accessible via
L<dmesg(1)>,
in addition to the journal. The journal daemon might be
configured to send all logs to kmsg anyway, in which case this
option is no different from C<journal>.

C<journal+console>,
C<syslog+console> and
C<kmsg+console> work in a similar way as the
three options above but copy the output to the system console
as well.

C<socket> connects standard output to a
socket acquired via socket activation. The semantics are
similar to the same option of
C<StandardInput>.

The C<fd> option connects
the output stream to a single file descriptor provided by a socket unit.
A custom named file descriptor can be specified as part of this option,
after a C<:> (e.g. C<fd:foobar>).
If no name is specified, C<stdout> is assumed
(i.e. C<fd> is equivalent to C<fd:stdout>).
At least one socket unit defining such name must be explicitly provided via the
C<Sockets> option, and file descriptor name may differ
from the name of its containing socket unit.
If multiple matches are found, the first one will be used.
See C<FileDescriptorName> in
L<systemd.socket(5)>
for more details about named descriptors and ordering.

If the standard output (or error output, see below) of a unit is connected to the journal, syslog or the
kernel log buffer, the unit will implicitly gain a dependency of type C<After> on
systemd-journald.socket (also see the automatic dependencies section above).

This setting defaults to the value set with
C<DefaultStandardOutput> in
L<systemd-system.conf(5)>,
which defaults to C<journal>. Note that setting
this parameter might result in additional dependencies to be
added to the unit (see above). I< Optional. Type enum. choice: 'inherit', 'null', 'tty', 'journal', 'syslog', 'kmsg', 'journal+console', 'syslog+console', 'kmsg+console', 'socket', 'fd'.  > 

=head2 StandardError

Controls where file descriptor 2 (STDERR) of
the executed processes is connected to. The available options
are identical to those of C<StandardOutput>,
with some exceptions: if set to C<inherit> the
file descriptor used for standard output is duplicated for
standard error, while C<fd> operates on the error
stream and will look by default for a descriptor named
C<stderr>.

This setting defaults to the value set with
C<DefaultStandardError> in
L<systemd-system.conf(5)>,
which defaults to C<inherit>. Note that setting
this parameter might result in additional dependencies to be
added to the unit (see above). I< Optional. Type uniline.  > 

=head2 TTYPath

Sets the terminal device node to use if
standard input, output, or error are connected to a TTY (see
above). Defaults to
/dev/console. I< Optional. Type uniline.  > 

=head2 TTYReset

Reset the terminal device specified with
C<TTYPath> before and after execution.
Defaults to C<no>. I< Optional. Type uniline.  > 

=head2 TTYVHangup

Disconnect all clients which have opened the
terminal device specified with C<TTYPath>
before and after execution. Defaults to
C<no>. I< Optional. Type uniline.  > 

=head2 TTYVTDisallocate

If the terminal device specified with
C<TTYPath> is a virtual console terminal, try
to deallocate the TTY before and after execution. This ensures
that the screen and scrollback buffer is cleared. Defaults to
C<no>. I< Optional. Type uniline.  > 

=head2 SyslogIdentifier

Sets the process name to prefix log lines sent
to the logging system or the kernel log buffer with. If not
set, defaults to the process name of the executed process.
This option is only useful when
C<StandardOutput> or
C<StandardError> are set to
C<syslog>, C<journal> or
C<kmsg> (or to the same settings in combination
with C<+console>). I< Optional. Type uniline.  > 

=head2 SyslogFacility

Sets the syslog facility to use when logging
to syslog. One of C<kern>,
C<user>, C<mail>,
C<daemon>, C<auth>,
C<syslog>, C<lpr>,
C<news>, C<uucp>,
C<cron>, C<authpriv>,
C<ftp>, C<local0>,
C<local1>, C<local2>,
C<local3>, C<local4>,
C<local5>, C<local6> or
C<local7>. See
L<syslog(3)>
for details. This option is only useful when
C<StandardOutput> or
C<StandardError> are set to
C<syslog>. Defaults to
C<daemon>. I< Optional. Type uniline.  > 

=head2 SyslogLevel

The default syslog level to use when logging to
syslog or the kernel log buffer. One of
C<emerg>,
C<alert>,
C<crit>,
C<err>,
C<warning>,
C<notice>,
C<info>,
C<debug>. See
L<syslog(3)>
for details. This option is only useful when
C<StandardOutput> or
C<StandardError> are set to
C<syslog> or C<kmsg>. Note that
individual lines output by the daemon might be prefixed with a
different log level which can be used to override the default
log level specified here. The interpretation of these prefixes
may be disabled with C<SyslogLevelPrefix>,
see below. For details, see
L<sd-daemon(3)>.
Defaults to
C<info>. I< Optional. Type uniline.  > 

=head2 SyslogLevelPrefix

Takes a boolean argument. If true and
C<StandardOutput> or
C<StandardError> are set to
C<syslog>, C<kmsg> or
C<journal>, log lines written by the executed
process that are prefixed with a log level will be passed on
to syslog with this log level set but the prefix removed. If
set to false, the interpretation of these prefixes is disabled
and the logged lines are passed on as-is. For details about
this prefixing see
L<sd-daemon(3)>.
Defaults to true. I< Optional. Type boolean.  > 

=head2 TimerSlackNSec

Sets the timer slack in nanoseconds for the
executed processes. The timer slack controls the accuracy of
wake-ups triggered by timers. See
L<prctl(2)>
for more information. Note that in contrast to most other time
span definitions this parameter takes an integer value in
nano-seconds if no unit is specified. The usual time units are
understood too. I< Optional. Type uniline.  > 

=head2 LimitCPU

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitFSIZE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitDATA

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitSTACK

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitCORE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitRSS

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitNOFILE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitAS

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitNPROC

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitMEMLOCK

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitLOCKS

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitSIGPENDING

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitMSGQUEUE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitNICE

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitRTPRIO

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 LimitRTTIME

Set soft and hard limits on various resources for executed processes. See
L<setrlimit(2)> for details on
the resource limit concept. Resource limits may be specified in two formats: either as single value to set a
specific soft and hard limit to the same value, or as colon-separated pair C<soft:hard> to set
both limits individually (e.g. C<LimitAS=4G:16G>).  Use the string C<infinity>
to configure no limit on a specific resource. The multiplicative suffixes K, M, G, T, P and E (to the base
1024) may be used for resource limits measured in bytes (e.g. LimitAS=16G). For the limits referring to time
values, the usual time units ms, s, min, h and so on may be used (see
L<systemd.time(7)> for
details). Note that if no time unit is specified for C<LimitCPU> the default unit of seconds
is implied, while for C<LimitRTTIME> the default unit of microseconds is implied. Also, note
that the effective granularity of the limits might influence their enforcement. For example, time limits
specified for C<LimitCPU> will be rounded up implicitly to multiples of 1s. For
C<LimitNICE> the value may be specified in two syntaxes: if prefixed with C<+>
or C<->, the value is understood as regular Linux nice value in the range -20..19. If not
prefixed like this the value is understood as raw resource limit parameter in the range 0..40 (with 0 being
equivalent to 1).

Note that most process resource limits configured with
these options are per-process, and processes may fork in order
to acquire a new set of resources that are accounted
independently of the original process, and may thus escape
limits set. Also note that C<LimitRSS> is not
implemented on Linux, and setting it has no effect. Often it
is advisable to prefer the resource controls listed in
L<systemd.resource-control(5)>
over these per-process limits, as they apply to services as a
whole, may be altered dynamically at runtime, and are
generally more expressive. For example,
C<MemoryLimit> is a more powerful (and
working) replacement for C<LimitRSS>.

For system units these resource limits may be chosen freely. For user units however (i.e. units run by a
per-user instance of
L<systemd(1)>), these limits are
bound by (possibly more restrictive) per-user limits enforced by the OS.

Resource limits not configured explicitly for a unit default to the value configured in the various
C<DefaultLimitCPU>, C<DefaultLimitFSIZE>, … options available in
L<systemd-system.conf(5)>, and –
if not configured there – the kernel or per-user defaults, as defined by the OS (the latter only for user
services, see above). I< Optional. Type uniline.  > 

=head2 PAMName

Sets the PAM service name to set up a session
as. If set, the executed process will be registered as a PAM
session under the specified service name. This is only useful
in conjunction with the C<User> setting. If
not set, no PAM session will be opened for the executed
processes. See
L<pam(8)>
for details. I< Optional. Type uniline.  > 

=head2 CapabilityBoundingSet

Controls which capabilities to include in the capability bounding set for the executed
process. See L<capabilities(7)> for
details. Takes a whitespace-separated list of capability names, e.g. C<CAP_SYS_ADMIN>,
C<CAP_DAC_OVERRIDE>, C<CAP_SYS_PTRACE>. Capabilities listed will be
included in the bounding set, all others are removed. If the list of capabilities is prefixed with
C<~>, all but the listed capabilities will be included, the effect of the assignment
inverted. Note that this option also affects the respective capabilities in the effective, permitted and
inheritable capability sets. If this option is not used, the capability bounding set is not modified on process
execution, hence no limits on the capabilities of the process are enforced. This option may appear more than
once, in which case the bounding sets are merged. If the empty string is assigned to this option, the bounding
set is reset to the empty capability set, and all prior settings have no effect.  If set to
C<~> (without any further argument), the bounding set is reset to the full set of available
capabilities, also undoing any previous settings. This does not affect commands prefixed with
C<+>. I< Optional. Type uniline.  > 

=head2 AmbientCapabilities

Controls which capabilities to include in the ambient capability set for the executed
process. Takes a whitespace-separated list of capability names, e.g. C<CAP_SYS_ADMIN>,
C<CAP_DAC_OVERRIDE>, C<CAP_SYS_PTRACE>. This option may appear more than
once in which case the ambient capability sets are merged.  If the list of capabilities is prefixed with
C<~>, all but the listed capabilities will be included, the effect of the assignment
inverted. If the empty string is assigned to this option, the ambient capability set is reset to the empty
capability set, and all prior settings have no effect.  If set to C<~> (without any further
argument), the ambient capability set is reset to the full set of available capabilities, also undoing any
previous settings. Note that adding capabilities to ambient capability set adds them to the process's inherited
capability set.  

 Ambient capability sets are useful if you want to execute a process as a
non-privileged user but still want to give it some capabilities.  Note that in this case option
C<keep-caps> is automatically added to C<SecureBits> to retain the
capabilities over the user change. C<AmbientCapabilities> does not affect commands prefixed
with C<+>. I< Optional. Type uniline.  > 

=head2 SecureBits

Controls the secure bits set for the executed
process. Takes a space-separated combination of options from
the following list:
C<keep-caps>,
C<keep-caps-locked>,
C<no-setuid-fixup>,
C<no-setuid-fixup-locked>,
C<noroot>, and
C<noroot-locked>.
This option may appear more than once, in which case the secure
bits are ORed. If the empty string is assigned to this option,
the bits are reset to 0. This does not affect commands prefixed with C<+>.
See L<capabilities(7)>
for details. I< Optional. Type uniline.  > 

=head2 ReadWritePaths

Sets up a new file system namespace for executed processes. These options may be used to limit
access a process might have to the file system hierarchy. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager).  Note that if paths
contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace with the same
access modes as from outside of it. Paths listed in C<ReadOnlyPaths> are accessible for
reading only, writing will be refused even if the usual file access controls would permit this. Nest
C<ReadWritePaths> inside of C<ReadOnlyPaths> in order to provide writable
subdirectories within read-only directories. Use C<ReadWritePaths> in order to whitelist
specific paths for write access if C<ProtectSystem=strict> is used. Paths listed in
C<InaccessiblePaths> will be made inaccessible for processes inside the namespace (along with
everything below them in the file system hierarchy).

Note that restricting access with these options does not extend to submounts of a directory that are
created later on.  Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths> and
C<InaccessiblePaths> may be prefixed with C<->, in which case they will be ignored
when they do not exist. Note that using this setting will disconnect propagation of mounts from the service to
the host (propagation in the opposite direction continues to work). This means that this setting may not be used
for services which shall be able to install mount points in the main mount namespace. Note that the effect of
these settings may be undone by privileged processes. In order to set up an effective sandboxed environment for
a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>. I< Optional. Type list of uniline.  > 

=head2 ReadOnlyPaths

Sets up a new file system namespace for executed processes. These options may be used to limit
access a process might have to the file system hierarchy. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager).  Note that if paths
contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace with the same
access modes as from outside of it. Paths listed in C<ReadOnlyPaths> are accessible for
reading only, writing will be refused even if the usual file access controls would permit this. Nest
C<ReadWritePaths> inside of C<ReadOnlyPaths> in order to provide writable
subdirectories within read-only directories. Use C<ReadWritePaths> in order to whitelist
specific paths for write access if C<ProtectSystem=strict> is used. Paths listed in
C<InaccessiblePaths> will be made inaccessible for processes inside the namespace (along with
everything below them in the file system hierarchy).

Note that restricting access with these options does not extend to submounts of a directory that are
created later on.  Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths> and
C<InaccessiblePaths> may be prefixed with C<->, in which case they will be ignored
when they do not exist. Note that using this setting will disconnect propagation of mounts from the service to
the host (propagation in the opposite direction continues to work). This means that this setting may not be used
for services which shall be able to install mount points in the main mount namespace. Note that the effect of
these settings may be undone by privileged processes. In order to set up an effective sandboxed environment for
a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>. I< Optional. Type list of uniline.  > 

=head2 InaccessiblePaths

Sets up a new file system namespace for executed processes. These options may be used to limit
access a process might have to the file system hierarchy. Each setting takes a space-separated list of paths
relative to the host's root directory (i.e. the system running the service manager).  Note that if paths
contain symlinks, they are resolved relative to the root directory set with
C<RootDirectory>.

Paths listed in C<ReadWritePaths> are accessible from within the namespace with the same
access modes as from outside of it. Paths listed in C<ReadOnlyPaths> are accessible for
reading only, writing will be refused even if the usual file access controls would permit this. Nest
C<ReadWritePaths> inside of C<ReadOnlyPaths> in order to provide writable
subdirectories within read-only directories. Use C<ReadWritePaths> in order to whitelist
specific paths for write access if C<ProtectSystem=strict> is used. Paths listed in
C<InaccessiblePaths> will be made inaccessible for processes inside the namespace (along with
everything below them in the file system hierarchy).

Note that restricting access with these options does not extend to submounts of a directory that are
created later on.  Non-directory paths may be specified as well. These options may be specified more than once,
in which case all paths listed will have limited access from within the namespace. If the empty string is
assigned to this option, the specific list is reset, and all prior assignments have no effect.

Paths in C<ReadWritePaths>, C<ReadOnlyPaths> and
C<InaccessiblePaths> may be prefixed with C<->, in which case they will be ignored
when they do not exist. Note that using this setting will disconnect propagation of mounts from the service to
the host (propagation in the opposite direction continues to work). This means that this setting may not be used
for services which shall be able to install mount points in the main mount namespace. Note that the effect of
these settings may be undone by privileged processes. In order to set up an effective sandboxed environment for
a unit it is thus recommended to combine these settings with either
C<CapabilityBoundingSet=~CAP_SYS_ADMIN> or C<SystemCallFilter=~@mount>. I< Optional. Type list of uniline.  > 

=head2 PrivateTmp

Takes a boolean argument. If true, sets up a new file system namespace for the executed
processes and mounts private /tmp and /var/tmp directories inside it
that is not shared by processes outside of the namespace. This is useful to secure access to temporary files of
the process, but makes sharing between processes via /tmp or /var/tmp
impossible. If this is enabled, all temporary files created by a service in these directories will be removed
after the service is stopped.  Defaults to false. It is possible to run two or more units within the same
private /tmp and /var/tmp namespace by using the
C<JoinsNamespaceOf> directive, see
L<systemd.unit(5)> for
details. This setting is implied if C<DynamicUser> is set. For this setting the same
restrictions regarding mount propagation and privileges apply as for C<ReadOnlyPaths> and
related calls, see above. I< Optional. Type boolean.  > 

=head2 PrivateDevices

Takes a boolean argument. If true, sets up a new /dev namespace for the executed processes and
only adds API pseudo devices such as /dev/null, /dev/zero or
/dev/random (as well as the pseudo TTY subsystem) to it, but no physical devices such as
/dev/sda, system memory /dev/mem, system ports
/dev/port and others. This is useful to securely turn off physical device access by the
executed process. Defaults to false. Enabling this option will install a system call filter to block low-level
I/O system calls that are grouped in the C<@raw-io> set, will also remove
C<CAP_MKNOD> and C<CAP_SYS_RAWIO> from the capability bounding set for
the unit (see above), and set C<DevicePolicy=closed> (see
L<systemd.resource-control(5)>
for details). Note that using this setting will disconnect propagation of mounts from the service to the host
(propagation in the opposite direction continues to work).  This means that this setting may not be used for
services which shall be able to install mount points in the main mount namespace. The /dev namespace will be
mounted read-only and 'noexec'.  The latter may break old programs which try to set up executable memory by
using L<mmap(2)> of
/dev/zero instead of using C<MAP_ANON>. This setting is implied if
C<DynamicUser> is set. For this setting the same restrictions regarding mount propagation and
privileges apply as for C<ReadOnlyPaths> and related calls, see above. I< Optional. Type boolean.  > 

=head2 PrivateNetwork

Takes a boolean argument. If true, sets up a
new network namespace for the executed processes and
configures only the loopback network device
C<lo> inside it. No other network devices will
be available to the executed process. This is useful to
securely turn off network access by the executed process.
Defaults to false. It is possible to run two or more units
within the same private network namespace by using the
C<JoinsNamespaceOf> directive, see
L<systemd.unit(5)>
for details. Note that this option will disconnect all socket
families from the host, this includes AF_NETLINK and AF_UNIX.
The latter has the effect that AF_UNIX sockets in the abstract
socket namespace will become unavailable to the processes
(however, those located in the file system will continue to be
accessible). I< Optional. Type boolean.  > 

=head2 PrivateUsers

Takes a boolean argument. If true, sets up a new user namespace for the executed processes and
configures a minimal user and group mapping, that maps the C<root> user and group as well as
the unit's own user and group to themselves and everything else to the C<nobody> user and
group. This is useful to securely detach the user and group databases used by the unit from the rest of the
system, and thus to create an effective sandbox environment. All files, directories, processes, IPC objects and
other resources owned by users/groups not equaling C<root> or the unit's own will stay visible
from within the unit but appear owned by the C<nobody> user and group. If this mode is enabled,
all unit processes are run without privileges in the host user namespace (regardless if the unit's own
user/group is C<root> or not). Specifically this means that the process will have zero process
capabilities on the host's user namespace, but full capabilities within the service's user namespace. Settings
such as C<CapabilityBoundingSet> will affect only the latter, and there's no way to acquire
additional capabilities in the host's user namespace. Defaults to off.

This setting is particularly useful in conjunction with C<RootDirectory>, as the need to
synchronize the user and group databases in the root directory and on the host is reduced, as the only users
and groups who need to be matched are C<root>, C<nobody> and the unit's own
user and group. I< Optional. Type boolean.  > 

=head2 ProtectSystem

Takes a boolean argument or the special values C<full> or
C<strict>. If true, mounts the /usr and /boot
directories read-only for processes invoked by this unit. If set to C<full>, the
/etc directory is mounted read-only, too. If set to C<strict> the entire
file system hierarchy is mounted read-only, except for the API file system subtrees /dev,
/proc and /sys (protect these directories using
C<PrivateDevices>, C<ProtectKernelTunables>,
C<ProtectControlGroups>). This setting ensures that any modification of the vendor-supplied
operating system (and optionally its configuration, and local mounts) is prohibited for the service.  It is
recommended to enable this setting for all long-running services, unless they are involved with system updates
or need to modify the operating system in other ways. If this option is used,
C<ReadWritePaths> may be used to exclude specific directories from being made read-only. This
setting is implied if C<DynamicUser> is set. For this setting the same restrictions regarding
mount propagation and privileges apply as for C<ReadOnlyPaths> and related calls, see
above. Defaults to off. I< Optional. Type enum. choice: 'no', 'yes', 'full', 'strict'.  > 

=head2 ProtectHome

Takes a boolean argument or C<read-only>. If true, the directories
/home, /root and /run/user are made inaccessible
and empty for processes invoked by this unit. If set to C<read-only>, the three directories are
made read-only instead. It is recommended to enable this setting for all long-running services (in particular
network-facing ones), to ensure they cannot get access to private user data, unless the services actually
require access to the user's private data. This setting is implied if C<DynamicUser> is
set. For this setting the same restrictions regarding mount propagation and privileges apply as for
C<ReadOnlyPaths> and related calls, see above. I< Optional. Type enum. choice: 'no', 'yes', 'read-only'.  > 

=head2 ProtectKernelTunables

Takes a boolean argument. If true, kernel variables accessible through
/proc/sys, /sys, /proc/sysrq-trigger,
/proc/latency_stats, /proc/acpi,
/proc/timer_stats, /proc/fs and /proc/irq will
be made read-only to all processes of the unit. Usually, tunable kernel variables should only be written at
boot-time, with the L<sysctl.d(5)>
mechanism. Almost no services need to write to these at runtime; it is hence recommended to turn this on for
most services. For this setting the same restrictions regarding mount propagation and privileges apply as for
C<ReadOnlyPaths> and related calls, see above. Defaults to off.
Note that this option does not prevent kernel tuning through IPC interfaces and external programs. However
C<InaccessiblePaths> can be used to make some IPC file system objects
inaccessible. I< Optional. Type boolean.  > 

=head2 ProtectControlGroups

Takes a boolean argument. If true, the Linux Control Groups (L<cgroups(7)>) hierarchies
accessible through /sys/fs/cgroup will be made read-only to all processes of the
unit. Except for container managers no services should require write access to the control groups hierarchies;
it is hence recommended to turn this on for most services. For this setting the same restrictions regarding
mount propagation and privileges apply as for C<ReadOnlyPaths> and related calls, see
above. Defaults to off. I< Optional. Type boolean.  > 

=head2 MountFlags

Takes a mount propagation flag: C<shared>, C<slave> or
C<private>, which control whether mounts in the file system namespace set up for this unit's
processes will receive or propagate mounts or unmounts. See L<mount(2)> for
details. Defaults to C<shared>. Use C<shared> to ensure that mounts and unmounts
are propagated from the host to the container and vice versa. Use C<slave> to run processes so
that none of their mounts and unmounts will propagate to the host. Use C<private> to also ensure
that no mounts and unmounts from the host will propagate into the unit processes' namespace. Note that
C<slave> means that file systems mounted on the host might stay mounted continuously in the
unit's namespace, and thus keep the device busy. Note that the file system namespace related options
(C<PrivateTmp>, C<PrivateDevices>, C<ProtectSystem>,
C<ProtectHome>, C<ProtectKernelTunables>,
C<ProtectControlGroups>, C<ReadOnlyPaths>,
C<InaccessiblePaths>, C<ReadWritePaths>) require that mount and unmount
propagation from the unit's file system namespace is disabled, and hence downgrade C<shared> to
C<slave>. I< Optional. Type uniline.  > 

=head2 UtmpIdentifier

Takes a four character identifier string for
an L<utmp(5)>
and wtmp entry for this service. This should only be
set for services such as getty
implementations (such as L<agetty(8)>)
where utmp/wtmp entries must be created and cleared before and
after execution, or for services that shall be executed as if
they were run by a getty process (see
below). If the configured string is longer than four
characters, it is truncated and the terminal four characters
are used. This setting interprets %I style string
replacements. This setting is unset by default, i.e. no
utmp/wtmp entries are created or cleaned up for this
service. I< Optional. Type uniline.  > 

=head2 UtmpMode

Takes one of C<init>,
C<login> or C<user>. If
C<UtmpIdentifier> is set, controls which
type of L<utmp(5)>/wtmp
entries for this service are generated. This setting has no
effect unless C<UtmpIdentifier> is set
too. If C<init> is set, only an
C<INIT_PROCESS> entry is generated and the
invoked process must implement a
getty-compatible utmp/wtmp logic. If
C<login> is set, first an
C<INIT_PROCESS> entry, followed by a
C<LOGIN_PROCESS> entry is generated. In
this case, the invoked process must implement a L<login(1)>-compatible
utmp/wtmp logic. If C<user> is set, first an
C<INIT_PROCESS> entry, then a
C<LOGIN_PROCESS> entry and finally a
C<USER_PROCESS> entry is generated. In this
case, the invoked process may be any process that is suitable
to be run as session leader. Defaults to
C<init>. I< Optional. Type enum. choice: 'init', 'login', 'user'.  > 

=head2 SELinuxContext

Set the SELinux security context of the
executed process. If set, this will override the automated
domain transition. However, the policy still needs to
authorize the transition. This directive is ignored if SELinux
is disabled. If prefixed by C<->, all errors
will be ignored. This does not affect commands prefixed with C<+>.
See L<setexeccon(3)>
for details. I< Optional. Type uniline.  > 

=head2 AppArmorProfile

Takes a profile name as argument. The process
executed by the unit will switch to this profile when started.
Profiles must already be loaded in the kernel, or the unit
will fail. This result in a non operation if AppArmor is not
enabled. If prefixed by C<->, all errors will
be ignored. This does not affect commands prefixed with C<+>. I< Optional. Type uniline.  > 

=head2 SmackProcessLabel

Takes a C<SMACK64> security
label as argument. The process executed by the unit will be
started under this label and SMACK will decide whether the
process is allowed to run or not, based on it. The process
will continue to run under the label specified here unless the
executable has its own C<SMACK64EXEC> label, in
which case the process will transition to run under that
label. When not specified, the label that systemd is running
under is used. This directive is ignored if SMACK is
disabled.

The value may be prefixed by C<->, in
which case all errors will be ignored. An empty value may be
specified to unset previous assignments. This does not affect
commands prefixed with C<+>. I< Optional. Type uniline.  > 

=head2 IgnoreSIGPIPE

Takes a boolean argument. If true, causes
C<SIGPIPE> to be ignored in the executed
process. Defaults to true because C<SIGPIPE>
generally is useful only in shell pipelines. I< Optional. Type boolean.  > 

=head2 NoNewPrivileges

Takes a boolean argument. If true, ensures that the service
process and all its children can never gain new privileges. This option is more
powerful than the respective secure bits flags (see above), as it also prohibits
UID changes of any kind. This is the simplest and most effective way to ensure that
a process and its children can never elevate privileges again. Defaults to false,
but in the user manager instance certain settings force
C<NoNewPrivileges=yes>, ignoring the value of this setting.
Those is the case when C<SystemCallFilter>,
C<SystemCallArchitectures>,
C<RestrictAddressFamilies>,
C<PrivateDevices>,
C<ProtectKernelTunables>,
C<ProtectKernelModules>,
C<MemoryDenyWriteExecute>, or
C<RestrictRealtime> are specified.
I< Optional. Type boolean.  > 

=head2 SystemCallFilter

Takes a space-separated list of system call names. If this setting is used, all system calls
executed by the unit processes except for the listed ones will result in immediate process termination with the
C<SIGSYS> signal (whitelisting). If the first character of the list is C<~>,
the effect is inverted: only the listed system calls will result in immediate process termination
(blacklisting). If running in user mode, or in system mode, but without the C<CAP_SYS_ADMIN>
capability (e.g. setting C<User=nobody>), C<NoNewPrivileges=yes> is
implied. This feature makes use of the Secure Computing Mode 2 interfaces of the kernel ('seccomp filtering')
and is useful for enforcing a minimal sandboxing environment. Note that the execve,
exit, exit_group, getrlimit,
rt_sigreturn, sigreturn system calls and the system calls for
querying time and sleeping are implicitly whitelisted and do not need to be listed explicitly. This option may
be specified more than once, in which case the filter masks are merged. If the empty string is assigned, the
filter is reset, all prior assignments will have no effect. This does not affect commands prefixed with
C<+>.

Note that strict system call filters may impact execution and error handling code paths of the service
invocation. Specifically, access to the execve system call is required for the execution
of the service binary — if it is blocked service invocation will necessarily fail. Also, if execution of the
service binary fails for some reason (for example: missing service executable), the error handling logic might
require access to an additional set of system calls in order to process and log this failure correctly. It
might be necessary to temporarily disable system call filters in order to simplify debugging of such
failures.

If you specify both types of this option (i.e.
whitelisting and blacklisting), the first encountered will
take precedence and will dictate the default action
(termination or approval of a system call). Then the next
occurrences of this option will add or delete the listed
system calls from the set of the filtered system calls,
depending of its type and the default action. (For example, if
you have started with a whitelisting of
read and write, and
right after it add a blacklisting of
write, then write
will be removed from the set.)

As the number of possible system
calls is large, predefined sets of system calls are provided.
A set starts with C<@> character, followed by
name of the set.
Currently predefined system call setsSetDescription@basic-ioSystem calls for basic I/O: reading, writing, seeking, file descriptor duplication and closing (L<read(2)>, L<write(2)>, and related calls)@clockSystem calls for changing the system clock (L<adjtimex(2)>, L<settimeofday(2)>, and related calls)@cpu-emulationSystem calls for CPU emulation functionality (L<vm86(2)> and related calls)@debugDebugging, performance monitoring and tracing functionality (L<ptrace(2)>, L<perf_event_open(2)> and related calls)@io-eventEvent loop system calls (L<poll(2)>, L<select(2)>, L<epoll(7)>, L<eventfd(2)> and related calls)@ipcPipes, SysV IPC, POSIX Message Queues and other IPC (L<mq_overview(7)>, L<svipc(7)>)@keyringKernel keyring access (L<keyctl(2)> and related calls)@moduleKernel module control (L<init_module(2)>, L<delete_module(2)> and related calls)@mountFile system mounting and unmounting (L<mount(2)>, L<chroot(2)>, and related calls)@network-ioSocket I/O (including local AF_UNIX): L<socket(7)>, L<unix(7)>@obsoleteUnusual, obsolete or unimplemented (L<create_module(2)>, L<gtty(2)>, …)@privilegedAll system calls which need super-user capabilities (L<capabilities(7)>)@processProcess control, execution, namespaces (L<clone(2)>, L<kill(2)>, L<namespaces(7)>, …@raw-ioRaw I/O port access (L<ioperm(2)>, L<iopl(2)>, pciconfig_read(), …)@resourcesSystem calls for changing resource limits, memory and scheduling parameters (L<setrlimit(2)>, L<setpriority(2)>, …)
Note that as new system calls are added to the kernel, additional system calls might be added to the groups
above, so the contents of the sets may change between systemd versions.

It is recommended to combine the file system namespacing related options with
C<SystemCallFilter=~@mount>, in order to prohibit the unit's processes to undo the
mappings. Specifically these are the options C<PrivateTmp>,
C<PrivateDevices>, C<ProtectSystem>, C<ProtectHome>,
C<ProtectKernelTunables>, C<ProtectControlGroups>,
C<ReadOnlyPaths>, C<InaccessiblePaths> and
C<ReadWritePaths>. I< Optional. Type list of uniline.  > 

=head2 SystemCallErrorNumber

Takes an C<errno> error number
name to return when the system call filter configured with
C<SystemCallFilter> is triggered, instead of
terminating the process immediately. Takes an error name such
as C<EPERM>, C<EACCES> or
C<EUCLEAN>. When this setting is not used,
or when the empty string is assigned, the process will be
terminated immediately when the filter is
triggered. I< Optional. Type uniline.  > 

=head2 SystemCallArchitectures

Takes a space-separated list of architecture identifiers to
include in the system call filter. The known architecture identifiers are the same
as for C<ConditionArchitecture> described in
L<systemd.unit(5)>,
as well as C<x32>, C<mips64-n32>,
C<mips64-le-n32>, and the special identifier
C<native>. Only system calls of the specified architectures will
be permitted to processes of this unit. This is an effective way to disable
compatibility with non-native architectures for processes, for example to prohibit
execution of 32-bit x86 binaries on 64-bit x86-64 systems. The special
C<native> identifier implicitly maps to the native architecture
of the system (or more strictly: to the architecture the system manager is
compiled for). If running in user mode, or in system mode, but without the
C<CAP_SYS_ADMIN> capability (e.g. setting
C<User=nobody>), C<NoNewPrivileges=yes> is
implied. Note that setting this option to a non-empty list implies that
C<native> is included too. By default, this option is set to the
empty list, i.e. no architecture system call filtering is applied.
I< Optional. Type uniline.  > 

=head2 RestrictAddressFamilies

Restricts the set of socket address families
accessible to the processes of this unit. Takes a
space-separated list of address family names to whitelist,
such as
C<AF_UNIX>,
C<AF_INET> or
C<AF_INET6>. When
prefixed with C<~> the listed address
families will be applied as blacklist, otherwise as whitelist.
Note that this restricts access to the
L<socket(2)>
system call only. Sockets passed into the process by other
means (for example, by using socket activation with socket
units, see
L<systemd.socket(5)>)
are unaffected. Also, sockets created with
socketpair() (which creates connected
AF_UNIX sockets only) are unaffected. Note that this option
has no effect on 32-bit x86 and is ignored (but works
correctly on x86-64). If running in user mode, or in system
mode, but without the C<CAP_SYS_ADMIN>
capability (e.g. setting C<User=nobody>),
C<NoNewPrivileges=yes> is implied. By
default, no restriction applies, all address families are
accessible to processes. If assigned the empty string, any
previous list changes are undone.

Use this option to limit exposure of processes to remote
systems, in particular via exotic network protocols. Note that
in most cases, the local C<AF_UNIX> address
family should be included in the configured whitelist as it is
frequently used for local communication, including for
L<syslog(2)>
logging. This does not affect commands prefixed with C<+>. I< Optional. Type uniline.  > 

=head2 ProtectKernelModules

Takes a boolean argument. If true, explicit module loading will
be denied. This allows to turn off module load and unload operations on modular
kernels. It is recommended to turn this on for most services that do not need special
file systems or extra kernel modules to work. Default to off. Enabling this option
removes C<CAP_SYS_MODULE> from the capability bounding set for
the unit, and installs a system call filter to block module system calls,
also /usr/lib/modules is made inaccessible. For this
setting the same restrictions regarding mount propagation and privileges
apply as for C<ReadOnlyPaths> and related calls, see above.
Note that limited automatic module loading due to user configuration or kernel
mapping tables might still happen as side effect of requested user operations,
both privileged and unprivileged. To disable module auto-load feature please see
L<sysctl.d(5)>C<kernel.modules_disabled> mechanism and
/proc/sys/kernel/modules_disabled documentation. I< Optional. Type boolean.  > 

=head2 Personality

Controls which kernel architecture L<uname(2)> shall report,
when invoked by unit processes. Takes one of the architecture identifiers C<x86>,
C<x86-64>, C<ppc>, C<ppc-le>, C<ppc64>,
C<ppc64-le>, C<s390> or C<s390x>. Which personality
architectures are supported depends on the system architecture. Usually the 64bit versions of the various
system architectures support their immediate 32bit personality architecture counterpart, but no others. For
example, C<x86-64> systems support the C<x86-64> and
C<x86> personalities but no others. The personality feature is useful when running 32-bit
services on a 64-bit host system. If not specified, the personality is left unmodified and thus reflects the
personality of the host system's kernel. I< Optional. Type enum. choice: 'x86', 'x86-64', 'ppc', 'ppc-le', 'ppc64', 'ppc64-le', 's390', 's390x'.  > 

=head2 RuntimeDirectory

Takes a list of directory names. If set, one
or more directories by the specified names will be created
below /run (for system services) or below
C<$XDG_RUNTIME_DIR> (for user services) when
the unit is started, and removed when the unit is stopped. The
directories will have the access mode specified in
C<RuntimeDirectoryMode>, and will be owned by
the user and group specified in C<User> and
C<Group>. Use this to manage one or more
runtime directories of the unit and bind their lifetime to the
daemon runtime. The specified directory names must be
relative, and may not include a C</>, i.e.
must refer to simple directories to create or remove. This is
particularly useful for unprivileged daemons that cannot
create runtime directories in /run due to
lack of privileges, and to make sure the runtime directory is
cleaned up automatically after use. For runtime directories
that require more complex or different configuration or
lifetime guarantees, please consider using
L<tmpfiles.d(5)>. I< Optional. Type uniline.  > 

=head2 RuntimeDirectoryMode

Takes a list of directory names. If set, one
or more directories by the specified names will be created
below /run (for system services) or below
C<$XDG_RUNTIME_DIR> (for user services) when
the unit is started, and removed when the unit is stopped. The
directories will have the access mode specified in
C<RuntimeDirectoryMode>, and will be owned by
the user and group specified in C<User> and
C<Group>. Use this to manage one or more
runtime directories of the unit and bind their lifetime to the
daemon runtime. The specified directory names must be
relative, and may not include a C</>, i.e.
must refer to simple directories to create or remove. This is
particularly useful for unprivileged daemons that cannot
create runtime directories in /run due to
lack of privileges, and to make sure the runtime directory is
cleaned up automatically after use. For runtime directories
that require more complex or different configuration or
lifetime guarantees, please consider using
L<tmpfiles.d(5)>. I< Optional. Type uniline.  > 

=head2 MemoryDenyWriteExecute

Takes a boolean argument. If set, attempts to create memory mappings that are writable and
executable at the same time, or to change existing memory mappings to become executable, or mapping shared memory
segments as executable are prohibited.
Specifically, a system call filter is added that rejects
L<mmap(2)>
system calls with both C<PROT_EXEC> and C<PROT_WRITE> set,
L<mprotect(2)>
system calls with C<PROT_EXEC> set and
L<shmat(2)>
system calls with C<SHM_EXEC> set. Note that this option is incompatible with programs
that generate program code dynamically at runtime, such as JIT execution engines, or programs compiled making
use of the code "trampoline" feature of various C compilers. This option improves service security, as it makes
harder for software exploits to change running code dynamically.
I< Optional. Type boolean.  > 

=head2 RestrictRealtime

Takes a boolean argument. If set, any attempts to enable realtime scheduling in a process of
the unit are refused. This restricts access to realtime task scheduling policies such as
C<SCHED_FIFO>, C<SCHED_RR> or C<SCHED_DEADLINE>. See
L<sched(7)> for details about
these scheduling policies. Realtime scheduling policies may be used to monopolize CPU time for longer periods
of time, and may hence be used to lock up or otherwise trigger Denial-of-Service situations on the system. It
is hence recommended to restrict access to realtime scheduling to the few programs that actually require
them. Defaults to off. I< Optional. Type boolean.  > 

=head2 KillMode

Specifies how processes of this unit shall be
killed. One of
C<control-group>,
C<process>,
C<mixed>,
C<none>.

If set to C<control-group>, all remaining
processes in the control group of this unit will be killed on
unit stop (for services: after the stop command is executed,
as configured with C<ExecStop>). If set to
C<process>, only the main process itself is
killed. If set to C<mixed>, the
C<SIGTERM> signal (see below) is sent to the
main process while the subsequent C<SIGKILL>
signal (see below) is sent to all remaining processes of the
unit's control group. If set to C<none>, no
process is killed. In this case, only the stop command will be
executed on unit stop, but no process be killed otherwise.
Processes remaining alive after stop are left in their control
group and the control group continues to exist after stop
unless it is empty.

Processes will first be terminated via
C<SIGTERM> (unless the signal to send is
changed via C<KillSignal>). Optionally, this
is immediately followed by a C<SIGHUP> (if
enabled with C<SendSIGHUP>). If then, after a
delay (configured via the C<TimeoutStopSec>
option), processes still remain, the termination request is
repeated with the C<SIGKILL> signal (unless
this is disabled via the C<SendSIGKILL>
option). See
L<kill(2)>
for more information.

Defaults to
C<control-group>. I< Optional. Type uniline.  > 

=head2 KillSignal

Specifies which signal to use when killing a
service. This controls the signal that is sent as first step
of shutting down a unit (see above), and is usually followed
by C<SIGKILL> (see above and below). For a
list of valid signals, see
L<signal(7)>.
Defaults to C<SIGTERM>. 

Note that, right after sending the signal specified in
this setting, systemd will always send
C<SIGCONT>, to ensure that even suspended
tasks can be terminated cleanly. I< Optional. Type uniline.  > 

=head2 SendSIGHUP

Specifies whether to send
C<SIGHUP> to remaining processes immediately
after sending the signal configured with
C<KillSignal>. This is useful to indicate to
shells and shell-like programs that their connection has been
severed. Takes a boolean value. Defaults to "no".
I< Optional. Type boolean.  > 

=head2 SendSIGKILL

Specifies whether to send
C<SIGKILL> to remaining processes after a
timeout, if the normal shutdown procedure left processes of
the service around. Takes a boolean value. Defaults to "yes".
I< Optional. Type boolean.  > 

=head2 Type

Configures the process start-up type for this
service unit. One of
C<simple>,
C<forking>,
C<oneshot>,
C<dbus>,
C<notify> or
C<idle>.

If set to C<simple> (the default if
neither C<Type> nor
C<BusName>, but C<ExecStart>
are specified), it is expected that the process configured
with C<ExecStart> is the main process of the
service. In this mode, if the process offers functionality to
other processes on the system, its communication channels
should be installed before the daemon is started up (e.g.
sockets set up by systemd, via socket activation), as systemd
will immediately proceed starting follow-up units.

If set to C<forking>, it is expected that
the process configured with C<ExecStart> will
call fork() as part of its start-up. The
parent process is expected to exit when start-up is complete
and all communication channels are set up. The child continues
to run as the main daemon process. This is the behavior of
traditional UNIX daemons. If this setting is used, it is
recommended to also use the C<PIDFile>
option, so that systemd can identify the main process of the
daemon. systemd will proceed with starting follow-up units as
soon as the parent process exits.

Behavior of C<oneshot> is similar to
C<simple>; however, it is expected that the
process has to exit before systemd starts follow-up units.
C<RemainAfterExit> is particularly useful for
this type of service. This is the implied default if neither
C<Type> or C<ExecStart> are
specified.

Behavior of C<dbus> is similar to
C<simple>; however, it is expected that the
daemon acquires a name on the D-Bus bus, as configured by
C<BusName>. systemd will proceed with
starting follow-up units after the D-Bus bus name has been
acquired. Service units with this option configured implicitly
gain dependencies on the dbus.socket
unit. This type is the default if C<BusName>
is specified.

Behavior of C<notify> is similar to
C<simple>; however, it is expected that the
daemon sends a notification message via
L<sd_notify(3)>
or an equivalent call when it has finished starting up.
systemd will proceed with starting follow-up units after this
notification message has been sent. If this option is used,
C<NotifyAccess> (see below) should be set to
open access to the notification socket provided by systemd. If
C<NotifyAccess> is missing or set to
C<none>, it will be forcibly set to
C<main>. Note that currently
C<Type>C<notify> will not work
if used in combination with
C<PrivateNetwork>C<yes>.

Behavior of C<idle> is very similar to C<simple>; however, actual execution
of the service binary is delayed until all active jobs are dispatched. This may be used to avoid interleaving
of output of shell services with the status output on the console. Note that this type is useful only to
improve console output, it is not useful as a general unit ordering tool, and the effect of this service type
is subject to a 5s time-out, after which the service binary is invoked anyway. I< Optional. Type uniline.  > 

=head2 RemainAfterExit

Takes a boolean value that specifies whether
the service shall be considered active even when all its
processes exited. Defaults to C<no>. I< Optional. Type boolean.  > 

=head2 GuessMainPID

Takes a boolean value that specifies whether
systemd should try to guess the main PID of a service if it
cannot be determined reliably. This option is ignored unless
C<Type=forking> is set and
C<PIDFile> is unset because for the other types
or with an explicitly configured PID file, the main PID is
always known. The guessing algorithm might come to incorrect
conclusions if a daemon consists of more than one process. If
the main PID cannot be determined, failure detection and
automatic restarting of a service will not work reliably.
Defaults to C<yes>. I< Optional. Type boolean.  > 

=head2 PIDFile

Takes an absolute file name pointing to the
PID file of this daemon. Use of this option is recommended for
services where C<Type> is set to
C<forking>. systemd will read the PID of the
main process of the daemon after start-up of the service.
systemd will not write to the file configured here, although
it will remove the file after the service has shut down if it
still exists.
I< Optional. Type uniline.  > 

=head2 BusName

Takes a D-Bus bus name that this service is
reachable as. This option is mandatory for services where
C<Type> is set to
C<dbus>. I< Optional. Type uniline.  > 

=head2 ExecStart

Commands with their arguments that are
executed when this service is started. The value is split into
zero or more command lines according to the rules described
below (see section "Command Lines" below).

Unless C<Type> is C<oneshot>, exactly one command must be given. When
C<Type=oneshot> is used, zero or more commands may be specified. Commands may be specified by
providing multiple command lines in the same directive, or alternatively, this directive may be specified more
than once with the same effect. If the empty string is assigned to this option, the list of commands to start
is reset, prior assignments of this option will have no effect. If no C<ExecStart> is
specified, then the service must have C<RemainAfterExit=yes> set.

For each of the specified commands, the first argument must be an absolute path to an
executable. Optionally, if this file name is prefixed with C<@>, the second token will be
passed as C<argv[0]> to the executed process, followed by the further arguments specified.  If
the absolute filename is prefixed with C<->, an exit code of the command normally considered a
failure (i.e. non-zero exit status or abnormal exit due to signal) is ignored and considered success.  If the
absolute path is prefixed with C<+> then it is executed with full
privileges. C<@>, C<->, and C<+> may be used together and they
can appear in any order.

If more than one command is specified, the commands are
invoked sequentially in the order they appear in the unit
file. If one of the commands fails (and is not prefixed with
C<->), other lines are not executed, and the
unit is considered failed.

Unless C<Type=forking> is set, the
process started via this command line will be considered the
main process of the daemon. I< Optional. Type list of uniline.  > 

=head2 ExecStartPre

Additional commands that are executed before
or after the command in C<ExecStart>,
respectively. Syntax is the same as for
C<ExecStart>, except that multiple command
lines are allowed and the commands are executed one after the
other, serially.

If any of those commands (not prefixed with
C<->) fail, the rest are not executed and the
unit is considered failed.

C<ExecStart> commands are only run after
all C<ExecStartPre> commands that were not prefixed
with a C<-> exit successfully.

C<ExecStartPost> commands are only run after
the service has started successfully, as determined by C<Type>
(i.e. the process has been started for C<Type=simple>
or C<Type=idle>, the process exits successfully for
C<Type=oneshot>, the initial process exits successfully
for C<Type=forking>, C<READY=1> is sent
for C<Type=notify>, or the C<BusName>
has been taken for C<Type=dbus>).

Note that C<ExecStartPre> may not be
used to start long-running processes. All processes forked
off by processes invoked via C<ExecStartPre> will
be killed before the next service process is run.

Note that if any of the commands specified in C<ExecStartPre>,
C<ExecStart>, or C<ExecStartPost> fail (and are not prefixed with
C<->, see above) or time out before the service is fully up, execution continues with commands
specified in C<ExecStopPost>, the commands in C<ExecStop> are skipped. I< Optional. Type list of uniline.  > 

=head2 ExecStartPost

Additional commands that are executed before
or after the command in C<ExecStart>,
respectively. Syntax is the same as for
C<ExecStart>, except that multiple command
lines are allowed and the commands are executed one after the
other, serially.

If any of those commands (not prefixed with
C<->) fail, the rest are not executed and the
unit is considered failed.

C<ExecStart> commands are only run after
all C<ExecStartPre> commands that were not prefixed
with a C<-> exit successfully.

C<ExecStartPost> commands are only run after
the service has started successfully, as determined by C<Type>
(i.e. the process has been started for C<Type=simple>
or C<Type=idle>, the process exits successfully for
C<Type=oneshot>, the initial process exits successfully
for C<Type=forking>, C<READY=1> is sent
for C<Type=notify>, or the C<BusName>
has been taken for C<Type=dbus>).

Note that C<ExecStartPre> may not be
used to start long-running processes. All processes forked
off by processes invoked via C<ExecStartPre> will
be killed before the next service process is run.

Note that if any of the commands specified in C<ExecStartPre>,
C<ExecStart>, or C<ExecStartPost> fail (and are not prefixed with
C<->, see above) or time out before the service is fully up, execution continues with commands
specified in C<ExecStopPost>, the commands in C<ExecStop> are skipped. I< Optional. Type list of uniline.  > 

=head2 ExecReload

Commands to execute to trigger a configuration
reload in the service. This argument takes multiple command
lines, following the same scheme as described for
C<ExecStart> above. Use of this setting is
optional. Specifier and environment variable substitution is
supported here following the same scheme as for
C<ExecStart>.

One additional, special environment variable is set: if
known, C<$MAINPID> is set to the main process
of the daemon, and may be used for command lines like the
following:

Note however that reloading a daemon by sending a signal
(as with the example line above) is usually not a good choice,
because this is an asynchronous operation and hence not
suitable to order reloads of multiple services against each
other. It is strongly recommended to set
C<ExecReload> to a command that not only
triggers a configuration reload of the daemon, but also
synchronously waits for it to complete. I< Optional. Type list of uniline.  > 

=head2 ExecStop

Commands to execute to stop the service
started via C<ExecStart>. This argument takes
multiple command lines, following the same scheme as described
for C<ExecStart> above. Use of this setting
is optional. After the commands configured in this option are
run, all processes remaining for a service are terminated
according to the C<KillMode> setting (see
L<systemd.kill(5)>).
If this option is not specified, the process is terminated by
sending the signal specified in C<KillSignal>
when service stop is requested. Specifier and environment
variable substitution is supported (including
C<$MAINPID>, see above).

Note that it is usually not sufficient to specify a
command for this setting that only asks the service to
terminate (for example, by queuing some form of termination
signal for it), but does not wait for it to do so. Since the
remaining processes of the services are killed using
C<SIGKILL> immediately after the command
exited, this would not result in a clean stop. The specified
command should hence be a synchronous operation, not an
asynchronous one.

Note that the commands specified in C<ExecStop> are only executed when the service
started successfully first. They are not invoked if the service was never started at all, or in case its
start-up failed, for example because any of the commands specified in C<ExecStart>,
C<ExecStartPre> or C<ExecStartPost> failed (and weren't prefixed with
C<->, see above) or timed out. Use C<ExecStopPost> to invoke commands when a
service failed to start up correctly and is shut down again.

It is recommended to use this setting for commands that communicate with the service requesting clean
termination. When the commands specified with this option are executed it should be assumed that the service is
still fully up and is able to react correctly to all commands. For post-mortem clean-up steps use
C<ExecStopPost> instead. I< Optional. Type list of uniline.  > 

=head2 ExecStopPost

Additional commands that are executed after the service is stopped. This includes cases where
the commands configured in C<ExecStop> were used, where the service does not have any
C<ExecStop> defined, or where the service exited unexpectedly. This argument takes multiple
command lines, following the same scheme as described for C<ExecStart>. Use of these settings
is optional. Specifier and environment variable substitution is supported. Note that – unlike
C<ExecStop> – commands specified with this setting are invoked when a service failed to start
up correctly and is shut down again.

It is recommended to use this setting for clean-up operations that shall be executed even when the
service failed to start up correctly. Commands configured with this setting need to be able to operate even if
the service failed starting up half-way and left incompletely initialized data around. As the service's
processes have been terminated already when the commands specified with this setting are executed they should
not attempt to communicate with them.

Note that all commands that are configured with this setting are invoked with the result code of the
service, as well as the main process' exit code and status, set in the C<$SERVICE_RESULT>,
C<$EXIT_CODE> and C<$EXIT_STATUS> environment variables, see
L<systemd.exec(5)> for
details. I< Optional. Type list of uniline.  > 

=head2 RestartSec

Configures the time to sleep before restarting
a service (as configured with C<Restart>).
Takes a unit-less value in seconds, or a time span value such
as "5min 20s". Defaults to 100ms. I< Optional. Type uniline.  > 

=head2 TimeoutStartSec

Configures the time to wait for start-up. If a
daemon service does not signal start-up completion within the
configured time, the service will be considered failed and
will be shut down again. Takes a unit-less value in seconds,
or a time span value such as "5min 20s". Pass
C<infinity> to disable the timeout logic. Defaults to
C<DefaultTimeoutStartSec> from the manager
configuration file, except when
C<Type=oneshot> is used, in which case the
timeout is disabled by default (see
L<systemd-system.conf(5)>).
I< Optional. Type uniline.  > 

=head2 TimeoutStopSec

Configures the time to wait for stop. If a
service is asked to stop, but does not terminate in the
specified time, it will be terminated forcibly via
C<SIGTERM>, and after another timeout of
equal duration with C<SIGKILL> (see
C<KillMode> in
L<systemd.kill(5)>).
Takes a unit-less value in seconds, or a time span value such
as "5min 20s". Pass C<infinity> to disable the
timeout logic. Defaults to
C<DefaultTimeoutStopSec> from the manager
configuration file (see
L<systemd-system.conf(5)>).
I< Optional. Type uniline.  > 

=head2 TimeoutSec

A shorthand for configuring both
C<TimeoutStartSec> and
C<TimeoutStopSec> to the specified value.
I< Optional. Type uniline.  > 

=head2 RuntimeMaxSec

Configures a maximum time for the service to run. If this is used and the service has been
active for longer than the specified time it is terminated and put into a failure state. Note that this setting
does not have any effect on C<Type=oneshot> services, as they terminate immediately after
activation completed. Pass C<infinity> (the default) to configure no runtime
limit. I< Optional. Type uniline.  > 

=head2 WatchdogSec

Configures the watchdog timeout for a service.
The watchdog is activated when the start-up is completed. The
service must call
L<sd_notify(3)>
regularly with C<WATCHDOG=1> (i.e. the
"keep-alive ping"). If the time between two such calls is
larger than the configured time, then the service is placed in
a failed state and it will be terminated with
C<SIGABRT>. By setting
C<Restart> to C<on-failure>,
C<on-watchdog>, C<on-abnormal> or
C<always>, the service will be automatically
restarted. The time configured here will be passed to the
executed service process in the
C<WATCHDOG_USEC> environment variable. This
allows daemons to automatically enable the keep-alive pinging
logic if watchdog support is enabled for the service. If this
option is used, C<NotifyAccess> (see below)
should be set to open access to the notification socket
provided by systemd. If C<NotifyAccess> is
not set, it will be implicitly set to C<main>.
Defaults to 0, which disables this feature. The service can
check whether the service manager expects watchdog keep-alive
notifications. See
L<sd_watchdog_enabled(3)>
for details.
L<sd_event_set_watchdog(3)>
may be used to enable automatic watchdog notification support.
I< Optional. Type uniline.  > 

=head2 Restart

Configures whether the service shall be
restarted when the service process exits, is killed, or a
timeout is reached. The service process may be the main
service process, but it may also be one of the processes
specified with C<ExecStartPre>,
C<ExecStartPost>,
C<ExecStop>,
C<ExecStopPost>, or
C<ExecReload>. When the death of the process
is a result of systemd operation (e.g. service stop or
restart), the service will not be restarted. Timeouts include
missing the watchdog "keep-alive ping" deadline and a service
start, reload, and stop operation timeouts.

Takes one of
C<no>,
C<on-success>,
C<on-failure>,
C<on-abnormal>,
C<on-watchdog>,
C<on-abort>, or
C<always>.
If set to C<no> (the default), the service will
not be restarted. If set to C<on-success>, it
will be restarted only when the service process exits cleanly.
In this context, a clean exit means an exit code of 0, or one
of the signals
C<SIGHUP>,
C<SIGINT>,
C<SIGTERM> or
C<SIGPIPE>, and
additionally, exit statuses and signals specified in
C<SuccessExitStatus>. If set to
C<on-failure>, the service will be restarted
when the process exits with a non-zero exit code, is
terminated by a signal (including on core dump, but excluding
the aforementioned four signals), when an operation (such as
service reload) times out, and when the configured watchdog
timeout is triggered. If set to C<on-abnormal>,
the service will be restarted when the process is terminated
by a signal (including on core dump, excluding the
aforementioned four signals), when an operation times out, or
when the watchdog timeout is triggered. If set to
C<on-abort>, the service will be restarted only
if the service process exits due to an uncaught signal not
specified as a clean exit status. If set to
C<on-watchdog>, the service will be restarted
only if the watchdog timeout for the service expires. If set
to C<always>, the service will be restarted
regardless of whether it exited cleanly or not, got terminated
abnormally by a signal, or hit a timeout.

As exceptions to the setting above, the service will not
be restarted if the exit code or signal is specified in
C<RestartPreventExitStatus> (see below).
Also, the services will always be restarted if the exit code
or signal is specified in
C<RestartForceExitStatus> (see below).

Setting this to C<on-failure> is the
recommended choice for long-running services, in order to
increase reliability by attempting automatic recovery from
errors. For services that shall be able to terminate on their
own choice (and avoid immediate restarting),
C<on-abnormal> is an alternative choice. I< Optional. Type enum. choice: 'no', 'on-success', 'on-failure', 'on-abnormal', 'on-watchdog', 'on-abort', 'always'.  > 

=head2 SuccessExitStatus

Takes a list of exit status definitions that,
when returned by the main service process, will be considered
successful termination, in addition to the normal successful
exit code 0 and the signals C<SIGHUP>,
C<SIGINT>, C<SIGTERM>, and
C<SIGPIPE>. Exit status definitions can
either be numeric exit codes or termination signal names,
separated by spaces. For example:

    SuccessExitStatus=1 2 8 SIGKILL

ensures that exit codes 1, 2, 8 and
the termination signal C<SIGKILL> are
considered clean service terminations.

Note that if a process has a signal handler installed
and exits by calling
L<_exit(2)>
in response to a signal, the information about the signal is
lost. Programs should instead perform cleanup and kill
themselves with the same signal instead. See
Proper
handling of SIGINT/SIGQUIT — How to be a proper
program.

This option may appear more than once, in which case the
list of successful exit statuses is merged. If the empty
string is assigned to this option, the list is reset, all
prior assignments of this option will have no
effect. I< Optional. Type uniline.  > 

=head2 RestartPreventExitStatus

Takes a list of exit status definitions that,
when returned by the main service process, will prevent
automatic service restarts, regardless of the restart setting
configured with C<Restart>. Exit status
definitions can either be numeric exit codes or termination
signal names, and are separated by spaces. Defaults to the
empty list, so that, by default, no exit status is excluded
from the configured restart logic. For example:

    RestartPreventExitStatus=1 6 SIGABRT

ensures that exit codes 1 and 6 and the termination signal
C<SIGABRT> will not result in automatic
service restarting. This option may appear more than once, in
which case the list of restart-preventing statuses is
merged. If the empty string is assigned to this option, the
list is reset and all prior assignments of this option will
have no effect. I< Optional. Type uniline.  > 

=head2 RestartForceExitStatus

Takes a list of exit status definitions that,
when returned by the main service process, will force automatic
service restarts, regardless of the restart setting configured
with C<Restart>. The argument format is
similar to
C<RestartPreventExitStatus>. I< Optional. Type uniline.  > 

=head2 PermissionsStartOnly

Takes a boolean argument. If true, the
permission-related execution options, as configured with
C<User> and similar options (see
L<systemd.exec(5)>
for more information), are only applied to the process started
with
C<ExecStart>, and not to the various other
C<ExecStartPre>,
C<ExecStartPost>,
C<ExecReload>,
C<ExecStop>, and
C<ExecStopPost>
commands. If false, the setting is applied to all configured
commands the same way. Defaults to false. I< Optional. Type boolean.  > 

=head2 RootDirectoryStartOnly

Takes a boolean argument. If true, the root
directory, as configured with the
C<RootDirectory> option (see
L<systemd.exec(5)>
for more information), is only applied to the process started
with C<ExecStart>, and not to the various
other C<ExecStartPre>,
C<ExecStartPost>,
C<ExecReload>, C<ExecStop>,
and C<ExecStopPost> commands. If false, the
setting is applied to all configured commands the same way.
Defaults to false. I< Optional. Type boolean.  > 

=head2 NonBlocking

Set the C<O_NONBLOCK> flag
for all file descriptors passed via socket-based activation.
If true, all file descriptors >= 3 (i.e. all except stdin,
stdout, and stderr) will have the
C<O_NONBLOCK> flag set and hence are in
non-blocking mode. This option is only useful in conjunction
with a socket unit, as described in
L<systemd.socket(5)>.
Defaults to false. I< Optional. Type uniline.  > 

=head2 NotifyAccess

Controls access to the service status
notification socket, as accessible via the
L<sd_notify(3)>
call. Takes one of C<none> (the default),
C<main> or C<all>. If
C<none>, no daemon status updates are accepted
from the service processes, all status update messages are
ignored. If C<main>, only service updates sent
from the main process of the service are accepted. If
C<all>, all services updates from all members of
the service's control group are accepted. This option should
be set to open access to the notification socket when using
C<Type=notify> or
C<WatchdogSec> (see above). If those options
are used but C<NotifyAccess> is not
configured, it will be implicitly set to
C<main>. I< Optional. Type enum. choice: 'none', 'main', 'all'.  > 

=head2 Sockets

Specifies the name of the socket units this
service shall inherit socket file descriptors from when the
service is started. Normally, it should not be necessary to use
this setting, as all socket file descriptors whose unit shares
the same name as the service (subject to the different unit
name suffix of course) are passed to the spawned
process.

Note that the same socket file descriptors may be passed
to multiple processes simultaneously. Also note that a
different service may be activated on incoming socket traffic
than the one which is ultimately configured to inherit the
socket file descriptors. Or, in other words: the
C<Service> setting of
.socket units does not have to match the
inverse of the C<Sockets> setting of the
.service it refers to.

This option may appear more than once, in which case the
list of socket units is merged. If the empty string is
assigned to this option, the list of sockets is reset, and all
prior uses of this setting will have no
effect. I< Optional. Type uniline.  > 

=head2 FailureAction

Configure the action to take when the service enters a failed state. Takes the same values as
the unit setting C<StartLimitAction> and executes the same actions (see
L<systemd.unit(5)>). Defaults to
C<none>. I< Optional. Type uniline.  > 

=head2 FileDescriptorStoreMax

Configure how many file descriptors may be
stored in the service manager for the service using
L<sd_pid_notify_with_fds(3)>'s
C<FDSTORE=1> messages. This is useful for
implementing service restart schemes where the state is
serialized to /run and the file
descriptors passed to the service manager, to allow restarts
without losing state. Defaults to 0, i.e. no file descriptors
may be stored in the service manager. All file
descriptors passed to the service manager from a specific
service are passed back to the service's main process on the
next service restart. Any file descriptors passed to the
service manager are automatically closed when POLLHUP or
POLLERR is seen on them, or when the service is fully stopped
and no job is queued or being executed for it. I< Optional. Type uniline.  > 

=head2 USBFunctionDescriptors

Configure the location of a file containing
USB
FunctionFS descriptors, for implementation of USB
gadget functions. This is used only in conjunction with a
socket unit with C<ListenUSBFunction>
configured. The contents of this file are written to the
ep0 file after it is
opened. I< Optional. Type uniline.  > 

=head2 USBFunctionStrings

Configure the location of a file containing
USB FunctionFS strings.  Behavior is similar to
C<USBFunctionDescriptors>
above. I< Optional. Type uniline.  > 

=head1 SEE ALSO

=over

=item *

L<cme>

=back

=head1 COPYRIGHT

=over

=item 2010-2016 Lennart Poettering and others

=item 2016 Dominique Dumont


=back

=head1 LICENSE

=over

=item LGPLv2.1+


=back

=cut

