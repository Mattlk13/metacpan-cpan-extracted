# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.1
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

package Ufal::UDPipe;
our $VERSION = '1.3.1.1';
use base qw(Exporter);
use base qw(DynaLoader);
package Ufal::UDPipec;
our $VERSION = '1.3.1.1';
bootstrap Ufal::UDPipe;
package Ufal::UDPipe;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Ufal::UDPipe;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Ufal::UDPipe;


############# Class : Ufal::UDPipe::Children ##############

package Ufal::UDPipe::Children;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Children(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::UDPipec::Children_size;
*empty = *Ufal::UDPipec::Children_empty;
*clear = *Ufal::UDPipec::Children_clear;
*push = *Ufal::UDPipec::Children_push;
*pop = *Ufal::UDPipec::Children_pop;
*get = *Ufal::UDPipec::Children_get;
*set = *Ufal::UDPipec::Children_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Children($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Bytes ##############

package Ufal::UDPipe::Bytes;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Bytes(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::UDPipec::Bytes_size;
*empty = *Ufal::UDPipec::Bytes_empty;
*clear = *Ufal::UDPipec::Bytes_clear;
*push = *Ufal::UDPipec::Bytes_push;
*pop = *Ufal::UDPipec::Bytes_pop;
*get = *Ufal::UDPipec::Bytes_get;
*set = *Ufal::UDPipec::Bytes_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Bytes($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Comments ##############

package Ufal::UDPipe::Comments;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Comments(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::UDPipec::Comments_size;
*empty = *Ufal::UDPipec::Comments_empty;
*clear = *Ufal::UDPipec::Comments_clear;
*push = *Ufal::UDPipec::Comments_push;
*pop = *Ufal::UDPipec::Comments_pop;
*get = *Ufal::UDPipec::Comments_get;
*set = *Ufal::UDPipec::Comments_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Comments($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::ProcessingError ##############

package Ufal::UDPipe::ProcessingError;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
*occurred = *Ufal::UDPipec::ProcessingError_occurred;
*swig_message_get = *Ufal::UDPipec::ProcessingError_message_get;
*swig_message_set = *Ufal::UDPipec::ProcessingError_message_set;
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_ProcessingError(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_ProcessingError($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Token ##############

package Ufal::UDPipe::Token;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
*swig_form_get = *Ufal::UDPipec::Token_form_get;
*swig_form_set = *Ufal::UDPipec::Token_form_set;
*swig_misc_get = *Ufal::UDPipec::Token_misc_get;
*swig_misc_set = *Ufal::UDPipec::Token_misc_set;
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Token(@_);
    bless $self, $pkg if defined($self);
}

*getSpaceAfter = *Ufal::UDPipec::Token_getSpaceAfter;
*setSpaceAfter = *Ufal::UDPipec::Token_setSpaceAfter;
*getSpacesBefore = *Ufal::UDPipec::Token_getSpacesBefore;
*setSpacesBefore = *Ufal::UDPipec::Token_setSpacesBefore;
*getSpacesAfter = *Ufal::UDPipec::Token_getSpacesAfter;
*setSpacesAfter = *Ufal::UDPipec::Token_setSpacesAfter;
*getSpacesInToken = *Ufal::UDPipec::Token_getSpacesInToken;
*setSpacesInToken = *Ufal::UDPipec::Token_setSpacesInToken;
*getTokenRange = *Ufal::UDPipec::Token_getTokenRange;
*getTokenRangeStart = *Ufal::UDPipec::Token_getTokenRangeStart;
*getTokenRangeEnd = *Ufal::UDPipec::Token_getTokenRangeEnd;
*setTokenRange = *Ufal::UDPipec::Token_setTokenRange;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Token($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Word ##############

package Ufal::UDPipe::Word;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe::Token Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
*swig_id_get = *Ufal::UDPipec::Word_id_get;
*swig_id_set = *Ufal::UDPipec::Word_id_set;
*swig_lemma_get = *Ufal::UDPipec::Word_lemma_get;
*swig_lemma_set = *Ufal::UDPipec::Word_lemma_set;
*swig_upostag_get = *Ufal::UDPipec::Word_upostag_get;
*swig_upostag_set = *Ufal::UDPipec::Word_upostag_set;
*swig_xpostag_get = *Ufal::UDPipec::Word_xpostag_get;
*swig_xpostag_set = *Ufal::UDPipec::Word_xpostag_set;
*swig_feats_get = *Ufal::UDPipec::Word_feats_get;
*swig_feats_set = *Ufal::UDPipec::Word_feats_set;
*swig_head_get = *Ufal::UDPipec::Word_head_get;
*swig_head_set = *Ufal::UDPipec::Word_head_set;
*swig_deprel_get = *Ufal::UDPipec::Word_deprel_get;
*swig_deprel_set = *Ufal::UDPipec::Word_deprel_set;
*swig_deps_get = *Ufal::UDPipec::Word_deps_get;
*swig_deps_set = *Ufal::UDPipec::Word_deps_set;
*swig_children_get = *Ufal::UDPipec::Word_children_get;
*swig_children_set = *Ufal::UDPipec::Word_children_set;
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Word(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Word($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Words ##############

package Ufal::UDPipe::Words;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Words(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::UDPipec::Words_size;
*empty = *Ufal::UDPipec::Words_empty;
*clear = *Ufal::UDPipec::Words_clear;
*push = *Ufal::UDPipec::Words_push;
*pop = *Ufal::UDPipec::Words_pop;
*get = *Ufal::UDPipec::Words_get;
*set = *Ufal::UDPipec::Words_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Words($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::MultiwordToken ##############

package Ufal::UDPipe::MultiwordToken;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe::Token Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
*swig_idFirst_get = *Ufal::UDPipec::MultiwordToken_idFirst_get;
*swig_idFirst_set = *Ufal::UDPipec::MultiwordToken_idFirst_set;
*swig_idLast_get = *Ufal::UDPipec::MultiwordToken_idLast_get;
*swig_idLast_set = *Ufal::UDPipec::MultiwordToken_idLast_set;
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_MultiwordToken(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_MultiwordToken($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::MultiwordTokens ##############

package Ufal::UDPipe::MultiwordTokens;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_MultiwordTokens(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::UDPipec::MultiwordTokens_size;
*empty = *Ufal::UDPipec::MultiwordTokens_empty;
*clear = *Ufal::UDPipec::MultiwordTokens_clear;
*push = *Ufal::UDPipec::MultiwordTokens_push;
*pop = *Ufal::UDPipec::MultiwordTokens_pop;
*get = *Ufal::UDPipec::MultiwordTokens_get;
*set = *Ufal::UDPipec::MultiwordTokens_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_MultiwordTokens($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::EmptyNode ##############

package Ufal::UDPipe::EmptyNode;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
*swig_id_get = *Ufal::UDPipec::EmptyNode_id_get;
*swig_id_set = *Ufal::UDPipec::EmptyNode_id_set;
*swig_index_get = *Ufal::UDPipec::EmptyNode_index_get;
*swig_index_set = *Ufal::UDPipec::EmptyNode_index_set;
*swig_form_get = *Ufal::UDPipec::EmptyNode_form_get;
*swig_form_set = *Ufal::UDPipec::EmptyNode_form_set;
*swig_lemma_get = *Ufal::UDPipec::EmptyNode_lemma_get;
*swig_lemma_set = *Ufal::UDPipec::EmptyNode_lemma_set;
*swig_upostag_get = *Ufal::UDPipec::EmptyNode_upostag_get;
*swig_upostag_set = *Ufal::UDPipec::EmptyNode_upostag_set;
*swig_xpostag_get = *Ufal::UDPipec::EmptyNode_xpostag_get;
*swig_xpostag_set = *Ufal::UDPipec::EmptyNode_xpostag_set;
*swig_feats_get = *Ufal::UDPipec::EmptyNode_feats_get;
*swig_feats_set = *Ufal::UDPipec::EmptyNode_feats_set;
*swig_deps_get = *Ufal::UDPipec::EmptyNode_deps_get;
*swig_deps_set = *Ufal::UDPipec::EmptyNode_deps_set;
*swig_misc_get = *Ufal::UDPipec::EmptyNode_misc_get;
*swig_misc_set = *Ufal::UDPipec::EmptyNode_misc_set;
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_EmptyNode(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_EmptyNode($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::EmptyNodes ##############

package Ufal::UDPipe::EmptyNodes;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_EmptyNodes(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::UDPipec::EmptyNodes_size;
*empty = *Ufal::UDPipec::EmptyNodes_empty;
*clear = *Ufal::UDPipec::EmptyNodes_clear;
*push = *Ufal::UDPipec::EmptyNodes_push;
*pop = *Ufal::UDPipec::EmptyNodes_pop;
*get = *Ufal::UDPipec::EmptyNodes_get;
*set = *Ufal::UDPipec::EmptyNodes_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_EmptyNodes($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Sentence ##############

package Ufal::UDPipe::Sentence;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Sentence(@_);
    bless $self, $pkg if defined($self);
}

*swig_words_get = *Ufal::UDPipec::Sentence_words_get;
*swig_words_set = *Ufal::UDPipec::Sentence_words_set;
*swig_multiwordTokens_get = *Ufal::UDPipec::Sentence_multiwordTokens_get;
*swig_multiwordTokens_set = *Ufal::UDPipec::Sentence_multiwordTokens_set;
*swig_emptyNodes_get = *Ufal::UDPipec::Sentence_emptyNodes_get;
*swig_emptyNodes_set = *Ufal::UDPipec::Sentence_emptyNodes_set;
*swig_comments_get = *Ufal::UDPipec::Sentence_comments_get;
*swig_comments_set = *Ufal::UDPipec::Sentence_comments_set;
*rootForm = *Ufal::UDPipec::Sentence_rootForm;
*empty = *Ufal::UDPipec::Sentence_empty;
*clear = *Ufal::UDPipec::Sentence_clear;
*addWord = *Ufal::UDPipec::Sentence_addWord;
*setHead = *Ufal::UDPipec::Sentence_setHead;
*unlinkAllNodes = *Ufal::UDPipec::Sentence_unlinkAllNodes;
*getNewDoc = *Ufal::UDPipec::Sentence_getNewDoc;
*getNewDocId = *Ufal::UDPipec::Sentence_getNewDocId;
*setNewDoc = *Ufal::UDPipec::Sentence_setNewDoc;
*getNewPar = *Ufal::UDPipec::Sentence_getNewPar;
*getNewParId = *Ufal::UDPipec::Sentence_getNewParId;
*setNewPar = *Ufal::UDPipec::Sentence_setNewPar;
*getSentId = *Ufal::UDPipec::Sentence_getSentId;
*setSentId = *Ufal::UDPipec::Sentence_setSentId;
*getText = *Ufal::UDPipec::Sentence_getText;
*setText = *Ufal::UDPipec::Sentence_setText;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Sentence($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Sentences ##############

package Ufal::UDPipe::Sentences;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Sentences(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::UDPipec::Sentences_size;
*empty = *Ufal::UDPipec::Sentences_empty;
*clear = *Ufal::UDPipec::Sentences_clear;
*push = *Ufal::UDPipec::Sentences_push;
*pop = *Ufal::UDPipec::Sentences_pop;
*get = *Ufal::UDPipec::Sentences_get;
*set = *Ufal::UDPipec::Sentences_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Sentences($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::InputFormat ##############

package Ufal::UDPipe::InputFormat;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_InputFormat($self);
        delete $OWNER{$self};
    }
}

*resetDocument = *Ufal::UDPipec::InputFormat_resetDocument;
*setText = *Ufal::UDPipec::InputFormat_setText;
*nextSentence = *Ufal::UDPipec::InputFormat_nextSentence;
*newInputFormat = *Ufal::UDPipec::InputFormat_newInputFormat;
*newConlluInputFormat = *Ufal::UDPipec::InputFormat_newConlluInputFormat;
*newGenericTokenizerInputFormat = *Ufal::UDPipec::InputFormat_newGenericTokenizerInputFormat;
*newHorizontalInputFormat = *Ufal::UDPipec::InputFormat_newHorizontalInputFormat;
*newVerticalInputFormat = *Ufal::UDPipec::InputFormat_newVerticalInputFormat;
*newPresegmentedTokenizer = *Ufal::UDPipec::InputFormat_newPresegmentedTokenizer;
*CONLLU_V1 = *Ufal::UDPipec::InputFormat_CONLLU_V1;
*CONLLU_V2 = *Ufal::UDPipec::InputFormat_CONLLU_V2;
*GENERIC_TOKENIZER_NORMALIZED_SPACES = *Ufal::UDPipec::InputFormat_GENERIC_TOKENIZER_NORMALIZED_SPACES;
*GENERIC_TOKENIZER_PRESEGMENTED = *Ufal::UDPipec::InputFormat_GENERIC_TOKENIZER_PRESEGMENTED;
*GENERIC_TOKENIZER_RANGES = *Ufal::UDPipec::InputFormat_GENERIC_TOKENIZER_RANGES;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::OutputFormat ##############

package Ufal::UDPipe::OutputFormat;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_OutputFormat($self);
        delete $OWNER{$self};
    }
}

*writeSentence = *Ufal::UDPipec::OutputFormat_writeSentence;
*finishDocument = *Ufal::UDPipec::OutputFormat_finishDocument;
*newOutputFormat = *Ufal::UDPipec::OutputFormat_newOutputFormat;
*newConlluOutputFormat = *Ufal::UDPipec::OutputFormat_newConlluOutputFormat;
*newEpeOutputFormat = *Ufal::UDPipec::OutputFormat_newEpeOutputFormat;
*newMatxinOutputFormat = *Ufal::UDPipec::OutputFormat_newMatxinOutputFormat;
*newHorizontalOutputFormat = *Ufal::UDPipec::OutputFormat_newHorizontalOutputFormat;
*newPlaintextOutputFormat = *Ufal::UDPipec::OutputFormat_newPlaintextOutputFormat;
*newVerticalOutputFormat = *Ufal::UDPipec::OutputFormat_newVerticalOutputFormat;
*CONLLU_V1 = *Ufal::UDPipec::OutputFormat_CONLLU_V1;
*CONLLU_V2 = *Ufal::UDPipec::OutputFormat_CONLLU_V2;
*HORIZONTAL_PARAGRAPHS = *Ufal::UDPipec::OutputFormat_HORIZONTAL_PARAGRAPHS;
*PLAINTEXT_NORMALIZED_SPACES = *Ufal::UDPipec::OutputFormat_PLAINTEXT_NORMALIZED_SPACES;
*VERTICAL_PARAGRAPHS = *Ufal::UDPipec::OutputFormat_VERTICAL_PARAGRAPHS;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Model ##############

package Ufal::UDPipe::Model;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Model($self);
        delete $OWNER{$self};
    }
}

*load = *Ufal::UDPipec::Model_load;
*newTokenizer = *Ufal::UDPipec::Model_newTokenizer;
*tag = *Ufal::UDPipec::Model_tag;
*parse = *Ufal::UDPipec::Model_parse;
*DEFAULT = *Ufal::UDPipec::Model_DEFAULT;
*TOKENIZER_NORMALIZED_SPACES = *Ufal::UDPipec::Model_TOKENIZER_NORMALIZED_SPACES;
*TOKENIZER_PRESEGMENTED = *Ufal::UDPipec::Model_TOKENIZER_PRESEGMENTED;
*TOKENIZER_RANGES = *Ufal::UDPipec::Model_TOKENIZER_RANGES;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Pipeline ##############

package Ufal::UDPipe::Pipeline;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Pipeline(@_);
    bless $self, $pkg if defined($self);
}

*setModel = *Ufal::UDPipec::Pipeline_setModel;
*setInput = *Ufal::UDPipec::Pipeline_setInput;
*setTagger = *Ufal::UDPipec::Pipeline_setTagger;
*setParser = *Ufal::UDPipec::Pipeline_setParser;
*setOutput = *Ufal::UDPipec::Pipeline_setOutput;
*setImmediate = *Ufal::UDPipec::Pipeline_setImmediate;
*setDocumentId = *Ufal::UDPipec::Pipeline_setDocumentId;
*process = *Ufal::UDPipec::Pipeline_process;
*DEFAULT = *Ufal::UDPipec::Pipeline_DEFAULT;
*NONE = *Ufal::UDPipec::Pipeline_NONE;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Pipeline($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Trainer ##############

package Ufal::UDPipe::Trainer;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
*train = *Ufal::UDPipec::Trainer_train;
*DEFAULT = *Ufal::UDPipec::Trainer_DEFAULT;
*NONE = *Ufal::UDPipec::Trainer_NONE;
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Trainer(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Trainer($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Evaluator ##############

package Ufal::UDPipe::Evaluator;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Evaluator(@_);
    bless $self, $pkg if defined($self);
}

*setModel = *Ufal::UDPipec::Evaluator_setModel;
*setTokenizer = *Ufal::UDPipec::Evaluator_setTokenizer;
*setTagger = *Ufal::UDPipec::Evaluator_setTagger;
*setParser = *Ufal::UDPipec::Evaluator_setParser;
*evaluate = *Ufal::UDPipec::Evaluator_evaluate;
*DEFAULT = *Ufal::UDPipec::Evaluator_DEFAULT;
*NONE = *Ufal::UDPipec::Evaluator_NONE;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Evaluator($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::UDPipe::Version ##############

package Ufal::UDPipe::Version;
our $VERSION = '1.3.1.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::UDPipe );
%OWNER = ();
%ITERATORS = ();
*swig_major_get = *Ufal::UDPipec::Version_major_get;
*swig_major_set = *Ufal::UDPipec::Version_major_set;
*swig_minor_get = *Ufal::UDPipec::Version_minor_get;
*swig_minor_set = *Ufal::UDPipec::Version_minor_set;
*swig_patch_get = *Ufal::UDPipec::Version_patch_get;
*swig_patch_set = *Ufal::UDPipec::Version_patch_set;
*swig_prerelease_get = *Ufal::UDPipec::Version_prerelease_get;
*swig_prerelease_set = *Ufal::UDPipec::Version_prerelease_set;
*current = *Ufal::UDPipec::Version_current;
sub new {
    my $pkg = shift;
    my $self = Ufal::UDPipec::new_Version(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::UDPipec::delete_Version($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Ufal::UDPipe;

*Sentence_rootForm = *Ufal::UDPipec::Sentence_rootForm;
*InputFormat_CONLLU_V1 = *Ufal::UDPipec::InputFormat_CONLLU_V1;
*InputFormat_CONLLU_V2 = *Ufal::UDPipec::InputFormat_CONLLU_V2;
*InputFormat_GENERIC_TOKENIZER_NORMALIZED_SPACES = *Ufal::UDPipec::InputFormat_GENERIC_TOKENIZER_NORMALIZED_SPACES;
*InputFormat_GENERIC_TOKENIZER_PRESEGMENTED = *Ufal::UDPipec::InputFormat_GENERIC_TOKENIZER_PRESEGMENTED;
*InputFormat_GENERIC_TOKENIZER_RANGES = *Ufal::UDPipec::InputFormat_GENERIC_TOKENIZER_RANGES;
*OutputFormat_CONLLU_V1 = *Ufal::UDPipec::OutputFormat_CONLLU_V1;
*OutputFormat_CONLLU_V2 = *Ufal::UDPipec::OutputFormat_CONLLU_V2;
*OutputFormat_HORIZONTAL_PARAGRAPHS = *Ufal::UDPipec::OutputFormat_HORIZONTAL_PARAGRAPHS;
*OutputFormat_PLAINTEXT_NORMALIZED_SPACES = *Ufal::UDPipec::OutputFormat_PLAINTEXT_NORMALIZED_SPACES;
*OutputFormat_VERTICAL_PARAGRAPHS = *Ufal::UDPipec::OutputFormat_VERTICAL_PARAGRAPHS;
*Model_DEFAULT = *Ufal::UDPipec::Model_DEFAULT;
*Model_TOKENIZER_NORMALIZED_SPACES = *Ufal::UDPipec::Model_TOKENIZER_NORMALIZED_SPACES;
*Model_TOKENIZER_PRESEGMENTED = *Ufal::UDPipec::Model_TOKENIZER_PRESEGMENTED;
*Model_TOKENIZER_RANGES = *Ufal::UDPipec::Model_TOKENIZER_RANGES;
*Pipeline_DEFAULT = *Ufal::UDPipec::Pipeline_DEFAULT;
*Pipeline_NONE = *Ufal::UDPipec::Pipeline_NONE;
*Trainer_DEFAULT = *Ufal::UDPipec::Trainer_DEFAULT;
*Trainer_NONE = *Ufal::UDPipec::Trainer_NONE;
*Evaluator_DEFAULT = *Ufal::UDPipec::Evaluator_DEFAULT;
*Evaluator_NONE = *Ufal::UDPipec::Evaluator_NONE;
1;
