# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Ufal::Parsito;
our $VERSION = '1.1.0.1';
use base qw(Exporter);
use base qw(DynaLoader);
package Ufal::Parsitoc;
our $VERSION = '1.1.0.1';
bootstrap Ufal::Parsito;
package Ufal::Parsito;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Ufal::Parsito;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Ufal::Parsito;


############# Class : Ufal::Parsito::Children ##############

package Ufal::Parsito::Children;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::Parsitoc::new_Children(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::Parsitoc::Children_size;
*empty = *Ufal::Parsitoc::Children_empty;
*clear = *Ufal::Parsitoc::Children_clear;
*push = *Ufal::Parsitoc::Children_push;
*pop = *Ufal::Parsitoc::Children_pop;
*get = *Ufal::Parsitoc::Children_get;
*set = *Ufal::Parsitoc::Children_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_Children($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::Parsito::Node ##############

package Ufal::Parsito::Node;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
*swig_id_get = *Ufal::Parsitoc::Node_id_get;
*swig_id_set = *Ufal::Parsitoc::Node_id_set;
*swig_form_get = *Ufal::Parsitoc::Node_form_get;
*swig_form_set = *Ufal::Parsitoc::Node_form_set;
*swig_lemma_get = *Ufal::Parsitoc::Node_lemma_get;
*swig_lemma_set = *Ufal::Parsitoc::Node_lemma_set;
*swig_upostag_get = *Ufal::Parsitoc::Node_upostag_get;
*swig_upostag_set = *Ufal::Parsitoc::Node_upostag_set;
*swig_xpostag_get = *Ufal::Parsitoc::Node_xpostag_get;
*swig_xpostag_set = *Ufal::Parsitoc::Node_xpostag_set;
*swig_feats_get = *Ufal::Parsitoc::Node_feats_get;
*swig_feats_set = *Ufal::Parsitoc::Node_feats_set;
*swig_head_get = *Ufal::Parsitoc::Node_head_get;
*swig_head_set = *Ufal::Parsitoc::Node_head_set;
*swig_deprel_get = *Ufal::Parsitoc::Node_deprel_get;
*swig_deprel_set = *Ufal::Parsitoc::Node_deprel_set;
*swig_deps_get = *Ufal::Parsitoc::Node_deps_get;
*swig_deps_set = *Ufal::Parsitoc::Node_deps_set;
*swig_misc_get = *Ufal::Parsitoc::Node_misc_get;
*swig_misc_set = *Ufal::Parsitoc::Node_misc_set;
*swig_children_get = *Ufal::Parsitoc::Node_children_get;
*swig_children_set = *Ufal::Parsitoc::Node_children_set;
sub new {
    my $pkg = shift;
    my $self = Ufal::Parsitoc::new_Node(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_Node($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::Parsito::Nodes ##############

package Ufal::Parsito::Nodes;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::Parsitoc::new_Nodes(@_);
    bless $self, $pkg if defined($self);
}

*size = *Ufal::Parsitoc::Nodes_size;
*empty = *Ufal::Parsitoc::Nodes_empty;
*clear = *Ufal::Parsitoc::Nodes_clear;
*push = *Ufal::Parsitoc::Nodes_push;
*pop = *Ufal::Parsitoc::Nodes_pop;
*get = *Ufal::Parsitoc::Nodes_get;
*set = *Ufal::Parsitoc::Nodes_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_Nodes($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::Parsito::Tree ##############

package Ufal::Parsito::Tree;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Ufal::Parsitoc::new_Tree(@_);
    bless $self, $pkg if defined($self);
}

*swig_nodes_get = *Ufal::Parsitoc::Tree_nodes_get;
*swig_nodes_set = *Ufal::Parsitoc::Tree_nodes_set;
*empty = *Ufal::Parsitoc::Tree_empty;
*clear = *Ufal::Parsitoc::Tree_clear;
*addNode = *Ufal::Parsitoc::Tree_addNode;
*setHead = *Ufal::Parsitoc::Tree_setHead;
*unlinkAllNodes = *Ufal::Parsitoc::Tree_unlinkAllNodes;
*root_form = *Ufal::Parsitoc::Tree_root_form;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_Tree($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::Parsito::TreeInputFormat ##############

package Ufal::Parsito::TreeInputFormat;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_TreeInputFormat($self);
        delete $OWNER{$self};
    }
}

*setText = *Ufal::Parsitoc::TreeInputFormat_setText;
*nextTree = *Ufal::Parsitoc::TreeInputFormat_nextTree;
*lastError = *Ufal::Parsitoc::TreeInputFormat_lastError;
*newInputFormat = *Ufal::Parsitoc::TreeInputFormat_newInputFormat;
*newConlluInputFormat = *Ufal::Parsitoc::TreeInputFormat_newConlluInputFormat;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::Parsito::TreeOutputFormat ##############

package Ufal::Parsito::TreeOutputFormat;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_TreeOutputFormat($self);
        delete $OWNER{$self};
    }
}

*writeTree = *Ufal::Parsitoc::TreeOutputFormat_writeTree;
*newOutputFormat = *Ufal::Parsitoc::TreeOutputFormat_newOutputFormat;
*newConlluOutputFormat = *Ufal::Parsitoc::TreeOutputFormat_newConlluOutputFormat;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::Parsito::Version ##############

package Ufal::Parsito::Version;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
*swig_major_get = *Ufal::Parsitoc::Version_major_get;
*swig_major_set = *Ufal::Parsitoc::Version_major_set;
*swig_minor_get = *Ufal::Parsitoc::Version_minor_get;
*swig_minor_set = *Ufal::Parsitoc::Version_minor_set;
*swig_patch_get = *Ufal::Parsitoc::Version_patch_get;
*swig_patch_set = *Ufal::Parsitoc::Version_patch_set;
*swig_prerelease_get = *Ufal::Parsitoc::Version_prerelease_get;
*swig_prerelease_set = *Ufal::Parsitoc::Version_prerelease_set;
*current = *Ufal::Parsitoc::Version_current;
sub new {
    my $pkg = shift;
    my $self = Ufal::Parsitoc::new_Version(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_Version($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Ufal::Parsito::Parser ##############

package Ufal::Parsito::Parser;
our $VERSION = '1.1.0.1';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Ufal::Parsito );
%OWNER = ();
%ITERATORS = ();
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Ufal::Parsitoc::delete_Parser($self);
        delete $OWNER{$self};
    }
}

*parse = *Ufal::Parsitoc::Parser_parse;
*NO_CACHE = *Ufal::Parsitoc::Parser_NO_CACHE;
*FULL_CACHE = *Ufal::Parsitoc::Parser_FULL_CACHE;
*load = *Ufal::Parsitoc::Parser_load;
sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Ufal::Parsito;

*Tree_root_form = *Ufal::Parsitoc::Tree_root_form;
1;
