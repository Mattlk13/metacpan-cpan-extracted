# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Lingua::ZH::Jieba;
$Lingua::ZH::Jieba::VERSION = '0.003';
use base qw(Exporter);
use base qw(DynaLoader);
package Lingua::ZH::Jiebac;
$Lingua::ZH::Jiebac::VERSION = '0.003';
bootstrap Lingua::ZH::Jieba;
package Lingua::ZH::Jieba;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Lingua::ZH::Jieba;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Lingua::ZH::Jieba;


############# Class : Lingua::ZH::Jieba::vector_s ##############

package Lingua::ZH::Jieba::vector_s;
$Lingua::ZH::Jieba::vector_s::VERSION = '0.003';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_vector_s(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::ZH::Jiebac::vector_s_size;
*empty = *Lingua::ZH::Jiebac::vector_s_empty;
*clear = *Lingua::ZH::Jiebac::vector_s_clear;
*push = *Lingua::ZH::Jiebac::vector_s_push;
*pop = *Lingua::ZH::Jiebac::vector_s_pop;
*get = *Lingua::ZH::Jiebac::vector_s_get;
*set = *Lingua::ZH::Jiebac::vector_s_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_vector_s($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::vector_wordpos ##############

package Lingua::ZH::Jieba::vector_wordpos;
$Lingua::ZH::Jieba::vector_wordpos::VERSION = '0.003';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_vector_wordpos(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::ZH::Jiebac::vector_wordpos_size;
*empty = *Lingua::ZH::Jiebac::vector_wordpos_empty;
*clear = *Lingua::ZH::Jiebac::vector_wordpos_clear;
*push = *Lingua::ZH::Jiebac::vector_wordpos_push;
*pop = *Lingua::ZH::Jiebac::vector_wordpos_pop;
*get = *Lingua::ZH::Jiebac::vector_wordpos_get;
*set = *Lingua::ZH::Jiebac::vector_wordpos_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_vector_wordpos($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::vector_keyword ##############

package Lingua::ZH::Jieba::vector_keyword;
$Lingua::ZH::Jieba::vector_keyword::VERSION = '0.003';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_vector_keyword(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::ZH::Jiebac::vector_keyword_size;
*empty = *Lingua::ZH::Jiebac::vector_keyword_empty;
*clear = *Lingua::ZH::Jiebac::vector_keyword_clear;
*push = *Lingua::ZH::Jiebac::vector_keyword_push;
*pop = *Lingua::ZH::Jiebac::vector_keyword_pop;
*get = *Lingua::ZH::Jiebac::vector_keyword_get;
*set = *Lingua::ZH::Jiebac::vector_keyword_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_vector_keyword($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::KeywordExtractor ##############

package Lingua::ZH::Jieba::KeywordExtractor;
$Lingua::ZH::Jieba::KeywordExtractor::VERSION = '0.003';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_KeywordExtractor(@_);
    bless $self, $pkg if defined($self);
}

*_extract = *Lingua::ZH::Jiebac::KeywordExtractor__extract;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_KeywordExtractor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::Jieba ##############

package Lingua::ZH::Jieba::Jieba;
$Lingua::ZH::Jieba::Jieba::VERSION = '0.003';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_Jieba(@_);
    bless $self, $pkg if defined($self);
}

*_cut = *Lingua::ZH::Jiebac::Jieba__cut;
*_cut_all = *Lingua::ZH::Jiebac::Jieba__cut_all;
*_cut_for_search = *Lingua::ZH::Jiebac::Jieba__cut_for_search;
*insert_user_word = *Lingua::ZH::Jiebac::Jieba_insert_user_word;
*_tag = *Lingua::ZH::Jiebac::Jieba__tag;
*extractor = *Lingua::ZH::Jiebac::Jieba_extractor;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_Jieba($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Lingua::ZH::Jieba;



package Lingua::ZH::Jieba::KeywordExtractor;
use strict;
use warnings;
use utf8;

sub extract {
    my ($self, $sentence, $top_n) = @_;

    my $words = $self->_extract($sentence, $top_n);

    for (@$words) {
        utf8::decode($_->[0]);
    }
    return $words;
}


package Lingua::ZH::Jieba::Jieba;
use strict;
use warnings;
use utf8;

sub cut {
    my ($self, $sentence, $opts) = @_;
    
    $opts ||= {};
    my $no_hmm = $opts->{no_hmm};
    my $cut_all = $opts->{cut_all};
    
    my $words;
    if ($cut_all) {
        $words = $self->_cut_all($sentence);
    } else {
        $words = $self->_cut($sentence, !$no_hmm);
    }
    
    for (@$words) {
        utf8::decode($_);
    }
    return $words;
}

sub cut_for_search {
    my ($self, $sentence, $opts) = @_;

    $opts ||= {};
    my $no_hmm = $opts->{no_hmm};
    
    my $words = $self->_cut_for_search($sentence, !$no_hmm);
    
    for (@$words) {
        utf8::decode($_);
    }
    return $words;
}

sub tag {
    my ($self, $sentence) = @_;

    my $words = $self->_tag($sentence);
    for (@$words) {
        utf8::decode($_->[0]);
    }
    return $words;
}


package Lingua::ZH::Jieba;
# ABSTRACT: Perl wrapper for CppJieba (Chinese text segmentation)
use 5.010;
use strict;
use warnings;
use utf8;

use File::ShareDir qw(dist_file);

sub _shared_file {
    my $file = shift;
    return dist_file('Lingua-ZH-Jieba', $file);
}
my $default_dict_path = _shared_file('dict/jieba.dict.utf8');
my $default_user_dict_path = _shared_file('dict/user.dict.utf8');
my $default_hmm_path = _shared_file('dict/hmm_model.utf8');
my $default_idf_path = _shared_file('dict/idf.utf8');
my $default_stop_word_path = _shared_file('dict/stop_words.utf8');

sub new {
    my $pkg = shift;
    my $opts = shift;

    $opts //= {};
    
    my $dict_path = $opts->{dict_path};
    my $hmm_path = $opts->{hmm_path};
    my $user_dict_path = $opts->{user_dict_path};
    my $idf_path = $opts->{idf_path};
    my $stop_word_path = $opts->{stop_word_path};

    $dict_path //= $default_dict_path;
    $hmm_path //= $default_hmm_path;
    $user_dict_path //= $default_user_dict_path;
    $idf_path //= $default_idf_path;
    $stop_word_path //= $default_stop_word_path;
   
    return Lingua::ZH::Jieba::Jieba->new(
            $dict_path . "",
            $hmm_path . "",
            $user_dict_path . "",
            $idf_path . "",
            $stop_word_path . ""   
        );
}

1;
