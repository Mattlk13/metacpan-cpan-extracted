# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Lingua::ZH::Jieba;
$Lingua::ZH::Jieba::VERSION = '0.006';
use base qw(Exporter);
use base qw(DynaLoader);
package Lingua::ZH::Jiebac;
$Lingua::ZH::Jiebac::VERSION = '0.006';
bootstrap Lingua::ZH::Jieba;
package Lingua::ZH::Jieba;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Lingua::ZH::Jieba;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Lingua::ZH::Jieba;


############# Class : Lingua::ZH::Jieba::vector_s ##############

package Lingua::ZH::Jieba::vector_s;
$Lingua::ZH::Jieba::vector_s::VERSION = '0.006';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_vector_s(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::ZH::Jiebac::vector_s_size;
*empty = *Lingua::ZH::Jiebac::vector_s_empty;
*clear = *Lingua::ZH::Jiebac::vector_s_clear;
*push = *Lingua::ZH::Jiebac::vector_s_push;
*pop = *Lingua::ZH::Jiebac::vector_s_pop;
*get = *Lingua::ZH::Jiebac::vector_s_get;
*set = *Lingua::ZH::Jiebac::vector_s_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_vector_s($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::vector_wordpos ##############

package Lingua::ZH::Jieba::vector_wordpos;
$Lingua::ZH::Jieba::vector_wordpos::VERSION = '0.006';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_vector_wordpos(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::ZH::Jiebac::vector_wordpos_size;
*empty = *Lingua::ZH::Jiebac::vector_wordpos_empty;
*clear = *Lingua::ZH::Jiebac::vector_wordpos_clear;
*push = *Lingua::ZH::Jiebac::vector_wordpos_push;
*pop = *Lingua::ZH::Jiebac::vector_wordpos_pop;
*get = *Lingua::ZH::Jiebac::vector_wordpos_get;
*set = *Lingua::ZH::Jiebac::vector_wordpos_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_vector_wordpos($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::vector_keyword ##############

package Lingua::ZH::Jieba::vector_keyword;
$Lingua::ZH::Jieba::vector_keyword::VERSION = '0.006';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_vector_keyword(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::ZH::Jiebac::vector_keyword_size;
*empty = *Lingua::ZH::Jiebac::vector_keyword_empty;
*clear = *Lingua::ZH::Jiebac::vector_keyword_clear;
*push = *Lingua::ZH::Jiebac::vector_keyword_push;
*pop = *Lingua::ZH::Jiebac::vector_keyword_pop;
*get = *Lingua::ZH::Jiebac::vector_keyword_get;
*set = *Lingua::ZH::Jiebac::vector_keyword_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_vector_keyword($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::vector_word ##############

package Lingua::ZH::Jieba::vector_word;
$Lingua::ZH::Jieba::vector_word::VERSION = '0.006';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_vector_word(@_);
    bless $self, $pkg if defined($self);
}

*size = *Lingua::ZH::Jiebac::vector_word_size;
*empty = *Lingua::ZH::Jiebac::vector_word_empty;
*clear = *Lingua::ZH::Jiebac::vector_word_clear;
*push = *Lingua::ZH::Jiebac::vector_word_push;
*pop = *Lingua::ZH::Jiebac::vector_word_pop;
*get = *Lingua::ZH::Jiebac::vector_word_get;
*set = *Lingua::ZH::Jiebac::vector_word_set;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_vector_word($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::Word ##############

package Lingua::ZH::Jieba::Word;
$Lingua::ZH::Jieba::Word::VERSION = '0.006';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
*swig_word_get = *Lingua::ZH::Jiebac::Word_word_get;
*swig_word_set = *Lingua::ZH::Jiebac::Word_word_set;
*swig_offset_get = *Lingua::ZH::Jiebac::Word_offset_get;
*swig_offset_set = *Lingua::ZH::Jiebac::Word_offset_set;
*swig_length_get = *Lingua::ZH::Jiebac::Word_length_get;
*swig_length_set = *Lingua::ZH::Jiebac::Word_length_set;
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_Word(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_Word($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::KeywordExtractor ##############

package Lingua::ZH::Jieba::KeywordExtractor;
$Lingua::ZH::Jieba::KeywordExtractor::VERSION = '0.006';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_KeywordExtractor(@_);
    bless $self, $pkg if defined($self);
}

*_extract = *Lingua::ZH::Jiebac::KeywordExtractor__extract;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_KeywordExtractor($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Lingua::ZH::Jieba::Jieba ##############

package Lingua::ZH::Jieba::Jieba;
$Lingua::ZH::Jieba::Jieba::VERSION = '0.006';
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Lingua::ZH::Jieba );
%OWNER = ();
%ITERATORS = ();
sub new {
    my $pkg = shift;
    my $self = Lingua::ZH::Jiebac::new_Jieba(@_);
    bless $self, $pkg if defined($self);
}

*_cut = *Lingua::ZH::Jiebac::Jieba__cut;
*_cut_ex = *Lingua::ZH::Jiebac::Jieba__cut_ex;
*_cut_all = *Lingua::ZH::Jiebac::Jieba__cut_all;
*_cut_all_ex = *Lingua::ZH::Jiebac::Jieba__cut_all_ex;
*_cut_for_search = *Lingua::ZH::Jiebac::Jieba__cut_for_search;
*_cut_for_search_ex = *Lingua::ZH::Jiebac::Jieba__cut_for_search_ex;
*insert_user_word = *Lingua::ZH::Jiebac::Jieba_insert_user_word;
*_tag = *Lingua::ZH::Jiebac::Jieba__tag;
*extractor = *Lingua::ZH::Jiebac::Jieba_extractor;
sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Lingua::ZH::Jiebac::delete_Jieba($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Lingua::ZH::Jieba;



use 5.010;
use strict;
use warnings;
use utf8;

package Lingua::ZH::Jieba::KeywordExtractor;

sub extract {
    my ($self, $sentence, $top_n) = @_;

    my $words = $self->_extract($sentence, $top_n);

    for (@$words) {
        utf8::decode($_->[0]);
    }
    return $words;
}


package Lingua::ZH::Jieba::Jieba;

sub _make_cut {
    my $want_position = shift;

    return sub {
        my ($self, $sentence, $opts) = @_;
        
        $opts ||= {};
        my $no_hmm = $opts->{no_hmm};
        my $cut_all = $opts->{cut_all};
        
        my $words;
        
        if ($want_position) {
            if ($cut_all) {
                $words = $self->_cut_all_ex($sentence);
            } else {
                $words = $self->_cut_ex($sentence, !$no_hmm);
            }
            for (@$words) {
                utf8::decode($_->[0]);
            }
        } else {
            if ($cut_all) {
                $words = $self->_cut_all($sentence);
            } else {
                $words = $self->_cut($sentence, !$no_hmm);
            }
            for (@$words) {
                utf8::decode($_);
            }
        }
    
        return $words;
    };
}

sub _make_cut_for_search {
    my $want_position = shift;

    return sub {
        my ($self, $sentence, $opts) = @_;

        $opts ||= {};
        my $no_hmm = $opts->{no_hmm};
        
        my $words;
        if ($want_position) {
            $words = $self->_cut_for_search_ex($sentence, !$no_hmm);
            for (@$words) {
                utf8::decode($_->[0]);
            }
        } else {
            $words = $self->_cut_for_search($sentence, !$no_hmm);
            for (@$words) {
                utf8::decode($_);
            }
        }
        return $words;
    };
}

{
    no strict 'refs';
    *cut = _make_cut(0);
    *cut_ex = _make_cut(1);
    *cut_for_search = _make_cut_for_search(0);
    *cut_for_search_ex = _make_cut_for_search(1);
}

sub tag {
    my ($self, $sentence) = @_;

    my $words = $self->_tag($sentence);
    for (@$words) {
        utf8::decode($_->[0]);
    }
    return $words;
}


package Lingua::ZH::Jieba;

use File::ShareDir qw(dist_file);

sub _shared_file {
    my $file = shift;
    return dist_file('Lingua-ZH-Jieba', $file);
}
my $default_dict_path = _shared_file('dict/jieba.dict.utf8');
my $default_user_dict_path = _shared_file('dict/user.dict.utf8');
my $default_hmm_path = _shared_file('dict/hmm_model.utf8');
my $default_idf_path = _shared_file('dict/idf.utf8');
my $default_stop_word_path = _shared_file('dict/stop_words.utf8');

sub new {
    my $pkg = shift;
    my $opts = shift;

    $opts //= {};
    
    my $dict_path = $opts->{dict_path};
    my $hmm_path = $opts->{hmm_path};
    my $user_dict_path = $opts->{user_dict_path};
    my $idf_path = $opts->{idf_path};
    my $stop_word_path = $opts->{stop_word_path};

    $dict_path //= $default_dict_path;
    $hmm_path //= $default_hmm_path;
    $user_dict_path //= $default_user_dict_path;
    $idf_path //= $default_idf_path;
    $stop_word_path //= $default_stop_word_path;
   
    return Lingua::ZH::Jieba::Jieba->new(
            $dict_path . "",
            $hmm_path . "",
            $user_dict_path . "",
            $idf_path . "",
            $stop_word_path . ""   
        );
}

1;
