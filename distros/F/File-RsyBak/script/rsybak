#!/usr/bin/perl

# BEGIN DATAPACK CODE
{
    my $toc;
    my $data_linepos = 1;
    unshift @INC, sub {
        $toc ||= do {

            my $fh = \*DATA;

        my $header_line;
        my $header_found;
        while (1) {
            my $header_line = <$fh>;
            defined($header_line)
                or die "Unexpected end of data section while reading header line";
            chomp($header_line);
            if ($header_line eq 'Data::Section::Seekable v1') {
                $header_found++;
                last;
            }
        }
        die "Can't find header 'Data::Section::Seekable v1'"
            unless $header_found;

        my %toc;
        my $i = 0;
        while (1) {
            $i++;
            my $toc_line = <$fh>;
            defined($toc_line)
                or die "Unexpected end of data section while reading TOC line #$i";
            chomp($toc_line);
            $toc_line =~ /\S/ or last;
            $toc_line =~ /^([^,]+),(\d+),(\d+)(?:,(.*))?$/
                or die "Invalid TOC line #$i in data section: $toc_line";
            $toc{$1} = [$2, $3, $4];
        }
        my $pos = tell $fh;
        $toc{$_}[0] += $pos for keys %toc;


            # calculate the line number of data section
            my $data_pos = tell(DATA);
            seek DATA, 0, 0;
            my $pos = 0;
            while (1) {
                my $line = <DATA>;
                $pos += length($line);
                $data_linepos++;
                last if $pos >= $data_pos;
            }
            seek DATA, $data_pos, 0;

            \%toc;
        };
        if ($toc->{$_[1]}) {
            seek DATA, $toc->{$_[1]}[0], 0;
            read DATA, my($content), $toc->{$_[1]}[1];
            my ($order, $lineoffset) = split(';', $toc->{$_[1]}[2]);
            $content =~ s/^#//gm;
            $content = "# line ".($data_linepos + $order+1 + $lineoffset)." \"".__FILE__."\"\n" . $content;
            open my $fh, '<', \$content
                or die "DataPacker error loading $_[1]: $!";
            return $fh;
        }
        return;
    };
}
# END DATAPACK CODE

our $DATE = '2019-03-11'; # DATE
our $DIST = 'File-RsyBak'; # DIST
our $VERSION = '0.361'; # VERSION

use 5.010001;
use strict;
use warnings;

require Perinci::CmdLine::Lite;

Perinci::CmdLine::Lite->new(
    url => "/File/RsyBak/backup",
    log => 1,
    program_name => "rsybak",
    per_arg_yaml => 1,
)->run;

# ABSTRACT: Backup files/directories with histories, using rsync
# PODNAME: rsybak

__END__

=pod

=encoding UTF-8

=head1 NAME

rsybak - Backup files/directories with histories, using rsync

=head1 VERSION

This document describes version 0.361 of rsybak (from Perl distribution File-RsyBak), released on 2019-03-11.

=head1 SYNOPSIS

Usage:

 % rsybak [options] <source> <target>

Examples:

 % rsybak /home/jajang/mydata /backup/jajang/mydata

=head1 OPTIONS

C<*> marks required options.

=head2 Main options

=over

=item B<--extra-dir>

Whether to force creation of source directory in target.

If set to 1, then backup(source => '/a', target => '/backup/a') will create
another 'a' directory in target, i.e. /backup/a/current/a. Otherwise, contents
of a/ will be directly copied under /backup/a/current/.

Will always be set to 1 if source is more than one, but default to 0 if source
is a single directory. You can set this to 1 to so that behaviour when there is
a single source is the same as behaviour when there are several sources.


=item B<--extra-rsync-opts-json>=I<s>

Pass extra options to rsync command (JSON-encoded).

See C<--extra-rsync-opts>.

=item B<--extra-rsync-opts-yaml>=I<s>

Pass extra options to rsync command (YAML-encoded).

See C<--extra-rsync-opts>.

=item B<--extra-rsync-opts>=I<s@>

Pass extra options to rsync command.

Extra options to pass to rsync command when doing backup. Note that the options
will be shell quoted, , so you should pass it unquoted, e.g. ['--exclude',
'/Program Files'].


Can be specified multiple times.

=item B<--histories-json>=I<s>

Histories/history levels (JSON-encoded).

See C<--histories>.

=item B<--histories-yaml>=I<s>

Histories/history levels (YAML-encoded).

See C<--histories>.

=item B<--histories>=I<s@>

Histories/history levels.

Default value:

 [-7,4,3]

Specifies number of backup histories to keep for level 1, 2, and so on. If
number is negative, specifies number of days to keep instead (regardless of
number of histories).


Can be specified multiple times.

=item B<--no-backup>

If backup=1 and rotate=0 then will only create new backup without rotating
histories.


=item B<--no-rotate>

If backup=0 and rotate=1 then will only do history rotating.


=item B<--source>=I<s>*

Director(y|ies) to backup.

=item B<--target>=I<s>*

Backup destination.

=back

=head2 Configuration options

=over

=item B<--config-path>=I<filename>, B<-c>

Set path to configuration file.

=item B<--config-profile>=I<s>, B<-P>

Set configuration profile to use.

=item B<--no-config>, B<-C>

Do not use any configuration file.

=back

=head2 Environment options

=over

=item B<--no-env>

Do not read environment for default options.

=back

=head2 Logging options

=over

=item B<--debug>

Shortcut for --log-level=debug.

=item B<--log-level>=I<s>

Set log level.

=item B<--quiet>

Shortcut for --log-level=error.

=item B<--trace>

Shortcut for --log-level=trace.

=item B<--verbose>

Shortcut for --log-level=info.

=back

=head2 Output options

=over

=item B<--format>=I<s>

Choose output format, e.g. json, text.

Default value:

 undef

=item B<--json>

Set output format to json.

=item B<--naked-res>

When outputing as JSON, strip result envelope.

Default value:

 0

By default, when outputing as JSON, the full enveloped result is returned, e.g.:

    [200,"OK",[1,2,3],{"func.extra"=>4}]

The reason is so you can get the status (1st element), status message (2nd
element) as well as result metadata/extra result (4th element) instead of just
the result (3rd element). However, sometimes you want just the result, e.g. when
you want to pipe the result for more post-processing. In this case you can use
`--naked-res` so you just get:

    [1,2,3]


=back

=head2 Other options

=over

=item B<--help>, B<-h>, B<-?>

Display help message and exit.

=item B<--version>, B<-v>

Display program's version and exit.

=back

=head1 COMPLETION

This script has shell tab completion capability with support for several
shells.

=head2 bash

To activate bash completion for this script, put:

 complete -C rsybak rsybak

in your bash startup (e.g. F<~/.bashrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is recommended, however, that you install modules using L<cpanm-shcompgen>
which can activate shell completion for scripts immediately.

=head2 tcsh

To activate tcsh completion for this script, put:

 complete rsybak 'p/*/`rsybak`/'

in your tcsh startup (e.g. F<~/.tcshrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is also recommended to install L<shcompgen> (see above).

=head2 other shells

For fish and zsh, install L<shcompgen> as described above.

=head1 CONFIGURATION FILE

This script can read configuration files. Configuration files are in the format of L<IOD>, which is basically INI with some extra features.

By default, these names are searched for configuration filenames (can be changed using C<--config-path>): F<~/.config/rsybak.conf>, F<~/rsybak.conf>, or F</etc/rsybak.conf>.

All found files will be read and merged.

To disable searching for configuration files, pass C<--no-config>.

You can put multiple profiles in a single file by using section names like C<[profile=SOMENAME]> or C<[SOMESECTION profile=SOMENAME]>. Those sections will only be read if you specify the matching C<--config-profile SOMENAME>.

You can also put configuration for multiple programs inside a single file, and use filter C<program=NAME> in section names, e.g. C<[program=NAME ...]> or C<[SOMESECTION program=NAME]>. The section will then only be used when the reading program matches.

Finally, you can filter a section by environment variable using the filter C<env=CONDITION> in section names. For example if you only want a section to be read if a certain environment variable is true: C<[env=SOMEVAR ...]> or C<[SOMESECTION env=SOMEVAR ...]>. If you only want a section to be read when the value of an environment variable has value equals something: C<[env=HOSTNAME=blink ...]> or C<[SOMESECTION env=HOSTNAME=blink ...]>. If you only want a section to be read when the value of an environment variable does not equal something: C<[env=HOSTNAME!=blink ...]> or C<[SOMESECTION env=HOSTNAME!=blink ...]>. If you only want a section to be read when an environment variable contains something: C<[env=HOSTNAME*=server ...]> or C<[SOMESECTION env=HOSTNAME*=server ...]>. Note that currently due to simplistic parsing, there must not be any whitespace in the value being compared because it marks the beginning of a new section filter or section name.

List of available configuration parameters:

 backup (see --no-backup)
 extra_dir (see --extra-dir)
 extra_rsync_opts (see --extra-rsync-opts)
 format (see --format)
 histories (see --histories)
 log_level (see --log-level)
 naked_res (see --naked-res)
 rotate (see --no-rotate)
 source (see --source)
 target (see --target)

=head1 ENVIRONMENT

=head2 RSYBAK_OPT => str

Specify additional command-line options.

=head1 FILES

F<~/.config/rsybak.conf>

F<~/rsybak.conf>

F</etc/rsybak.conf>

=head1 HOMEPAGE

Please visit the project's homepage at L<https://metacpan.org/release/File-RsyBak>.

=head1 SOURCE

Source repository is at L<https://github.com/perlancar/perl-File-RsyBak>.

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=File-RsyBak>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 AUTHOR

perlancar <perlancar@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2019, 2017, 2015, 2014, 2013, 2012, 2011 by perlancar@cpan.org.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut

__DATA__
Data::Section::Seekable v1
Capture/Tiny.pm,24,10394,0;0
Class/Inspector.pm,10445,6464,1;337
Class/Inspector/Functions.pm,16946,700,2;646
Clone/PP.pm,17666,1884,3;693
Color/ANSI/Util.pm,19577,16410,4;764
Complete/Bash.pm,36012,17675,5;1301
Complete/Common.pm,53714,945,6;1832
Complete/Env.pm,54683,2847,7;1871
Complete/File.pm,57555,8536,8;1996
Complete/Fish.pm,66116,2069,9;2269
Complete/Getopt/Long.pm,68217,18507,10;2359
Complete/Path.pm,86749,7961,11;2913
Complete/Tcsh.pm,94735,2757,12;3173
Complete/Util.pm,97517,23157,13;3278
Complete/Zsh.pm,120698,1345,14;4055
Config/IOD/Base.pm,122070,13499,15;4117
Config/IOD/Expr.pm,135596,1416,16;4622
Config/IOD/INI/Reader.pm,137045,496,17;4710
Config/IOD/Reader.pm,137570,6412,18;4736
Data/Check/Structure.pm,144014,3504,19;4943
Data/Clean.pm,147540,7815,20;5105
Data/Clean/FromJSON.pm,155386,535,21;5373
Data/Clean/JSON.pm,155948,1314,22;5403
Data/Dmp.pm,157282,4396,23;5460
Data/Dump.pm,161699,12066,24;5644
Data/Dump/FilterContext.pm,173800,1740,25;6177
Data/Dump/Filtered.pm,175570,812,26;6271
Data/Dump/Trace.pm,176409,6339,27;6304
Data/ModeMerge.pm,182774,10593,28;6570
Data/ModeMerge/Config.pm,193400,2140,29;6888
Data/ModeMerge/Mode/ADD.pm,195575,1373,30;6959
Data/ModeMerge/Mode/Base.pm,196984,16705,31;7028
Data/ModeMerge/Mode/CONCAT.pm,213727,442,32;7558
Data/ModeMerge/Mode/DELETE.pm,214207,1218,33;7586
Data/ModeMerge/Mode/KEEP.pm,215461,1174,34;7661
Data/ModeMerge/Mode/NORMAL.pm,216673,1501,35;7729
Data/ModeMerge/Mode/SUBTRACT.pm,218214,2064,36;7822
Data/Sah.pm,220298,2542,37;7914
Data/Sah/Coerce.pm,222867,3930,38;8027
Data/Sah/Coerce/js/bool/float.pm,226838,527,39;8160
Data/Sah/Coerce/js/bool/str.pm,227404,684,40;8199
Data/Sah/Coerce/js/date/float_epoch.pm,228135,557,41;8241
Data/Sah/Coerce/js/date/obj_Date.pm,228736,542,42;8280
Data/Sah/Coerce/js/date/str.pm,229317,605,43;8318
Data/Sah/Coerce/js/datenotime/float_epoch.pm,229975,240,44;8356
Data/Sah/Coerce/js/datenotime/obj_Date.pm,230265,234,45;8371
Data/Sah/Coerce/js/datenotime/str.pm,230544,224,46;8386
Data/Sah/Coerce/js/datetime/float_epoch.pm,230819,238,47;8401
Data/Sah/Coerce/js/datetime/obj_Date.pm,231105,232,48;8416
Data/Sah/Coerce/js/datetime/str.pm,231380,222,49;8431
Data/Sah/Coerce/js/duration/float_secs.pm,231652,708,50;8446
Data/Sah/Coerce/js/duration/str_iso8601.pm,232411,934,51;8487
Data/Sah/Coerce/js/timeofday/str_hms.pm,233393,1198,52;8529
Data/Sah/Coerce/perl/bool/str.pm,234632,528,53;8576
Data/Sah/Coerce/perl/date/float_epoch.pm,235209,1175,54;8613
Data/Sah/Coerce/perl/date/float_epoch_always.pm,236440,1120,55;8666
Data/Sah/Coerce/perl/date/obj_DateTime.pm,237610,1061,56;8717
Data/Sah/Coerce/perl/date/obj_TimeMoment.pm,238723,1199,57;8768
Data/Sah/Coerce/perl/date/str_iso8601.pm,239971,1905,58;8819
Data/Sah/Coerce/perl/datenotime/float_epoch.pm,241931,244,59;8873
Data/Sah/Coerce/perl/datenotime/float_epoch_always.pm,242237,258,60;8888
Data/Sah/Coerce/perl/datenotime/obj_DateTime.pm,242551,248,61;8903
Data/Sah/Coerce/perl/datenotime/obj_TimeMoment.pm,242857,250,62;8919
Data/Sah/Coerce/perl/datenotime/str_iso8601.pm,243162,1729,63;8934
Data/Sah/Coerce/perl/datetime/float_epoch.pm,244944,242,64;8988
Data/Sah/Coerce/perl/datetime/float_epoch_always.pm,245246,256,65;9003
Data/Sah/Coerce/perl/datetime/obj_DateTime.pm,245556,244,66;9018
Data/Sah/Coerce/perl/datetime/obj_TimeMoment.pm,245856,248,67;9033
Data/Sah/Coerce/perl/datetime/str_iso8601.pm,246157,1844,68;9048
Data/Sah/Coerce/perl/duration/float_secs.pm,248053,937,69;9102
Data/Sah/Coerce/perl/duration/obj_DateTimeDuration.pm,249052,1104,70;9149
Data/Sah/Coerce/perl/duration/str_human.pm,250207,1917,71;9197
Data/Sah/Coerce/perl/duration/str_iso8601.pm,252177,1414,72;9246
Data/Sah/Coerce/perl/float/str_percent.pm,253641,501,73;9294
Data/Sah/Coerce/perl/int/str_percent.pm,254190,487,74;9330
Data/Sah/Coerce/perl/timeofday/obj_DateTimeOfDay.pm,254737,994,75;9366
Data/Sah/Coerce/perl/timeofday/str_hms.pm,255781,1716,76;9416
Data/Sah/CoerceCommon.pm,257530,6618,77;9467
Data/Sah/CoerceJS.pm,264177,4421,78;9677
Data/Sah/Compiler.pm,268627,20536,79;9819
Data/Sah/Compiler/Prog.pm,289197,25951,80;10523
Data/Sah/Compiler/Prog/TH.pm,315185,3109,81;11382
Data/Sah/Compiler/Prog/TH/all.pm,318335,535,82;11509
Data/Sah/Compiler/Prog/TH/any.pm,318911,535,83;11541
Data/Sah/Compiler/TH.pm,319478,1248,84;11573
Data/Sah/Compiler/TextResultRole.pm,320770,1191,85;11639
Data/Sah/Compiler/human.pm,321996,12250,86;11701
Data/Sah/Compiler/human/TH.pm,334284,1083,87;12145
Data/Sah/Compiler/human/TH/Comparable.pm,335416,689,88;12211
Data/Sah/Compiler/human/TH/HasElems.pm,336152,1965,89;12243
Data/Sah/Compiler/human/TH/Sortable.pm,338164,1544,90;12315
Data/Sah/Compiler/human/TH/all.pm,339750,1853,91;12382
Data/Sah/Compiler/human/TH/any.pm,341645,1802,92;12462
Data/Sah/Compiler/human/TH/array.pm,343491,2854,93;12541
Data/Sah/Compiler/human/TH/bool.pm,346388,1153,94;12652
Data/Sah/Compiler/human/TH/buf.pm,347583,473,95;12710
Data/Sah/Compiler/human/TH/cistr.pm,348100,267,96;12740
Data/Sah/Compiler/human/TH/code.pm,348410,471,97;12758
Data/Sah/Compiler/human/TH/date.pm,348924,565,98;12787
Data/Sah/Compiler/human/TH/datenotime.pm,349538,273,99;12817
Data/Sah/Compiler/human/TH/datetime.pm,349858,454,100;12835
Data/Sah/Compiler/human/TH/duration.pm,350359,585,101;12862
Data/Sah/Compiler/human/TH/float.pm,350988,2137,102;12892
Data/Sah/Compiler/human/TH/hash.pm,353168,8936,103;12989
Data/Sah/Compiler/human/TH/int.pm,362146,1742,104;13330
Data/Sah/Compiler/human/TH/num.pm,363930,569,105;13409
Data/Sah/Compiler/human/TH/obj.pm,364541,902,106;13439
Data/Sah/Compiler/human/TH/re.pm,365484,517,107;13490
Data/Sah/Compiler/human/TH/str.pm,366043,2307,108;13521
Data/Sah/Compiler/human/TH/timeofday.pm,368398,575,109;13626
Data/Sah/Compiler/human/TH/undef.pm,369017,529,110;13656
Data/Sah/Compiler/perl.pm,369580,9997,111;13687
Data/Sah/Compiler/perl/TH.pm,379614,1301,112;14101
Data/Sah/Compiler/perl/TH/all.pm,380956,317,113;14149
Data/Sah/Compiler/perl/TH/any.pm,381314,317,114;14171
Data/Sah/Compiler/perl/TH/array.pm,381674,4413,115;14193
Data/Sah/Compiler/perl/TH/bool.pm,386129,2361,116;14327
Data/Sah/Compiler/perl/TH/buf.pm,388531,293,117;14411
Data/Sah/Compiler/perl/TH/cistr.pm,388867,3622,118;14430
Data/Sah/Compiler/perl/TH/code.pm,392531,457,119;14563
Data/Sah/Compiler/perl/TH/date.pm,393030,5700,120;14590
Data/Sah/Compiler/perl/TH/datenotime.pm,398778,308,121;14746
Data/Sah/Compiler/perl/TH/datetime.pm,399132,304,122;14765
Data/Sah/Compiler/perl/TH/duration.pm,399482,5789,123;14784
Data/Sah/Compiler/perl/TH/float.pm,405314,6296,124;14950
Data/Sah/Compiler/perl/TH/hash.pm,411652,15327,125;15134
Data/Sah/Compiler/perl/TH/int.pm,427020,1066,126;15603
Data/Sah/Compiler/perl/TH/num.pm,428127,2068,127;15654
Data/Sah/Compiler/perl/TH/obj.pm,430236,883,128;15730
Data/Sah/Compiler/perl/TH/re.pm,431159,524,129;15776
Data/Sah/Compiler/perl/TH/str.pm,431724,5219,130;15805
Data/Sah/Compiler/perl/TH/timeofday.pm,436990,4892,131;15976
Data/Sah/Compiler/perl/TH/undef.pm,441925,454,132;16111
Data/Sah/Human.pm,442405,668,133;16138
Data/Sah/Lang.pm,443098,262,134;16173
Data/Sah/Lang/fr_FR.pm,443391,1564,135;16194
Data/Sah/Lang/id_ID.pm,444986,8192,136;16300
Data/Sah/Lang/zh_CN.pm,453209,1464,137;16696
Data/Sah/Normalize.pm,454703,6074,138;16803
Data/Sah/Resolve.pm,460805,3692,139;16984
Data/Sah/Type/BaseType.pm,464531,2721,140;17092
Data/Sah/Type/Comparable.pm,467288,736,141;17225
Data/Sah/Type/HasElems.pm,468058,3600,142;17258
Data/Sah/Type/Sortable.pm,471692,1981,143;17402
Data/Sah/Type/all.pm,473702,464,144;17485
Data/Sah/Type/any.pm,474195,464,145;17508
Data/Sah/Type/array.pm,474690,757,146;17531
Data/Sah/Type/bool.pm,475477,438,147;17564
Data/Sah/Type/buf.pm,475944,180,148;17588
Data/Sah/Type/cistr.pm,476155,182,149;17602
Data/Sah/Type/code.pm,476367,186,150;17616
Data/Sah/Type/date.pm,476583,301,151;17630
Data/Sah/Type/datenotime.pm,476920,188,152;17648
Data/Sah/Type/datetime.pm,477142,186,153;17662
Data/Sah/Type/duration.pm,477362,305,154;17676
Data/Sah/Type/float.pm,477698,887,155;17694
Data/Sah/Type/hash.pm,478615,4581,156;17741
Data/Sah/Type/int.pm,483225,649,157;17929
Data/Sah/Type/num.pm,483903,257,158;17960
Data/Sah/Type/obj.pm,484189,510,159;17976
Data/Sah/Type/re.pm,484727,225,160;18004
Data/Sah/Type/str.pm,484981,776,161;18019
Data/Sah/Type/timeofday.pm,485792,304,162;18058
Data/Sah/Type/undef.pm,486127,168,163;18075
Data/Sah/Util/Func.pm,486325,330,164;18087
Data/Sah/Util/Role.pm,486685,3346,165;18110
Data/Sah/Util/Type.pm,490061,3406,166;18225
Data/Sah/Util/Type/Date.pm,493502,5075,167;18354
Data/Sah/Util/TypeX.pm,498608,338,168;18500
File/Flock/Retry.pm,498974,1846,169;18525
File/RsyBak.pm,500843,11695,170;18626
File/RsyBak/Packed.pm,512568,11570,171;18987
File/ShareDir.pm,524163,6067,172;18999
File/ShareDir/Tarball.pm,530263,1502,173;19279
File/Slurper.pm,531789,2626,174;19357
File/Which.pm,534437,2267,175;19460
File/chdir.pm,536726,3979,176;19575
Function/Fallback/CoreOrPP.pm,540743,1761,177;19763
Getopt/Long/Negate/EN.pm,542537,1797,178;19854
Getopt/Long/Util.pm,544362,9133,179;19906
HTTP/Tiny.pm,553516,40445,180;20239
HTTP/Tiny/UNIX.pm,593987,2143,181;21581
IO/Pty.pm,596148,3553,182;21679
IO/Tty.pm,599719,2398,183;21826
IPC/Run.pm,602136,65044,184;21934
IPC/Run/Debug.pm,667205,5880,185;23993
IPC/Run/IO.pm,673107,9599,186;24232
IPC/Run/Timer.pm,682731,6347,187;24625
IPC/Run/Win32Helper.pm,689109,9319,188;24907
IPC/Run/Win32IO.pm,698455,11108,189;25194
IPC/Run/Win32Pump.pm,709592,2609,190;25619
IPC/System/Options.pm,712231,11526,191;25720
JSON.pm,723773,55930,192;26102
JSON/MaybeXS.pm,779727,2412,193;27747
JSON/PP.pm,782158,41808,194;27847
JSON/PP/Boolean.pm,823993,43,195;29403
Lingua/EN/Numbers/Ordinate.pm,824074,724,196;29410
Lingua/EN/PluralToSingular.pm,824836,6120,197;29449
Log/ger.pm,830975,3553,198;29882
Log/ger/App.pm,834551,4847,199;30019
Log/ger/Format.pm,839424,184,200;30185
Log/ger/Format/None.pm,839639,281,201;30198
Log/ger/Heavy.pm,839945,14829,202;30217
Log/ger/Layout.pm,854800,197,203;30556
Log/ger/Layout/Pattern.pm,855031,3658,204;30569
Log/ger/Output.pm,858715,195,205;30696
Log/ger/Output/Array.pm,858942,565,206;30709
Log/ger/Output/ArrayML.pm,859541,685,207;30741
Log/ger/Output/Composite.pm,860262,10391,208;30775
Log/ger/Output/File.pm,870684,2042,209;31022
Log/ger/Output/Null.pm,872757,328,210;31098
Log/ger/Output/Screen.pm,873118,3112,211;31118
Log/ger/Output/String.pm,876263,981,212;31238
Log/ger/Output/Syslog.pm,877277,1440,213;31279
Log/ger/Plugin.pm,878743,1096,214;31338
Log/ger/Plugin/MultilevelLog.pm,879879,552,215;31398
Log/ger/Util.pm,880455,8411,216;31428
Mo.pm,888880,591,217;31702
Mo/Golf.pm,889490,7519,218;31706
Mo/Inline.pm,897030,2047,219;31923
Mo/Moose.pm,899097,533,220;32009
Mo/Mouse.pm,899650,563,221;32014
Mo/build.pm,900233,248,222;32019
Mo/builder.pm,900503,338,223;32023
Mo/chain.pm,900861,216,224;32027
Mo/coerce.pm,901098,330,225;32031
Mo/default.pm,901450,435,226;32035
Mo/exporter.pm,901908,176,227;32039
Mo/import.pm,902105,185,228;32043
Mo/importer.pm,902313,207,229;32047
Mo/is.pm,902537,228,230;32051
Mo/nonlazy.pm,902787,129,231;32055
Mo/option.pm,902937,259,232;32059
Mo/required.pm,903219,340,233;32063
Mo/xs.pm,903576,256,234;32067
Module/Installed/Tiny.pm,903865,3030,235;32071
Monkey/Patch/Action.pm,906926,3287,236;32188
Monkey/Patch/Action/Handle.pm,910251,2860,237;32299
Nodejs/Util.pm,913134,7096,238;32413
Number/Format/BigFloat.pm,920264,894,239;32681
PERLANCAR/File/HomeDir.pm,921192,1230,240;32723
Perinci/Access/Lite.pm,922453,6811,241;32784
Perinci/AccessUtil.pm,929294,2450,242;32981
Perinci/CmdLine/Base.pm,931776,48130,243;33069
Perinci/CmdLine/Help.pm,979938,7382,244;34592
Perinci/CmdLine/Lite.pm,987352,14644,245;34827
Perinci/CmdLine/Util/Config.pm,1002035,10394,246;35335
Perinci/Object.pm,1012455,1134,247;35660
Perinci/Object/EnvResult.pm,1013625,1592,248;35719
Perinci/Object/EnvResultMulti.pm,1015258,1396,249;35804
Perinci/Object/EnvResultTable.pm,1016695,360,250;35863
Perinci/Object/Function.pm,1017090,1338,251;35884
Perinci/Object/Metadata.pm,1018463,2644,252;35948
Perinci/Object/Package.pm,1021141,223,253;36083
Perinci/Object/ResMeta.pm,1021398,223,254;36100
Perinci/Object/Variable.pm,1021656,225,255;36117
Perinci/Result/Format/Lite.pm,1021919,19058,256;36134
Perinci/Sub/Complete.pm,1041009,47862,257;36628
Perinci/Sub/ConvertArgs/Argv.pm,1088911,4241,258;37878
Perinci/Sub/ConvertArgs/Array.pm,1093193,2051,259;38020
Perinci/Sub/DepChecker.pm,1095278,5057,260;38101
Perinci/Sub/GetArgs/Argv.pm,1100371,38489,261;38290
Perinci/Sub/GetArgs/Array.pm,1138897,3800,262;39350
Perinci/Sub/Normalize.pm,1142730,4886,263;39481
Perinci/Sub/To/CLIDocData.pm,1147653,16158,264;39633
Perinci/Sub/Util.pm,1163839,12303,265;40083
Perinci/Sub/Util/Args.pm,1176175,3131,266;40521
Perinci/Sub/Util/ResObj.pm,1179341,243,267;40638
Perinci/Sub/Util/Sort.pm,1179617,463,268;40653
Proc/ChildError.pm,1180107,1012,269;40682
Progress/Any.pm,1181143,14396,270;40732
Progress/Any/Output.pm,1195570,1287,271;41271
Progress/Any/Output/Null.pm,1196893,227,272;41335
Progress/Any/Output/TermProgressBarColor.pm,1197172,7659,273;41356
Regexp/Stringify.pm,1204859,2473,274;41639
Role/Tiny.pm,1207353,11656,275;41738
Role/Tiny/With.pm,1219035,297,276;42167
Sah/Schema/rinci/function_meta.pm,1219374,3665,277;42189
Sah/Schema/rinci/meta.pm,1223072,683,278;42328
Sah/Schema/rinci/result_meta.pm,1223795,611,279;42371
Sah/SchemaR/rinci/function_meta.pm,1224449,4195,280;42406
Sah/SchemaR/rinci/meta.pm,1228678,1144,281;42417
Sah/SchemaR/rinci/result_meta.pm,1229863,435,282;42428
Sah/Schemas/Rinci.pm,1230327,108,283;42439
Scalar/Util/Numeric/PP.pm,1230469,1353,284;42448
Sort/BySpec.pm,1231845,5900,285;42518
String/Elide/Parts.pm,1237775,4770,286;42730
String/LineNumber.pm,1242574,859,287;42883
String/PerlQuote.pm,1243461,890,288;42923
String/ShellQuote.pm,1244380,1822,289;42973
String/Wildcard/Bash.pm,1246234,2159,290;43087
Sub/Delete.pm,1248415,1622,291;43175
Test/Config/IOD/Common.pm,1250071,6478,292;43241
Test/Data/Sah.pm,1256574,9820,293;43535
Test/Data/Sah/Human.pm,1266425,935,294;43845
Test/Data/Sah/Perl.pm,1267390,4124,295;43887
Text/ANSI/BaseUtil.pm,1271544,21721,296;44012
Text/ANSI/Util.pm,1293291,903,297;44741
Text/Table/ASV.pm,1294220,982,298;44778
Text/Table/Any.pm,1295228,6042,299;44829
Text/Table/Tiny.pm,1301297,2733,300;44992
Text/sprintfn.pm,1304055,3295,301;45091
Tie/IxHash.pm,1307372,6075,302;45216
Time/Duration.pm,1313472,5577,303;45562
YAML/Old.pm,1319069,2970,304;45766
YAML/Old/Dumper.pm,1322066,15162,305;45879
YAML/Old/Dumper/Base.pm,1337260,3525,306;46402
YAML/Old/Error.pm,1340811,5985,307;46508
YAML/Old/Loader.pm,1346823,22219,308;46699
YAML/Old/Loader/Base.pm,1369074,1235,309;47411
YAML/Old/Marshall.pm,1370338,934,310;47448
YAML/Old/Mo.pm,1371295,3050,311;47495
YAML/Old/Node.pm,1374370,4409,312;47566
YAML/Old/Tag.pm,1378803,240,313;47781
YAML/Old/Types.pm,1379069,5904,314;47800
experimental.pm,1384997,2970,315;48023
subroutines.pm,1387990,953,316;48142

### Capture/Tiny.pm ###
#use 5.006;
#use strict;
#use warnings;
#package Capture::Tiny;
#our $VERSION = '0.46';
#use Carp ();
#use Exporter ();
#use IO::Handle ();
#use File::Spec ();
#use File::Temp qw/tempfile tmpnam/;
#use Scalar::Util qw/reftype blessed/;
#BEGIN {
#  local $@;
#  eval { require PerlIO; PerlIO->can('get_layers') }
#    or *PerlIO::get_layers = sub { return () };
#}
#
#
#my %api = (
#  capture         => [1,1,0,0],
#  capture_stdout  => [1,0,0,0],
#  capture_stderr  => [0,1,0,0],
#  capture_merged  => [1,1,1,0],
#  tee             => [1,1,0,1],
#  tee_stdout      => [1,0,0,1],
#  tee_stderr      => [0,1,0,1],
#  tee_merged      => [1,1,1,1],
#);
#
#for my $sub ( keys %api ) {
#  my $args = join q{, }, @{$api{$sub}};
#  eval "sub $sub(&;@) {unshift \@_, $args; goto \\&_capture_tee;}"; 
#}
#
#our @ISA = qw/Exporter/;
#our @EXPORT_OK = keys %api;
#our %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
#
#
#my $IS_WIN32 = $^O eq 'MSWin32';
#
#
#our $TIMEOUT = 30;
#
#my @cmd = ($^X, '-C0', '-e', <<'HERE');
#use Fcntl;
#$SIG{HUP}=sub{exit};
#if ( my $fn=shift ) {
#    sysopen(my $fh, qq{$fn}, O_WRONLY|O_CREAT|O_EXCL) or die $!;
#    print {$fh} $$;
#    close $fh;
#}
#my $buf; while (sysread(STDIN, $buf, 2048)) {
#    syswrite(STDOUT, $buf); syswrite(STDERR, $buf);
#}
#HERE
#
#
#sub _relayer {
#  my ($fh, $apply_layers) = @_;
#
#  binmode( $fh, ":raw" );
#  while ( 1 < ( my $layers =()= PerlIO::get_layers( $fh, output => 1 ) ) ) {
#      binmode( $fh, ":pop" );
#  }
#  my @to_apply = @$apply_layers;
#  shift @to_apply; 
#  binmode($fh, ":" . join(":",@to_apply));
#}
#
#sub _name {
#  my $glob = shift;
#  no strict 'refs'; 
#  return *{$glob}{NAME};
#}
#
#sub _open {
#  open $_[0], $_[1] or Carp::confess "Error from open(" . join(q{, }, @_) . "): $!";
#}
#
#sub _close {
#  close $_[0] or Carp::confess "Error from close(" . join(q{, }, @_) . "): $!";
#}
#
#my %dup; 
#my %proxy_count;
#sub _proxy_std {
#  my %proxies;
#  if ( ! defined fileno STDIN ) {
#    $proxy_count{stdin}++;
#    if (defined $dup{stdin}) {
#      _open \*STDIN, "<&=" . fileno($dup{stdin});
#    }
#    else {
#      _open \*STDIN, "<" . File::Spec->devnull;
#      _open $dup{stdin} = IO::Handle->new, "<&=STDIN";
#    }
#    $proxies{stdin} = \*STDIN;
#    binmode(STDIN, ':utf8') if $] >= 5.008; 
#  }
#  if ( ! defined fileno STDOUT ) {
#    $proxy_count{stdout}++;
#    if (defined $dup{stdout}) {
#      _open \*STDOUT, ">&=" . fileno($dup{stdout});
#    }
#    else {
#      _open \*STDOUT, ">" . File::Spec->devnull;
#      _open $dup{stdout} = IO::Handle->new, ">&=STDOUT";
#    }
#    $proxies{stdout} = \*STDOUT;
#    binmode(STDOUT, ':utf8') if $] >= 5.008; 
#  }
#  if ( ! defined fileno STDERR ) {
#    $proxy_count{stderr}++;
#    if (defined $dup{stderr}) {
#      _open \*STDERR, ">&=" . fileno($dup{stderr});
#    }
#    else {
#      _open \*STDERR, ">" . File::Spec->devnull;
#      _open $dup{stderr} = IO::Handle->new, ">&=STDERR";
#    }
#    $proxies{stderr} = \*STDERR;
#    binmode(STDERR, ':utf8') if $] >= 5.008; 
#  }
#  return %proxies;
#}
#
#sub _unproxy {
#  my (%proxies) = @_;
#  for my $p ( keys %proxies ) {
#    $proxy_count{$p}--;
#    if ( ! $proxy_count{$p} ) {
#      _close $proxies{$p};
#      _close $dup{$p} unless $] < 5.008; 
#      delete $dup{$p};
#    }
#  }
#}
#
#sub _copy_std {
#  my %handles;
#  for my $h ( qw/stdout stderr stdin/ ) {
#    next if $h eq 'stdin' && ! $IS_WIN32; 
#    my $redir = $h eq 'stdin' ? "<&" : ">&";
#    _open $handles{$h} = IO::Handle->new(), $redir . uc($h); 
#  }
#  return \%handles;
#}
#
#sub _open_std {
#  my ($handles) = @_;
#  _open \*STDIN, "<&" . fileno $handles->{stdin} if defined $handles->{stdin};
#  _open \*STDOUT, ">&" . fileno $handles->{stdout} if defined $handles->{stdout};
#  _open \*STDERR, ">&" . fileno $handles->{stderr} if defined $handles->{stderr};
#}
#
#
#sub _start_tee {
#  my ($which, $stash) = @_; 
#  $stash->{$_}{$which} = IO::Handle->new for qw/tee reader/;
#  pipe $stash->{reader}{$which}, $stash->{tee}{$which};
#  select((select($stash->{tee}{$which}), $|=1)[0]); 
#  $stash->{new}{$which} = $stash->{tee}{$which};
#  $stash->{child}{$which} = {
#    stdin   => $stash->{reader}{$which},
#    stdout  => $stash->{old}{$which},
#    stderr  => $stash->{capture}{$which},
#  };
#  $stash->{flag_files}{$which} = scalar tmpnam();
#  if ( $IS_WIN32 ) {
#    my $old_eval_err=$@;
#    undef $@;
#
#    eval "use Win32API::File qw/GetOsFHandle SetHandleInformation fileLastError HANDLE_FLAG_INHERIT INVALID_HANDLE_VALUE/ ";
#    my $os_fhandle = GetOsFHandle( $stash->{tee}{$which} );
#    my $result = SetHandleInformation( $os_fhandle, HANDLE_FLAG_INHERIT(), 0);
#    _open_std( $stash->{child}{$which} );
#    $stash->{pid}{$which} = system(1, @cmd, $stash->{flag_files}{$which});
#    $@=$old_eval_err;
#  }
#  else { 
#    _fork_exec( $which, $stash );
#  }
#}
#
#sub _fork_exec {
#  my ($which, $stash) = @_; 
#  my $pid = fork;
#  if ( not defined $pid ) {
#    Carp::confess "Couldn't fork(): $!";
#  }
#  elsif ($pid == 0) { 
#    untie *STDIN; untie *STDOUT; untie *STDERR;
#    _close $stash->{tee}{$which};
#    _open_std( $stash->{child}{$which} );
#    exec @cmd, $stash->{flag_files}{$which};
#  }
#  $stash->{pid}{$which} = $pid
#}
#
#my $have_usleep = eval "use Time::HiRes 'usleep'; 1";
#sub _files_exist {
#  return 1 if @_ == grep { -f } @_;
#  Time::HiRes::usleep(1000) if $have_usleep;
#  return 0;
#}
#
#sub _wait_for_tees {
#  my ($stash) = @_;
#  my $start = time;
#  my @files = values %{$stash->{flag_files}};
#  my $timeout = defined $ENV{PERL_CAPTURE_TINY_TIMEOUT}
#              ? $ENV{PERL_CAPTURE_TINY_TIMEOUT} : $TIMEOUT;
#  1 until _files_exist(@files) || ($timeout && (time - $start > $timeout));
#  Carp::confess "Timed out waiting for subprocesses to start" if ! _files_exist(@files);
#  unlink $_ for @files;
#}
#
#sub _kill_tees {
#  my ($stash) = @_;
#  if ( $IS_WIN32 ) {
#    close($_) for values %{ $stash->{tee} };
#    my $start = time;
#    1 until wait == -1 || (time - $start > 30);
#  }
#  else {
#    _close $_ for values %{ $stash->{tee} };
#    waitpid $_, 0 for values %{ $stash->{pid} };
#  }
#}
#
#sub _slurp {
#  my ($name, $stash) = @_;
#  my ($fh, $pos) = map { $stash->{$_}{$name} } qw/capture pos/;
#  seek( $fh, $pos, 0 ) or die "Couldn't seek on capture handle for $name\n";
#  my $text = do { local $/; scalar readline $fh };
#  return defined($text) ? $text : "";
#}
#
#
#sub _capture_tee {
#  my ($do_stdout, $do_stderr, $do_merge, $do_tee, $code, @opts) = @_;
#  my %do = ($do_stdout ? (stdout => 1) : (),  $do_stderr ? (stderr => 1) : ());
#  Carp::confess("Custom capture options must be given as key/value pairs\n")
#    unless @opts % 2 == 0;
#  my $stash = { capture => { @opts } };
#  for ( keys %{$stash->{capture}} ) {
#    my $fh = $stash->{capture}{$_};
#    Carp::confess "Custom handle for $_ must be seekable\n"
#      unless ref($fh) eq 'GLOB' || (blessed($fh) && $fh->isa("IO::Seekable"));
#  }
#  local *CT_ORIG_STDIN  = *STDIN ;
#  local *CT_ORIG_STDOUT = *STDOUT;
#  local *CT_ORIG_STDERR = *STDERR;
#  my %layers = (
#    stdin   => [PerlIO::get_layers(\*STDIN) ],
#    stdout  => [PerlIO::get_layers(\*STDOUT, output => 1)],
#    stderr  => [PerlIO::get_layers(\*STDERR, output => 1)],
#  );
#  $layers{stdout} = [PerlIO::get_layers(tied *STDOUT)]
#    if tied(*STDOUT) && (reftype tied *STDOUT eq 'GLOB');
#  $layers{stderr} = [PerlIO::get_layers(tied *STDERR)]
#    if tied(*STDERR) && (reftype tied *STDERR eq 'GLOB');
#  my %localize;
#  $localize{stdin}++,  local(*STDIN)
#    if grep { $_ eq 'scalar' } @{$layers{stdin}};
#  $localize{stdout}++, local(*STDOUT)
#    if $do_stdout && grep { $_ eq 'scalar' } @{$layers{stdout}};
#  $localize{stderr}++, local(*STDERR)
#    if ($do_stderr || $do_merge) && grep { $_ eq 'scalar' } @{$layers{stderr}};
#  $localize{stdin}++, local(*STDIN), _open( \*STDIN, "<&=0")
#    if tied *STDIN && $] >= 5.008;
#  $localize{stdout}++, local(*STDOUT), _open( \*STDOUT, ">&=1")
#    if $do_stdout && tied *STDOUT && $] >= 5.008;
#  $localize{stderr}++, local(*STDERR), _open( \*STDERR, ">&=2")
#    if ($do_stderr || $do_merge) && tied *STDERR && $] >= 5.008;
#  my %proxy_std = _proxy_std();
#  $layers{stdout} = [PerlIO::get_layers(\*STDOUT, output => 1)] if $proxy_std{stdout};
#  $layers{stderr} = [PerlIO::get_layers(\*STDERR, output => 1)] if $proxy_std{stderr};
#  $stash->{old} = _copy_std();
#  $stash->{new} = { %{$stash->{old}} }; 
#  for ( keys %do ) {
#    $stash->{new}{$_} = ($stash->{capture}{$_} ||= File::Temp->new);
#    seek( $stash->{capture}{$_}, 0, 2 ) or die "Could not seek on capture handle for $_\n";
#    $stash->{pos}{$_} = tell $stash->{capture}{$_};
#    _start_tee( $_ => $stash ) if $do_tee; 
#  }
#  _wait_for_tees( $stash ) if $do_tee;
#  $stash->{new}{stderr} = $stash->{new}{stdout} if $do_merge;
#  _open_std( $stash->{new} );
#  my ($exit_code, $inner_error, $outer_error, $orig_pid, @result);
#  {
#    $orig_pid = $$;
#    local *STDIN = *CT_ORIG_STDIN if $localize{stdin}; 
#    _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
#    _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
#    my $old_eval_err=$@;
#    undef $@;
#    eval { @result = $code->(); $inner_error = $@ };
#    $exit_code = $?; 
#    $outer_error = $@; 
#    STDOUT->flush if $do_stdout;
#    STDERR->flush if $do_stderr;
#    $@ = $old_eval_err;
#  }
#  _open_std( $stash->{old} );
#  _close( $_ ) for values %{$stash->{old}}; 
#  _relayer(\*STDOUT, $layers{stdout}) if $do_stdout;
#  _relayer(\*STDERR, $layers{stderr}) if $do_stderr;
#  _unproxy( %proxy_std );
#  _kill_tees( $stash ) if $do_tee;
#  my %got;
#  if ( $orig_pid == $$ and ( defined wantarray or ($do_tee && keys %localize) ) ) {
#    for ( keys %do ) {
#      _relayer($stash->{capture}{$_}, $layers{$_});
#      $got{$_} = _slurp($_, $stash);
#    }
#    print CT_ORIG_STDOUT $got{stdout}
#      if $do_stdout && $do_tee && $localize{stdout};
#    print CT_ORIG_STDERR $got{stderr}
#      if $do_stderr && $do_tee && $localize{stderr};
#  }
#  $? = $exit_code;
#  $@ = $inner_error if $inner_error;
#  die $outer_error if $outer_error;
#  return unless defined wantarray;
#  my @return;
#  push @return, $got{stdout} if $do_stdout;
#  push @return, $got{stderr} if $do_stderr && ! $do_merge;
#  push @return, @result;
#  return wantarray ? @return : $return[0];
#}
#
#1;
#
#__END__
#
### Class/Inspector.pm ###
#package Class::Inspector;
#
#use 5.006;
#use strict qw{vars subs};
#use warnings;
#use File::Spec ();
#
#our $VERSION = '1.31'; 
#
#
#BEGIN {
#  local $@;
#  eval "require utf8; utf8->import";
#}
#
#our $RE_IDENTIFIER = qr/\A[^\W\d]\w*\z/s;
#our $RE_CLASS      = qr/\A[^\W\d]\w*(?:(?:\'|::)\w+)*\z/s;
#
#our $UNIX  = !! ( $File::Spec::ISA[0] eq 'File::Spec::Unix'  );
#
#
#
#
#sub _resolved_inc_handler {
#  my $class    = shift;
#  my $filename = $class->_inc_filename(shift) or return undef;
#  
#  foreach my $inc ( @INC ) {
#    if(ref $inc eq 'CODE') {
#      my @ret = $inc->($inc, $filename);
#      if(@ret) {
#        return 1;
#      }
#    }
#  }
#  
#  '';
#}
#
#sub installed {
#  my $class = shift;
#  !! ($class->loaded_filename($_[0]) or $class->resolved_filename($_[0]) or $class->_resolved_inc_handler($_[0]));
#}
#
#
#sub loaded {
#  my $class = shift;
#  my $name  = $class->_class(shift) or return undef;
#  $class->_loaded($name);
#}
#
#sub _loaded {
#  my $class = shift;
#  my $name  = shift;
#
#  return 1 if defined ${"${name}::VERSION"};
#  return 1 if @{"${name}::ISA"};
#
#  foreach ( keys %{"${name}::"} ) {
#    next if substr($_, -2, 2) eq '::';
#    return 1 if defined &{"${name}::$_"};
#  }
#
#  my $filename = $class->_inc_filename($name);
#  return 1 if defined $INC{$filename};
#
#  '';
#}
#
#
#sub filename {
#  my $class = shift;
#  my $name  = $class->_class(shift) or return undef;
#  File::Spec->catfile( split /(?:\'|::)/, $name ) . '.pm';
#}
#
#
#sub resolved_filename {
#  my $class     = shift;
#  my $filename  = $class->_inc_filename(shift) or return undef;
#  my @try_first = @_;
#
#  foreach ( @try_first, @INC ) {
#    my $full = "$_/$filename";
#    next unless -e $full;
#    return $UNIX ? $full : $class->_inc_to_local($full);
#  }
#
#  '';
#}
#
#
#sub loaded_filename {
#  my $class    = shift;
#  my $filename = $class->_inc_filename(shift);
#  $UNIX ? $INC{$filename} : $class->_inc_to_local($INC{$filename});
#}
#
#
#
#
#
#
#
#sub functions {
#  my $class = shift;
#  my $name  = $class->_class(shift) or return undef;
#  return undef unless $class->loaded( $name );
#
#  my @functions = sort grep { /$RE_IDENTIFIER/o }
#    grep { defined &{"${name}::$_"} }
#    keys %{"${name}::"};
#  \@functions;
#}
#
#
#sub function_refs {
#  my $class = shift;
#  my $name  = $class->_class(shift) or return undef;
#  return undef unless $class->loaded( $name );
#
#  my @functions = map { \&{"${name}::$_"} }
#    sort grep { /$RE_IDENTIFIER/o }
#    grep { defined &{"${name}::$_"} }
#    keys %{"${name}::"};
#  \@functions;
#}
#
#
#sub function_exists {
#  my $class    = shift;
#  my $name     = $class->_class( shift ) or return undef;
#  my $function = shift or return undef;
#
#  return undef unless $class->loaded( $name );
#
#  defined &{"${name}::$function"};
#}
#
#
#sub methods {
#  my $class     = shift;
#  my $name      = $class->_class( shift ) or return undef;
#  my @arguments = map { lc $_ } @_;
#
#  my %options = ();
#  foreach ( @arguments ) {
#    if ( $_ eq 'public' ) {
#      return undef if $options{private};
#      $options{public} = 1;
#
#    } elsif ( $_ eq 'private' ) {
#      return undef if $options{public};
#      $options{private} = 1;
#
#    } elsif ( $_ eq 'full' ) {
#      return undef if $options{expanded};
#      $options{full} = 1;
#
#    } elsif ( $_ eq 'expanded' ) {
#      return undef if $options{full};
#      $options{expanded} = 1;
#
#    } else {
#      return undef;
#    }
#  }
#
#  return undef unless $class->loaded( $name );
#
#  my @path  = ();
#  my @queue = ( $name );
#  my %seen  = ( $name => 1 );
#  while ( my $cl = shift @queue ) {
#    push @path, $cl;
#    unshift @queue, grep { ! $seen{$_}++ }
#      map { s/^::/main::/; s/\'/::/g; $_ }
#      ( @{"${cl}::ISA"} );
#  }
#
#  my %methods = ();
#  foreach my $namespace ( @path ) {
#    my @functions = grep { ! $methods{$_} }
#      grep { /$RE_IDENTIFIER/o }
#      grep { defined &{"${namespace}::$_"} } 
#      keys %{"${namespace}::"};
#    foreach ( @functions ) {
#      $methods{$_} = $namespace;
#    }
#  }
#
#  my @methodlist = sort keys %methods;
#  @methodlist = grep { ! /^\_/ } @methodlist if $options{public};
#  @methodlist = grep {   /^\_/ } @methodlist if $options{private};
#
#  @methodlist = map { "$methods{$_}::$_" } @methodlist if $options{full};
#  @methodlist = map { 
#    [ "$methods{$_}::$_", $methods{$_}, $_, \&{"$methods{$_}::$_"} ] 
#    } @methodlist if $options{expanded};
#
#  \@methodlist;
#}
#
#
#
#
#
#
#
#sub subclasses {
#  my $class = shift;
#  my $name  = $class->_class( shift ) or return undef;
#
#  my @found = ();
#  my @queue = grep { $_ ne 'main' } $class->_subnames('');
#  while ( @queue ) {
#    my $c = shift(@queue); 
#    if ( $class->_loaded($c) ) {
#      local $@;
#      eval {
#        if ( $c->isa($name) ) {
#          push @found, $c unless $c eq $name;
#        }
#      };
#    }
#
#    unshift @queue, map { "${c}::$_" } $class->_subnames($c);
#  }
#
#  @found ? \@found : '';
#}
#
#sub _subnames {
#  my ($class, $name) = @_;
#  return sort
#    grep {
#      substr($_, -2, 2, '') eq '::'
#      and
#      /$RE_IDENTIFIER/o
#    }
#    keys %{"${name}::"};
#}
#
#
#
#
#
#
#
#sub children {
#  my $class = shift;
#  my $name  = $class->_class(shift) or return ();
#
#  no strict 'refs';
#  map { "${name}::$_" } sort grep { s/::$// } keys %{"${name}::"};
#}
#
#sub recursive_children {
#  my $class    = shift;
#  my $name     = $class->_class(shift) or return ();
#  my @children = ( $name );
#
#  my $i = 0;
#  no strict 'refs';
#  while ( my $namespace = $children[$i++] ) {
#    push @children, map { "${namespace}::$_" }
#      grep { ! /^::/ } 
#      grep { s/::$// }
#      keys %{"${namespace}::"};
#  }
#
#  sort @children;
#}
#
#
#
#
#
#
#sub _class {
#  my $class = shift;
#  my $name  = shift or return '';
#
#  return 'main' if $name eq '::';
#  $name =~ s/\A::/main::/;
#
#  $name =~ /$RE_CLASS/o ? $name : '';
#}
#
#sub _inc_filename {
#  my $class = shift;
#  my $name  = $class->_class(shift) or return undef;
#  join( '/', split /(?:\'|::)/, $name ) . '.pm';
#}
#
#sub _inc_to_local {
#  return $_[1] if $UNIX;
#
#  my $class              = shift;
#  my $inc_name           = shift or return undef;
#  my ($vol, $dir, $file) = File::Spec->splitpath( $inc_name );
#  $dir = File::Spec->catdir( File::Spec->splitdir( $dir || "" ) );
#  File::Spec->catpath( $vol, $dir, $file || "" );
#}
#
#1;
#
#__END__
#
### Class/Inspector/Functions.pm ###
#package Class::Inspector::Functions;
#
#use 5.006;
#use strict;
#use warnings;
#use Exporter         ();
#use Class::Inspector ();
#
#our $VERSION = '1.31'; 
#
#BEGIN {
#  our @ISA     = 'Exporter';
#
#
#  our @EXPORT = qw(
#    installed
#    loaded
#
#    filename
#    functions
#    methods
#
#    subclasses
#  );
#
#  our @EXPORT_OK = qw(
#    resolved_filename
#    loaded_filename
#
#    function_refs
#    function_exists
#  );
#
#  our %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
#
#  foreach my $meth (@EXPORT, @EXPORT_OK) {
#      my $sub = Class::Inspector->can($meth);
#      no strict 'refs';
#      *{$meth} = sub {&$sub('Class::Inspector', @_)};
#  }
#
#}
#
#1;
#
#__END__
#
### Clone/PP.pm ###
#package Clone::PP;
#
#use 5.006;
#use strict;
#use warnings;
#use vars qw($VERSION @EXPORT_OK);
#use Exporter;
#
#$VERSION = 1.07;
#
#@EXPORT_OK = qw( clone );
#sub import { goto &Exporter::import } 
#
#use vars qw( $CloneSelfMethod $CloneInitMethod );
#$CloneSelfMethod ||= 'clone_self';
#$CloneInitMethod ||= 'clone_init';
#
#use vars qw( %CloneCache );
#
#sub clone {
#  my $source = shift;
#
#  return undef if not defined($source);
#  
#  my $depth = shift;
#  return $source if ( defined $depth and $depth -- < 1 );
#  
#  local %CloneCache = ( undef => undef ) unless ( exists $CloneCache{undef} );
#  
#  return $CloneCache{ $source } if ( defined $CloneCache{ $source } );
#  
#  my $ref_type = ref $source or return $source;
#  
#  my $class_name;
#  if ( "$source" =~ /^\Q$ref_type\E\=([A-Z]+)\(0x[0-9a-f]+\)$/ ) {
#    $class_name = $ref_type;
#    $ref_type = $1;
#    return $CloneCache{ $source } = $source->$CloneSelfMethod() 
#				  if $source->can($CloneSelfMethod);
#  }
#  
#  
#  my $copy;
#  if ($ref_type eq 'HASH') {
#    $CloneCache{ $source } = $copy = {};
#    if ( my $tied = tied( %$source ) ) { tie %$copy, ref $tied }
#    %$copy = map { ! ref($_) ? $_ : clone($_, $depth) } %$source;
#  } elsif ($ref_type eq 'ARRAY') {
#    $CloneCache{ $source } = $copy = [];
#    if ( my $tied = tied( @$source ) ) { tie @$copy, ref $tied }
#    @$copy = map { ! ref($_) ? $_ : clone($_, $depth) } @$source;
#  } elsif ($ref_type eq 'REF' or $ref_type eq 'SCALAR') {
#    $CloneCache{ $source } = $copy = \( my $var = "" );
#    if ( my $tied = tied( $$source ) ) { tie $$copy, ref $tied }
#    $$copy = clone($$source, $depth);
#  } else {
#    $CloneCache{ $source } = $copy = $source;
#  }
#  
#  if ( $class_name ) {
#    bless $copy, $class_name;
#    $copy->$CloneInitMethod() if $copy->can($CloneInitMethod);
#  }
#  
#  return $copy;
#}
#
#1;
#
#__END__
#
### Color/ANSI/Util.pm ###
#package Color::ANSI::Util;
#
#our $DATE = '2018-12-02'; 
#our $VERSION = '0.162'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       ansi16_to_rgb
#                       rgb_to_ansi16
#                       rgb_to_ansi16_fg_code
#                       ansi16fg
#                       rgb_to_ansi16_bg_code
#                       ansi16bg
#
#                       ansi256_to_rgb
#                       rgb_to_ansi256
#                       rgb_to_ansi256_fg_code
#                       ansi256fg
#                       rgb_to_ansi256_bg_code
#                       ansi256bg
#
#                       rgb_to_ansi24b_fg_code
#                       ansi24bfg
#                       rgb_to_ansi24b_bg_code
#                       ansi24bbg
#
#                       rgb_to_ansi_fg_code
#                       ansifg
#                       rgb_to_ansi_bg_code
#                       ansibg
#
#                       ansi_reset
#               );
#
#our %SPEC;
#
#my %ansi16 = (
#    0  => '000000',
#    1  => '800000',
#    2  => '008000',
#    3  => '808000',
#    4  => '000080',
#    5  => '800080',
#    6  => '008080',
#    7  => 'c0c0c0',
#    8  => '808080',
#    9  => 'ff0000',
#    10 => '00ff00',
#    11 => 'ffff00',
#    12 => '0000ff',
#    13 => 'ff00ff',
#    14 => '00ffff',
#    15 => 'ffffff',
#);
#my @revansi16;
#for (sort {$a<=>$b} keys %ansi16) {
#    $ansi16{$_} =~ /(..)(..)(..)/;
#    push @revansi16, [hex($1), hex($2), hex($3), $_];
#}
#
#my %ansi256 = (
#    %ansi16,
#
#    16 => '000000',  17 => '00005f',  18 => '000087',  19 => '0000af',  20 => '0000d7',  21 => '0000ff',
#    22 => '005f00',  23 => '005f5f',  24 => '005f87',  25 => '005faf',  26 => '005fd7',  27 => '005fff',
#    28 => '008700',  29 => '00875f',  30 => '008787',  31 => '0087af',  32 => '0087d7',  33 => '0087ff',
#    34 => '00af00',  35 => '00af5f',  36 => '00af87',  37 => '00afaf',  38 => '00afd7',  39 => '00afff',
#    40 => '00d700',  41 => '00d75f',  42 => '00d787',  43 => '00d7af',  44 => '00d7d7',  45 => '00d7ff',
#    46 => '00ff00',  47 => '00ff5f',  48 => '00ff87',  49 => '00ffaf',  50 => '00ffd7',  51 => '00ffff',
#    52 => '5f0000',  53 => '5f005f',  54 => '5f0087',  55 => '5f00af',  56 => '5f00d7',  57 => '5f00ff',
#    58 => '5f5f00',  59 => '5f5f5f',  60 => '5f5f87',  61 => '5f5faf',  62 => '5f5fd7',  63 => '5f5fff',
#    64 => '5f8700',  65 => '5f875f',  66 => '5f8787',  67 => '5f87af',  68 => '5f87d7',  69 => '5f87ff',
#    70 => '5faf00',  71 => '5faf5f',  72 => '5faf87',  73 => '5fafaf',  74 => '5fafd7',  75 => '5fafff',
#    76 => '5fd700',  77 => '5fd75f',  78 => '5fd787',  79 => '5fd7af',  80 => '5fd7d7',  81 => '5fd7ff',
#    82 => '5fff00',  83 => '5fff5f',  84 => '5fff87',  85 => '5fffaf',  86 => '5fffd7',  87 => '5fffff',
#    88 => '870000',  89 => '87005f',  90 => '870087',  91 => '8700af',  92 => '8700d7',  93 => '8700ff',
#    94 => '875f00',  95 => '875f5f',  96 => '875f87',  97 => '875faf',  98 => '875fd7',  99 => '875fff',
#    100 => '878700', 101 => '87875f', 102 => '878787', 103 => '8787af', 104 => '8787d7', 105 => '8787ff',
#    106 => '87af00', 107 => '87af5f', 108 => '87af87', 109 => '87afaf', 110 => '87afd7', 111 => '87afff',
#    112 => '87d700', 113 => '87d75f', 114 => '87d787', 115 => '87d7af', 116 => '87d7d7', 117 => '87d7ff',
#    118 => '87ff00', 119 => '87ff5f', 120 => '87ff87', 121 => '87ffaf', 122 => '87ffd7', 123 => '87ffff',
#    124 => 'af0000', 125 => 'af005f', 126 => 'af0087', 127 => 'af00af', 128 => 'af00d7', 129 => 'af00ff',
#    130 => 'af5f00', 131 => 'af5f5f', 132 => 'af5f87', 133 => 'af5faf', 134 => 'af5fd7', 135 => 'af5fff',
#    136 => 'af8700', 137 => 'af875f', 138 => 'af8787', 139 => 'af87af', 140 => 'af87d7', 141 => 'af87ff',
#    142 => 'afaf00', 143 => 'afaf5f', 144 => 'afaf87', 145 => 'afafaf', 146 => 'afafd7', 147 => 'afafff',
#    148 => 'afd700', 149 => 'afd75f', 150 => 'afd787', 151 => 'afd7af', 152 => 'afd7d7', 153 => 'afd7ff',
#    154 => 'afff00', 155 => 'afff5f', 156 => 'afff87', 157 => 'afffaf', 158 => 'afffd7', 159 => 'afffff',
#    160 => 'd70000', 161 => 'd7005f', 162 => 'd70087', 163 => 'd700af', 164 => 'd700d7', 165 => 'd700ff',
#    166 => 'd75f00', 167 => 'd75f5f', 168 => 'd75f87', 169 => 'd75faf', 170 => 'd75fd7', 171 => 'd75fff',
#    172 => 'd78700', 173 => 'd7875f', 174 => 'd78787', 175 => 'd787af', 176 => 'd787d7', 177 => 'd787ff',
#    178 => 'd7af00', 179 => 'd7af5f', 180 => 'd7af87', 181 => 'd7afaf', 182 => 'd7afd7', 183 => 'd7afff',
#    184 => 'd7d700', 185 => 'd7d75f', 186 => 'd7d787', 187 => 'd7d7af', 188 => 'd7d7d7', 189 => 'd7d7ff',
#    190 => 'd7ff00', 191 => 'd7ff5f', 192 => 'd7ff87', 193 => 'd7ffaf', 194 => 'd7ffd7', 195 => 'd7ffff',
#    196 => 'ff0000', 197 => 'ff005f', 198 => 'ff0087', 199 => 'ff00af', 200 => 'ff00d7', 201 => 'ff00ff',
#    202 => 'ff5f00', 203 => 'ff5f5f', 204 => 'ff5f87', 205 => 'ff5faf', 206 => 'ff5fd7', 207 => 'ff5fff',
#    208 => 'ff8700', 209 => 'ff875f', 210 => 'ff8787', 211 => 'ff87af', 212 => 'ff87d7', 213 => 'ff87ff',
#    214 => 'ffaf00', 215 => 'ffaf5f', 216 => 'ffaf87', 217 => 'ffafaf', 218 => 'ffafd7', 219 => 'ffafff',
#    220 => 'ffd700', 221 => 'ffd75f', 222 => 'ffd787', 223 => 'ffd7af', 224 => 'ffd7d7', 225 => 'ffd7ff',
#    226 => 'ffff00', 227 => 'ffff5f', 228 => 'ffff87', 229 => 'ffffaf', 230 => 'ffffd7', 231 => 'ffffff',
#
#    232 => '080808', 233 => '121212', 234 => '1c1c1c', 235 => '262626', 236 => '303030', 237 => '3a3a3a',
#    238 => '444444', 239 => '4e4e4e', 240 => '585858', 241 => '606060', 242 => '666666', 243 => '767676',
#    244 => '808080', 245 => '8a8a8a', 246 => '949494', 247 => '9e9e9e', 248 => 'a8a8a8', 249 => 'b2b2b2',
#    250 => 'bcbcbc', 251 => 'c6c6c6', 252 => 'd0d0d0', 253 => 'dadada', 254 => 'e4e4e4', 255 => 'eeeeee',
#);
#my @revansi256;
#for (sort {$a<=>$b} keys %ansi256) {
#    $ansi256{$_} =~ /(..)(..)(..)/;
#    push @revansi256, [hex($1), hex($2), hex($3), $_];
#}
#
#$SPEC{ansi16_to_rgb} = {
#    v => 1.1,
#    summary => 'Convert ANSI-16 color to RGB',
#    description => <<'_',
#
#Returns 6-hexdigit, e.g. 'ff00cc'.
#
#_
#    args => {
#        color => {
#            schema => 'color::ansi16*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'color::rgb24*',
#    },
#    result_naked => 1,
#};
#sub ansi16_to_rgb {
#    my ($input) = @_;
#
#    if ($input =~ /^\d+$/) {
#        if ($input >= 0 && $input <= 15) {
#            return $ansi16{$input + 0}; 
#        } else {
#            die "Invalid ANSI 16-color number '$input'";
#        }
#    } elsif ($input =~ /^(?:(bold|bright) \s )?(black|red|green|yellow|blue|magenta|cyan|white)$/ix) {
#        my ($bold, $col) = (lc($1 // ""), lc($2));
#        my $i;
#        if ($col eq 'black') {
#            $i = 0;
#        } elsif ($col eq 'red') {
#            $i = 1;
#        } elsif ($col eq 'green') {
#            $i = 2;
#        } elsif ($col eq 'yellow') {
#            $i = 3;
#        } elsif ($col eq 'blue') {
#            $i = 4;
#        } elsif ($col eq 'magenta') {
#            $i = 5;
#        } elsif ($col eq 'cyan') {
#            $i = 6;
#        } elsif ($col eq 'white') {
#            $i = 7;
#        }
#        $i += 8 if $bold;
#        return $ansi16{$i};
#    } else {
#        die "Invalid ANSI 16-color name '$input'";
#    }
#}
#
#sub _rgb_to_indexed {
#    my ($rgb, $table) = @_;
#
#    $rgb =~ /^#?([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$/
#        or die "Invalid RGB input '$rgb'";
#    my $r = hex($1);
#    my $g = hex($2);
#    my $b = hex($3);
#
#    my ($minsqdist, $res);
#    for my $e (@$table) {
#        my $sqdist =
#            abs($e->[0]-$r)**2 + abs($e->[1]-$g)**2 + abs($e->[2]-$b)**2;
#        return $e->[3] if $sqdist == 0;
#        if (!defined($minsqdist) || $minsqdist > $sqdist) {
#            $minsqdist = $sqdist;
#            $res = $e->[3];
#        }
#    }
#    return $res;
#}
#
#$SPEC{ansi256_to_rgb} = {
#    v => 1.1,
#    summary => 'Convert ANSI-256 color to RGB',
#    args => {
#        color => {
#            schema => 'color::ansi256*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'color::rgb24',
#    },
#    result_naked => 1,
#};
#sub ansi256_to_rgb {
#    my ($input) = @_;
#
#    $input += 0;
#    exists($ansi256{$input}) or die "Invalid ANSI 256-color index '$input'";
#    $ansi256{$input};
#}
#
#$SPEC{rgb_to_ansi16} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI-16 color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'color::ansi16*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi16 {
#    my ($input) = @_;
#    _rgb_to_indexed($input, \@revansi16);
#}
#
#$SPEC{rgb_to_ansi256} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI-256 color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'color::ansi256*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi256 {
#    my ($input) = @_;
#    _rgb_to_indexed($input, \@revansi256);
#}
#
#$SPEC{rgb_to_ansi16_fg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI-16 color escape sequence to change foreground color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi16_fg_code {
#    my ($input) = @_;
#
#    my $res = _rgb_to_indexed($input, \@revansi16);
#    return "\e[" . ($res >= 8 ? ($res+30-8) . ";1" : ($res+30)) . "m";
#}
#
#sub ansi16fg  { goto &rgb_to_ansi16_fg_code  }
#
#$SPEC{rgb_to_ansi16_bg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI-16 color escape sequence to change background color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi16_bg_code {
#    my ($input) = @_;
#
#    my $res = _rgb_to_indexed($input, \@revansi16);
#    return "\e[" . ($res >= 8 ? ($res+40-8) : ($res+40)) . "m";
#}
#
#sub ansi16bg  { goto &rgb_to_ansi16_bg_code  }
#
#$SPEC{rgb_to_ansi256_fg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI-256 color escape sequence to change foreground color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi256_fg_code {
#    my ($input) = @_;
#
#    my $res = _rgb_to_indexed($input, \@revansi16);
#    return "\e[38;5;${res}m";
#}
#
#sub ansi256fg { goto &rgb_to_ansi256_fg_code }
#
#$SPEC{rgb_to_ansi256_bg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI-256 color escape sequence to change background color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi256_bg_code {
#    my ($input) = @_;
#
#    my $res = _rgb_to_indexed($input, \@revansi16);
#    return "\e[48;5;${res}m";
#}
#
#sub ansi256bg { goto &rgb_to_ansi256_bg_code }
#
#$SPEC{rgb_to_ansi24b_fg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI 24bit-color escape sequence to change foreground color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi24b_fg_code {
#    my ($rgb) = @_;
#
#    return sprintf("\e[38;2;%d;%d;%dm",
#                   hex(substr($rgb, 0, 2)),
#                   hex(substr($rgb, 2, 2)),
#                   hex(substr($rgb, 4, 2)));
#}
#
#sub ansi24bfg { goto &rgb_to_ansi24b_fg_code }
#
#$SPEC{rgb_to_ansi24b_bg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI 24bit-color escape sequence to change background color',
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi24b_bg_code {
#    my ($rgb) = @_;
#
#    return sprintf("\e[48;2;%d;%d;%dm",
#                   hex(substr($rgb, 0, 2)),
#                   hex(substr($rgb, 2, 2)),
#                   hex(substr($rgb, 4, 2)));
#}
#
#sub ansi24bbg { goto &rgb_to_ansi24b_bg_code }
#
#our $_use_termdetsw = 1;
#our $_color_depth; 
#sub _color_depth {
#    unless (defined $_color_depth) {
#        {
#            if (exists $ENV{NO_COLOR}) {
#                $_color_depth = 0;
#                last;
#            }
#            if (defined $ENV{COLOR} && !$ENV{COLOR}) {
#                $_color_depth = 0;
#                last;
#            }
#            if (defined $ENV{COLOR_DEPTH}) {
#                $_color_depth = $ENV{COLOR_DEPTH};
#                last;
#            }
#            if ($_use_termdetsw) {
#                eval { require Term::Detect::Software };
#                if (!$@) {
#                    $_color_depth = Term::Detect::Software::detect_terminal_cached()->{color_depth};
#                    last;
#                }
#            }
#            if ($ENV{KONSOLE_DBUS_SERVICE}) {
#                $_color_depth = 2**24;
#                last;
#            }
#            $_color_depth = 16;
#        }
#    };
#    $_color_depth;
#}
#
#$SPEC{rgb_to_ansi_fg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI color escape sequence to change foreground color',
#    description => <<'_',
#
#Autodetect terminal capability and can return either empty string, 16-color,
#256-color, or 24bit-code.
#
#Color depth used is determined by `COLOR_DEPTH` environment setting or from
#<pm:Term::Detect::Software> if that module is available. In other words, this
#function automatically chooses rgb_to_ansi{24b,256,16}_fg_code().
#
#_
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi_fg_code {
#    my ($rgb) = @_;
#    my $cd = _color_depth();
#    if ($cd >= 2**24) {
#        rgb_to_ansi24b_fg_code($rgb);
#    } elsif ($cd >= 256) {
#        rgb_to_ansi256_fg_code($rgb);
#    } elsif ($cd >= 16) {
#        rgb_to_ansi16_fg_code($rgb);
#    } else {
#        "";
#    }
#}
#
#sub ansifg { goto &rgb_to_ansi_fg_code }
#
#$SPEC{rgb_to_ansi_bg_code} = {
#    v => 1.1,
#    summary => 'Convert RGB to ANSI color escape sequence to change background color',
#    description => <<'_',
#
#Autodetect terminal capability and can return either empty string, 16-color,
#256-color, or 24bit-code.
#
#Which color depth used is determined by `COLOR_DEPTH` environment setting or
#from <pm:Term::Detect::Software> if that module is available). In other words,
#this function automatically chooses rgb_to_ansi{24b,256,16}_bg_code().
#
#_
#    args => {
#        color => {
#            schema => 'color::rgb24*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result => {
#        schema => 'str*',
#    },
#    result_naked => 1,
#};
#sub rgb_to_ansi_bg_code {
#    my ($rgb) = @_;
#    my $cd = _color_depth();
#    if ($cd >= 2**24) {
#        rgb_to_ansi24b_bg_code($rgb);
#    } elsif ($cd >= 256) {
#        rgb_to_ansi256_bg_code($rgb);
#    } else {
#        rgb_to_ansi16_bg_code($rgb);
#    }
#}
#
#sub ansibg { goto &rgb_to_ansi_bg_code }
#
#sub ansi_reset { "\e[0m" }
#
#1;
#
#__END__
#
### Complete/Bash.pm ###
#package Complete::Bash;
#
#our $DATE = '2018-10-10'; 
#our $VERSION = '0.320'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       point
#                       parse_cmdline
#                       join_wordbreak_words
#                       format_completion
#               );
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Completion routines for bash shell',
#};
#
#sub _expand_tilde {
#    my ($user, $slash) = @_;
#    my @ent;
#    if (length $user) {
#        @ent = getpwnam($user);
#    } else {
#        @ent = getpwuid($>);
#        $user = $ent[0];
#    }
#    return $ent[7] . $slash if @ent;
#    "~$user$slash"; 
#}
#
#sub _add_unquoted {
#    no warnings 'uninitialized';
#
#    my ($word, $is_cur_word, $after_ws) = @_;
#
#
#    $word =~ s!^(~)(\w*)(/|\z) |  # 1) tilde  2) username  3) optional slash
#               \\(.)           |  # 4) escaped char
#               \$(\w+)            # 5) variable name
#              !
#                  $1 ? (not($after_ws) || $is_cur_word ? "$1$2$3" : _expand_tilde($2, $3)) :
#                      $4 ? $4 :
#                          ($is_cur_word ? "\$$5" : $ENV{$5})
#                              !egx;
#    $word;
#}
#
#sub _add_double_quoted {
#    no warnings 'uninitialized';
#
#    my ($word, $is_cur_word) = @_;
#
#    $word =~ s!\\(.)           |  # 1) escaped char
#               \$(\w+)            # 2) variable name
#              !
#                  $1 ? $1 :
#                      ($is_cur_word ? "\$$2" : $ENV{$2})
#                          !egx;
#    $word;
#}
#
#sub _add_single_quoted {
#    my $word = shift;
#    $word =~ s/\\(.)/$1/g;
#    $word;
#}
#
#$SPEC{point} = {
#    v => 1.1,
#    summary => 'Return line with point marked by a marker',
#    description => <<'_',
#
#This is a utility function useful for testing/debugging. `parse_cmdline()`
#expects a command-line and a cursor position (`$line`, `$point`). This routine
#expects `$line` with a marker character (by default it's the caret, `^`) and
#return (`$line`, `$point`) to feed to `parse_cmdline()`.
#
#Example:
#
#    point("^foo") # => ("foo", 0)
#    point("fo^o") # => ("foo", 2)
#
#_
#    args_as => 'array',
#    args => {
#        cmdline => {
#            summary => 'Command-line which contains a marker character',
#            schema => 'str*',
#            pos => 0,
#        },
#        marker => {
#            summary => 'Marker character',
#            schema => ['str*', len=>1],
#            default => '^',
#            pos => 1,
#        },
#    },
#    result_naked => 1,
#};
#sub point {
#    my ($line, $marker) = @_;
#    $marker //= '^';
#
#    my $point = index($line, $marker);
#    die "BUG: No marker '$marker' in line <$line>" unless $point >= 0;
#    $line =~ s/\Q$marker\E//;
#    ($line, $point);
#}
#
#$SPEC{parse_cmdline} = {
#    v => 1.1,
#    summary => 'Parse shell command-line for processing by completion routines',
#    description => <<'_',
#
#This function basically converts `COMP_LINE` (str) and `COMP_POINT` (int) into
#something like (but not exactly the same as) `COMP_WORDS` (array) and
#`COMP_CWORD` (int) that bash supplies to shell functions.
#
#The differences with bash are (these differences are mostly for parsing
#convenience for programs that use this routine; this comparison is made against
#bash versions 4.2-4.3):
#
#1) quotes and backslashes are stripped (bash's `COMP_WORDS` contains all the
#   quotes and backslashes);
#
#2) quoted phrase that contains spaces, or phrase that contains escaped spaces is
#   parsed as a single word. For example:
#
#    command "First argument" Second\ argument
#
#   bash would split it as (represented as Perl):
#
#    ["command", "\"First", "argument\"", "Second\\", "argument"]
#
#   which is not very convenient. We parse it into:
#
#    ["command", "First argument", "Second argument"]
#
#3) variables are substituted with their values from environment variables except
#   for the current word (`COMP_WORDS[COMP_CWORD]`) (bash does not perform
#   variable substitution for `COMP_WORDS`). However, note that special shell
#   variables that are not environment variables like `$0`, `$_`, `$IFS` will not
#   be replaced correctly because bash does not export those variables for us.
#
#4) tildes (`~`) are expanded with user's home directory except for the current
#   word (bash does not perform tilde expansion for `COMP_WORDS`);
#
#Caveats:
#
#* Like bash, we group non-whitespace word-breaking characters into its own word.
#  By default `COMP_WORDBREAKS` is:
#
#    "'@><=;|&(:
#
#  So if raw command-line is:
#
#    command --foo=bar http://example.com:80 mail@example.org Foo::Bar
#
#  then the parse result will be:
#
#    ["command", "--foo", "=", "bar", "http", ":", "//example.com", ":", "80", "Foo", "::", "Bar"]
#
#  which is annoying sometimes. But we follow bash here so we can more easily
#  accept input from a joined `COMP_WORDS` if we write completion bash functions,
#  e.g. (in the example, `foo` is a Perl script):
#
#    _foo ()
#    {
#        local words=(${COMP_CWORDS[@]})
#        # add things to words, etc
#        local point=... # calculate the new point
#        COMPREPLY=( `COMP_LINE="foo ${words[@]}" COMP_POINT=$point foo` )
#    }
#
#  To avoid these word-breaking characters to be split/grouped, we can escape
#  them with backslash or quote them, e.g.:
#
#    command "http://example.com:80" Foo\:\:Bar
#
#  which bash will parse as:
#
#    ["command", "\"http://example.com:80\"", "Foo\\:\\:Bar"]
#
#  and we parse as:
#
#    ["command", "http://example.com:80", "Foo::Bar"]
#
#* Due to the way bash parses the command line (see above), the two below are
#  equivalent:
#
#    % cmd --foo=bar
#    % cmd --foo = bar
#
#Because they both expand to `['--foo', '=', 'bar']`. But obviously
#<pm:Getopt::Long> does not regard the two as equivalent.
#
#_
#    args_as => 'array',
#    args => {
#        cmdline => {
#            summary => 'Command-line, defaults to COMP_LINE environment',
#            schema => 'str*',
#            pos => 0,
#        },
#        point => {
#            summary => 'Point/position to complete in command-line, '.
#                'defaults to COMP_POINT',
#            schema => 'int*',
#            pos => 1,
#        },
#        opts => {
#            summary => 'Options',
#            schema => 'hash*',
#            description => <<'_',
#
#Optional. Known options:
#
#* `truncate_current_word` (bool). If set to 1, will truncate current word to the
#  position of cursor, for example (`^` marks the position of cursor):
#  `--vers^oo` to `--vers` instead of `--versoo`. This is more convenient when
#  doing tab completion.
#
#_
#            schema => 'hash*',
#            pos => 2,
#        },
#    },
#    result => {
#        schema => ['array*', len=>2],
#        description => <<'_',
#
#Return a 2-element array: `[$words, $cword]`. `$words` is array of str,
#equivalent to `COMP_WORDS` provided by bash to shell functions. `$cword` is an
#integer, roughly equivalent to `COMP_CWORD` provided by bash to shell functions.
#The word to be completed is at `$words->[$cword]`.
#
#Note that COMP_LINE includes the command name. If you want the command-line
#arguments only (like in `@ARGV`), you need to strip the first element from
#`$words` and reduce `$cword` by 1.
#
#
#_
#    },
#    result_naked => 1,
#    links => [
#    ],
#};
#sub parse_cmdline {
#    no warnings 'uninitialized';
#    my ($line, $point, $opts) = @_;
#
#    $line  //= $ENV{COMP_LINE};
#    $point //= $ENV{COMP_POINT} // 0;
#
#    die "$0: COMP_LINE not set, make sure this script is run under ".
#        "bash completion (e.g. through complete -C)\n" unless defined $line;
#
#    log_trace "[compbash] line=<$line> point=<$point>"
#        if $ENV{COMPLETE_BASH_TRACE};
#
#    my @words;
#    my $cword;
#    my $pos = 0;
#    my $pos_min_ws = 0;
#    my $after_ws = 1; 
#    my $chunk;
#    my $add_blank;
#    my $is_cur_word;
#    $line =~ s!(                                                         # 1) everything
#                  (")((?: \\\\|\\"|[^"])*)(?:"|\z)(\s*)               |  #  2) open "  3) content  4) space after
#                  (')((?: \\\\|\\'|[^'])*)(?:'|\z)(\s*)               |  #  5) open '  6) content  7) space after
#                  ((?: \\\\|\\"|\\'|\\=|\\\s|[^"'@><=|&\(:\s])+)(\s*) |  #  8) unquoted word  9) space after
#                  ([\@><=|&\(:]+) |                                      #  10) non-whitespace word-breaking characters
#                  \s+
#              )!
#                  $pos += length($1);
#                  #say "D: \$1=<$1> \$2=<$3> \$3=<$3> \$4=<$4> \$5=<$5> \$6=<$6> \$7=<$7> \$8=<$8> \$9=<$9> \$10=<$10>";
#                  #say "D:<$1> pos=$pos, point=$point, cword=$cword, after_ws=$after_ws";
#
#                  if ($2 || $5 || defined($8)) {
#                      # double-quoted/single-quoted/unquoted chunk
#
#                      if (not(defined $cword)) {
#                          $pos_min_ws = $pos - length($2 ? $4 : $5 ? $7 : $9);
#                          #say "D:pos_min_ws=$pos_min_ws";
#                          if ($point <= $pos_min_ws) {
#                              $cword = @words - ($after_ws ? 0 : 1);
#                          } elsif ($point < $pos) {
#                              $cword = @words + 1 - ($after_ws ? 0 : 1);
#                              $add_blank = 1;
#                          }
#                      }
#
#                      if ($after_ws) {
#                          $is_cur_word = defined($cword) && $cword==@words;
#                      } else {
#                          $is_cur_word = defined($cword) && $cword==@words-1;
#                      }
#                      #say "D:is_cur_word=$is_cur_word";
#                      $chunk =
#                          $2 ? _add_double_quoted($3, $is_cur_word) :
#                              $5 ? _add_single_quoted($6) :
#                              _add_unquoted($8, $is_cur_word, $after_ws);
#                      if ($opts && $opts->{truncate_current_word} &&
#                              $is_cur_word && $pos > $point) {
#                          $chunk = substr(
#                              $chunk, 0, length($chunk)-($pos_min_ws-$point));
#                          #say "D:truncating current word to <$chunk>";
#                      }
#                      if ($after_ws) {
#                          push @words, $chunk;
#                      } else {
#                          $words[-1] .= $chunk;
#                      }
#                      if ($add_blank) {
#                          push @words, '';
#                          $add_blank = 0;
#                      }
#                      $after_ws = ($2 ? $4 : $5 ? $7 : $9) ? 1:0;
#
#                  } elsif ($10) {
#                      # non-whitespace word-breaking characters
#                      push @words, $10;
#                      $after_ws = 1;
#                  } else {
#                      # whitespace
#                      $after_ws = 1;
#                  }
#    !egx;
#
#    $cword //= @words;
#    $words[$cword] //= '';
#
#    log_trace "[compbash] words=%s, cword=%s", \@words, $cword
#        if $ENV{COMPLETE_BASH_TRACE};
#
#    [\@words, $cword];
#}
#
#$SPEC{join_wordbreak_words} = {
#    v => 1.1,
#    summary => 'Post-process parse_cmdline() result by joining some words',
#    description => <<'_',
#
#`parse_cmdline()`, like bash, splits some characters that are considered as
#word-breaking characters:
#
#    "'@><=;|&(:
#
#So if command-line is:
#
#    command -MData::Dump bob@example.org
#
#then they will be parsed as:
#
#    ["command", "-MData", "::", "Dump", "bob", '@', "example.org"]
#
#Normally in Perl applications, we want `:`, `@` to be part of word. So this
#routine will convert the above into:
#
#    ["command", "-MData::Dump", 'bob@example.org']
#
#_
#};
#sub join_wordbreak_words {
#    my ($words, $cword) = @_;
#    my $new_words = [];
#    my $i = -1;
#    while (++$i < @$words) {
#        my $w = $words->[$i];
#        if ($w =~ /\A[\@=:]+\z/) {
#            if (@$new_words and $#$new_words != $cword) {
#                $new_words->[-1] .= $w;
#                $cword-- if $cword >= $i || $cword >= @$new_words;
#            } else {
#                push @$new_words, $w;
#            }
#            if ($i+1 < @$words) {
#                $i++;
#                $new_words->[-1] .= $words->[$i];
#                $cword-- if $cword >= $i || $cword >= @$new_words;
#            }
#        } else {
#            push @$new_words, $w;
#        }
#    }
#    [$new_words, $cword];
#}
#
#$SPEC{format_completion} = {
#    v => 1.1,
#    summary => 'Format completion for output (for shell)',
#    description => <<'_',
#
#Bash accepts completion reply in the form of one entry per line to STDOUT. Some
#characters will need to be escaped. This function helps you do the formatting,
#with some options.
#
#This function accepts completion answer structure as described in the `Complete`
#POD. Aside from `words`, this function also recognizes these keys:
#
#* `as` (str): Either `string` (the default) or `array` (to return array of lines
#  instead of the lines joined together). Returning array is useful if you are
#  doing completion inside `Term::ReadLine`, for example, where the library
#  expects an array.
#
#* `esc_mode` (str): Escaping mode for entries. Either `default` (most
#  nonalphanumeric characters will be escaped), `shellvar` (like `default`, but
#  dollar sign `$` will not be escaped, convenient when completing environment
#  variables for example), `filename` (currently equals to `default`), `option`
#  (currently equals to `default`), or `none` (no escaping will be done).
#
#* `path_sep` (str): If set, will enable "path mode", useful for
#  completing/drilling-down path. Below is the description of "path mode".
#
#  In shell, when completing filename (e.g. `foo`) and there is only a single
#  possible completion (e.g. `foo` or `foo.txt`), the shell will display the
#  completion in the buffer and automatically add a space so the user can move to
#  the next argument. This is also true when completing other values like
#  variables or program names.
#
#  However, when completing directory (e.g. `/et` or `Downloads`) and there is
#  solely a single completion possible and it is a directory (e.g. `/etc` or
#  `Downloads`), the shell automatically adds the path separator character
#  instead (`/etc/` or `Downloads/`). The user can press Tab again to complete
#  for files/directories inside that directory, and so on. This is obviously more
#  convenient compared to when shell adds a space instead.
#
#  The `path_sep` option, when set, will employ a trick to mimic this behaviour.
#  The trick is, if you have a completion array of `['foo/']`, it will be changed
#  to `['foo/', 'foo/ ']` (the second element is the first element with added
#  space at the end) to prevent bash from adding a space automatically.
#
#  Path mode is not restricted to completing filesystem paths. Anything path-like
#  can use it. For example when you are completing Java or Perl module name (e.g.
#  `com.company.product.whatever` or `File::Spec::Unix`) you can use this mode
#  (with `path_sep` appropriately set to, e.g. `.` or `::`).
#
#_
#    args_as => 'array',
#    args => {
#        completion => {
#            summary => 'Completion answer structure',
#            description => <<'_',
#
#Either an array or hash. See function description for more details.
#
#_
#            schema=>['any*' => of => ['hash*', 'array*']],
#            req=>1,
#            pos=>0,
#        },
#        opts => {
#            schema=>'hash*',
#            pos=>1,
#        },
#    },
#    result => {
#        summary => 'Formatted string (or array, if `as` is set to `array`)',
#        schema => ['any*' => of => ['str*', 'array*']],
#    },
#    result_naked => 1,
#};
#sub format_completion {
#    my ($hcomp, $opts) = @_;
#
#    $opts //= {};
#
#    $hcomp = {words=>$hcomp} unless ref($hcomp) eq 'HASH';
#    my $comp     = $hcomp->{words};
#    my $as       = $hcomp->{as} // 'string';
#    my $esc_mode = $hcomp->{esc_mode} // $hcomp->{escmode} // 'default';
#    my $path_sep = $hcomp->{path_sep};
#
#    if (defined($path_sep) && @$comp == 1) {
#        my $re = qr/\Q$path_sep\E\z/;
#        my $word;
#        if (ref($comp->[0]) eq 'HASH') {
#            $comp = [$comp->[0], {word=>"$comp->[0] "}] if
#                $comp->[0]{word} =~ $re;
#        } else {
#            $comp = [$comp->[0], "$comp->[0] "]
#                if $comp->[0] =~ $re;
#        }
#    }
#
#    if (defined($opts->{word})) {
#        if ($opts->{word} =~ s/(.+[\@><=;|&\(:])//) {
#            my $prefix = $1;
#            for (@$comp) {
#                if (ref($_) eq 'HASH') {
#                    $_->{word} =~ s/\A\Q$prefix\E//i;
#                } else {
#                    s/\A\Q$prefix\E//i;
#                }
#            }
#        }
#    }
#
#    my @res;
#    for my $entry (@$comp) {
#        my $word = ref($entry) eq 'HASH' ? $entry->{word} : $entry;
#        if ($esc_mode eq 'shellvar') {
#            $word =~ s!([^A-Za-z0-9,+._/\$~-])!\\$1!g;
#        } elsif ($esc_mode eq 'none') {
#        } else {
#            $word =~ s!([^A-Za-z0-9,+._/:~-])!\\$1!g;
#        }
#        push @res, $word;
#    }
#
#    if ($as eq 'array') {
#        return \@res;
#    } else {
#        return join("", map {($_, "\n")} @res);
#    }
#}
#
#1;
#
#__END__
#
### Complete/Common.pm ###
#package Complete::Common;
#
#our $DATE = '2016-01-05'; 
#our $VERSION = '0.22'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       %arg_word
#               );
#
#our %EXPORT_TAGS = (
#    all => \@EXPORT_OK
#);
#
#our %arg_word = (
#    word => {
#        summary => 'Word to complete',
#        schema => ['str', default=>''],
#        pos=>0,
#        req=>1,
#    },
#);
#
#our $OPT_CI          = ($ENV{COMPLETE_OPT_CI}          // 1) ? 1:0;
#our $OPT_WORD_MODE   = ($ENV{COMPLETE_OPT_WORD_MODE}   // 1) ? 1:0;
#our $OPT_CHAR_MODE   = ($ENV{COMPLETE_OPT_CHAR_MODE}   // 1) ? 1:0;
#our $OPT_FUZZY       = ($ENV{COMPLETE_OPT_FUZZY}       // 1)+0;
#our $OPT_MAP_CASE    = ($ENV{COMPLETE_OPT_MAP_CASE}    // 1) ? 1:0;
#our $OPT_EXP_IM_PATH = ($ENV{COMPLETE_OPT_EXP_IM_PATH} // 1) ? 1:0;
#our $OPT_DIG_LEAF    = ($ENV{COMPLETE_OPT_DIG_LEAF}    // 1) ? 1:0;
#
#1;
#
#__END__
#
### Complete/Env.pm ###
#package Complete::Env;
#
#our $DATE = '2017-12-31'; 
#our $VERSION = '0.400'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Complete::Common qw(:all);
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       complete_env
#                       complete_env_elem
#                       complete_path_env_elem
#               );
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Completion routines related to environment variables',
#};
#
#$SPEC{complete_env} = {
#    v => 1.1,
#    summary => 'Complete from environment variables',
#    description => <<'_',
#
#On Windows, environment variable names are all converted to uppercase. You can
#use case-insensitive option (`ci`) to match against original casing.
#
#_
#    args => {
#        %arg_word,
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_env {
#    require Complete::Util;
#
#    my %args  = @_;
#    my $word     = $args{word} // "";
#    if ($word =~ /^\$/) {
#        Complete::Util::complete_array_elem(
#            word=>$word, array=>[map {"\$$_"} keys %ENV],
#        );
#    } else {
#        Complete::Util::complete_array_elem(
#            word=>$word, array=>[keys %ENV],
#        );
#    }
#}
#
#$SPEC{complete_env_elem} = {
#    v => 1.1,
#    summary => 'Complete from elements of an environment variable',
#    description => <<'_',
#
#An environment variable like PATH contains colon- (or, on Windows, semicolon-)
#separated elements. This routine complete from the elements of such variable.
#
#_
#    args => {
#        %arg_word,
#        env      => {
#            summary => 'Name of environment variable to use',
#            schema  => 'str*',
#            req => 1,
#            pos => 1,
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_env_elem {
#    require Complete::Util;
#
#    my %args  = @_;
#    my $word  = $args{word} // "";
#    my $env   = $args{env};
#    my @elems;
#    if ($^O eq 'MSWin32') {
#        @elems = split /;/, ($ENV{$env} // '');
#    } else {
#        @elems = split /:/, ($ENV{$env} // '');
#    }
#    Complete::Util::complete_array_elem(
#        word=>$word, array=>\@elems,
#    );
#}
#
#$SPEC{complete_path_env_elem} = {
#    v => 1.1,
#    summary => 'Complete from elements of PATH environment variable',
#    description => <<'_',
#
#PATH environment variable contains colon- (or, on Windows, semicolon-) separated
#elements. This routine complete from those elements.
#
#_
#    args => {
#        %arg_word,
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_path_env_elem {
#    my %args  = @_;
#    complete_env_elem(word => $args{word}, env => 'PATH');
#}
#
#1;
#
#__END__
#
### Complete/File.pm ###
#package Complete::File;
#
#our $DATE = '2017-07-14'; 
#our $VERSION = '0.43'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Complete::Common qw(:all);
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       complete_file
#                       complete_dir
#               );
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Completion routines related to files',
#};
#
#$SPEC{complete_file} = {
#    v => 1.1,
#    summary => 'Complete file and directory from local filesystem',
#    args => {
#        %arg_word,
#        filter => {
#            summary => 'Only return items matching this filter',
#            description => <<'_',
#
#Filter can either be a string or a code.
#
#For string filter, you can specify a pipe-separated groups of sequences of these
#characters: f, d, r, w, x. Dash can appear anywhere in the sequence to mean
#not/negate. An example: `f` means to only show regular files, `-f` means only
#show non-regular files, `drwx` means to show only directories which are
#readable, writable, and executable (cd-able). `wf|wd` means writable regular
#files or writable directories.
#
#For code filter, you supply a coderef. The coderef will be called for each item
#with these arguments: `$name`. It should return true if it wants the item to be
#included.
#
#_
#            schema  => ['any*' => {of => ['str*', 'code*']}],
#            tags => ['category:filtering'],
#        },
#        file_regex_filter => {
#            summary => 'Filter shortcut for file regex',
#            description => <<'_',
#
#This is a shortcut for constructing a filter. So instead of using `filter`, you
#use this option. This will construct a filter of including only directories or
#regular files, and the file must match a regex pattern. This use-case is common.
#
#_
#            schema => 're*',
#            tags => ['category:filtering'],
#        },
#        exclude_dir => {
#            schema => 'bool*',
#            description => <<'_',
#
#This is also an alternative to specifying full `filter`. Set this to true if you
#do not want directories.
#
#If you only want directories, take a look at `complete_dir()`.
#
#_
#            tags => ['category:filtering'],
#        },
#        file_ext_filter => {
#            schema => ['any*', of=>['re*', ['array*',of=>'str*']]],
#            description => <<'_',
#
#This is also an alternative to specifying full `filter` or `file_regex_filter`.
#You can set this to a regex or a set of extensions to accept. Note that like in
#`file_regex_filter`, directories of any name is also still allowed.
#
#_
#            tags => ['category:filtering'],
#        },
#        starting_path => {
#            schema  => 'str*',
#            default => '.',
#        },
#        handle_tilde => {
#            schema  => 'bool',
#            default => 1,
#        },
#        allow_dot => {
#            summary => 'If turned off, will not allow "." or ".." in path',
#            description => <<'_',
#
#This is most useful when combined with `starting_path` option to prevent user
#going up/outside the starting path.
#
#_
#            schema  => 'bool',
#            default => 1,
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_file {
#    require Complete::Path;
#    require Encode;
#    require File::Glob;
#
#    my %args   = @_;
#    my $word   = $args{word} // "";
#    my $handle_tilde = $args{handle_tilde} // 1;
#    my $allow_dot   = $args{allow_dot} // 1;
#
#    my $result_prefix;
#    my $starting_path = $args{starting_path} // '.';
#    if ($handle_tilde && $word =~ s!\A(~[^/]*)/!!) {
#        $result_prefix = "$1/";
#        my @dir = File::Glob::bsd_glob($1); 
#        return [] unless @dir;
#        $starting_path = Encode::decode('UTF-8', $dir[0]);
#    } elsif ($allow_dot && $word =~ s!\A((?:\.\.?/+)+|/+)!!) {
#        $starting_path = $1;
#        $result_prefix = $1;
#        $starting_path =~ s#/+\z## unless $starting_path =~ m!\A/!;
#    }
#
#    return [] if !$allow_dot &&
#        $word =~ m!(?:\A|/)\.\.?(?:\z|/)!;
#
#    my $list = sub {
#        my ($path, $intdir, $isint) = @_;
#        opendir my($dh), $path or return undef;
#        my @res;
#        for (sort readdir $dh) {
#            next if ($_ eq '.' || $_ eq '..') && $intdir eq '';
#            next if $isint && !(-d "$path/$_");
#            push @res, Encode::decode('UTF-8', $_);
#        }
#        \@res;
#    };
#
#
#    my $filter;
#    if ($args{filter} && !ref($args{filter})) {
#        my @seqs = split /\s*\|\s*/, $args{filter};
#        $filter = sub {
#            my $name = shift;
#            my @st = stat($name) or return 0;
#            my $mode = $st[2];
#            my $pass;
#          SEQ:
#            for my $seq (@seqs) {
#                my $neg = sub { $_[0] };
#                for my $c (split //, $seq) {
#                    if    ($c eq '-') { $neg = sub { $_[0] ? 0 : 1 } }
#                    elsif ($c eq 'r') { next SEQ unless $neg->($mode & 0400) }
#                    elsif ($c eq 'w') { next SEQ unless $neg->($mode & 0200) }
#                    elsif ($c eq 'x') { next SEQ unless $neg->($mode & 0100) }
#                    elsif ($c eq 'f') { next SEQ unless $neg->($mode & 0100000)}
#                    elsif ($c eq 'd') { next SEQ unless $neg->($mode & 0040000)}
#                    else {
#                        die "Unknown character in filter: $c (in $seq)";
#                    }
#                }
#                $pass = 1; last SEQ;
#            }
#            $pass;
#        };
#    } elsif ($args{filter} && ref($args{filter}) eq 'CODE') {
#        $filter = $args{filter};
#    }
#
#    my $filter_fregex;
#    if ($args{file_regex_filter}) {
#        $filter_fregex = sub {
#            my $name = shift;
#            return 1 if -d $name;
#            return 0 unless -f _;
#            return 1 if $name =~ $args{file_regex_filter};
#            0;
#        };
#    }
#
#    my $filter_fext;
#    if ($args{file_ext_filter} && ref $args{file_ext_filter} eq 'Regexp') {
#        $filter_fext = sub {
#            my $name = shift;
#            return 1 if -d $name;
#            return 0 unless -f _;
#            my $ext = $name =~ /\.(\w+)\z/ ? $1 : '';
#            return 1 if $ext =~ $args{file_ext_filter};
#            0;
#        };
#    } elsif ($args{file_ext_filter} && ref $args{file_ext_filter} eq 'ARRAY') {
#        $filter_fext = sub {
#            my $name = shift;
#            return 1 if -d $name;
#            return 0 unless -f _;
#            my $ext = $name =~ /\.(\w+)\z/ ? $1 : '';
#            if ($Complete::Common::OPT_CI) {
#                $ext = lc($ext);
#                for my $e (@{ $args{file_ext_filter} }) {
#                    return 1 if $ext eq lc($e);
#                }
#            } else {
#                for my $e (@{ $args{file_ext_filter} }) {
#                    return 1 if $ext eq $e;
#                }
#            }
#            0;
#        };
#    }
#
#    my $filter_dir;
#    if ($args{_dir}) {
#        $filter_dir = sub { return 0 unless (-d $_[0]); 1 };
#    }
#
#    my $filter_xdir;
#    if ($args{exclude_dir}) {
#        $filter_xdir = sub { return 0 if (-d $_[0]); 1 };
#    }
#
#    my $final_filter = sub {
#        my $name = shift;
#        if ($filter_dir)    { return 0 unless $filter_dir->($name)    }
#        if ($filter_xdir)   { return 0 unless $filter_xdir->($name)   }
#        if ($filter)        { return 0 unless $filter->($name)        }
#        if ($filter_fregex) { return 0 unless $filter_fregex->($name) }
#        if ($filter_fext)   { return 0 unless $filter_fext->($name)   }
#        1;
#    };
#
#    Complete::Path::complete_path(
#        word => $word,
#        list_func => $list,
#        is_dir_func => sub { -d $_[0] },
#        filter_func => $final_filter,
#        starting_path => $starting_path,
#        result_prefix => $result_prefix,
#    );
#}
#
#$SPEC{complete_dir} = do {
#    my $spec = {%{ $SPEC{complete_file} }}; 
#
#    $spec->{summary} = 'Complete directory from local filesystem '.
#        '(wrapper for complete_dir() that only picks directories)';
#    $spec->{args} = { %{$spec->{args}} }; 
#    delete $spec->{args}{file_regex_filter};
#    delete $spec->{args}{file_ext_filter};
#    delete $spec->{args}{exclude_dir};
#
#    $spec;
#};
#sub complete_dir {
#    my %args = @_;
#
#    complete_file(%args, _dir=>1);
#}
#
#1;
#
#__END__
#
### Complete/Fish.pm ###
#package Complete::Fish;
#
#our $DATE = '2016-10-21'; 
#our $VERSION = '0.05'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       format_completion
#               );
#
#require Complete::Bash;
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Completion module for fish shell',
#};
#
#$SPEC{format_completion} = {
#    v => 1.1,
#    summary => 'Format completion for output (for shell)',
#    description => <<'_',
#
#fish accepts completion reply in the form of one entry per line to STDOUT.
#Description can be added to each entry, prefixed by tab character.
#
#_
#    args_as => 'array',
#    args => {
#        completion => {
#            summary => 'Completion answer structure',
#            description => <<'_',
#
#Either an array or hash, as described in `Complete`.
#
#_
#            schema=>['any*' => of => ['hash*', 'array*']],
#            req=>1,
#            pos=>0,
#        },
#    },
#    result => {
#        summary => 'Formatted string (or array, if `as` key is set to `array`)',
#        schema => ['any*' => of => ['str*', 'array*']],
#    },
#    result_naked => 1,
#};
#sub format_completion {
#    my $comp = shift;
#
#    my $as;
#    my $entries;
#
#    if (ref($comp) eq 'HASH') {
#        $as = $comp->{as} // 'string';
#        $entries = Complete::Bash::format_completion({%$comp, as=>'array'});
#    } else {
#        $as = 'string';
#        $entries = Complete::Bash::format_completion({
#            words=>$comp, as=>'array',
#        });
#    }
#
#    {
#        my $compary = ref($comp) eq 'HASH' ? $comp->{words} : $comp;
#        for (my $i=0; $i<@$compary; $i++) {
#
#            my $desc = (ref($compary->[$i]) eq 'HASH' ?
#                            $compary->[$i]{description} : '' ) // '';
#            $desc =~ s/\R/ /g;
#            $entries->[$i] .= "\t$desc";
#        }
#    }
#
#    if ($as eq 'string') {
#        $entries = join("", map{"$_\n"} @$entries);
#    }
#    $entries;
#}
#
#1;
#
#__END__
#
### Complete/Getopt/Long.pm ###
#package Complete::Getopt::Long;
#
#our $DATE = '2017-01-13'; 
#our $VERSION = '0.46'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       complete_cli_arg
#               );
#
#our %SPEC;
#
#sub _default_completion {
#    require Complete::Env;
#    require Complete::File;
#    require Complete::Util;
#
#    my %args = @_;
#    my $word = $args{word} // '';
#
#    my $fres;
#
#    if ($word =~ /\A\$/) {
#        {
#            my $compres = Complete::Env::complete_env(
#                word=>$word);
#            last unless @$compres;
#            $fres = {words=>$compres, esc_mode=>'shellvar'};
#            goto RETURN_RES;
#        }
#    }
#
#    if ($word =~ m!\A~([^/]*)\z!) {
#        {
#            eval { require Unix::Passwd::File };
#            last if $@;
#            my $res = Unix::Passwd::File::list_users(detail=>1);
#            last unless $res->[0] == 200;
#            my $compres = Complete::Util::complete_array_elem(
#                array=>[map {"~" . $_->{user} . ((-d $_->{home}) ? "/":"")}
#                            @{ $res->[2] }],
#                word=>$word,
#            );
#            last unless @$compres;
#            $fres = {words=>$compres, path_sep=>'/'};
#            goto RETURN_RES;
#        }
#    }
#
#    if ($word =~ m!\A(~[^/]*)/!) {
#        $fres = {words=>Complete::File::complete_file(word=>$word),
#                 path_sep=>'/'};
#        goto RETURN_RES;
#    }
#
#    require String::Wildcard::Bash;
#    if (String::Wildcard::Bash::contains_wildcard($word)) {
#        {
#            my $compres = [glob("$word*")];
#            last unless @$compres;
#            for (@$compres) {
#                $_ .= "/" if (-d $_);
#            }
#            $fres = {words=>$compres, path_sep=>'/'};
#            goto RETURN_RES;
#        }
#    }
#    $fres = {words=>Complete::File::complete_file(word=>$word),
#             path_sep=>'/'};
#  RETURN_RES:
#    $fres;
#}
#
#sub _expand1 {
#    my ($opt, $opts) = @_;
#    my @candidates;
#    my $is_hash = ref($opts) eq 'HASH';
#    for ($is_hash ? (sort {length($a)<=>length($b)} keys %$opts) : @$opts) {
#        next unless index($_, $opt) == 0;
#        push @candidates, $is_hash ? $opts->{$_} : $_;
#        last if $opt eq $_;
#    }
#    return @candidates == 1 ? $candidates[0] : undef;
#}
#
#sub _mark_seen {
#    my ($seen_opts, $opt, $opts) = @_;
#    my $opthash = $opts->{$opt};
#    return unless $opthash;
#    my $ospec = $opthash->{ospec};
#    for (keys %$opts) {
#        my $v = $opts->{$_};
#        $seen_opts->{$_}++ if $v->{ospec} eq $ospec;
#    }
#}
#
#$SPEC{complete_cli_arg} = {
#    v => 1.1,
#    summary => 'Complete command-line argument using '.
#        'Getopt::Long specification',
#    description => <<'_',
#
#This routine can complete option names, where the option names are retrieved
#from <pm:Getopt::Long> specification. If you provide completion routine in
#`completion`, you can also complete _option values_ and _arguments_.
#
#Note that this routine does not use <pm:Getopt::Long> (it does its own parsing)
#and currently is not affected by Getopt::Long's configuration. Its behavior
#mimics Getopt::Long under these configuration: `no_ignore_case`, `bundling` (or
#`no_bundling` if the `bundling` option is turned off). Which I think is the
#sensible default. This routine also does not currently support `auto_help` and
#`auto_version`, so you'll need to add those options specifically if you want to
#recognize `--help/-?` and `--version`, respectively.
#
#_
#    args => {
#        getopt_spec => {
#            summary => 'Getopt::Long specification',
#            schema  => 'hash*',
#            req     => 1,
#        },
#        completion => {
#            summary     =>
#                'Completion routine to complete option value/argument',
#            schema      => 'code*',
#            description => <<'_',
#
#Completion code will receive a hash of arguments (`%args`) containing these
#keys:
#
#* `type` (str, what is being completed, either `optval`, or `arg`)
#* `word` (str, word to be completed)
#* `cword` (int, position of words in the words array, starts from 0)
#* `opt` (str, option name, e.g. `--str`; undef if we're completing argument)
#* `ospec` (str, Getopt::Long option spec, e.g. `str|S=s`; undef when completing
#  argument)
#* `argpos` (int, argument position, zero-based; undef if type='optval')
#* `nth` (int, the number of times this option has seen before, starts from 0
#  that means this is the first time this option has been seen; undef when
#  type='arg')
#* `seen_opts` (hash, all the options seen in `words`)
#* `parsed_opts` (hash, options parsed the standard/raw way)
#
#as well as all keys from `extras` (but these won't override the above keys).
#
#and is expected to return a completion answer structure as described in
#`Complete` which is either a hash or an array. The simplest form of answer is
#just to return an array of strings. The various `complete_*` function like those
#in <pm:Complete::Util> or the other `Complete::*` modules are suitable to use
#here.
#
#Completion routine can also return undef to express declination, in which case
#the default completion routine will then be consulted. The default routine
#completes from shell environment variables (`$FOO`), Unix usernames (`~foo`),
#and files/directories.
#
#Example:
#
#    use Complete::Unix qw(complete_user);
#    use Complete::Util qw(complete_array_elem);
#    complete_cli_arg(
#        getopt_spec => {
#            'help|h'   => sub{...},
#            'format=s' => \$format,
#            'user=s'   => \$user,
#        },
#        completion  => sub {
#            my %args  = @_;
#            my $word  = $args{word};
#            my $ospec = $args{ospec};
#            if ($ospec && $ospec eq 'format=s') {
#                complete_array_elem(array=>[qw/json text xml yaml/], word=>$word);
#            } else {
#                complete_user(word=>$word);
#            }
#        },
#    );
#
#_
#        },
#        words => {
#            summary     => 'Command line arguments, like @ARGV',
#            description => <<'_',
#
#See function `parse_cmdline` in <pm:Complete::Bash> on how to produce this (if
#you're using bash).
#
#_
#            schema      => 'array*',
#            req         => 1,
#        },
#        cword => {
#            summary     =>
#                "Index in words of the word we're trying to complete",
#            description => <<'_',
#
#See function `parse_cmdline` in <pm:Complete::Bash> on how to produce this (if
#you're using bash).
#
#_
#            schema      => 'int*',
#            req         => 1,
#        },
#        extras => {
#            summary => 'Add extra arguments to completion routine',
#            schema  => 'hash',
#            description => <<'_',
#
#The keys from this `extras` hash will be merged into the final `%args` passed to
#completion routines. Note that standard keys like `type`, `word`, and so on as
#described in the function description will not be overwritten by this.
#
#_
#        },
#        bundling => {
#            schema  => 'bool*',
#            default => 1,
#            'summary.alt.bool.not' => 'Turn off bundling',
#            description => <<'_',
#
#If you turn off bundling, completion of short-letter options won't support
#bundling (e.g. `-b<tab>` won't add more single-letter options), but single-dash
#multiletter options can be recognized. Currently only those specified with a
#single dash will be completed. For example if you have `-foo=s` in your option
#specification, `-f<tab>` can complete it.
#
#This can be used to complete old-style programs, e.g. emacs which has options
#like `-nw`, `-nbc` etc (but also have double-dash options like
#`--no-window-system` or `--no-blinking-cursor`).
#
#_
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => ['any*' => of => ['hash*', 'array*']],
#        description => <<'_',
#
#You can use `format_completion` function in <pm:Complete::Bash> module to format
#the result of this function for bash.
#
#_
#    },
#};
#sub complete_cli_arg {
#    require Complete::Util;
#    require Getopt::Long::Util;
#
#    my %args = @_;
#
#    my $fname = __PACKAGE__ . "::complete_cli_arg"; 
#    my $fres;
#
#    $args{words} or die "Please specify words";
#    my @words = @{ $args{words} };
#    defined(my $cword = $args{cword}) or die "Please specify cword";
#    my $gospec = $args{getopt_spec} or die "Please specify getopt_spec";
#    my $comp = $args{completion};
#    my $extras = $args{extras} // {};
#    my $bundling = $args{bundling} // 1;
#    my %parsed_opts;
#
#
#    my %opts;
#    for my $ospec (keys %$gospec) {
#        my $res = Getopt::Long::Util::parse_getopt_long_opt_spec($ospec)
#            or die "Can't parse option spec '$ospec'";
#        next if $res->{is_arg};
#        $res->{min_vals} //= $res->{type} ? 1 : 0;
#        $res->{max_vals} //= $res->{type} || $res->{opttype} ? 1:0;
#        for my $o0 (@{ $res->{opts} }) {
#            my @o = $res->{is_neg} && length($o0) > 1 ?
#                ($o0, "no$o0", "no-$o0") : ($o0);
#            for my $o (@o) {
#                my $k = length($o)==1 ||
#                    (!$bundling && $res->{dash_prefix} eq '-') ?
#                        "-$o" : "--$o";
#                $opts{$k} = {
#                    name => $k,
#                    ospec => $ospec, 
#                    parsed => $res,
#                };
#            }
#        }
#    }
#    my @optnames = sort keys %opts;
#
#    my %seen_opts;
#
#
#    my @expects;
#
#    my $i = -1;
#    my $argpos = 0;
#
#  WORD:
#    while (1) {
#        last WORD if ++$i >= @words;
#        my $word = $words[$i];
#
#        if ($word eq '--' && $i != $cword) {
#            $expects[$i] = {separator=>1};
#            while (1) {
#                $i++;
#                last WORD if $i >= @words;
#                $expects[$i] = {arg=>1, argpos=>$argpos++};
#            }
#        }
#
#        if ($word =~ /\A-/) {
#
#          SHORT_OPTS:
#            {
#                last unless $opts{"-".substr($word,1,1)};
#
#                last unless $bundling;
#
#                my $j = $i;
#                my $rest = substr($word, 1);
#                my @inswords;
#                my $encounter_equal_sign;
#              EXPAND:
#                while (1) {
#                    $rest =~ s/(.)// or last;
#                    my $opt = "-$1";
#                    my $opthash = $opts{$opt};
#                    unless ($opthash) {
#                        @inswords = ();
#                        $expects[$i]{short_only} = 0;
#                        $rest = $word;
#                        last EXPAND;
#                    }
#                    if ($opthash->{parsed}{max_vals}) {
#                        _mark_seen(\%seen_opts, $opt, \%opts);
#
#                        if ($i == $j) {
#                            $words[$i] = $opt;
#                        } else {
#                            push @inswords, $opt;
#                            $j++;
#                        }
#
#                        my $expand;
#                        if (length $rest) {
#                            $expand++;
#                            $expects[$j > $i ? $j+1 : $j+2]{do_complete_optname} = 0;
#                            $expects[$j > $i ? $j+1 : $j+2]{optval} = $opt;
#                        } else {
#                            $expects[$j > $i ? $j-1 : $j]{optname} = $opt;
#                            $expects[$j > $i ? $j-1 : $j]{comp_result} = [
#                                substr($word, 0, length($word)-length($rest))];
#                        }
#
#                        if ($rest =~ s/\A=//) {
#                            $encounter_equal_sign++;
#                        }
#
#                        if ($expand) {
#                            push @inswords, "=", $rest;
#                            $j+=2;
#                        }
#                        last EXPAND;
#                    }
#                    _mark_seen(\%seen_opts, $opt, \%opts);
#                    if ($i == $j) {
#                        $words[$i] = $opt;
#                    } else {
#                        push @inswords, $opt;
#                    }
#                    $j++;
#                }
#
#
#                my $prefix = $encounter_equal_sign ? '' :
#                    substr($word, 0, length($word)-length($rest));
#                splice @words, $i+1, 0, @inswords;
#                for (0..@inswords) {
#                    $expects[$i+$_]{prefix} = $prefix;
#                    $expects[$i+$_]{word}   = $rest;
#                }
#                $cword += @inswords;
#                $i += @inswords;
#                $word = $words[$i];
#                $expects[$i]{short_only} //= 1;
#            } 
#
#          SPLIT_EQUAL:
#            {
#                if ($word =~ /\A(--?[^=]+)(=)(.*)/) {
#                    splice @words, $i, 1, $1, $2, $3;
#                    $word = $1;
#                    $cword += 2 if $cword >= $i;
#                }
#            }
#
#            my $opt = $word;
#            my $opthash = _expand1($opt, \%opts);
#
#            if ($opthash) {
#                $opt = $opthash->{name};
#                $expects[$i]{optname} = $opt;
#                my $nth = $seen_opts{$opt} // 0;
#                $expects[$i]{nth} = $nth;
#                _mark_seen(\%seen_opts, $opt, \%opts);
#
#                my $min_vals = $opthash->{parsed}{min_vals};
#                my $max_vals = $opthash->{parsed}{max_vals};
#
#                if ($i+1 < @words && $words[$i+1] eq '=') {
#                    $i++;
#                    $expects[$i] = {separator=>1, optval=>$opt, word=>'', nth=>$nth};
#                    if (!$max_vals) { $min_vals = $max_vals = 1 }
#                }
#
#                for (1 .. $min_vals) {
#                    $i++;
#                    last WORD if $i >= @words;
#                    $expects[$i]{optval} = $opt;
#                    $expects[$i]{nth} = $nth;
#                    push @{ $parsed_opts{$opt} }, $words[$i];
#                }
#                for (1 .. $max_vals-$min_vals) {
#                    last if $i+$_ >= @words;
#                    last if $words[$i+$_] =~ /\A-/; 
#                    $expects[$i+$_]{optval} = $opt; 
#                    $expects[$i]{nth} = $nth;
#                    push @{ $parsed_opts{$opt} }, $words[$i+$_];
#                }
#            } else {
#                $opt = undef;
#                $expects[$i]{optname} = $opt;
#
#                if ($i+1 < @words && $words[$i+1] eq '=') {
#                    $i++;
#                    $expects[$i] = {separator=>1, optval=>undef, word=>''};
#                    if ($i+1 < @words) {
#                        $i++;
#                        $expects[$i]{optval} = $opt;
#                    }
#                }
#            }
#        } else {
#            $expects[$i]{optname} = '';
#            $expects[$i]{arg} = 1;
#            $expects[$i]{argpos} = $argpos++;
#        }
#    }
#
#    my $exp = $expects[$cword];
#    my $word = $exp->{word} // $words[$cword];
#
#
#    my @answers;
#
#    {
#        last if $word =~ /\A[^-]/;
#        last unless exists $exp->{optname};
#        last if defined($exp->{do_complete_optname}) &&
#            !$exp->{do_complete_optname};
#        if ($exp->{comp_result}) {
#            push @answers, $exp->{comp_result};
#            last;
#        }
#        my $opt = $exp->{optname};
#        my @o;
#        for (@optnames) {
#            my $repeatable = 0;
#            next if $exp->{short_only} && /\A--/;
#            if ($seen_opts{$_}) {
#                my $opthash = $opts{$_};
#                my $ospecval = $gospec->{$opthash->{ospec}};
#                my $parsed = $opthash->{parsed};
#                if (ref($ospecval) eq 'ARRAY') {
#                    $repeatable = 1;
#                } elsif ($parsed->{desttype} || $parsed->{is_inc}) {
#                    $repeatable = 1;
#                }
#            }
#            next if $seen_opts{$_} && !$repeatable && (
#                (!$opt || $opt ne $_) ||
#                    (defined($exp->{prefix}) &&
#                         index($exp->{prefix}, substr($opt, 1, 1)) >= 0));
#            if (defined $exp->{prefix}) {
#                my $o = $_; $o =~ s/\A-//;
#                push @o, "$exp->{prefix}$o";
#            } else {
#                push @o, $_;
#            }
#        }
#        my $compres = Complete::Util::complete_array_elem(
#            array => \@o, word => $word);
#        push @answers, $compres;
#        if (!exists($exp->{optval}) && !exists($exp->{arg})) {
#            $fres = {words=>$compres, esc_mode=>'option'};
#            goto RETURN_RES;
#        }
#    }
#
#    {
#        last unless exists($exp->{optval});
#        my $opt = $exp->{optval};
#        my $opthash = $opts{$opt} if $opt;
#        my %compargs = (
#            %$extras,
#            type=>'optval', words=>\@words, cword=>$args{cword},
#            word=>$word, opt=>$opt, ospec=>$opthash->{ospec},
#            argpos=>undef, nth=>$exp->{nth}, seen_opts=>\%seen_opts,
#            parsed_opts=>\%parsed_opts,
#        );
#        my $compres;
#        if ($comp) {
#            $compres = $comp->(%compargs);
#            Complete::Util::modify_answer(answer=>$compres, prefix=>$exp->{prefix})
#                if defined $exp->{prefix};
#        }
#        if (!$compres || !$comp) {
#            $compres = _default_completion(%compargs);
#            Complete::Util::modify_answer(answer=>$compres, prefix=>$exp->{prefix})
#                if defined $exp->{prefix};
#        }
#        push @answers, $compres;
#    }
#
#    {
#        last unless exists($exp->{arg});
#        my %compargs = (
#            %$extras,
#            type=>'arg', words=>\@words, cword=>$args{cword},
#            word=>$word, opt=>undef, ospec=>undef,
#            argpos=>$exp->{argpos}, seen_opts=>\%seen_opts,
#            parsed_opts=>\%parsed_opts,
#        );
#        my $compres = $comp->(%compargs) if $comp;
#        if (!defined $compres) {
#            $compres = _default_completion(%compargs);
#        }
#        push @answers, $compres;
#    }
#
#    $fres = Complete::Util::combine_answers(@answers) // [];
#
#  RETURN_RES:
#    $fres;
#}
#
#1;
#
#__END__
#
### Complete/Path.pm ###
#package Complete::Path;
#
#our $DATE = '2017-07-03'; 
#our $VERSION = '0.24'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Complete::Common qw(:all);
#
#our $COMPLETE_PATH_TRACE = $ENV{COMPLETE_PATH_TRACE} // 0;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       complete_path
#               );
#
#sub _dig_leaf {
#    my ($p, $list_func, $is_dir_func, $filter_func, $path_sep) = @_;
#    my $num_dirs;
#    my $listres = $list_func->($p, '', 0);
#    return $p unless ref($listres) eq 'ARRAY' && @$listres;
#    my @candidates;
#  L1:
#    for my $e (@$listres) {
#        my $p2 = $p =~ m!\Q$path_sep\E\z! ? "$p$e" : "$p$path_sep$e";
#        {
#            local $_ = $p2; 
#            next L1 if $filter_func && !$filter_func->($p2);
#        }
#        push @candidates, $p2;
#    }
#    return $p unless @candidates == 1;
#    my $p2 = $candidates[0];
#    my $is_dir;
#    if ($p2 =~ m!\Q$path_sep\E\z!) {
#        $is_dir++;
#    } else {
#        $is_dir = $is_dir_func && $is_dir_func->($p2);
#    }
#    return _dig_leaf($p2, $list_func, $is_dir_func, $filter_func, $path_sep)
#        if $is_dir;
#    $p2;
#}
#
#our %SPEC;
#
#$SPEC{complete_path} = {
#    v => 1.1,
#    summary => 'Complete path',
#    description => <<'_',
#
#Complete path, for anything path-like. Meant to be used as backend for other
#functions like `Complete::File::complete_file` or
#`Complete::Module::complete_module`. Provides features like case-insensitive
#matching, expanding intermediate paths, and case mapping.
#
#Algorithm is to split path into path elements, then list items (using the
#supplied `list_func`) and perform filtering (using the supplied `filter_func`)
#at every level.
#
#_
#    args => {
#        %arg_word,
#        list_func => {
#            summary => 'Function to list the content of intermediate "dirs"',
#            schema => 'code*',
#            req => 1,
#            description => <<'_',
#
#Code will be called with arguments: ($path, $cur_path_elem, $is_intermediate).
#Code should return an arrayref containing list of elements. "Directories" can be
#marked by ending the name with the path separator (see `path_sep`). Or, you can
#also provide an `is_dir_func` function that will be consulted after filtering.
#If an item is a "directory" then its name will be suffixed with a path
#separator by `complete_path()`.
#
#_
#        },
#        is_dir_func => {
#            summary => 'Function to check whether a path is a "dir"',
#            schema  => 'code*',
#            description => <<'_',
#
#Optional. You can provide this function to determine if an item is a "directory"
#(so its name can be suffixed with path separator). You do not need to do this if
#you already suffix names of "directories" with path separator in `list_func`.
#
#One reason you might want to provide this and not mark "directories" in
#`list_func` is when you want to do extra filtering with `filter_func`. Sometimes
#you do not want to suffix the names first (example: see `complete_file` in
#`Complete::File`).
#
#_
#        },
#        starting_path => {
#            schema => 'str*',
#            req => 1,
#            default => '',
#        },
#        filter_func => {
#            schema  => 'code*',
#            description => <<'_',
#
#Provide extra filtering. Code will be given path and should return 1 if the item
#should be included in the final result or 0 if the item should be excluded.
#
#_
#        },
#        path_sep => {
#            schema  => 'str*',
#            default => '/',
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_path {
#    require Complete::Util;
#
#    my %args   = @_;
#    my $word   = $args{word} // "";
#    my $path_sep = $args{path_sep} // '/';
#    my $list_func   = $args{list_func};
#    my $is_dir_func = $args{is_dir_func};
#    my $filter_func = $args{filter_func};
#    my $result_prefix = $args{result_prefix};
#    my $starting_path = $args{starting_path} // '';
#
#    my $ci          = $Complete::Common::OPT_CI;
#    my $word_mode   = $Complete::Common::OPT_WORD_MODE;
#    my $fuzzy       = $Complete::Common::OPT_FUZZY;
#    my $map_case    = $Complete::Common::OPT_MAP_CASE;
#    my $exp_im_path = $Complete::Common::OPT_EXP_IM_PATH;
#    my $dig_leaf    = $Complete::Common::OPT_DIG_LEAF;
#
#    my $re_ends_with_path_sep = qr!\A\z|\Q$path_sep\E\z!;
#
#    my @intermediate_dirs;
#    {
#        @intermediate_dirs = split qr/\Q$path_sep/, $word;
#        @intermediate_dirs = ('') if !@intermediate_dirs;
#        push @intermediate_dirs, '' if $word =~ $re_ends_with_path_sep;
#    }
#
#    my $leaf = pop @intermediate_dirs;
#    @intermediate_dirs = ('') if !@intermediate_dirs;
#
#
#    my @candidate_paths;
#
#    for my $i (0..$#intermediate_dirs) {
#        my $intdir = $intermediate_dirs[$i];
#        my $intdir_with_path_sep = "$intdir$path_sep";
#        my @dirs;
#        if ($i == 0) {
#            @dirs = ($starting_path);
#        } else {
#            @dirs = @candidate_paths;
#        }
#
#        if ($i == $#intermediate_dirs && $intdir eq '') {
#            @candidate_paths = @dirs;
#            last;
#        }
#
#        my @new_candidate_paths;
#        for my $dir (@dirs) {
#            my $listres = $list_func->($dir, $intdir, 1);
#            next unless $listres && @$listres;
#            my $matches = Complete::Util::complete_array_elem(
#                word => $intdir, array => $listres,
#            );
#            my $exact_matches = [grep {
#                $_ eq $intdir || $_ eq $intdir_with_path_sep
#            } @$matches];
#
#            if (!$exp_im_path || @$exact_matches == 1) {
#                $matches = $exact_matches;
#            }
#
#            for (@$matches) {
#                my $p = $dir =~ $re_ends_with_path_sep ?
#                    "$dir$_" : "$dir$path_sep$_";
#                push @new_candidate_paths, $p;
#            }
#
#        }
#        return [] unless @new_candidate_paths;
#        @candidate_paths = @new_candidate_paths;
#    }
#
#    my $cut_chars = 0;
#    if (length($starting_path)) {
#        $cut_chars += length($starting_path);
#        unless ($starting_path =~ /\Q$path_sep\E\z/) {
#            $cut_chars += length($path_sep);
#        }
#    }
#
#    my @res;
#    for my $dir (@candidate_paths) {
#        my $listres = $list_func->($dir, $leaf, 0);
#        next unless $listres && @$listres;
#        my $matches = Complete::Util::complete_array_elem(
#            word => $leaf, array => $listres,
#        );
#
#      L1:
#        for my $e (@$matches) {
#            my $p = $dir =~ $re_ends_with_path_sep ?
#                "$dir$e" : "$dir$path_sep$e";
#            {
#                local $_ = $p; 
#                next L1 if $filter_func && !$filter_func->($p);
#            }
#
#            my $is_dir;
#            if ($e =~ $re_ends_with_path_sep) {
#                $is_dir = 1;
#            } else {
#                local $_ = $p; 
#                $is_dir = $is_dir_func->($p);
#            }
#
#            if ($is_dir && $dig_leaf) {
#                {
#                    my $p2 = _dig_leaf($p, $list_func, $is_dir_func, $filter_func, $path_sep);
#                    last if $p2 eq $p;
#                    $p = $p2;
#
#                    if ($p =~ $re_ends_with_path_sep) {
#                        $is_dir = 1;
#                    } else {
#                        local $_ = $p; 
#                        $is_dir = $is_dir_func->($p);
#                    }
#                }
#            }
#
#            my $p0 = $p;
#            substr($p, 0, $cut_chars) = '' if $cut_chars;
#            $p = "$result_prefix$p" if length($result_prefix);
#            unless ($p =~ /\Q$path_sep\E\z/) {
#                $p .= $path_sep if $is_dir;
#            }
#            push @res, $p;
#        }
#    }
#
#    \@res;
#}
#1;
#
#__END__
#
### Complete/Tcsh.pm ###
#package Complete::Tcsh;
#
#our $DATE = '2015-09-09'; 
#our $VERSION = '0.02'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       parse_cmdline
#                       format_completion
#               );
#
#require Complete::Bash;
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Completion module for tcsh shell',
#};
#
#$SPEC{parse_cmdline} = {
#    v => 1.1,
#    summary => 'Parse shell command-line for processing by completion routines',
#    description => <<'_',
#
#This function converts COMMAND_LINE (str) given by tcsh to become something like
#COMP_WORDS (array) and COMP_CWORD (int), like what bash supplies to shell
#functions. Currently implemented using `Complete::Bash`'s `parse_cmdline`.
#
#_
#    args_as => 'array',
#    args => {
#        cmdline => {
#            summary => 'Command-line, defaults to COMMAND_LINE environment',
#            schema => 'str*',
#            pos => 0,
#        },
#    },
#    result => {
#        schema => ['array*', len=>2],
#        description => <<'_',
#
#Return a 2-element array: `[$words, $cword]`. `$words` is array of str,
#equivalent to `COMP_WORDS` provided by bash to shell functions. `$cword` is an
#integer, equivalent to `COMP_CWORD` provided by bash to shell functions. The
#word to be completed is at `$words->[$cword]`.
#
#Note that COMP_LINE includes the command name. If you want the command-line
#arguments only (like in `@ARGV`), you need to strip the first element from
#`$words` and reduce `$cword` by 1.
#
#_
#    },
#    result_naked => 1,
#};
#sub parse_cmdline {
#    my ($line) = @_;
#
#    $line //= $ENV{COMMAND_LINE};
#    Complete::Bash::parse_cmdline($line, length($line));
#}
#
#$SPEC{format_completion} = {
#    v => 1.1,
#    summary => 'Format completion for output (for shell)',
#    description => <<'_',
#
#tcsh accepts completion reply in the form of one entry per line to STDOUT.
#Currently the formatting is done using `Complete::Bash`'s `format_completion`
#because escaping rule and so on are not yet well defined in tcsh.
#
#_
#    args_as => 'array',
#    args => {
#        completion => {
#            summary => 'Completion answer structure',
#            description => <<'_',
#
#Either an array or hash, as described in `Complete`.
#
#_
#            schema=>['any*' => of => ['hash*', 'array*']],
#            req=>1,
#            pos=>0,
#        },
#    },
#    result => {
#        summary => 'Formatted string (or array, if `as` is set to `array`)',
#        schema => ['any*' => of => ['str*', 'array*']],
#    },
#    result_naked => 1,
#};
#sub format_completion {
#    Complete::Bash::format_completion(@_);
#}
#
#1;
#
#__END__
#
### Complete/Util.pm ###
#package Complete::Util;
#
#our $DATE = '2017-12-08'; 
#our $VERSION = '0.600'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#use Complete::Common qw(:all);
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       hashify_answer
#                       arrayify_answer
#                       combine_answers
#                       modify_answer
#                       ununiquify_answer
#                       complete_array_elem
#                       complete_hash_key
#                       complete_comma_sep
#               );
#
#our %SPEC;
#
#our $COMPLETE_UTIL_TRACE = $ENV{COMPLETE_UTIL_TRACE} // 0;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'General completion routine',
#    description => <<'_',
#
#This package provides some generic completion routines that follow the
#<pm:Complete> convention. (If you are looking for bash/shell tab completion
#routines, take a look at the See Also section.) The main routine is
#`complete_array_elem` which tries to complete a word using choices from elements
#of supplied array. For example:
#
#    complete_array_elem(word => "a", array => ["apple", "apricot", "banana"]);
#
#The routine will first try a simple substring prefix matching. If that fails,
#will try some other methods like word-mode, character-mode, or fuzzy matching.
#These methods can be disabled using settings.
#
#There are other utility routines e.g. for converting completion answer structure
#from hash to array/array to hash, combine or modify answer, etc. These routines
#are usually used by the other more specific or higher-level completion modules.
#
#_
#};
#
#$SPEC{hashify_answer} = {
#    v => 1.1,
#    summary => 'Make sure we return completion answer in hash form',
#    description => <<'_',
#
#This function accepts a hash or an array. If it receives an array, will convert
#the array into `{words=>$ary}' first to make sure the completion answer is in
#hash form.
#
#Then will add keys from `meta` to the hash.
#
#_
#    args => {
#        arg => {
#            summary => '',
#            schema  => ['any*' => of => ['array*','hash*']],
#            req => 1,
#            pos => 0,
#        },
#        meta => {
#            summary => 'Metadata (extra keys) for the hash',
#            schema  => 'hash*',
#            pos => 1,
#        },
#    },
#    args_as => 'array',
#    result_naked => 1,
#    result => {
#        schema => 'hash*',
#    },
#};
#sub hashify_answer {
#    my $ans = shift;
#    if (ref($ans) ne 'HASH') {
#        $ans = {words=>$ans};
#    }
#    if (@_) {
#        my $meta = shift;
#        for (keys %$meta) {
#            $ans->{$_} = $meta->{$_};
#        }
#    }
#    $ans;
#}
#
#$SPEC{arrayify_answer} = {
#    v => 1.1,
#    summary => 'Make sure we return completion answer in array form',
#    description => <<'_',
#
#This is the reverse of `hashify_answer`. It accepts a hash or an array. If it
#receives a hash, will return its `words` key.
#
#_
#    args => {
#        arg => {
#            summary => '',
#            schema  => ['any*' => of => ['array*','hash*']],
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result_naked => 1,
#    result => {
#        schema => 'array*',
#    },
#};
#sub arrayify_answer {
#    my $ans = shift;
#    if (ref($ans) eq 'HASH') {
#        $ans = $ans->{words};
#    }
#    $ans;
#}
#
#sub __min(@) {
#    my $m = $_[0];
#    for (@_) {
#        $m = $_ if $_ < $m;
#    }
#    $m;
#}
#
#our $code_editdist;
#our $editdist_flex;
#
#sub __editdist {
#    my @a = split //, shift;
#    my @b = split //, shift;
#
#    my @d;
#    $d[$_][0] = $_ for 0 .. @a;
#    $d[0][$_] = $_ for 0 .. @b;
#
#    for my $i (1 .. @a) {
#        for my $j (1 .. @b) {
#            $d[$i][$j] = (
#                $a[$i-1] eq $b[$j-1]
#                    ? $d[$i-1][$j-1]
#                    : 1 + __min(
#                        $d[$i-1][$j],
#                        $d[$i][$j-1],
#                        $d[$i-1][$j-1]
#                    )
#                );
#        }
#    }
#
#    $d[@a][@b];
#}
#
#my %complete_array_elem_args = (
#    %arg_word,
#    array       => {
#        schema => ['array*'=>{of=>'str*'}],
#        req => 1,
#        pos => 1,
#        greedy => 1,
#    },
#    exclude     => {
#        schema => ['array*'],
#    },
#    replace_map => {
#        schema => ['hash*', each_value=>['array*', of=>'str*']],
#        description => <<'_',
#
#You can supply correction entries in this option. An example is when array if
#`['mount','unmount']` and `umount` is a popular "typo" for `unmount`. When
#someone already types `um` it cannot be completed into anything (even the
#current fuzzy mode will return *both* so it cannot complete immediately).
#
#One solution is to add replace_map `{'unmount'=>['umount']}`. This way, `umount`
#will be regarded the same as `unmount` and when user types `um` it can be
#completed unambiguously into `unmount`.
#
#_
#        tags => ['experimental'],
#    },
#);
#
#$SPEC{complete_array_elem} = {
#    v => 1.1,
#    summary => 'Complete from array',
#    description => <<'_',
#
#Try to find completion from an array of strings. Will attempt several methods,
#from the cheapest and most discriminating to the most expensive and least
#discriminating.
#
#First method is normal/exact string prefix matching (either case-sensitive or
#insensitive depending on the `$Complete::Common::OPT_CI` variable or the
#`COMPLETE_OPT_CI` environment variable). If at least one match is found, return
#result. Else, proceed to the next method.
#
#Word-mode matching (can be disabled by setting
#`$Complete::Common::OPT_WORD_MODE` or `COMPLETE_OPT_WORD_MODE` environment
#varialbe to false). Word-mode matching is described in <pm:Complete::Common>. If
#at least one match is found, return result. Else, proceed to the next method.
#
#Prefix char-mode matching (can be disabled by settings
#`$Complete::Common::OPT_CHAR_MODE` or `COMPLETE_OPT_CHAR_MODE` environment
#variable to false). Prefix char-mode matching is just like char-mode matching
#(see next paragraph) except the first character must match. If at least one
#match is found, return result. Else, proceed to the next method.
#
#Char-mode matching (can be disabled by settings
#`$Complete::Common::OPT_CHAR_MODE` or `COMPLETE_OPT_CHAR_MODE` environment
#variable to false). Char-mode matching is described in <pm:Complete::Common>. If
#at least one match is found, return result. Else, proceed to the next method.
#
#Fuzzy matching (can be disabled by setting `$Complete::Common::OPT_FUZZY` or
#`COMPLETE_OPT_FUZZY` to false). Fuzzy matching is described in
#<pm:Complete::Common>. If at least one match is found, return result. Else,
#return empty string.
#
#Will sort the resulting completion list, so you don't have to presort the array.
#
#_
#    args => {
#        %complete_array_elem_args,
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_array_elem {
#    my %args  = @_;
#
#    my $array0    = $args{array} or die "Please specify array";
#    my $word      = $args{word} // "";
#
#    my $ci          = $Complete::Common::OPT_CI;
#    my $map_case    = $Complete::Common::OPT_MAP_CASE;
#    my $word_mode   = $Complete::Common::OPT_WORD_MODE;
#    my $char_mode   = $Complete::Common::OPT_CHAR_MODE;
#    my $fuzzy       = $Complete::Common::OPT_FUZZY;
#
#    log_trace("[computil] entering complete_array_elem(), word=<%s>", $word)
#        if $COMPLETE_UTIL_TRACE;
#
#    my $res;
#
#    unless (@$array0) {
#        $res = []; goto RETURN_RES;
#    }
#
#    my $wordn = $ci ? uc($word) : $word; $wordn =~ s/_/-/g if $map_case;
#
#    my $excluden;
#    if ($args{exclude}) {
#        $excluden = {};
#        for my $el (@{$args{exclude}}) {
#            my $eln = $ci ? uc($el) : $el; $eln =~ s/_/-/g if $map_case;
#            $excluden->{$eln} //= 1;
#        }
#    }
#
#    my $rmapn;
#    my $rev_rmapn; 
#    if (my $rmap = $args{replace_map}) {
#        $rmapn = {};
#        $rev_rmapn = {};
#        for my $k (keys %$rmap) {
#            my $kn = $ci ? uc($k) : $k; $kn =~ s/_/-/g if $map_case;
#            my @vn;
#            for my $v (@{ $rmap->{$k} }) {
#                my $vn = $ci ? uc($v) : $v; $vn =~ s/_/-/g if $map_case;
#                push @vn, $vn;
#                $rev_rmapn->{$vn} //= $k;
#            }
#            $rmapn->{$kn} = \@vn;
#        }
#    }
#
#    my @words; 
#    my @array ;  
#    my @arrayn;  
#
#    log_trace("[computil] Trying normal string-prefix matching ...") if $COMPLETE_UTIL_TRACE;
#    for my $el (@$array0) {
#        my $eln = $ci ? uc($el) : $el; $eln =~ s/_/-/g if $map_case;
#        next if $excluden && $excluden->{$eln};
#        push @array , $el;
#        push @arrayn, $eln;
#        push @words , $el if 0==index($eln, $wordn);
#        if ($rmapn && $rmapn->{$eln}) {
#            for my $vn (@{ $rmapn->{$eln} }) {
#                push @array , $el;
#                push @arrayn, $vn;
#                push @words , $vn if 0==index($vn, $wordn);
#            }
#        }
#    }
#    log_trace("[computil] Result from normal string-prefix matching: %s", \@words) if @words && $COMPLETE_UTIL_TRACE;
#
#    {
#        last unless $word_mode && !@words;
#        my @split_wordn = $wordn =~ /(\w+)/g;
#        unshift @split_wordn, '' if $wordn =~ /\A\W/;
#        last unless @split_wordn > 1;
#        my $re = '\A';
#        for my $i (0..$#split_wordn) {
#            $re .= '(?:\W+\w+)*\W+' if $i;
#            $re .= quotemeta($split_wordn[$i]).'\w*';
#        }
#        $re = qr/$re/;
#        log_trace("[computil] Trying word-mode matching (re=%s) ...", $re) if $COMPLETE_UTIL_TRACE;
#
#        for my $i (0..$#array) {
#            my $match;
#            {
#                if ($arrayn[$i] =~ $re) {
#                    $match++;
#                    last;
#                }
#                my $tmp = $array[$i];
#                if ($tmp =~ s/([a-z0-9_])([A-Z])/$1-$2/g) {
#                    $tmp = uc($tmp) if $ci; $tmp =~ s/_/-/g if $map_case; 
#                    if ($tmp =~ $re) {
#                        $match++;
#                        last;
#                    }
#                }
#            }
#            next unless $match;
#            push @words, $array[$i];
#        }
#        log_trace("[computil] Result from word-mode matching: %s", \@words) if @words && $COMPLETE_UTIL_TRACE;
#    }
#
#    if ($char_mode && !@words && length($wordn) && length($wordn) <= 7) {
#        my $re = join(".*", map {quotemeta} split(//, $wordn));
#        $re = qr/\A$re/;
#        log_trace("[computil] Trying prefix char-mode matching (re=%s) ...", $re) if $COMPLETE_UTIL_TRACE;
#        for my $i (0..$#array) {
#            push @words, $array[$i] if $arrayn[$i] =~ $re;
#        }
#        log_trace("[computil] Result from prefix char-mode matching: %s", \@words) if @words && $COMPLETE_UTIL_TRACE;
#    }
#
#    if ($char_mode && !@words && length($wordn) && length($wordn) <= 7) {
#        my $re = join(".*", map {quotemeta} split(//, $wordn));
#        $re = qr/$re/;
#        log_trace("[computil] Trying char-mode matching (re=%s) ...", $re) if $COMPLETE_UTIL_TRACE;
#        for my $i (0..$#array) {
#            push @words, $array[$i] if $arrayn[$i] =~ $re;
#        }
#        log_trace("[computil] Result from char-mode matching: %s", \@words) if @words && $COMPLETE_UTIL_TRACE;
#    }
#
#    if ($fuzzy && !@words) {
#        log_trace("[computil] Trying fuzzy matching ...") if $COMPLETE_UTIL_TRACE;
#        $code_editdist //= do {
#            my $env = $ENV{COMPLETE_UTIL_LEVENSHTEIN} // '';
#            if ($env eq 'xs') {
#                require Text::Levenshtein::XS;
#                $editdist_flex = 0;
#                \&Text::Levenshtein::XS::distance;
#            } elsif ($env eq 'flexible') {
#                require Text::Levenshtein::Flexible;
#                $editdist_flex = 1;
#                \&Text::Levenshtein::Flexible::levenshtein_l;
#            } elsif ($env eq 'pp') {
#                $editdist_flex = 0;
#                \&__editdist;
#            } elsif (eval { require Text::Levenshtein::Flexible; 1 }) {
#                $editdist_flex = 1;
#                \&Text::Levenshtein::Flexible::levenshtein_l;
#            } else {
#                $editdist_flex = 0;
#                \&__editdist;
#            }
#        };
#
#        my $factor = 1.3;
#        my $x = -1;
#        my $y = 1;
#
#
#        my %editdists;
#      ELEM:
#        for my $i (0..$#array) {
#            my $eln = $arrayn[$i];
#
#            for my $l (length($wordn)-$y .. length($wordn)+$y) {
#                next if $l <= 0;
#                my $chopped = substr($eln, 0, $l);
#                my $maxd = __min(
#                    __min(length($chopped), length($word))/$factor,
#                    $fuzzy,
#                );
#                my $d;
#                unless (defined $editdists{$chopped}) {
#                    if ($editdist_flex) {
#                        $d = $code_editdist->($wordn, $chopped, $maxd);
#                        next ELEM unless defined $d;
#                    } else {
#                        $d = $code_editdist->($wordn, $chopped);
#                    }
#                    $editdists{$chopped} = $d;
#                } else {
#                    $d = $editdists{$chopped};
#                }
#                next unless $d <= $maxd;
#                push @words, $array[$i];
#                next ELEM;
#            }
#        }
#        log_trace("[computil] Result from fuzzy matching: %s", \@words) if @words && $COMPLETE_UTIL_TRACE;
#    }
#
#    if ($rmapn && @words) {
#        my @wordsn;
#        for my $el (@words) {
#            my $eln = $ci ? uc($el) : $el; $eln =~ s/_/-/g if $map_case;
#            push @wordsn, $eln;
#        }
#        for my $i (0..$#words) {
#            if (my $w = $rev_rmapn->{$wordsn[$i]}) {
#                $words[$i] = $w;
#            }
#        }
#    }
#
#    $res =$ci ? [sort {lc($a) cmp lc($b)} @words] : [sort @words];
#
#  RETURN_RES:
#    log_trace("[computil] leaving complete_array_elem(), res=%s", $res)
#        if $COMPLETE_UTIL_TRACE;
#    $res;
#}
#
#$SPEC{complete_hash_key} = {
#    v => 1.1,
#    summary => 'Complete from hash keys',
#    args => {
#        %arg_word,
#        hash      => { schema=>['hash*'=>{}], req=>1 },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_hash_key {
#    my %args  = @_;
#    my $hash      = $args{hash} or die "Please specify hash";
#    my $word      = $args{word} // "";
#
#    complete_array_elem(
#        word=>$word, array=>[sort keys %$hash],
#    );
#}
#
#my %complete_comma_sep_args = (
#    %complete_array_elem_args,
#    sep => {
#        schema  => 'str*',
#        default => ',',
#    },
#    uniq => {
#        summary => 'Whether list should contain unique elements',
#        description => <<'_',
#
#When this option is set to true, if the formed list in the current word already
#contains an element, the element will not be offered again as completion answer.
#For example, if `elems` is `[1,2,3,4]` and `word` is `2,3,` then without `uniq`
#set to true the completion answer is:
#
#    2,3,1
#    2,3,2
#    2,3,3
#    2,3,4
#
#but with `uniq` set to true, the completion answer becomes:
#
#    2,3,1
#    2,3,4
#
#See also the `remaining` option for a more general mechanism of offering fewer
#elements.
#
#_
#        schema => ['bool*', is=>1],
#    },
#    remaining => {
#        schema => ['code*'],
#        summary => 'What elements should remain for completion',
#        description => <<'_',
#
#This is a more general mechanism if the `uniq` option does not suffice. Suppose
#you are offering completion for sorting fields. The elements are field names as
#well as field names prefixed with dash (`-`) to mean sorting with a reverse
#order. So for example `elems` is `["name","-name","age","-age"]`. When current
#word is `name`, it doesn't make sense to offer `name` nor `-name` again as the
#next sorting field. So we can set `remaining` to this code:
#
#    sub {
#        my ($seen_elems, $elems) = @_;
#
#        my %seen;
#        for (@$seen_elems) {
#            (my $nodash = $_) =~ s/^-//;
#            $seen{$nodash}++;
#        }
#
#        my @remaining;
#        for (@$elems) {
#            (my $nodash = $_) =~ s/^-//;
#            push @remaining, $_ unless $seen{$nodash};
#        }
#
#        \@remaining;
#    }
#
#As you can see above, the code is given `$seen_elems` and `$elems` as arguments
#and is expected to return remaining elements to offer.
#
#_
#        tags => ['hidden-cli'],
#    },
#);
#$complete_comma_sep_args{elems} = delete $complete_comma_sep_args{array};
#
#$SPEC{complete_comma_sep} = {
#    v => 1.1,
#    summary => 'Complete a comma-separated list string',
#    args => {
#        %complete_comma_sep_args,
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array',
#    },
#};
#sub complete_comma_sep {
#    my %args  = @_;
#    my $word      = delete $args{word} // "";
#    my $sep       = delete $args{sep} // ',';
#    my $elems     = delete $args{elems} or die "Please specify elems";
#    my $uniq      = delete $args{uniq};
#    my $remaining = delete $args{remaining};
#
#    my $ci = $Complete::Common::OPT_CI;
#
#    my @mentioned_elems = split /\Q$sep\E/, $word, -1;
#    my $cae_word = @mentioned_elems ? pop(@mentioned_elems) : '';
#
#    my $remaining_elems;
#    if ($remaining) {
#        $remaining_elems = $remaining->(\@mentioned_elems, $elems);
#    } elsif ($uniq) {
#        my %mem;
#        $remaining_elems = [];
#        for (@mentioned_elems) {
#            if ($ci) { $mem{lc $_}++ } else { $mem{$_}++ }
#        }
#        for (@$elems) {
#            push @$remaining_elems, $_ unless ($ci ? $mem{lc $_} : $mem{$_});
#        }
#    } else {
#        $remaining_elems = $elems;
#    }
#
#    my $cae_res = complete_array_elem(
#        %args,
#        word  => $cae_word,
#        array => $remaining_elems,
#    );
#
#    my $prefix = join($sep, @mentioned_elems);
#    $prefix .= $sep if @mentioned_elems;
#    $cae_res = [map { "$prefix$_" } @$cae_res];
#
#    {
#        last unless @$cae_res == 1;
#        last if @$remaining_elems <= 1;
#        $cae_res->[0] .= $sep;
#    }
#    $cae_res;
#}
#
#$SPEC{combine_answers} = {
#    v => 1.1,
#    summary => 'Given two or more answers, combine them into one',
#    description => <<'_',
#
#This function is useful if you want to provide a completion answer that is
#gathered from multiple sources. For example, say you are providing completion
#for the Perl tool <prog:cpanm>, which accepts a filename (a tarball like
#`*.tar.gz`), a directory, or a module name. You can do something like this:
#
#    combine_answers(
#        complete_file(word=>$word),
#        complete_module(word=>$word),
#    );
#
#But if a completion answer has a metadata `final` set to true, then that answer
#is used as the final answer without any combining with the other answers.
#
#_
#    args => {
#        answers => {
#            schema => [
#                'array*' => {
#                    of => ['any*', of=>['hash*','array*']], 
#                    min_len => 1,
#                },
#            ],
#            req => 1,
#            pos => 0,
#            greedy => 1,
#        },
#    },
#    args_as => 'array',
#    result_naked => 1,
#    result => {
#        schema => 'hash*',
#        description => <<'_',
#
#Return a combined completion answer. Words from each input answer will be
#combined, order preserved and duplicates removed. The other keys from each
#answer will be merged.
#
#_
#    },
#};
#sub combine_answers {
#    require List::Util;
#
#    return undef unless @_;
#    return $_[0] if @_ < 2;
#
#    my $final = {words=>[]};
#    my $encounter_hash;
#    my $add_words = sub {
#        my $words = shift;
#        for my $entry (@$words) {
#            push @{ $final->{words} }, $entry
#                unless List::Util::first(
#                    sub {
#                        (ref($entry) ? $entry->{word} : $entry)
#                            eq
#                                (ref($_) ? $_->{word} : $_)
#                            }, @{ $final->{words} }
#                        );
#        }
#    };
#
#  ANSWER:
#    for my $ans (@_) {
#        if (ref($ans) eq 'ARRAY') {
#            $add_words->($ans);
#        } elsif (ref($ans) eq 'HASH') {
#            $encounter_hash++;
#
#            if ($ans->{final}) {
#                $final = $ans;
#                last ANSWER;
#            }
#
#            $add_words->($ans->{words} // []);
#            for (keys %$ans) {
#                if ($_ eq 'words') {
#                    next;
#                } elsif ($_ eq 'static') {
#                    if (exists $final->{$_}) {
#                        $final->{$_} &&= $ans->{$_};
#                    } else {
#                        $final->{$_} = $ans->{$_};
#                    }
#                } else {
#                    $final->{$_} = $ans->{$_};
#                }
#            }
#        }
#    }
#
#    if ($final->{words}) {
#        $final->{words} = [
#            sort {
#                (ref($a) ? $a->{word} : $a) cmp
#                    (ref($b) ? $b->{word} : $b);
#            }
#                @{ $final->{words} }];
#    }
#
#    $encounter_hash ? $final : $final->{words};
#}
#
#$SPEC{modify_answer} = {
#    v => 1.1,
#    summary => 'Modify answer (add prefix/suffix, etc)',
#    args => {
#        answer => {
#            schema => ['any*', of=>['hash*','array*']], 
#            req => 1,
#            pos => 0,
#        },
#        suffix => {
#            schema => 'str*',
#        },
#        prefix => {
#            schema => 'str*',
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'undef',
#    },
#};
#sub modify_answer {
#    my %args = @_;
#
#    my $answer = $args{answer};
#    my $words = ref($answer) eq 'HASH' ? $answer->{words} : $answer;
#
#    if (defined(my $prefix = $args{prefix})) {
#        $_ = "$prefix$_" for @$words;
#    }
#    if (defined(my $suffix = $args{suffix})) {
#        $_ = "$_$suffix" for @$words;
#    }
#    undef;
#}
#
#$SPEC{ununiquify_answer} = {
#    v => 1.1,
#    summary => 'If answer contains only one item, make it two',
#    description => <<'_',
#
#For example, if answer is `["a"]`, then will make answer become `["a","a "]`.
#This will prevent shell from automatically adding space.
#
#_
#    args => {
#        answer => {
#            schema => ['any*', of=>['hash*','array*']], 
#            req => 1,
#            pos => 0,
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'undef',
#    },
#};
#sub ununiquify_answer {
#    my %args = @_;
#
#    my $answer = $args{answer};
#    my $words = ref($answer) eq 'HASH' ? $answer->{words} : $answer;
#
#    if (@$words == 1) {
#        push @$words, "$words->[0] ";
#    }
#    undef;
#}
#
#1;
#
#__END__
#
### Complete/Zsh.pm ###
#package Complete::Zsh;
#
#our $DATE = '2016-10-22'; 
#our $VERSION = '0.03'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       parse_cmdline
#                       format_completion
#               );
#
#require Complete::Bash;
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Completion module for zsh shell',
#};
#
#$SPEC{format_completion} = {
#    v => 1.1,
#    summary => 'Format completion for output (for shell)',
#    description => <<'_',
#
#zsh accepts completion reply in the form of one entry per line to STDOUT.
#Currently the formatting is done using `Complete::Bash`'s `format_completion`.
#
#_
#    args_as => 'array',
#    args => {
#        completion => {
#            summary => 'Completion answer structure',
#            description => <<'_',
#
#Either an array or hash, as described in `Complete`.
#
#_
#            schema=>['any*' => of => ['hash*', 'array*']],
#            req=>1,
#            pos=>0,
#        },
#    },
#    result => {
#        summary => 'Formatted string (or array, if `as` key is set to `array`)',
#        schema => ['any*' => of => ['str*', 'array*']],
#    },
#    result_naked => 1,
#};
#sub format_completion {
#    Complete::Bash::format_completion(@_);
#}
#
#1;
#
#__END__
#
### Config/IOD/Base.pm ###
#package Config::IOD::Base;
#
#our $DATE = '2019-01-17'; 
#our $VERSION = '0.342'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use constant +{
#    COL_V_ENCODING => 0, 
#    COL_V_WS1 => 1,
#    COL_V_VALUE => 2,
#    COL_V_WS2 => 3,
#    COL_V_COMMENT_CHAR => 4,
#    COL_V_COMMENT => 5,
#};
#
#sub new {
#    my ($class, %attrs) = @_;
#    $attrs{default_section} //= 'GLOBAL';
#    $attrs{allow_bang_only} //= 1;
#    $attrs{allow_duplicate_key} //= 1;
#    $attrs{enable_directive} //= 1;
#    $attrs{enable_encoding} //= 1;
#    $attrs{enable_quoting}  //= 1;
#    $attrs{enable_bracket}  //= 1;
#    $attrs{enable_brace}    //= 1;
#    $attrs{enable_tilde}    //= 1;
#    $attrs{enable_expr}     //= 0;
#    $attrs{expr_vars}       //= {};
#    $attrs{ignore_unknown_directive} //= 0;
#    bless \%attrs, $class;
#}
#
#sub _parse_command_line {
#    my ($self, $str) = @_;
#
#    $str =~ s/\A\s+//ms;
#    $str =~ s/\s+\z//ms;
#
#    my @argv;
#    my $buf;
#    my $escaped;
#    my $double_quoted;
#    my $single_quoted;
#
#    for my $char (split //, $str) {
#        if ($escaped) {
#            $buf .= $char;
#            $escaped = undef;
#            next;
#        }
#
#        if ($char eq '\\') {
#            if ($single_quoted) {
#                $buf .= $char;
#            }
#            else {
#                $escaped = 1;
#            }
#            next;
#        }
#
#        if ($char =~ /\s/) {
#            if ($single_quoted || $double_quoted) {
#                $buf .= $char;
#            }
#            else {
#                push @argv, $buf if defined $buf;
#                undef $buf;
#            }
#            next;
#        }
#
#        if ($char eq '"') {
#            if ($single_quoted) {
#                $buf .= $char;
#                next;
#            }
#            $double_quoted = !$double_quoted;
#            next;
#        }
#
#        if ($char eq "'") {
#            if ($double_quoted) {
#                $buf .= $char;
#                next;
#            }
#            $single_quoted = !$single_quoted;
#            next;
#        }
#
#        $buf .= $char;
#    }
#    push @argv, $buf if defined $buf;
#
#    if ($escaped || $single_quoted || $double_quoted) {
#        return undef;
#    }
#
#    \@argv;
#}
#
#sub _parse_raw_value {
#    my ($self, $val, $needs_res) = @_;
#
#    if ($val =~ /\A!/ && $self->{enable_encoding}) {
#
#        $val =~ s/!(\w+)(\s+)// or return ("Invalid syntax in encoded value");
#        my ($enc, $ws1) = ($1, $2);
#
#        my $res; $res = [
#            "!$enc", 
#            $ws1, 
#            $1, 
#            $2, 
#            $3, 
#            $4, 
#        ] if $needs_res;
#
#        $enc = "json" if $enc eq 'j';
#        $enc = "hex"  if $enc eq 'h';
#        $enc = "expr" if $enc eq 'e';
#
#        if ($self->{allow_encodings}) {
#            return ("Encoding '$enc' is not in ".
#                        "allow_encodings list")
#                unless grep {$_ eq $enc} @{$self->{allow_encodings}};
#        }
#        if ($self->{disallow_encodings}) {
#            return ("Encoding '$enc' is in ".
#                        "disallow_encodings list")
#                if grep {$_ eq $enc} @{$self->{disallow_encodings}};
#        }
#
#        if ($enc eq 'json') {
#
#            $val =~ /\A
#                     (".*"|\[.*\]|\{.*\}|\S+)
#                     (\s*)
#                     (?: ([;#])(.*) )?
#                     \z/x or return ("Invalid syntax in JSON-encoded value");
#            my $decode_res = $self->_decode_json($val);
#            return ($decode_res->[1]) unless $decode_res->[0] == 200;
#            return (undef, $res, $decode_res->[2]);
#
#        } elsif ($enc eq 'path' || $enc eq 'paths') {
#
#            my $decode_res = $self->_decode_path_or_paths($val, $enc);
#            return ($decode_res->[1]) unless $decode_res->[0] == 200;
#            return (undef, $res, $decode_res->[2]);
#
#        } elsif ($enc eq 'hex') {
#
#            $val =~ /\A
#                     ([0-9A-Fa-f]*)
#                     (\s*)
#                     (?: ([;#])(.*) )?
#                     \z/x or return ("Invalid syntax in hex-encoded value");
#            my $decode_res = $self->_decode_hex($1);
#            return ($decode_res->[1]) unless $decode_res->[0] == 200;
#            return (undef, $res, $decode_res->[2]);
#
#        } elsif ($enc eq 'base64') {
#
#            $val =~ m!\A
#                      ([A-Za-z0-9+/]*=*)
#                      (\s*)
#                      (?: ([;#])(.*) )?
#                      \z!x or return ("Invalid syntax in base64-encoded value");
#            my $decode_res = $self->_decode_base64($1);
#            return ($decode_res->[1]) unless $decode_res->[0] == 200;
#            return (undef, $res, $decode_res->[2]);
#
#        } elsif ($enc eq 'none') {
#
#            return (undef, $res, $val);
#
#        } elsif ($enc eq 'expr') {
#
#            return ("expr is not allowed (enable_expr=0)")
#                unless $self->{enable_expr};
#            $val =~ m!\A
#                      ((?:[^#;])+?)
#                      (\s*)
#                      (?: ([;#])(.*) )?
#                      \z!x or return ("Invalid syntax in expr-encoded value");
#            my $decode_res = $self->_decode_expr($1);
#            return ($decode_res->[1]) unless $decode_res->[0] == 200;
#            return (undef, $res, $decode_res->[2]);
#
#        } else {
#
#            return ("unknown encoding '$enc'");
#
#        }
#
#    } elsif ($val =~ /\A"/ && $self->{enable_quoting}) {
#
#        $val =~ /\A
#                 "( (?:
#                         \\\\ | # backslash
#                         \\.  | # escaped something
#                         [^"\\]+ # non-doublequote or non-backslash
#                     )* )"
#                 (\s*)
#                 (?: ([;#])(.*) )?
#                 \z/x or return ("Invalid syntax in quoted string value");
#        my $res; $res = [
#            '"', 
#            '', 
#            $1, 
#            $2, 
#            $3, 
#            $4, 
#        ] if $needs_res;
#        my $decode_res = $self->_decode_json(qq("$1"));
#        return ($decode_res->[1]) unless $decode_res->[0] == 200;
#        return (undef, $res, $decode_res->[2]);
#
#    } elsif ($val =~ /\A\[/ && $self->{enable_bracket}) {
#
#        $val =~ /\A
#                 \[(.*)\]
#                 (?:
#                     (\s*)
#                     ([#;])(.*)
#                 )?
#                 \z/x or return ("Invalid syntax in bracketed array value");
#        my $res; $res = [
#            '[', 
#            '', 
#            $1, 
#            $2, 
#            $3, 
#            $4, 
#        ] if $needs_res;
#        my $decode_res = $self->_decode_json("[$1]");
#        return ($decode_res->[1]) unless $decode_res->[0] == 200;
#        return (undef, $res, $decode_res->[2]);
#
#    } elsif ($val =~ /\A\{/ && $self->{enable_brace}) {
#
#        $val =~ /\A
#                 \{(.*)\}
#                 (?:
#                     (\s*)
#                     ([#;])(.*)
#                 )?
#                 \z/x or return ("Invalid syntax in braced hash value");
#        my $res; $res = [
#            '{', 
#            '', 
#            $1, 
#            $2, 
#            $3, 
#            $4, 
#        ] if $needs_res;
#        my $decode_res = $self->_decode_json("{$1}");
#        return ($decode_res->[1]) unless $decode_res->[0] == 200;
#        return (undef, $res, $decode_res->[2]);
#
#    } elsif ($val =~ /\A~/ && $self->{enable_tilde}) {
#
#        $val =~ /\A
#                 ~(.*)
#                 (\s*)
#                 (?: ([;#])(.*) )?
#                 \z/x or return ("Invalid syntax in path value");
#        my $res; $res = [
#            '~', 
#            '', 
#            $1, 
#            $2, 
#            $3, 
#            $4, 
#        ] if $needs_res;
#
#        my $decode_res = $self->_decode_path_or_paths($val, 'path');
#        return ($decode_res->[1]) unless $decode_res->[0] == 200;
#        return (undef, $res, $decode_res->[2]);
#
#    } else {
#
#        $val =~ /\A
#                 (.*?)
#                 (\s*)
#                 (?: ([#;])(.*) )?
#                 \z/x or return ("Invalid syntax in value"); 
#        my $res; $res = [
#            '', 
#            '', 
#            $1, 
#            $2, 
#            $3, 
#            $4, 
#        ] if $needs_res;
#        return (undef, $res, $1);
#
#    }
#}
#
#sub _get_my_user_name {
#    if ($^O eq 'MSWin32') {
#        return $ENV{USERNAME};
#    } else {
#        return $ENV{USER} if $ENV{USER};
#        my @pw;
#        eval { @pw = getpwuid($>) };
#        return $pw[0] if @pw;
#    }
#}
#
#sub _get_my_home_dir {
#    if ($^O eq 'MSWin32') {
#        return $ENV{HOME} if $ENV{HOME};
#        return $ENV{USERPROFILE} if $ENV{USERPROFILE};
#        return join($ENV{HOMEDRIVE}, "\\", $ENV{HOMEPATH})
#            if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};
#    } else {
#        return $ENV{HOME} if $ENV{HOME};
#        my @pw;
#        eval { @pw = getpwuid($>) };
#        return $pw[7] if @pw;
#    }
#
#    die "Can't get home directory";
#}
#
#sub _get_user_home_dir {
#    my ($name) = @_;
#
#    if ($^O eq 'MSWin32') {
#        return undef;
#    } else {
#        if ($name eq getpwuid($<)) {
#            return _get_my_home_dir();
#        }
#
#      SCOPE: {
#            my $home = (getpwnam($name))[7];
#            return $home if $home and -d $home;
#        }
#
#        return undef;
#    }
#
#}
#
#sub _decode_json {
#    my ($self, $val) = @_;
#    state $json = do {
#        if (eval { require Cpanel::JSON::XS; 1 }) {
#            Cpanel::JSON::XS->new->allow_nonref;
#        } else {
#            require JSON::PP;
#            JSON::PP->new->allow_nonref;
#        }
#    };
#    my $res;
#    eval { $res = $json->decode($val) };
#    if ($@) {
#        return [500, "Invalid JSON: $@"];
#    } else {
#        return [200, "OK", $res];
#    }
#}
#
#sub _decode_path_or_paths {
#    my ($self, $val, $which) = @_;
#
#    if ($val =~ m!\A~([^/]+)?(?:/|\z)!) {
#        my $home_dir = length($1) ?
#            _get_user_home_dir($1) : _get_my_home_dir();
#        unless ($home_dir) {
#            if (length $1) {
#                return [500, "Can't get home directory for user '$1' in path"];
#            } else {
#                return [500, "Can't get home directory for current user in path"];
#            }
#        }
#        $val =~ s!\A~([^/]+)?!$home_dir!;
#    }
#    $val =~ s!(?<=.)/\z!!;
#
#    if ($which eq 'path') {
#        return [200, "OK", $val];
#    } else {
#        return [200, "OK", [glob $val]];
#    }
#}
#
#sub _decode_hex {
#    my ($self, $val) = @_;
#    [200, "OK", pack("H*", $val)];
#}
#
#sub _decode_base64 {
#    my ($self, $val) = @_;
#    require MIME::Base64;
#    [200, "OK", MIME::Base64::decode_base64($val)];
#}
#
#sub _decode_expr {
#    require Config::IOD::Expr;
#
#    my ($self, $val) = @_;
#    no strict 'refs';
#    local *{"Config::IOD::Expr::_Compiled::val"} = sub {
#        my $arg = shift;
#        if ($arg =~ /(.+)\.(.+)/) {
#            return $self->{_res}{$1}{$2};
#        } else {
#            return $self->{_res}{ $self->{_cur_section} }{$arg};
#        }
#    };
#    Config::IOD::Expr::_parse_expr($val);
#}
#
#sub _err {
#    my ($self, $msg) = @_;
#    die join(
#        "",
#        @{ $self->{_include_stack} } ? "$self->{_include_stack}[0] " : "",
#        "line $self->{_linum}: ",
#        $msg
#    );
#}
#
#sub _push_include_stack {
#    require Cwd;
#
#    my ($self, $path) = @_;
#
#    if (@{ $self->{_include_stack} }) {
#        require File::Spec;
#        my ($vol, $dir, $file) =
#            File::Spec->splitpath($self->{_include_stack}[-1]);
#        $path = File::Spec->rel2abs($path, File::Spec->catpath($vol, $dir));
#    }
#
#    my $abs_path = Cwd::abs_path($path) or return [400, "Invalid path name"];
#    return [409, "Recursive", $abs_path]
#        if grep { $_ eq $abs_path } @{ $self->{_include_stack} };
#    push @{ $self->{_include_stack} }, $abs_path;
#    return [200, "OK", $abs_path];
#}
#
#sub _pop_include_stack {
#    my $self = shift;
#
#    die "BUG: Overpopped _pop_include_stack"
#        unless @{$self->{_include_stack}};
#    pop @{ $self->{_include_stack} };
#}
#
#sub _init_read {
#    my $self = shift;
#
#    $self->{_include_stack} = [];
#
#    {
#        last unless $self->{enable_expr};
#        no strict 'refs';
#        my $pkg = \%{"Config::IOD::Expr::_Compiled::"};
#        undef ${"Config::IOD::Expr::_Compiled::$_"} for keys %$pkg;
#        my $vars = $self->{expr_vars};
#        ${"Config::IOD::Expr::_Compiled::$_"} = $vars->{$_} for keys %$vars;
#    }
#}
#
#sub _read_file {
#    my ($self, $filename) = @_;
#    open my $fh, "<", $filename
#        or die "Can't open file '$filename': $!";
#    binmode($fh, ":encoding(utf8)");
#    local $/;
#    my $res = scalar <$fh>;
#    close $fh;
#    $res;
#}
#
#sub read_file {
#    my $self = shift;
#    my $filename = shift;
#    $self->_init_read;
#    my $res = $self->_push_include_stack($filename);
#    die "Can't read '$filename': $res->[1]" unless $res->[0] == 200;
#    $res =
#        $self->_read_string($self->_read_file($filename), @_);
#    $self->_pop_include_stack;
#    $res;
#}
#
#sub read_string {
#    my $self = shift;
#    $self->_init_read;
#    $self->_read_string(@_);
#}
#
#1;
#
#__END__
#
### Config/IOD/Expr.pm ###
#package Config::IOD::Expr;
#
#our $DATE = '2019-01-17'; 
#our $VERSION = '0.342'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#my $EXPR_RE = qr{
#
#(?&ANSWER)
#
#(?(DEFINE)
#
#(?<ANSWER>    (?&ADD))
#(?<ADD>       (?&MULT)   | (?&MULT)  (?: \s* ([+.-]) \s* (?&MULT)  )+)
#(?<MULT>      (?&UNARY)  | (?&UNARY) (?: \s* ([*/x%]) \s* (?&UNARY))+)
#(?<UNARY>     (?&POWER)  | [!~+-] (?&POWER))
#(?<POWER>     (?&TERM)   | (?&TERM) (?: \s* \*\* \s* (?&TERM))+)
#
#(?<TERM>
#    (?&NUM)
#  | (?&STR_SINGLE)
#  | (?&STR_DOUBLE)
#  | undef
#  | (?&VAR)
#  | (?&FUNC)
#  | \( \s* ((?&ANSWER)) \s* \)
#)
#
#(?<FUNC> val \s* \( (?&TERM) \))
#
#(?<NUM>
#    (
#     -?
#     (?: 0 | [1-9][0-9]* )
#     (?: \. [0-9]+ )?
#     (?: [eE] [-+]? [0-9]+ )?
#    )
#)
#
#(?<VAR> \$[A-Za-z_][A-Za-z0-9_]{0,63})
#
#(?<STR_SINGLE>
#    (
#     '
#     (?:
#         [^\\']+
#       |
#         \\ ['\\]
#       |
#         \\
#     )*
#     '
#    )
#)
#
#(?<STR_DOUBLE>
#    (
#     "
#     (?:
#         [^\\"]+
#       |
#         \\ ["'\\\$tnrfbae]
## octal, hex, wide hex
#     )*
#     "
#    )
#)
#
#) # DEFINE
#
#}msx;
#
#sub _parse_expr {
#    my $str = shift;
#
#    return [400, 'Not a valid expr'] unless $str =~ m{\A$EXPR_RE\z}o;
#    my $res = eval "package Config::IOD::Expr::_Compiled; no strict; no warnings; $str";
#    return [500, "Died when evaluating expr: $@"] if $@;
#    [200, "OK", $res];
#}
#
#1;
#
#__END__
#
### Config/IOD/INI/Reader.pm ###
#package Config::IOD::INI::Reader;
#
#our $DATE = '2019-01-17'; 
#our $VERSION = '0.342'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use parent qw(Config::IOD::Reader);
#
#sub new {
#    my ($class, %attrs) = @_;
#    $attrs{enable_directive} //= 0;
#    $attrs{enable_encoding}  //= 0;
#    $attrs{enable_quoting}   //= 0;
#    $attrs{enable_bracket}   //= 0;
#    $attrs{enable_brace}     //= 0;
#    $attrs{enable_tilde}     //= 0;
#    $class->SUPER::new(%attrs);
#}
#
#1;
#
#__END__
#
### Config/IOD/Reader.pm ###
#package Config::IOD::Reader;
#
#our $DATE = '2019-01-17'; 
#our $VERSION = '0.342'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use parent qw(Config::IOD::Base);
#
#sub _merge {
#    my ($self, $section) = @_;
#
#    my $res = $self->{_res};
#    for my $msect (@{ $self->{_merge} }) {
#        if ($msect eq $section) {
#            next;
#        }
#        if (!exists($res->{$msect})) {
#            local $self->{_linum} = $self->{_linum}-1;
#            $self->_err("Can't merge section '$msect' to '$section': ".
#                            "Section '$msect' not seen yet");
#        }
#        for my $k (keys %{ $res->{$msect} }) {
#            $res->{$section}{$k} //= $res->{$msect}{$k};
#        }
#    }
#}
#
#sub _init_read {
#    my $self = shift;
#
#    $self->SUPER::_init_read;
#    $self->{_res} = {};
#    $self->{_merge} = undef;
#    $self->{_num_seen_section_lines} = 0;
#    $self->{_cur_section} = $self->{default_section};
#    $self->{_arrayified} = {};
#}
#
#sub _read_string {
#    my ($self, $str, $cb) = @_;
#
#    my $res = $self->{_res};
#    my $cur_section = $self->{_cur_section};
#
#    my $directive_re = $self->{allow_bang_only} ?
#        qr/^;?\s*!\s*(\w+)\s*/ :
#        qr/^;\s*!\s*(\w+)\s*/;
#
#    my $_raw_val; 
#
#    my @lines = split /^/, $str;
#    local $self->{_linum} = 0;
#  LINE:
#    for my $line (@lines) {
#        $self->{_linum}++;
#
#        if ($line !~ /\S/) {
#            next LINE;
#        }
#
#        if ($self->{enable_directive} && $line =~ s/$directive_re//) {
#            my $directive = $1;
#            if ($self->{allow_directives}) {
#                $self->_err("Directive '$directive' is not in ".
#                                "allow_directives list")
#                    unless grep { $_ eq $directive }
#                        @{$self->{allow_directives}};
#            }
#            if ($self->{disallow_directives}) {
#                $self->_err("Directive '$directive' is in ".
#                                "disallow_directives list")
#                    if grep { $_ eq $directive }
#                        @{$self->{disallow_directives}};
#            }
#            my $args = $self->_parse_command_line($line);
#            if (!defined($args)) {
#                $self->_err("Invalid arguments syntax '$line'");
#            }
#
#            if ($cb) {
#                $cb->(
#                    event => 'directive',
#                    linum=>$self->{_linum}, line=>$line, cur_section=>$self->{_cur_section},
#                    directive => $directive,
#                    args => $args,
#                );
#            }
#
#            if ($directive eq 'include') {
#                my $path;
#                if (! @$args) {
#                    $self->_err("Missing filename to include");
#                } elsif (@$args > 1) {
#                    $self->_err("Extraneous arguments");
#                } else {
#                    $path = $args->[0];
#                }
#                my $res = $self->_push_include_stack($path);
#                if ($res->[0] != 200) {
#                    $self->_err("Can't include '$path': $res->[1]");
#                }
#                $path = $res->[2];
#                $self->_read_string($self->_read_file($path, $cb), $cb);
#                $self->_pop_include_stack;
#            } elsif ($directive eq 'merge') {
#                $self->{_merge} = @$args ? $args : undef;
#            } elsif ($directive eq 'noop') {
#            } else {
#                if ($self->{ignore_unknown_directive}) {
#                    next LINE;
#                } else {
#                    $self->_err("Unknown directive '$directive'");
#                }
#            }
#            next LINE;
#        }
#
#        if ($line =~ /^\s*[;#]/) {
#
#            if ($cb) {
#                $cb->(
#                    event => 'comment',
#                    linum=>$self->{_linum}, line=>$line, cur_section=>$self->{_cur_section},
#                );
#            }
#
#            next LINE;
#        }
#
#        if ($line =~ /^\s*\[\s*(.+?)\s*\](?: \s*[;#].*)?/) {
#            my $prev_section = $self->{_cur_section};
#            $self->{_cur_section} = $cur_section = $1;
#            $res->{$cur_section} //= {};
#            $self->{_num_seen_section_lines}++;
#
#            if ($self->{_merge} && $self->{_num_seen_section_lines} > 1) {
#                $self->_merge($prev_section);
#            }
#
#            if ($cb) {
#                $cb->(
#                    event => 'section',
#                    linum=>$self->{_linum}, line=>$line, cur_section=>$self->{_cur_section},
#                    section => $cur_section,
#                );
#            }
#
#            next LINE;
#        }
#
#        if ($line =~ /^\s*([^=]+?)\s*=\s*(.*)/) {
#            my $key = $1;
#            my $val = $2;
#
#            if ($val =~ /\A["!\\[\{~]/) {
#                $_raw_val = $val if $cb;
#                my ($err, $parse_res, $decoded_val) = $self->_parse_raw_value($val);
#                $self->_err("Invalid value: " . $err) if $err;
#                $val = $decoded_val;
#            } else {
#                $_raw_val = $val if $cb;
#                $val =~ s/\s*[#;].*//; 
#            }
#
#            if (exists $res->{$cur_section}{$key}) {
#                if (!$self->{allow_duplicate_key}) {
#                    $self->_err("Duplicate key: $key (section $cur_section)");
#                } elsif ($self->{_arrayified}{$cur_section}{$key}++) {
#                    push @{ $res->{$cur_section}{$key} }, $val;
#                } else {
#                    $res->{$cur_section}{$key} = [
#                        $res->{$cur_section}{$key}, $val];
#                }
#            } else {
#                $res->{$cur_section}{$key} = $val;
#            }
#
#            if ($cb) {
#                $cb->(
#                    event => 'key',
#                    linum=>$self->{_linum}, line=>$line, cur_section=>$self->{_cur_section},
#                    key => $key,
#                    val => $val,
#                    raw_val => $_raw_val,
#                );
#            }
#
#            next LINE;
#        }
#
#        $self->_err("Invalid syntax");
#    }
#
#    if ($self->{_merge} && $self->{_num_seen_section_lines} > 1) {
#        $self->_merge($cur_section);
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Check/Structure.pm ###
#package Data::Check::Structure;
#
#our $DATE = '2017-07-18'; 
#our $VERSION = '0.04'; 
#
#use strict;
#
#use Exporter 'import';
#our @EXPORT_OK = qw(
#                       is_aoa
#                       is_aoaos
#                       is_aoh
#                       is_aohos
#                       is_aos
#                       is_hoa
#                       is_hoaos
#                       is_hoh
#                       is_hohos
#                       is_hos
#               );
#
#sub is_aos {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'ARRAY';
#    for my $i (0..@$data-1) {
#        last if defined($max) && $i >= $max;
#        return 0 if ref($data->[$i]);
#    }
#    1;
#}
#
#sub is_aoa {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'ARRAY';
#    for my $i (0..@$data-1) {
#        last if defined($max) && $i >= $max;
#        return 0 unless ref($data->[$i]) eq 'ARRAY';
#    }
#    1;
#}
#
#sub is_aoaos {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'ARRAY';
#    my $aos_opts = {max=>$max};
#    for my $i (0..@$data-1) {
#        last if defined($max) && $i >= $max;
#        return 0 unless is_aos($data->[$i], $aos_opts);
#    }
#    1;
#}
#
#sub is_aoh {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'ARRAY';
#    for my $i (0..@$data-1) {
#        last if defined($max) && $i >= $max;
#        return 0 unless ref($data->[$i]) eq 'HASH';
#    }
#    1;
#}
#
#sub is_aohos {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'ARRAY';
#    my $hos_opts = {max=>$max};
#    for my $i (0..@$data-1) {
#        last if defined($max) && $i >= $max;
#        return 0 unless is_hos($data->[$i], $hos_opts);
#    }
#    1;
#}
#
#sub is_hos {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'HASH';
#    my $i = 0;
#    for my $k (keys %$data) {
#        last if defined($max) && ++$i >= $max;
#        return 0 if ref($data->{$k});
#    }
#    1;
#}
#
#sub is_hoa {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'HASH';
#    my $i = 0;
#    for my $k (keys %$data) {
#        last if defined($max) && ++$i >= $max;
#        return 0 unless ref($data->{$k}) eq 'ARRAY';
#    }
#    1;
#}
#
#sub is_hoaos {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'HASH';
#    my $i = 0;
#    for my $k (keys %$data) {
#        last if defined($max) && ++$i >= $max;
#        return 0 unless is_aos($data->{$k});
#    }
#    1;
#}
#
#sub is_hoh {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'HASH';
#    my $i = 0;
#    for my $k (keys %$data) {
#        last if defined($max) && ++$i >= $max;
#        return 0 unless ref($data->{$k}) eq 'HASH';
#    }
#    1;
#}
#
#sub is_hohos {
#    my ($data, $opts) = @_;
#    $opts ||= {};
#    my $max = $opts->{max};
#
#    return 0 unless ref($data) eq 'HASH';
#    my $i = 0;
#    for my $k (keys %$data) {
#        last if defined($max) && ++$i >= $max;
#        return 0 unless is_hos($data->{$k});
#    }
#    1;
#}
#
#1;
#
#__END__
#
### Data/Clean.pm ###
#package Data::Clean;
#
#our $DATE = '2018-10-14'; 
#our $VERSION = '0.502'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#sub new {
#    my ($class, %opts) = @_;
#    my $self = bless {_opts=>\%opts}, $class;
#    log_trace("Cleanser options: %s", \%opts);
#
#    my $cd = $self->_generate_cleanser_code;
#    for my $mod (keys %{ $cd->{modules} }) {
#        (my $mod_pm = "$mod.pm") =~ s!::!/!g;
#        require $mod_pm;
#    }
#    $self->{_cd} = $cd;
#    $self->{_code} = eval $cd->{src};
#    {
#        last unless $cd->{clone_func} =~ /(.+)::(.+)/;
#        (my $mod_pm = "$1.pm") =~ s!::!/!g;
#        require $mod_pm;
#    }
#    die "Can't generate code: $@" if $@;
#
#    $self;
#}
#
#sub command_call_method {
#    my ($self, $cd, $args) = @_;
#    my $mn = $args->[0];
#    die "Invalid method name syntax" unless $mn =~ /\A\w+\z/;
#    return "{{var}} = {{var}}->$mn; \$ref = ref({{var}})";
#}
#
#sub command_call_func {
#    my ($self, $cd, $args) = @_;
#    my $fn = $args->[0];
#    die "Invalid func name syntax" unless $fn =~ /\A\w+(::\w+)*\z/;
#    return "{{var}} = $fn({{var}}); \$ref = ref({{var}})";
#}
#
#sub command_one_or_zero {
#    my ($self, $cd, $args) = @_;
#    return "{{var}} = {{var}} ? 1:0; \$ref = ''";
#}
#
#sub command_deref_scalar {
#    my ($self, $cd, $args) = @_;
#    return '{{var}} = ${ {{var}} }; $ref = ref({{var}})';
#}
#
#sub command_stringify {
#    my ($self, $cd, $args) = @_;
#    return '{{var}} = "{{var}}"; $ref = ""';
#}
#
#sub command_replace_with_ref {
#    my ($self, $cd, $args) = @_;
#    return '{{var}} = $ref; $ref = ""';
#}
#
#sub command_replace_with_str {
#    require String::PerlQuote;
#
#    my ($self, $cd, $args) = @_;
#    return "{{var}} = ".String::PerlQuote::double_quote($args->[0]).'; $ref=""';
#}
#
#sub command_unbless {
#    my ($self, $cd, $args) = @_;
#
#    return join(
#        "",
#        'my $reftype = Scalar::Util::reftype({{var}}); ',
#        '{{var}} = $reftype eq "HASH" ? {%{ {{var}} }} :',
#        ' $reftype eq "ARRAY" ? [@{ {{var}} }] :',
#        ' $reftype eq "SCALAR" ? \(my $copy = ${ {{var}} }) :',
#        ' $reftype eq "CODE" ? sub { goto &{ {{var}} } } :',
#        '(die "Cannot unbless object with type $ref")',
#    );
#}
#
#sub command_clone {
#    my ($self, $cd, $args) = @_;
#
#    my $limit = $args->[0] // 1;
#    return join(
#        "",
#        "if (++\$ctr_circ <= $limit) { ",
#        "{{var}} = $cd->{clone_func}({{var}}); redo ",
#        "} else { ",
#        "{{var}} = 'CIRCULAR'; \$ref = '' }",
#    );
#}
#
#sub command_die {
#    my ($self, $cd, $args) = @_;
#    return "die";
#}
#
#sub _generate_cleanser_code {
#    my $self = shift;
#    my $opts = $self->{_opts};
#
#    my $cd = {
#        modules => {}, 
#        clone_func   => $self->{_opts}{'!clone_func'},
#        code => '',
#    };
#
#    $cd->{modules}{'Scalar::Util'} //= 0;
#
#    if (!$cd->{clone_func}) {
#        $cd->{clone_func} = 'Clone::PP::clone';
#    }
#    {
#        last unless $cd->{clone_func} =~ /(.+)::(.+)/;
#        $cd->{modules}{$1} //= 0;
#    }
#
#    my (@code, @stmts_ary, @stmts_hash, @stmts_main);
#
#    my $n = 0;
#    my $add_stmt = sub {
#        my $which = shift;
#        if ($which eq 'if' || $which eq 'new_if') {
#            my ($cond0, $act0) = @_;
#            for ([\@stmts_ary, '$e', 'ary'],
#                 [\@stmts_hash, '$h->{$k}', 'hash'],
#                 [\@stmts_main, '$_', 'main']) {
#                my $act  = $act0 ; $act  =~ s/\Q{{var}}\E/$_->[1]/g;
#                my $cond = $cond0; $cond =~ s/\Q{{var}}\E/$_->[1]/g;
#                push @{ $_->[0] }, "    ".($n && $which ne 'new_if' ? "els":"")."if ($cond) { $act }\n";
#            }
#            $n++;
#        } else {
#            my ($stmt0) = @_;
#            for ([\@stmts_ary, '$e', 'ary'],
#                 [\@stmts_hash, '$h->{$k}', 'hash'],
#                 [\@stmts_main, '$_', 'main']) {
#                my $stmt = $stmt0; $stmt =~ s/\Q{{var}}\E/$_->[1]/g;
#                push @{ $_->[0] }, "    $stmt;\n";
#            }
#        }
#    };
#    my $add_if = sub {
#        $add_stmt->('if', @_);
#    };
#    my $add_new_if = sub {
#        $add_stmt->('new_if', @_);
#    };
#    my $add_if_ref = sub {
#        my ($ref, $act0) = @_;
#        $add_if->("\$ref eq '$ref'", $act0);
#    };
#    my $add_new_if_ref = sub {
#        my ($ref, $act0) = @_;
#        $add_new_if->("\$ref eq '$ref'", $act0);
#    };
#
#    my $circ = $opts->{-circular};
#    if ($circ) {
#        my $meth = "command_$circ->[0]";
#        die "Can't handle command $circ->[0] for option '-circular'" unless $self->can($meth);
#        my @args = @$circ; shift @args;
#        my $act = $self->$meth($cd, \@args);
#        $add_new_if->('$ref && $refs{ {{var}} }++', $act);
#    }
#
#    for my $on (grep {/\A\w*(::\w+)*\z/} sort keys %$opts) {
#        my $o = $opts->{$on};
#        next unless $o;
#        my $meth = "command_$o->[0]";
#        die "Can't handle command $o->[0] for option '$on'" unless $self->can($meth);
#        my @args = @$o; shift @args;
#        my $act = $self->$meth($cd, \@args);
#        $add_if_ref->($on, $act);
#    }
#
#    for my $p ([-obj => 'Scalar::Util::blessed({{var}})']) {
#        my $o = $opts->{$p->[0]};
#        next unless $o;
#        my $meth = "command_$o->[0]";
#        die "Can't handle command $o->[0] for option '$p->[0]'" unless $self->can($meth);
#        my @args = @$o; shift @args;
#        $add_if->($p->[1], $self->$meth($cd, \@args));
#    }
#
#    if ($opts->{'!recurse_obj'}) {
#        $add_stmt->('stmt', 'my $reftype=Scalar::Util::reftype({{var}})//""');
#        $add_new_if->('$reftype eq "ARRAY"', '$process_array->({{var}})');
#        $add_if->('$reftype eq "HASH"' , '$process_hash->({{var}})');
#    } else {
#        $add_new_if_ref->("ARRAY", '$process_array->({{var}})');
#        $add_if_ref->("HASH" , '$process_hash->({{var}})');
#    }
#
#    for my $p ([-ref => '$ref']) {
#        my $o = $opts->{$p->[0]};
#        next unless $o;
#        my $meth = "command_$o->[0]";
#        die "Can't handle command $o->[0] for option '$p->[0]'" unless $self->can($meth);
#        my @args = @$o; shift @args;
#        $add_if->($p->[1], $self->$meth($cd, \@args));
#    }
#
#    push @code, 'sub {'."\n";
#    push @code, 'my $data = shift;'."\n";
#    push @code, 'state %refs;'."\n" if $circ;
#    push @code, 'state $ctr_circ;'."\n" if $circ;
#    push @code, 'state $process_array;'."\n";
#    push @code, 'state $process_hash;'."\n";
#    push @code, (
#        'if (!$process_array) { $process_array = sub { my $a = shift; for my $e (@$a) { ',
#        'my $ref=ref($e);'."\n",
#        join("", @stmts_ary).'} } }'."\n"
#    );
#    push @code, (
#        'if (!$process_hash) { $process_hash = sub { my $h = shift; for my $k (keys %$h) { ',
#        'my $ref=ref($h->{$k});'."\n",
#        join("", @stmts_hash).'} } }'."\n"
#    );
#    push @code, '%refs = (); $ctr_circ=0;'."\n" if $circ;
#    push @code, (
#        'for ($data) { ',
#        'my $ref=ref($_);'."\n",
#        join("", @stmts_main).'}'."\n"
#    );
#    push @code, '$data'."\n";
#    push @code, '}'."\n";
#
#    my $code = join("", @code).";";
#
#    if ($ENV{LOG_CLEANSER_CODE} && log_is_trace()) {
#        require String::LineNumber;
#        log_trace("Cleanser code:\n%s",
#                     $ENV{LINENUM} // 1 ?
#                         String::LineNumber::linenum($code) : $code);
#    }
#
#    $cd->{src} = $code;
#
#    $cd;
#}
#
#sub clean_in_place {
#    my ($self, $data) = @_;
#
#    $self->{_code}->($data);
#}
#
#sub clone_and_clean {
#    no strict 'refs';
#
#    my ($self, $data) = @_;
#    my $clone = &{$self->{_cd}{clone_func}}($data);
#    $self->clean_in_place($clone);
#}
#
#1;
#
#__END__
#
### Data/Clean/FromJSON.pm ###
#package Data::Clean::FromJSON;
#
#our $DATE = '2018-10-09'; 
#our $VERSION = '0.391'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use parent qw(Data::Clean);
#
#sub new {
#    my ($class, %opts) = @_;
#    $opts{"JSON::PP::Boolean"} //= ['one_or_zero'];
#    $opts{"JSON::XS::Boolean"} //= ['one_or_zero']; 
#    $opts{"Cpanel::JSON::XS::Boolean"} //= ['one_or_zero']; 
#
#    $class->SUPER::new(%opts);
#}
#
#sub get_cleanser {
#    my $class = shift;
#    state $singleton = $class->new;
#    $singleton;
#}
#
#1;
#
#__END__
#
### Data/Clean/JSON.pm ###
#package Data::Clean::JSON;
#
#our $DATE = '2018-10-09'; 
#our $VERSION = '0.391'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use parent qw(Data::Clean);
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       clean_json_in_place
#                       clone_and_clean_json
#               );
#
#sub new {
#    my ($class, %opts) = @_;
#
#    $opts{"JSON::PP::Boolean"} //= ['one_or_zero'];
#    $opts{"JSON::XS::Boolean"} //= ['one_or_zero']; 
#    $opts{"Cpanel::JSON::XS::Boolean"} //= ['one_or_zero']; 
#
#    $opts{DateTime}  //= [call_method => 'epoch'];
#    $opts{'Time::Moment'} //= [call_method => 'epoch'];
#    $opts{'Math::BigInt'} //= [call_method => 'bstr'];
#    $opts{Regexp}    //= ['stringify'];
#    $opts{version}   //= ['stringify'];
#
#    $opts{SCALAR}    //= ['deref_scalar'];
#    $opts{-ref}      //= ['replace_with_ref'];
#    $opts{-circular} //= ['clone'];
#    $opts{-obj}      //= ['unbless'];
#
#    $opts{'!recurse_obj'} //= 1;
#    $class->SUPER::new(%opts);
#}
#
#sub get_cleanser {
#    my $class = shift;
#    state $singleton = $class->new;
#    $singleton;
#}
#
#sub clean_json_in_place {
#    __PACKAGE__->get_cleanser->clean_in_place(@_);
#}
#
#sub clone_and_clean_json {
#    __PACKAGE__->get_cleanser->clone_and_clean(@_);
#}
#
#1;
#
#__END__
#
### Data/Dmp.pm ###
#package Data::Dmp;
#
#our $DATE = '2017-01-30'; 
#our $VERSION = '0.23'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Scalar::Util qw(looks_like_number blessed reftype refaddr);
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT = qw(dd dmp);
#
#our %_seen_refaddrs;
#our %_subscripts;
#our @_fixups;
#
#our $OPT_PERL_VERSION = "5.010";
#our $OPT_REMOVE_PRAGMAS = 0;
#our $OPT_DEPARSE = 1;
#our $OPT_STRINGIFY_NUMBERS = 0;
#
#my %esc = (
#    "\a" => "\\a",
#    "\b" => "\\b",
#    "\t" => "\\t",
#    "\n" => "\\n",
#    "\f" => "\\f",
#    "\r" => "\\r",
#    "\e" => "\\e",
#);
#
#sub _double_quote {
#    local($_) = $_[0];
#
#    s/([\\\"\@\$])/\\$1/g;
#    return qq("$_") unless /[^\040-\176]/;  
#
#    s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
#
#    s/([\0-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
#
#    s/([\0-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
#    s/([^\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
#
#    return qq("$_");
#}
#
#sub _dump_code {
#    my $code = shift;
#
#    state $deparse = do {
#        require B::Deparse;
#        B::Deparse->new("-l"); 
#    };
#
#    my $res = $deparse->coderef2text($code);
#
#    my ($res_before_first_line, $res_after_first_line) =
#        $res =~ /(.+?)^(#line .+)/ms;
#
#    if ($OPT_REMOVE_PRAGMAS) {
#        $res_before_first_line = "{";
#    } elsif ($OPT_PERL_VERSION < 5.016) {
#        $res_before_first_line =~ s/no feature ':all';/no feature;/m;
#    }
#    $res_after_first_line =~ s/^#line .+//gm;
#
#    $res = "sub" . $res_before_first_line . $res_after_first_line;
#    $res =~ s/^\s+//gm;
#    $res =~ s/\n+//g;
#    $res =~ s/;\}\z/}/;
#    $res;
#}
#
#sub _quote_key {
#    $_[0] =~ /\A-?[A-Za-z_][A-Za-z0-9_]*\z/ ||
#        $_[0] =~ /\A-?[1-9][0-9]{0,8}\z/ ? $_[0] : _double_quote($_[0]);
#}
#
#sub _dump {
#    my ($val, $subscript) = @_;
#
#    my $ref = ref($val);
#    if ($ref eq '') {
#        if (!defined($val)) {
#            return "undef";
#        } elsif (looks_like_number($val) && !$OPT_STRINGIFY_NUMBERS &&
#                     $val eq $val+0 &&
#                     $val !~ /\A-?(?:inf(?:inity)?|nan)\z/i
#                 ) {
#            return $val;
#        } else {
#            return _double_quote($val);
#        }
#    }
#    my $refaddr = refaddr($val);
#    $_subscripts{$refaddr} //= $subscript;
#    if ($_seen_refaddrs{$refaddr}++) {
#        push @_fixups, "\$a->$subscript=\$a",
#            ($_subscripts{$refaddr} ? "->$_subscripts{$refaddr}" : ""), ";";
#        return "'fix'";
#    }
#
#    my $class;
#
#    if ($ref eq 'Regexp' || $ref eq 'REGEXP') {
#        require Regexp::Stringify;
#        return Regexp::Stringify::stringify_regexp(
#            regexp=>$val, with_qr=>1, plver=>$OPT_PERL_VERSION);
#    }
#
#    if (blessed $val) {
#        $class = $ref;
#        $ref = reftype($val);
#    }
#
#    my $res;
#    if ($ref eq 'ARRAY') {
#        $res = "[";
#        my $i = 0;
#        for (@$val) {
#            $res .= "," if $i;
#            $res .= _dump($_, "$subscript\[$i]");
#            $i++;
#        }
#        $res .= "]";
#    } elsif ($ref eq 'HASH') {
#        $res = "{";
#        my $i = 0;
#        for (sort keys %$val) {
#            $res .= "," if $i++;
#            my $k = _quote_key($_);
#            my $v = _dump($val->{$_}, "$subscript\{$k}");
#            $res .= "$k=>$v";
#        }
#        $res .= "}";
#    } elsif ($ref eq 'SCALAR') {
#        $res = "\\"._dump($$val, $subscript);
#    } elsif ($ref eq 'REF') {
#        $res = "\\"._dump($$val, $subscript);
#    } elsif ($ref eq 'CODE') {
#        $res = $OPT_DEPARSE ? _dump_code($val) : 'sub{"DUMMY"}';
#    } else {
#        die "Sorry, I can't dump $val (ref=$ref) yet";
#    }
#
#    $res = "bless($res,"._double_quote($class).")" if defined($class);
#    $res;
#}
#
#our $_is_dd;
#sub _dd_or_dmp {
#    local %_seen_refaddrs;
#    local %_subscripts;
#    local @_fixups;
#
#    my $res;
#    if (@_ > 1) {
#        $res = "(" . join(",", map {_dump($_, '')} @_) . ")";
#    } else {
#        $res = _dump($_[0], '');
#    }
#    if (@_fixups) {
#        $res = "do{my\$a=$res;" . join("", @_fixups) . "\$a}";
#    }
#
#    if ($_is_dd) {
#        say $res;
#        return wantarray() || @_ > 1 ? @_ : $_[0];
#    } else {
#        return $res;
#    }
#}
#
#sub dd { local $_is_dd=1; _dd_or_dmp(@_) } 
#sub dmp { goto &_dd_or_dmp }
#
#1;
#
#__END__
#
### Data/Dump.pm ###
#package Data::Dump;
#
#use strict;
#use vars qw(@EXPORT @EXPORT_OK $VERSION $DEBUG);
#use subs qq(dump);
#
#require Exporter;
#*import = \&Exporter::import;
#@EXPORT = qw(dd ddx);
#@EXPORT_OK = qw(dump pp dumpf quote);
#
#$VERSION = "1.23";
#$DEBUG = 0;
#
#use overload ();
#use vars qw(%seen %refcnt @dump @fixup %require $TRY_BASE64 @FILTERS $INDENT);
#
#$TRY_BASE64 = 50 unless defined $TRY_BASE64;
#$INDENT = "  " unless defined $INDENT;
#
#sub dump
#{
#    local %seen;
#    local %refcnt;
#    local %require;
#    local @fixup;
#
#    require Data::Dump::FilterContext if @FILTERS;
#
#    my $name = "a";
#    my @dump;
#
#    for my $v (@_) {
#	my $val = _dump($v, $name, [], tied($v));
#	push(@dump, [$name, $val]);
#    } continue {
#	$name++;
#    }
#
#    my $out = "";
#    if (%require) {
#	for (sort keys %require) {
#	    $out .= "require $_;\n";
#	}
#    }
#    if (%refcnt) {
#	for (@dump) {
#	    my $name = $_->[0];
#	    if ($refcnt{$name}) {
#		$out .= "my \$$name = $_->[1];\n";
#		undef $_->[1];
#	    }
#	}
#	for (@fixup) {
#	    $out .= "$_;\n";
#	}
#    }
#
#    my $paren = (@dump != 1);
#    $out .= "(" if $paren;
#    $out .= format_list($paren, undef,
#			map {defined($_->[1]) ? $_->[1] : "\$".$_->[0]}
#			    @dump
#		       );
#    $out .= ")" if $paren;
#
#    if (%refcnt || %require) {
#	$out .= ";\n";
#	$out =~ s/^/$INDENT/gm;
#	$out = "do {\n$out}";
#    }
#
#    print STDERR "$out\n" unless defined wantarray;
#    $out;
#}
#
#*pp = \&dump;
#
#sub dd {
#    print dump(@_), "\n";
#}
#
#sub ddx {
#    my(undef, $file, $line) = caller;
#    $file =~ s,.*[\\/],,;
#    my $out = "$file:$line: " . dump(@_) . "\n";
#    $out =~ s/^/# /gm;
#    print $out;
#}
#
#sub dumpf {
#    require Data::Dump::Filtered;
#    goto &Data::Dump::Filtered::dump_filtered;
#}
#
#sub _dump
#{
#    my $ref  = ref $_[0];
#    my $rval = $ref ? $_[0] : \$_[0];
#    shift;
#
#    my($name, $idx, $dont_remember, $pclass, $pidx) = @_;
#
#    my($class, $type, $id);
#    my $strval = overload::StrVal($rval);
#    if ((my $i = rindex($strval, "=")) >= 0) {
#	$class = substr($strval, 0, $i);
#	$strval = substr($strval, $i+1);
#    }
#    if ((my $i = index($strval, "(0x")) >= 0) {
#	$type = substr($strval, 0, $i);
#	$id = substr($strval, $i + 2, -1);
#    }
#    else {
#	die "Can't parse " . overload::StrVal($rval);
#    }
#    if ($] < 5.008 && $type eq "SCALAR") {
#	$type = "REF" if $ref eq "REF";
#    }
#    warn "\$$name(@$idx) $class $type $id ($ref)" if $DEBUG;
#
#    my $out;
#    my $comment;
#    my $hide_keys;
#    if (@FILTERS) {
#	my $pself = "";
#	$pself = fullname("self", [@$idx[$pidx..(@$idx - 1)]]) if $pclass;
#	my $ctx = Data::Dump::FilterContext->new($rval, $class, $type, $ref, $pclass, $pidx, $idx);
#	my @bless;
#	for my $filter (@FILTERS) {
#	    if (my $f = $filter->($ctx, $rval)) {
#		if (my $v = $f->{object}) {
#		    local @FILTERS;
#		    $out = _dump($v, $name, $idx, 1);
#		    $dont_remember++;
#		}
#		if (defined(my $c = $f->{bless})) {
#		    push(@bless, $c);
#		}
#		if (my $c = $f->{comment}) {
#		    $comment = $c;
#		}
#		if (defined(my $c = $f->{dump})) {
#		    $out = $c;
#		    $dont_remember++;
#		}
#		if (my $h = $f->{hide_keys}) {
#		    if (ref($h) eq "ARRAY") {
#			$hide_keys = sub {
#			    for my $k (@$h) {
#				return 1 if $k eq $_[0];
#			    }
#			    return 0;
#			};
#		    }
#		}
#	    }
#	}
#	push(@bless, "") if defined($out) && !@bless;
#	if (@bless) {
#	    $class = shift(@bless);
#	    warn "More than one filter callback tried to bless object" if @bless;
#	}
#    }
#
#    unless ($dont_remember) {
#	if (my $s = $seen{$id}) {
#	    my($sname, $sidx) = @$s;
#	    $refcnt{$sname}++;
#	    my $sref = fullname($sname, $sidx,
#				($ref && $type eq "SCALAR"));
#	    warn "SEEN: [\$$name(@$idx)] => [\$$sname(@$sidx)] ($ref,$sref)" if $DEBUG;
#	    return $sref unless $sname eq $name;
#	    $refcnt{$name}++;
#	    push(@fixup, fullname($name,$idx)." = $sref");
#	    return "do{my \$fix}" if @$idx && $idx->[-1] eq '$';
#	    return "'fix'";
#	}
#	$seen{$id} = [$name, $idx];
#    }
#
#    if ($class) {
#	$pclass = $class;
#	$pidx = @$idx;
#    }
#
#    if (defined $out) {
#    }
#    elsif ($type eq "SCALAR" || $type eq "REF" || $type eq "REGEXP") {
#	if ($ref) {
#	    if ($class && $class eq "Regexp") {
#		my $v = "$rval";
#
#		my $mod = "";
#		if ($v =~ /^\(\?\^?([msix-]*):([\x00-\xFF]*)\)\z/) {
#		    $mod = $1;
#		    $v = $2;
#		    $mod =~ s/-.*//;
#		}
#
#		my $sep = '/';
#		my $sep_count = ($v =~ tr/\///);
#		if ($sep_count) {
#		    for ('|', ',', ':', '#') {
#			my $c = eval "\$v =~ tr/\Q$_\E//";
#			if ($c < $sep_count) {
#			    $sep = $_;
#			    $sep_count = $c;
#			    last if $sep_count == 0;
#			}
#		    }
#		}
#		$v =~ s/\Q$sep\E/\\$sep/g;
#
#		$out = "qr$sep$v$sep$mod";
#		undef($class);
#	    }
#	    else {
#		delete $seen{$id} if $type eq "SCALAR";  
#		my $val = _dump($$rval, $name, [@$idx, "\$"], 0, $pclass, $pidx);
#		$out = $class ? "do{\\(my \$o = $val)}" : "\\$val";
#	    }
#	} else {
#	    if (!defined $$rval) {
#		$out = "undef";
#	    }
#	    elsif (do {no warnings 'numeric'; $$rval + 0 eq $$rval}) {
#		$out = $$rval;
#	    }
#	    else {
#		$out = str($$rval);
#	    }
#	    if ($class && !@$idx) {
#		$refcnt{$name}++;
#		my $obj = fullname($name, $idx);
#		my $cl  = quote($class);
#		push(@fixup, "bless \\$obj, $cl");
#	    }
#	}
#    }
#    elsif ($type eq "GLOB") {
#	if ($ref) {
#	    delete $seen{$id};
#	    my $val = _dump($$rval, $name, [@$idx, "*"], 0, $pclass, $pidx);
#	    $out = "\\$val";
#	    if ($out =~ /^\\\*Symbol::/) {
#		$require{Symbol}++;
#		$out = "Symbol::gensym()";
#	    }
#	} else {
#	    my $val = "$$rval";
#	    $out = "$$rval";
#
#	    for my $k (qw(SCALAR ARRAY HASH)) {
#		my $gval = *$$rval{$k};
#		next unless defined $gval;
#		next if $k eq "SCALAR" && ! defined $$gval;  
#		my $f = scalar @fixup;
#		push(@fixup, "RESERVED");  
#		$gval = _dump($gval, $name, [@$idx, "*{$k}"], 0, $pclass, $pidx);
#		$refcnt{$name}++;
#		my $gname = fullname($name, $idx);
#		$fixup[$f] = "$gname = $gval";  
#	    }
#	}
#    }
#    elsif ($type eq "ARRAY") {
#	my @vals;
#	my $tied = tied_str(tied(@$rval));
#	my $i = 0;
#	for my $v (@$rval) {
#	    push(@vals, _dump($v, $name, [@$idx, "[$i]"], $tied, $pclass, $pidx));
#	    $i++;
#	}
#	$out = "[" . format_list(1, $tied, @vals) . "]";
#    }
#    elsif ($type eq "HASH") {
#	my(@keys, @vals);
#	my $tied = tied_str(tied(%$rval));
#
#	my $kstat_max = 0;
#	my $kstat_sum = 0;
#	my $kstat_sum2 = 0;
#
#	my @orig_keys = keys %$rval;
#	if ($hide_keys) {
#	    @orig_keys = grep !$hide_keys->($_), @orig_keys;
#	}
#	my $text_keys = 0;
#	for (@orig_keys) {
#	    $text_keys++, last unless /^[-+]?(?:0|[1-9]\d*)(?:\.\d+)?\z/;
#	}
#
#	if ($text_keys) {
#	    @orig_keys = sort { lc($a) cmp lc($b) } @orig_keys;
#	}
#	else {
#	    @orig_keys = sort { $a <=> $b } @orig_keys;
#	}
#
#	my $quote;
#	for my $key (@orig_keys) {
#	    next if $key =~ /^-?[a-zA-Z_]\w*\z/;
#	    next if $key =~ /^-?[1-9]\d{0,8}\z/;
#	    $quote++;
#	    last;
#	}
#
#	for my $key (@orig_keys) {
#	    my $val = \$rval->{$key};  
#	    $key = quote($key) if $quote;
#	    $kstat_max = length($key) if length($key) > $kstat_max;
#	    $kstat_sum += length($key);
#	    $kstat_sum2 += length($key)*length($key);
#
#	    push(@keys, $key);
#	    push(@vals, _dump($$val, $name, [@$idx, "{$key}"], $tied, $pclass, $pidx));
#	}
#	my $nl = "";
#	my $klen_pad = 0;
#	my $tmp = "@keys @vals";
#	if (length($tmp) > 60 || $tmp =~ /\n/ || $tied) {
#	    $nl = "\n";
#
#	    if ($kstat_max < 4) {
#		$klen_pad = $kstat_max;
#	    }
#	    elsif (@keys >= 2) {
#		my $n = @keys;
#		my $avg = $kstat_sum/$n;
#		my $stddev = sqrt(($kstat_sum2 - $n * $avg * $avg) / ($n - 1));
#
#		if ($stddev / $kstat_max < 0.25) {
#		    $klen_pad = $kstat_max;
#		}
#		if ($DEBUG) {
#		    push(@keys, "__S");
#		    push(@vals, sprintf("%.2f (%d/%.1f/%.1f)",
#					$stddev / $kstat_max,
#					$kstat_max, $avg, $stddev));
#		}
#	    }
#	}
#	$out = "{$nl";
#	$out .= "$INDENT# $tied$nl" if $tied;
#	while (@keys) {
#	    my $key = shift @keys;
#	    my $val = shift @vals;
#	    my $vpad = $INDENT . (" " x ($klen_pad ? $klen_pad + 4 : 0));
#	    $val =~ s/\n/\n$vpad/gm;
#	    my $kpad = $nl ? $INDENT : " ";
#	    $key .= " " x ($klen_pad - length($key)) if $nl && $klen_pad > length($key);
#	    $out .= "$kpad$key => $val,$nl";
#	}
#	$out =~ s/,$/ / unless $nl;
#	$out .= "}";
#    }
#    elsif ($type eq "CODE") {
#	$out = 'sub { ... }';
#    }
#    elsif ($type eq "VSTRING") {
#        $out = sprintf +($ref ? '\v%vd' : 'v%vd'), $$rval;
#    }
#    else {
#	warn "Can't handle $type data";
#	$out = "'#$type#'";
#    }
#
#    if ($class && $ref) {
#	$out = "bless($out, " . quote($class) . ")";
#    }
#    if ($comment) {
#	$comment =~ s/^/# /gm;
#	$comment .= "\n" unless $comment =~ /\n\z/;
#	$comment =~ s/^#[ \t]+\n/\n/;
#	$out = "$comment$out";
#    }
#    return $out;
#}
#
#sub tied_str {
#    my $tied = shift;
#    if ($tied) {
#	if (my $tied_ref = ref($tied)) {
#	    $tied = "tied $tied_ref";
#	}
#	else {
#	    $tied = "tied";
#	}
#    }
#    return $tied;
#}
#
#sub fullname
#{
#    my($name, $idx, $ref) = @_;
#    substr($name, 0, 0) = "\$";
#
#    my @i = @$idx;  
#    if ($ref && @i && $i[0] eq "\$") {
#	shift(@i);  
#	$ref = 0;
#    }
#    while (@i && $i[0] eq "\$") {
#	shift @i;
#	$name = "\$$name";
#    }
#
#    my $last_was_index;
#    for my $i (@i) {
#	if ($i eq "*" || $i eq "\$") {
#	    $last_was_index = 0;
#	    $name = "$i\{$name}";
#	} elsif ($i =~ s/^\*//) {
#	    $name .= $i;
#	    $last_was_index++;
#	} else {
#	    $name .= "->" unless $last_was_index++;
#	    $name .= $i;
#	}
#    }
#    $name = "\\$name" if $ref;
#    $name;
#}
#
#sub format_list
#{
#    my $paren = shift;
#    my $comment = shift;
#    my $indent_lim = $paren ? 0 : 1;
#    if (@_ > 3) {
#	my $i = 0;
#	while ($i < @_) {
#	    my $j = $i + 1;
#	    my $v = $_[$i];
#	    while ($j < @_) {
#		if ($v eq "0" || $v =~ /^-?[1-9]\d{0,9}\z/) {
#		    $v++;
#		}
#		elsif ($v =~ /^"([A-Za-z]{1,3}\d*)"\z/) {
#		    $v = $1;
#		    $v++;
#		    $v = qq("$v");
#		}
#		else {
#		    last;
#		}
#		last if $_[$j] ne $v;
#		$j++;
#	    }
#	    if ($j - $i > 3) {
#		splice(@_, $i, $j - $i, "$_[$i] .. $_[$j-1]");
#	    }
#	    $i++;
#	}
#    }
#    my $tmp = "@_";
#    if ($comment || (@_ > $indent_lim && (length($tmp) > 60 || $tmp =~ /\n/))) {
#	my @elem = @_;
#	for (@elem) { s/^/$INDENT/gm; }
#	return "\n" . ($comment ? "$INDENT# $comment\n" : "") .
#               join(",\n", @elem, "");
#    } else {
#	return join(", ", @_);
#    }
#}
#
#sub str {
#  if (length($_[0]) > 20) {
#      for ($_[0]) {
#      if (/^(.)\1\1\1/s) {
#          unless (/[^\Q$1\E]/) {
#              my $base = quote($1);
#              my $repeat = length;
#              return "($base x $repeat)"
#          }
#      }
#      if (length($_) < 16 * 1024 && /^(.{2,5}?)\1*\z/s) {
#	  my $base   = quote($1);
#	  my $repeat = length($_)/length($1);
#	  return "($base x $repeat)";
#      }
#      }
#  }
#
#  local $_ = &quote;
#
#  if (length($_) > 40  && !/\\x\{/ && length($_) > (length($_[0]) * 2)) {
#
#      if ($TRY_BASE64 && length($_[0]) > $TRY_BASE64 &&
#	  (defined &utf8::is_utf8 && !utf8::is_utf8($_[0])) &&
#	  eval { require MIME::Base64 })
#      {
#	  $require{"MIME::Base64"}++;
#	  return "MIME::Base64::decode(\"" .
#	             MIME::Base64::encode($_[0],"") .
#		 "\")";
#      }
#      return "pack(\"H*\",\"" . unpack("H*", $_[0]) . "\")";
#  }
#
#  return $_;
#}
#
#my %esc = (
#    "\a" => "\\a",
#    "\b" => "\\b",
#    "\t" => "\\t",
#    "\n" => "\\n",
#    "\f" => "\\f",
#    "\r" => "\\r",
#    "\e" => "\\e",
#);
#
#sub quote {
#  local($_) = $_[0];
#  s/([\\\"\@\$])/\\$1/g;
#  return qq("$_") unless /[^\040-\176]/;  
#
#  s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
#
#  s/([\0-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
#
#  s/([\0-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
#  s/([^\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
#
#  return qq("$_");
#}
#
#1;
#
#__END__
#
### Data/Dump/FilterContext.pm ###
#package Data::Dump::FilterContext;
#
#sub new {
#    my($class, $obj, $oclass, $type, $ref, $pclass, $pidx, $idx) = @_;
#    return bless {
#	object => $obj,
#	class => $ref && $oclass,
#	reftype => $type,
#	is_ref => $ref,
#	pclass => $pclass,
#	pidx => $pidx,
#	idx => $idx,
#    }, $class;
#}
#
#sub object_ref {
#    my $self = shift;
#    return $self->{object};
#}
#
#sub class {
#    my $self = shift;
#    return $self->{class} || "";
#}
#
#*is_blessed = \&class;
#
#sub reftype {
#    my $self = shift;
#    return $self->{reftype};
#}
#
#sub is_scalar {
#    my $self = shift;
#    return $self->{reftype} eq "SCALAR";
#}
#
#sub is_array {
#    my $self = shift;
#    return $self->{reftype} eq "ARRAY";
#}
#
#sub is_hash {
#    my $self = shift;
#    return $self->{reftype} eq "HASH";
#}
#
#sub is_code {
#    my $self = shift;
#    return $self->{reftype} eq "CODE";
#}
#
#sub is_ref {
#    my $self = shift;
#    return $self->{is_ref};
#}
#
#sub container_class {
#    my $self = shift;
#    return $self->{pclass} || "";
#}
#
#sub container_self {
#    my $self = shift;
#    return "" unless $self->{pclass};
#    my $idx = $self->{idx};
#    my $pidx = $self->{pidx};
#    return Data::Dump::fullname("self", [@$idx[$pidx..(@$idx - 1)]]);
#}
#
#sub expr {
#    my $self = shift;
#    my $top = shift || "var";
#    $top =~ s/^\$//; 
#    my $idx = $self->{idx};
#    return Data::Dump::fullname($top, $idx);
#}
#
#sub object_isa {
#    my($self, $class) = @_;
#    return $self->{class} && $self->{class}->isa($class);
#}
#
#sub container_isa {
#    my($self, $class) = @_;
#    return $self->{pclass} && $self->{pclass}->isa($class);
#}
#
#sub depth {
#    my $self = shift;
#    return scalar @{$self->{idx}};
#}
#
#1;
### Data/Dump/Filtered.pm ###
#package Data::Dump::Filtered;
#
#use Data::Dump ();
#use Carp ();
#
#use base 'Exporter';
#our @EXPORT_OK = qw(add_dump_filter remove_dump_filter dump_filtered);
#
#sub add_dump_filter {
#    my $filter = shift;
#    unless (ref($filter) eq "CODE") {
#	Carp::croak("add_dump_filter argument must be a code reference");
#    }
#    push(@Data::Dump::FILTERS, $filter);
#    return $filter;
#}
#
#sub remove_dump_filter {
#    my $filter = shift;
#    @Data::Dump::FILTERS = grep $_ ne $filter, @Data::Dump::FILTERS;
#}
#
#sub dump_filtered {
#    my $filter = pop;
#    if (defined($filter) && ref($filter) ne "CODE") {
#	Carp::croak("Last argument to dump_filtered must be undef or a code reference");
#    }
#    local @Data::Dump::FILTERS = ($filter ? $filter : ());
#    return &Data::Dump::dump;
#}
#
#1;
#
### Data/Dump/Trace.pm ###
#package Data::Dump::Trace;
#
#$VERSION = "0.02";
#
#
#use strict;
#
#use base 'Exporter';
#our @EXPORT_OK = qw(call mcall wrap autowrap trace);
#
#use Carp qw(croak);
#use overload ();
#
#my %obj_name;
#my %autowrap_class;
#my %name_count;
#
#sub autowrap {
#    while (@_) {
#        my $class = shift;
#        my $info = shift;
#        $info = { prefix => $info } unless ref($info);
#        for ($info->{prefix}) {
#            unless ($_) {
#                $_ = lc($class);
#                s/.*:://;
#            }
#            $_ = '$' . $_ unless /^\$/;
#        }
#        $autowrap_class{$class} = $info;
#    }
#}
#
#sub wrap {
#    my %arg = @_;
#    my $name = $arg{name} || "func";
#    my $func = $arg{func};
#    my $proto = $arg{proto};
#
#    return sub {
#        call($name, $func, $proto, @_);
#    } if $func;
#
#    if (my $obj = $arg{obj}) {
#        $name = '$' . $name unless $name =~ /^\$/;
#        $obj_name{overload::StrVal($obj)} = $name;
#        return bless {
#            name => $name,
#            obj => $obj,
#            proto => $arg{proto},
#        }, "Data::Dump::Trace::Wrapper";
#    }
#
#    croak("Either the 'func' or 'obj' option must be given");
#}
#
#sub trace {
#    my($symbol, $prototype) = @_;
#    no strict 'refs';
#    no warnings 'redefine';
#    *{$symbol} = wrap(name => $symbol, func => \&{$symbol}, proto => $prototype);
#}
#
#sub call {
#    my $name = shift;
#    my $func = shift;
#    my $proto = shift;
#    my $fmt = Data::Dump::Trace::Call->new($name, $proto, \@_);
#    if (!defined wantarray) {
#        $func->(@_);
#        return $fmt->return_void(\@_);
#    }
#    elsif (wantarray) {
#        return $fmt->return_list(\@_, $func->(@_));
#    }
#    else {
#        return $fmt->return_scalar(\@_, scalar $func->(@_));
#    }
#}
#
#sub mcall {
#    my $o = shift;
#    my $method = shift;
#    my $proto = shift;
#    return if $method eq "DESTROY" && !$o->can("DESTROY");
#    my $oname = ref($o) ? $obj_name{overload::StrVal($o)} || "\$o" : $o;
#    my $fmt = Data::Dump::Trace::Call->new("$oname->$method", $proto, \@_);
#    if (!defined wantarray) {
#        $o->$method(@_);
#        return $fmt->return_void(\@_);
#    }
#    elsif (wantarray) {
#        return $fmt->return_list(\@_, $o->$method(@_));
#    }
#    else {
#        return $fmt->return_scalar(\@_, scalar $o->$method(@_));
#    }
#}
#
#package Data::Dump::Trace::Wrapper;
#
#sub AUTOLOAD {
#    my $self = shift;
#    our $AUTOLOAD;
#    my $method = substr($AUTOLOAD, rindex($AUTOLOAD, '::')+2);
#    Data::Dump::Trace::mcall($self->{obj}, $method, $self->{proto}{$method}, @_);
#}
#
#package Data::Dump::Trace::Call;
#
#use Term::ANSIColor ();
#use Data::Dump ();
#
#*_dump = \&Data::Dump::dump;
#
#our %COLOR = (
#    name => "yellow",
#    output => "cyan",
#    error => "red",
#    debug => "red",
#);
#
#%COLOR = () unless -t STDOUT;
#
#sub _dumpav {
#    return "(" . _dump(@_) . ")" if @_ == 1;
#    return _dump(@_);
#}
#
#sub _dumpkv {
#    return _dumpav(@_) if @_ % 2;
#    my %h = @_;
#    my $str = _dump(\%h);
#    $str =~ s/^\{/(/ && $str =~ s/\}\z/)/;
#    return $str;
#}
#
#sub new {
#    my($class, $name, $proto, $input_args) = @_;
#    my $self = bless {
#        name => $name,
#        proto => $proto,
#    }, $class;
#    my $proto_arg = $self->proto_arg;
#    if ($proto_arg =~ /o/) {
#        for (@$input_args) {
#            push(@{$self->{input_av}}, _dump($_));
#        }
#    }
#    else {
#        $self->{input} = $proto_arg eq "%" ? _dumpkv(@$input_args) : _dumpav(@$input_args);
#    }
#    return $self;
#}
#
#sub proto_arg {
#    my $self = shift;
#    my($arg, $ret) = split(/\s*=\s*/, $self->{proto} || "");
#    $arg ||= '@';
#    return $arg;
#}
#
#sub proto_ret {
#    my $self = shift;
#    my($arg, $ret) = split(/\s*=\s*/, $self->{proto} || "");
#    $ret ||= '@';
#    return $ret;
#}
#
#sub color {
#    my($self, $category, $text) = @_;
#    return $text unless $COLOR{$category};
#    return Term::ANSIColor::colored($text, $COLOR{$category});
#}
#
#sub print_call {
#    my $self = shift;
#    my $outarg = shift;
#    print $self->color("name", "$self->{name}");
#    if (my $input = $self->{input}) {
#        $input = "" if $input eq "()" && $self->{name} =~ /->/;
#        print $self->color("input", $input);
#    }
#    else {
#        my $proto_arg = $self->proto_arg;
#        print "(";
#        my $i = 0;
#        for (@{$self->{input_av}}) {
#            print ", " if $i;
#            my $proto = substr($proto_arg, 0, 1, "");
#            if ($proto ne "o") {
#                print $self->color("input", $_);
#            }
#            if ($proto eq "o" || $proto eq "O") {
#                print " = " if $proto eq "O";
#                print $self->color("output", _dump($outarg->[$i]));
#            }
#        }
#        continue {
#            $i++;
#        }
#        print ")";
#    }
#}
#
#sub return_void {
#    my $self = shift;
#    my $arg = shift;
#    $self->print_call($arg);
#    print "\n";
#    return;
#}
#
#sub return_scalar {
#    my $self = shift;
#    my $arg = shift;
#    $self->print_call($arg);
#    my $s = shift;
#    my $name;
#    my $proto_ret = $self->proto_ret;
#    my $wrap = $autowrap_class{ref($s)};
#    if ($proto_ret =~ /^\$\w+\z/ && ref($s) && ref($s) !~ /^(?:ARRAY|HASH|CODE|GLOB)\z/) {
#        $name = $proto_ret;
#    }
#    else {
#        $name = $wrap->{prefix} if $wrap;
#    }
#    if ($name) {
#        $name .= $name_count{$name} if $name_count{$name}++;
#        print " = ", $self->color("output", $name), "\n";
#        $s = Data::Dump::Trace::wrap(name => $name, obj => $s, proto => $wrap->{proto});
#    }
#    else {
#        print " = ", $self->color("output", _dump($s));
#        if (!$s && $proto_ret =~ /!/ && $!) {
#            print " ", $self->color("error", errno($!));
#        }
#        print "\n";
#    }
#    return $s;
#}
#
#sub return_list {
#    my $self = shift;
#    my $arg = shift;
#    $self->print_call($arg);
#    print " = ", $self->color("output", $self->proto_ret eq "%" ? _dumpkv(@_) : _dumpav(@_)), "\n";
#    return @_;
#}
#
#sub errno {
#    my $t = "";
#    for (keys %!) {
#        if ($!{$_}) {
#            $t = $_;
#            last;
#        }
#    }
#    my $n = int($!);
#    return "$t($n) $!";
#}
#
#1;
#
#__END__
#
### Data/ModeMerge.pm ###
#package Data::ModeMerge;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT = qw(mode_merge);
#
#sub mode_merge {
#    my ($l, $r, $config_vars) = @_;
#    my $mm = __PACKAGE__->new(config => $config_vars);
#    $mm->merge($l, $r);
#}
#
#has config => (is => "rw");
#
#has modes => (is => 'rw', default => sub { {} });
#
#has combine_rules => (is => 'rw');
#
#has path => (is => "rw", default => sub { [] });
#has errors => (is => "rw", default => sub { [] });
#has mem => (is => "rw", default => sub { {} }); 
#has cur_mem_key => (is => "rw"); 
#
#sub _in($$) {
#    state $load_dmp = do { require Data::Dmp };
#    my ($self, $needle, $haystack) = @_;
#    return 0 unless defined($needle);
#    my $r1 = ref($needle);
#    my $f1 = $r1 ? Data::Dmp::dmp($needle) : undef;
#    for (@$haystack) {
#        my $r2 = ref($_);
#        next if $r1 xor $r2;
#        return 1 if  $r2 && $f1 eq Data::Dmp::dmp($_);
#        return 1 if !$r2 && $needle eq $_;
#    }
#    0;
#}
#
#sub BUILD {
#    require Data::ModeMerge::Config;
#
#    my ($self, $args) = @_;
#
#    if ($self->config) {
#        my $is_hashref = ref($self->config) eq 'HASH';
#        die "config must be a hashref or a Data::ModeMerge::Config" unless
#            $is_hashref || UNIVERSAL::isa($self->config, "Data::ModeMerge::Config");
#        $self->config(Data::ModeMerge::Config->new(%{ $self->config })) if $is_hashref;
#    } else {
#        $self->config(Data::ModeMerge::Config->new);
#    }
#
#    for (qw(NORMAL KEEP ADD CONCAT SUBTRACT DELETE)) {
#	$self->register_mode($_);
#    }
#
#    if (!$self->combine_rules) {
#        $self->combine_rules({
#            'ADD+ADD'            => ['ADD'     , 'ADD'   ],
#            'ADD+DELETE'         => ['DELETE'  , 'DELETE'],
#            'ADD+NORMAL'         => ['NORMAL'  , 'NORMAL'],
#            'ADD+SUBTRACT'       => ['SUBTRACT', 'ADD'   ],
#
#            'CONCAT+CONCAT'      => ['CONCAT'  , 'CONCAT'],
#            'CONCAT+DELETE'      => ['DELETE'  , 'DELETE'],
#            'CONCAT+NORMAL'      => ['NORMAL'  , 'NORMAL'],
#
#            'DELETE+ADD'         => ['NORMAL'  , 'ADD'     ],
#            'DELETE+CONCAT'      => ['NORMAL'  , 'CONCAT'  ],
#            'DELETE+DELETE'      => ['DELETE'  , 'DELETE'  ],
#            'DELETE+KEEP'        => ['NORMAL'  , 'KEEP'    ],
#            'DELETE+NORMAL'      => ['NORMAL'  , 'NORMAL'  ],
#            'DELETE+SUBTRACT'    => ['NORMAL'  , 'SUBTRACT'],
#
#            'KEEP+ADD'          => ['KEEP', 'KEEP'],
#            'KEEP+CONCAT'       => ['KEEP', 'KEEP'],
#            'KEEP+DELETE'       => ['KEEP', 'KEEP'],
#            'KEEP+KEEP'         => ['KEEP', 'KEEP'],
#            'KEEP+NORMAL'       => ['KEEP', 'KEEP'],
#            'KEEP+SUBTRACT'     => ['KEEP', 'KEEP'],
#
#            'NORMAL+ADD'        => ['ADD'     , 'NORMAL'],
#            'NORMAL+CONCAT'     => ['CONCAT'  , 'NORMAL'],
#            'NORMAL+DELETE'     => ['DELETE'  , 'NORMAL'],
#            'NORMAL+KEEP'       => ['NORMAL'  , 'KEEP'  ],
#            'NORMAL+NORMAL'     => ['NORMAL'  , 'NORMAL'],
#            'NORMAL+SUBTRACT'   => ['SUBTRACT', 'NORMAL'],
#
#            'SUBTRACT+ADD'      => ['SUBTRACT', 'SUBTRACT'],
#            'SUBTRACT+DELETE'   => ['DELETE'  , 'DELETE'  ],
#            'SUBTRACT+NORMAL'   => ['NORMAL'  , 'NORMAL'  ],
#            'SUBTRACT+SUBTRACT' => ['ADD'     , 'SUBTRACT'],
#        });
#    }
#}
#
#sub push_error {
#    my ($self, $errmsg) = @_;
#    push @{ $self->errors }, [[@{ $self->path }], $errmsg];
#    return;
#}
#
#sub register_mode {
#    my ($self, $name0) = @_;
#    my $obj;
#    if (ref($name0)) {
#        my $obj = $name0;
#    } elsif ($name0 =~ /^\w+(::\w+)+$/) {
#        eval "require $name0; \$obj = $name0->new";
#        die "Can't load module $name0: $@" if $@;
#    } elsif ($name0 =~ /^\w+$/) {
#        my $modname = "Data::ModeMerge::Mode::$name0";
#        eval "require $modname; \$obj = $modname->new";
#        die "Can't load module $modname: $@" if $@;
#    } else {
#        die "Invalid mode name $name0";
#    }
#    my $name = $obj->name;
#    die "Mode $name already registered" if $self->modes->{$name};
#    $obj->merger($self);
#    $self->modes->{$name} = $obj;
#}
#
#sub check_prefix {
#    my ($self, $hash_key) = @_;
#    die "Hash key not a string" if ref($hash_key);
#    my $dis = $self->config->disable_modes;
#    if (defined($dis) && ref($dis) ne 'ARRAY') {
#        $self->push_error("Invalid config value `disable_modes`: must be an array");
#        return;
#    }
#    for my $mh (sort { $b->precedence_level <=> $a->precedence_level }
#                grep { !$dis || !$self->_in($_->name, $dis) }
#                values %{ $self->modes }) {
#        if ($mh->check_prefix($hash_key)) {
#            return $mh->name;
#        }
#    }
#    return;
#}
#
#sub check_prefix_on_hash {
#    my ($self, $hash) = @_;
#    die "Not a hash" unless ref($hash) eq 'HASH';
#    my $res = 0;
#    for (keys %$hash) {
#	do { $res++; last } if $self->check_prefix($_);
#    }
#    $res;
#}
#
#sub add_prefix {
#    my ($self, $hash_key, $mode) = @_;
#    die "Hash key not a string" if ref($hash_key);
#    my $dis = $self->config->disable_modes;
#    if (defined($dis) && ref($dis) ne 'ARRAY') {
#        die "Invalid config value `disable_modes`: must be an array";
#    }
#    if ($dis && $self->_in($mode, $dis)) {
#        $self->push_error("Can't add prefix for currently disabled mode `$mode`");
#        return $hash_key;
#    }
#    my $mh = $self->modes->{$mode} or die "Unknown mode: $mode";
#    $mh->add_prefix($hash_key);
#}
#
#sub remove_prefix {
#    my ($self, $hash_key) = @_;
#    die "Hash key not a string" if ref($hash_key);
#    my $dis = $self->config->disable_modes;
#    if (defined($dis) && ref($dis) ne 'ARRAY') {
#        die "Invalid config value `disable_modes`: must be an array";
#    }
#    for my $mh (sort { $b->precedence_level <=> $a->precedence_level }
#                grep { !$dis || !$self->_in($_->name, $dis) }
#                values %{ $self->modes }) {
#        if ($mh->check_prefix($hash_key)) {
#            my $r = $mh->remove_prefix($hash_key);
#            if (wantarray) { return ($r, $mh->name) }
#            else           { return $r }
#        }
#    }
#    if (wantarray) { return ($hash_key, $self->config->default_mode) }
#    else           { return $hash_key }
#}
#
#sub remove_prefix_on_hash {
#    my ($self, $hash) = @_;
#    die "Not a hash" unless ref($hash) eq 'HASH';
#    for (keys %$hash) {
#	my $old = $_;
#	$_ = $self->remove_prefix($_);
#	next unless $old ne $_;
#	die "Conflict when removing prefix on hash: $old -> $_ but $_ already exists"
#	    if exists $hash->{$_};
#	$hash->{$_} = $hash->{$old};
#	delete $hash->{$old};
#    }
#    $hash;
#}
#
#sub merge {
#    my ($self, $l, $r) = @_;
#    $self->path([]);
#    $self->errors([]);
#    $self->mem({});
#    $self->cur_mem_key(undef);
#    my ($key, $res, $backup) = $self->_merge(undef, $l, $r);
#    {
#        success => !@{ $self->errors },
#        error   => (@{ $self->errors } ?
#                    join(", ",
#                         map { sprintf("/%s: %s", join("/", @{ $_->[0] }), $_->[1]) }
#                             @{ $self->errors }) : ''),
#        result  => $res,
#        backup  => $backup,
#    };
#}
#
#sub _process_todo {
#    my ($self) = @_;
#    if ($self->cur_mem_key) {
#        for my $mk (keys %{ $self->mem }) {
#            my $res = $self->mem->{$mk}{res};
#            if (defined($res) && @{ $self->mem->{$mk}{todo} }) {
#                for (@{  $self->mem->{$mk}{todo} }) {
#                    $_->(@$res);
#                    return if @{ $self->errors };
#                }
#                $self->mem->{$mk}{todo} = [];
#            }
#        }
#    }
#}
#
#sub _merge {
#    my ($self, $key, $l, $r, $mode) = @_;
#    my $c = $self->config;
#    $mode //= $c->default_mode;
#
#    my $mh = $self->modes->{$mode};
#    die "Can't find handler for mode $mode" unless $mh;
#
#    my $rl = ref($l);
#    my $rr = ref($r);
#    my $tl = $rl eq 'HASH' ? 'HASH' : $rl eq 'ARRAY' ? 'ARRAY' : $rl eq 'CODE' ? 'CODE' : !$rl ? 'SCALAR' : '';
#    my $tr = $rr eq 'HASH' ? 'HASH' : $rr eq 'ARRAY' ? 'ARRAY' : $rr eq 'CODE' ? 'CODE' : !$rr ? 'SCALAR' : '';
#    if (!$tl) { $self->push_error("Unknown type in left side: $rl"); return }
#    if (!$tr) { $self->push_error("Unknown type in right side: $rr"); return }
#    if (!$c->allow_create_array && $tl ne 'ARRAY' && $tr eq 'ARRAY') {
#        $self->push_error("Not allowed to create array"); return;
#    }
#    if (!$c->allow_create_hash && $tl ne 'HASH' && $tr eq 'HASH') {
#        $self->push_error("Not allowed to create hash"); return;
#    }
#    if (!$c->allow_destroy_array && $tl eq 'ARRAY' && $tr ne 'ARRAY') {
#        $self->push_error("Not allowed to destroy array"); return;
#    }
#    if (!$c->allow_destroy_hash && $tl eq 'HASH' && $tr ne 'HASH') {
#        $self->push_error("Not allowed to destroy hash"); return;
#    }
#    my $meth = "merge_${tl}_${tr}";
#    if (!$mh->can($meth)) { $self->push_error("No merge method found for $tl + $tr (mode $mode)"); return }
#
#    my $memkey;
#    if ($rl || $rr) {
#        $memkey = sprintf "%s%s %s%s %s %s",
#            (defined($l) ? ($rl ? 2 : 1) : 0),
#            (defined($l) ? "$l" : ''),
#            (defined($r) ? ($rr ? 2 : 1) : 0),
#            (defined($r) ? "$r" : ''),
#            $mode,
#            $self->config;
#    }
#    if ($memkey) {
#        if (exists $self->mem->{$memkey}) {
#            $self->_process_todo;
#            if (defined $self->mem->{$memkey}{res}) {
#                return @{ $self->mem->{$memkey}{res} };
#            } else {
#                return ($key, undef, undef, 1);
#            }
#        } else {
#            $self->mem->{$memkey} = {res=>undef, todo=>[]};
#            $self->cur_mem_key($memkey);
#            my ($newkey, $res, $backup) = $mh->$meth($key, $l, $r);
#            $self->mem->{$memkey}{res} = [$newkey, $res, $backup];
#            $self->_process_todo;
#            return ($newkey, $res, $backup);
#        }
#    } else {
#        $self->_process_todo;
#        return $mh->$meth($key, $l, $r);
#    }
#}
#
#sub _path_is_included {
#    my ($self, $p1, $p2) = @_;
#    my $res = 1;
#    for my $i (0..@$p1-1) {
#        do { $res = 0; last } if !defined($p2->[$i]) || $p1->[$i] ne $p2->[$i];
#    }
#    $res;
#}
#
#1;
#
#__END__
#
### Data/ModeMerge/Config.pm ###
#package Data::ModeMerge::Config;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use Mo qw(build default);
#
#has recurse_hash          => (is => 'rw', default => sub{1});
#has recurse_array         => (is => 'rw', default => sub{0});
#has parse_prefix          => (is => 'rw', default => sub{1});
#has wanted_path           => (is => 'rw');
#has default_mode          => (is => 'rw', default => sub{'NORMAL'});
#has disable_modes         => (is => 'rw');
#has allow_create_array    => (is => 'rw', default => sub{1});
#has allow_create_hash     => (is => 'rw', default => sub{1});
#has allow_destroy_array   => (is => 'rw', default => sub{1});
#has allow_destroy_hash    => (is => 'rw', default => sub{1});
#has exclude_parse         => (is => 'rw');
#has exclude_parse_regex   => (is => 'rw');
#has include_parse         => (is => 'rw');
#has include_parse_regex   => (is => 'rw');
#has exclude_merge         => (is => 'rw');
#has exclude_merge_regex   => (is => 'rw');
#has include_merge         => (is => 'rw');
#has include_merge_regex   => (is => 'rw');
#has set_prefix            => (is => 'rw');
#has readd_prefix          => (is => 'rw', default => sub{1});
#has premerge_pair_filter  => (is => 'rw');
#has options_key           => (is => 'rw', default => sub{''});
#has allow_override        => (is => 'rw');
#has disallow_override     => (is => 'rw');
#
#sub _config_config {
#    state $a = [qw/
#        wanted_path
#        options_key
#        allow_override
#        disallow_override
#                  /];
#}
#
#sub _config_ok {
#    state $a = [qw/
#        recurse_hash
#        recurse_array
#        parse_prefix
#        default_mode
#        disable_modes
#        allow_create_array
#        allow_create_hash
#        allow_destroy_array
#        allow_destroy_hash
#        exclude_parse
#        exclude_parse_regex
#        include_parse
#        include_parse_regex
#        exclude_merge
#        exclude_merge_regex
#        include_merge
#        include_merge_regex
#        set_prefix
#        readd_prefix
#        premerge_pair_filter
#                  /];
#}
#
#1;
#
#__END__
#
### Data/ModeMerge/Mode/ADD.pm ###
#package Data::ModeMerge::Mode::ADD;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Mo qw(build default);
#extends 'Data::ModeMerge::Mode::NORMAL';
#
#sub name { 'ADD' }
#
#sub precedence_level { 3 }
#
#sub default_prefix { '+' }
#
#sub default_prefix_re { qr/^\+/ }
#
#sub merge_SCALAR_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, ( $l // 0 ) + $r);
#}
#
#sub merge_SCALAR_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't add scalar and array");
#    return;
#}
#
#sub merge_SCALAR_HASH {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't add scalar and hash");
#    return;
#}
#
#sub merge_ARRAY_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't add array and scalar");
#    return;
#}
#
#sub merge_ARRAY_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    ($key, [ @$l, @$r ]);
#}
#
#sub merge_ARRAY_HASH {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't add array and hash");
#    return;
#}
#
#sub merge_HASH_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't add hash and scalar");
#    return;
#}
#
#sub merge_HASH_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't add hash and array");
#    return;
#}
#
#1;
#
#__END__
#
### Data/ModeMerge/Mode/Base.pm ###
#package Data::ModeMerge::Mode::Base;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#
#use Mo qw(build default);
#
#
#has merger => (is => 'rw');
#has prefix => (is => 'rw');
#has prefix_re => (is => 'rw');
#has check_prefix_sub => (is => 'rw');
#has add_prefix_sub => (is => 'rw');
#has remove_prefix_sub => (is => 'rw');
#
#sub name {
#    die "Subclass must provide name()";
#}
#
#sub precedence_level {
#    die "Subclass must provide precedence_level()";
#}
#
#sub default_prefix {
#    die "Subclass must provide default_prefix()";
#}
#
#sub default_prefix_re {
#    die "Subclass must provide default_prefix_re()";
#}
#
#sub BUILD {
#    my ($self) = @_;
#    $self->prefix($self->default_prefix);
#    $self->prefix_re($self->default_prefix_re);
#}
#
#sub check_prefix {
#    my ($self, $hash_key) = @_;
#    if ($self->check_prefix_sub) {
#        $self->check_prefix_sub->($hash_key);
#    } else {
#        $hash_key =~ $self->prefix_re;
#    }
#}
#
#sub add_prefix {
#    my ($self, $hash_key) = @_;
#    if ($self->add_prefix_sub) {
#        $self->add_prefix_sub->($hash_key);
#    } else {
#        $self->prefix . $hash_key;
#    }
#}
#
#sub remove_prefix {
#    my ($self, $hash_key) = @_;
#    if ($self->remove_prefix_sub) {
#        $self->remove_prefix_sub->($hash_key);
#    } else {
#        my $re = $self->prefix_re;
#        $hash_key =~ s/$re//;
#        $hash_key;
#    }
#}
#
#sub merge_ARRAY_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    my $mm = $self->merger;
#    my $c = $mm->config;
#    return $self->merge_SCALAR_SCALAR($key, $l, $r) unless $c->recurse_array;
#    return if $c->wanted_path && !$mm->_path_is_included($mm->path, $c->wanted_path);
#
#    my @res;
#    my @backup;
#    my $la = @$l;
#    my $lb = @$r;
#    push @{ $mm->path }, -1;
#    for my $i (0..($la > $lb ? $la : $lb)-1) {
#        $mm->path->[-1] = $i;
#        if ($i < $la && $i < $lb) {
#            push @backup, $l->[$i];
#            my ($subnewkey, $subres, $subbackup, $is_circular) = $mm->_merge($i, $l->[$i], $r->[$i], $c->default_mode);
#            last if @{ $mm->errors };
#            if ($is_circular) {
#                push @res, undef;
#                push @{ $mm->mem->{ $mm->cur_mem_key }{todo} }, sub {
#                    my ($subnewkey, $subres, $subbackup) = @_;
#                    $res[$i] = $subres;
#                }
#            } else {
#                push @res, $subres;
#            }
#        } elsif ($i < $la) {
#            push @res, $l->[$i];
#        } else {
#            push @res, $r->[$i];
#        }
#    }
#    pop @{ $mm->path };
#    ($key, \@res, \@backup);
#}
#
#sub _prefilter_hash {
#    my ($self, $h, $desc, $sub) = @_;
#    my $mm = $self->merger;
#
#    if (ref($sub) ne 'CODE') {
#        $mm->push_error("$desc failed: filter must be a coderef");
#        return;
#    }
#
#    my $res = {};
#    for (keys %$h) {
#        my @r = $sub->($_, $h->{$_});
#        while (my ($k, $v) = splice @r, 0, 2) {
#            next unless defined $k;
#            if (exists $res->{$k}) {
#                $mm->push_error("$desc failed; key conflict: ".
#                                "$_ -> $k, but key $k already exists");
#                return;
#            }
#            $res->{$k} = $v;
#        }
#    }
#
#    $res;
#}
#
#sub _gen_left {
#    my ($self, $l, $mode, $esub, $ep, $ip, $epr, $ipr) = @_;
#    my $mm = $self->merger;
#    my $c = $mm->config;
#
#
#    if ($c->premerge_pair_filter) {
#        $l = $self->_prefilter_hash($l, "premerge filter left hash",
#                                    $c->premerge_pair_filter);
#        return if @{ $mm->errors };
#    }
#
#    my $hl = {};
#    if ($c->parse_prefix) {
#        for (keys %$l) {
#            my $do_parse = 1;
#            $do_parse = 0 if $do_parse && $ep  &&  $mm->_in($_, $ep);
#            $do_parse = 0 if $do_parse && $ip  && !$mm->_in($_, $ip);
#            $do_parse = 0 if $do_parse && $epr &&  /$epr/;
#            $do_parse = 0 if $do_parse && $ipr && !/$ipr/;
#
#            if ($do_parse) {
#                my $old = $_;
#                my $m2;
#                ($_, $m2) = $mm->remove_prefix($_);
#                next if $esub && !$esub->($_);
#                if ($old ne $_ && exists($l->{$_})) {
#                    $mm->push_error("Conflict when removing prefix on left-side ".
#                                    "hash key: $old -> $_ but $_ already exists");
#                    return;
#                }
#                $hl->{$_} = [$m2, $l->{$old}];
#            } else {
#                next if $esub && !$esub->($_);
#                $hl->{$_} = [$mode, $l->{$_}];
#            }
#        }
#    } else {
#        for (keys %$l) {
#            next if $esub && !$esub->($_);
#            $hl->{$_} = [$mode, $l->{$_}];
#        }
#    }
#
#    $hl;
#}
#
#sub _gen_right {
#    my ($self, $r, $mode, $esub, $ep, $ip, $epr, $ipr) = @_;
#    my $mm = $self->merger;
#    my $c = $mm->config;
#
#
#    if ($c->premerge_pair_filter) {
#        $r = $self->_prefilter_hash($r, "premerge filter right hash",
#                                    $c->premerge_pair_filter);
#        return if @{ $mm->errors };
#    }
#
#    my $hr = {};
#    if ($c->parse_prefix) {
#        for (keys %$r) {
#            my $do_parse = 1;
#            $do_parse = 0 if $do_parse && $ep  &&  $mm->_in($_, $ep);
#            $do_parse = 0 if $do_parse && $ip  && !$mm->_in($_, $ip);
#            $do_parse = 0 if $do_parse && $epr &&  /$epr/;
#            $do_parse = 0 if $do_parse && $ipr && !/$ipr/;
#
#            if ($do_parse) {
#                my $old = $_;
#                my $m2;
#                ($_, $m2) = $mm->remove_prefix($_);
#                next if $esub && !$esub->($_);
#                if (exists $hr->{$_}{$m2}) {
#                    $mm->push_error("Conflict when removing prefix on right-side ".
#                                    "hash key: $old($m2) -> $_ ($m2) but $_ ($m2) ".
#                                    "already exists");
#                    return;
#                }
#                $hr->{$_}{$m2} = $r->{$old};
#            } else {
#                next if $esub && !$esub->($_);
#                $hr->{$_} = {$mode => $r->{$_}};
#            }
#        }
#    } else {
#        for (keys %$r) {
#            next if $esub && !$esub->($_);
#            $hr->{$_} = {$mode => $r->{$_}}
#        }
#    }
#    $hr;
#}
#
#sub _merge_gen {
#    my ($self, $hl, $hr, $mode, $em, $im, $emr, $imr) = @_;
#    my $mm = $self->merger;
#    my $c = $mm->config;
#
#
#    my $res = {};
#    my $backup = {};
#
#    my %k = map {$_=>1} keys(%$hl), keys(%$hr);
#    push @{ $mm->path }, "";
#  K:
#    for my $k (keys %k) {
#        my @o;
#        $mm->path->[-1] = $k;
#        my $do_merge = 1;
#        $do_merge = 0 if $do_merge && $em  &&  $mm->_in($k, $em);
#        $do_merge = 0 if $do_merge && $im  && !$mm->_in($k, $im);
#        $do_merge = 0 if $do_merge && $emr && $k =~ /$emr/;
#        $do_merge = 0 if $do_merge && $imr && $k !~ /$imr/;
#
#        if (!$do_merge) {
#            $res->{$k} = $hl->{$k} if $hl->{$k};
#            next K;
#        }
#
#        $backup->{$k} = $hl->{$k}[1] if $hl->{$k} && $hr->{$k};
#        if ($hl->{$k}) {
#            push @o, $hl->{$k};
#        }
#        if ($hr->{$k}) {
#            my %m = map {$_=>$mm->modes->{$_}->precedence_level} keys %{ $hr->{$k} };
#            push @o, map { [$_, $hr->{$k}{$_}] } sort { $m{$b} <=> $m{$a} } keys %m;
#        }
#        my $final_mode;
#        my $is_circular;
#        my $v;
#        for my $i (0..$#o) {
#            if ($i == 0) {
#                my $mh = $mm->modes->{$o[$i][0]};
#                if (@o == 1 &&
#                        (($hl->{$k} && $mh->can("merge_left_only")) ||
#                         ($hr->{$k} && $mh->can("merge_right_only")))) {
#                    my $meth = $hl->{$k} ? "merge_left_only" : "merge_right_only";
#                    my ($subnewkey, $v, $subbackup, $is_circular, $newmode) = $mh->$meth($k, $o[$i][1]); 
#                    next K unless defined($subnewkey);
#                    $final_mode = $newmode;
#                    $v = $res;
#                } else {
#                    $final_mode = $o[$i][0];
#                    $v = $o[$i][1];
#                }
#            } else {
#                my $m = $mm->combine_rules->{"$final_mode+$o[$i][0]"}
#                    or do {
#                        $mm->push_error("Can't merge $final_mode + $o[$i][0]");
#                        return;
#                    };
#                my ($subnewkey, $subbackup);
#                ($subnewkey, $v, $subbackup, $is_circular) = $mm->_merge($k, $v, $o[$i][1], $m->[0]);
#                return if @{ $mm->errors };
#                if ($is_circular) {
#                    if ($i < $#o) {
#                        $mm->push_error("Can't handle circular at $i of $#o merges (mode $m->[0]): not the last merge");
#                        return;
#                    }
#                    push @{ $mm->mem->{ $mm->cur_mem_key }{todo} }, sub {
#                        my ($subnewkey, $subres, $subbackup) = @_;
#                        my $final_mode = $m->[1];
#                        $res->{$k} = [$m->[1], $subres];
#                        if ($c->readd_prefix) {
#                            $self->_readd_prefix($res, $k, $c->default_mode);
#                        } else {
#                            $res->{$k} = $res->{$k}[1];
#                        }
#                    };
#                    delete $res->{$k};
#                }
#                next K unless defined $subnewkey;
#                $final_mode = $m->[1];
#            }
#        }
#        $res->{$k} = [$final_mode, $v] unless $is_circular;
#    }
#    pop @{ $mm->path };
#    ($res, $backup);
#}
#
#sub _readd_prefix {
#    my ($self, $hh, $k, $defmode) = @_;
#    my $mm = $self->merger;
#    my $c = $mm->config;
#
#    my $m = $hh->{$k}[0];
#    if ($m eq $defmode) {
#        $hh->{$k} = $hh->{$k}[1];
#    } else {
#        my $kp = $mm->modes->{$m}->add_prefix($k);
#        if (exists $hh->{$kp}) {
#            $mm->push_error("BUG: conflict when re-adding prefix after merge: $kp");
#            return;
#        }
#        $hh->{$kp} = $hh->{$k}[1];
#        delete $hh->{$k};
#    }
#}
#
#sub merge_HASH_HASH {
#    my ($self, $key, $l, $r, $mode) = @_;
#    my $mm = $self->merger;
#    my $c = $mm->config;
#    $mode //= $c->default_mode;
#
#    return $self->merge_SCALAR_SCALAR($key, $l, $r) unless $c->recurse_hash;
#    return if $c->wanted_path && !$mm->_path_is_included($mm->path, $c->wanted_path);
#
#    my $config_replaced;
#    my $orig_c = $c;
#    my $ok = $c->options_key;
#    {
#        last unless defined $ok;
#
#        my $okl = $self->_gen_left ($l, $mode, sub {$_[0] eq $ok});
#        return if @{ $mm->errors };
#
#        my $okr = $self->_gen_right($r, $mode, sub {$_[0] eq $ok});
#        return if @{ $mm->errors };
#
#        push @{ $mm->path }, $ok;
#        my ($res, $backup);
#        {
#            local $c->{readd_prefix} = 0;
#            ($res, $backup) = $self->_merge_gen($okl, $okr, $mode);
#        }
#        pop @{ $mm->path };
#        return if @{ $mm->errors };
#
#
#        $res = $res->{$ok} ? $res->{$ok}[1] : undef;
#        if (defined($res) && ref($res) ne 'HASH') {
#            $mm->push_error("Invalid options key after merge: value must be hash");
#            return;
#        }
#        last unless keys %$res;
#        my $c2 = bless({ %$c }, ref($c));
#
#        for (keys %$res) {
#            if ($c->allow_override) {
#                my $re = $c->allow_override;
#                if (!/$re/) {
#                    $mm->push_error("Configuration in options key `$_` not allowed by allow_override $re");
#                    return;
#                }
#            }
#            if ($c->disallow_override) {
#                my $re = $c->disallow_override;
#                if (/$re/) {
#                    $mm->push_error("Configuration in options key `$_` not allowed by disallow_override $re");
#                    return;
#                }
#            }
#            if ($mm->_in($_, $c->_config_config)) {
#                $mm->push_error("Configuration not allowed in options key: $_");
#                return;
#            }
#            if ($_ ne $ok && !$mm->_in($_, $c->_config_ok)) {
#                $mm->push_error("Unknown configuration in options key: $_");
#                return;
#            }
#            $c2->$_($res->{$_}) unless $_ eq $ok;
#        }
#        $mm->config($c2);
#        $config_replaced++;
#        $c = $c2;
#    }
#
#    my $sp = $c->set_prefix;
#    my $saved_prefixes;
#    if (defined($sp)) {
#        if (ref($sp) ne 'HASH') {
#            $mm->push_error("Invalid config value `set_prefix`: must be a hash");
#            return;
#        }
#        $saved_prefixes = {};
#        for my $mh (values %{ $mm->modes }) {
#            my $n = $mh->name;
#            if ($sp->{$n}) {
#                $saved_prefixes->{$n} = {
#                    prefix => $mh->prefix,
#                    prefix_re => $mh->prefix_re,
#                    check_prefix_sub => $mh->check_prefix_sub,
#                    add_prefix_sub => $mh->add_prefix_sub,
#                    remove_prefix_sub => $mh->remove_prefix_sub,
#                };
#                $mh->prefix($sp->{$n});
#                my $re = quotemeta($sp->{$n});
#                $mh->prefix_re(qr/^$re/);
#                $mh->check_prefix_sub(undef);
#                $mh->add_prefix_sub(undef);
#                $mh->remove_prefix_sub(undef);
#            }
#        }
#    }
#
#    my $ep = $c->exclude_parse;
#    my $ip = $c->include_parse;
#    if (defined($ep) && ref($ep) ne 'ARRAY') {
#        $mm->push_error("Invalid config value `exclude_parse`: must be an array");
#        return;
#    }
#    if (defined($ip) && ref($ip) ne 'ARRAY') {
#        $mm->push_error("Invalid config value `include_parse`: must be an array");
#        return;
#    }
#
#    my $epr = $c->exclude_parse_regex;
#    my $ipr = $c->include_parse_regex;
#    if (defined($epr)) {
#        eval { $epr = qr/$epr/ };
#        if ($@) {
#            $mm->push_error("Invalid config value `exclude_parse_regex`: invalid regex: $@");
#            return;
#        }
#    }
#    if (defined($ipr)) {
#        eval { $ipr = qr/$ipr/ };
#        if ($@) {
#            $mm->push_error("Invalid config value `include_parse_regex`: invalid regex: $@");
#            return;
#        }
#    }
#
#    my $hl = $self->_gen_left ($l, $mode, sub {defined($ok) ? $_[0] ne $ok : 1}, $ep, $ip, $epr, $ipr);
#    return if @{ $mm->errors };
#
#    my $hr = $self->_gen_right($r, $mode, sub {defined($ok) ? $_[0] ne $ok : 1}, $ep, $ip, $epr, $ipr);
#    return if @{ $mm->errors };
#
#
#    my $em = $c->exclude_merge;
#    my $im = $c->include_merge;
#    if (defined($em) && ref($em) ne 'ARRAY') {
#        $mm->push_error("Invalid config value `exclude_marge`: must be an array");
#        return;
#    }
#    if (defined($im) && ref($im) ne 'ARRAY') {
#        $mm->push_error("Invalid config value `include_merge`: must be an array");
#        return;
#    }
#
#    my $emr = $c->exclude_merge_regex;
#    my $imr = $c->include_merge_regex;
#    if (defined($emr)) {
#        eval { $emr = qr/$emr/ };
#        if ($@) {
#            $mm->push_error("Invalid config value `exclude_merge_regex`: invalid regex: $@");
#            return;
#        }
#    }
#    if (defined($imr)) {
#        eval { $imr = qr/$imr/ };
#        if ($@) {
#            $mm->push_error("Invalid config value `include_merge_regex`: invalid regex: $@");
#            return;
#        }
#    }
#
#    my ($res, $backup) = $self->_merge_gen($hl, $hr, $mode, $em, $im, $emr, $imr);
#    return if @{ $mm->errors };
#
#
#    if ($c->readd_prefix) {
#        for my $k (keys %$res) {
#            $self->_readd_prefix($res, $k, $c->default_mode);
#        }
#    } else {
#        $res->{$_} = $res->{$_}[1] for keys %$res;
#    }
#
#    if ($saved_prefixes) {
#        for (keys %$saved_prefixes) {
#            my $mh = $mm->modes->{$_};
#            my $s = $saved_prefixes->{$_};
#            $mh->prefix($s->{prefix});
#            $mh->prefix_re($s->{prefix_re});
#            $mh->check_prefix_sub($s->{check_prefix_sub});
#            $mh->add_prefix_sub($s->{add_prefix_sub});
#            $mh->remove_prefix_sub($s->{remove_prefix_sub});
#        }
#    }
#
#    if ($config_replaced) {
#        $mm->config($orig_c);
#    }
#
#    ($key, $res, $backup);
#}
#
#1;
#
#__END__
#
### Data/ModeMerge/Mode/CONCAT.pm ###
#package Data::ModeMerge::Mode::CONCAT;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Mo qw(build default);
#extends 'Data::ModeMerge::Mode::ADD';
#
#sub name { 'CONCAT' }
#
#sub precedence_level { 2 }
#
#sub default_prefix { '.' }
#
#sub default_prefix_re { qr/^\./ }
#
#sub merge_SCALAR_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, ($l // "") . $r);
#}
#
#1;
#
#__END__
#
### Data/ModeMerge/Mode/DELETE.pm ###
#package Data::ModeMerge::Mode::DELETE;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Mo qw(build default);
#extends 'Data::ModeMerge::Mode::Base';
#
#sub name { 'DELETE' }
#
#sub precedence_level { 1 }
#
#sub default_prefix { '!' }
#
#sub default_prefix_re { qr/^!/ }
#
#sub merge_left_only {
#    my ($self, $key, $l) = @_;
#    return;
#}
#
#sub merge_right_only {
#    my ($self, $key, $r) = @_;
#    return;
#}
#
#sub merge_SCALAR_SCALAR {
#    return;
#}
#
#sub merge_SCALAR_ARRAY {
#    return;
#}
#
#sub merge_SCALAR_HASH {
#    return;
#}
#
#sub merge_ARRAY_SCALAR {
#    return;
#}
#
#sub merge_ARRAY_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->config->allow_destroy_array or
#        $self->merger->push_error("Now allowed to destroy array via DELETE mode");
#    return;
#}
#
#sub merge_ARRAY_HASH {
#    return;
#}
#
#sub merge_HASH_SCALAR {
#    return;
#}
#
#sub merge_HASH_ARRAY {
#    return;
#}
#
#sub merge_HASH_HASH {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->config->allow_destroy_hash or
#        $self->merger->push_error("Now allowed to destroy hash via DELETE mode");
#    return;
#}
#
#1;
#
#__END__
#
### Data/ModeMerge/Mode/KEEP.pm ###
#package Data::ModeMerge::Mode::KEEP;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Mo qw(build default);
#extends 'Data::ModeMerge::Mode::Base';
#
#sub name { 'KEEP' }
#
#sub precedence_level { 6 }
#
#sub default_prefix { '^' }
#
#sub default_prefix_re { qr/^\^/ }
#
#sub merge_SCALAR_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l);
#}
#
#sub merge_SCALAR_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l);
#}
#
#sub merge_SCALAR_HASH {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l);
#}
#
#sub merge_ARRAY_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l);
#}
#
#sub merge_ARRAY_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    $self->SUPER::merge_ARRAY_ARRAY($key, $l, $r, 'KEEP');
#};
#
#sub merge_ARRAY_HASH {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l);
#}
#
#sub merge_HASH_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l);
#}
#
#sub merge_HASH_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l);
#}
#
#sub merge_HASH_HASH {
#    my ($self, $key, $l, $r) = @_;
#    $self->SUPER::merge_HASH_HASH($key, $l, $r, 'KEEP');
#};
#
#1;
#
#__END__
#
### Data/ModeMerge/Mode/NORMAL.pm ###
#package Data::ModeMerge::Mode::NORMAL;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Mo qw(build default);
#extends 'Data::ModeMerge::Mode::Base';
#
#sub name { 'NORMAL' }
#
#sub precedence_level { 5 }
#
#sub default_prefix { '*' }
#
#sub default_prefix_re { qr/^\*/ }
#
#sub merge_SCALAR_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_SCALAR_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_SCALAR_HASH {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_SCALAR_CODE {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_ARRAY_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_ARRAY_HASH {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_ARRAY_CODE {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_HASH_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_HASH_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_HASH_CODE {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_CODE_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_CODE_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_CODE_HASH {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#sub merge_CODE_CODE {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $r);
#}
#
#1;
#
#__END__
#
### Data/ModeMerge/Mode/SUBTRACT.pm ###
#package Data::ModeMerge::Mode::SUBTRACT;
#
#our $DATE = '2016-07-22'; 
#our $VERSION = '0.35'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Mo qw(build default);
#extends 'Data::ModeMerge::Mode::NORMAL';
#
#sub name { 'SUBTRACT' }
#
#sub precedence_level { 4 }
#
#sub default_prefix { '-' }
#
#sub default_prefix_re { qr/^-/ }
#
#sub merge_SCALAR_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    ($key, $l - $r);
#}
#
#sub merge_SCALAR_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't subtract scalar and array");
#    return;
#}
#
#sub merge_SCALAR_HASH {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't subtract scalar and hash");
#    return;
#}
#
#sub merge_ARRAY_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't subtract array and scalar");
#    return;
#}
#
#sub merge_ARRAY_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    my @res;
#    my $mm = $self->merger;
#    for (@$l) {
#        push @res, $_ unless $mm->_in($_, $r);
#    }
#    ($key, \@res);
#}
#
#sub merge_ARRAY_HASH {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't subtract array and hash");
#    return;
#}
#
#sub merge_HASH_SCALAR {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't subtract hash and scalar");
#    return;
#}
#
#sub merge_HASH_ARRAY {
#    my ($self, $key, $l, $r) = @_;
#    $self->merger->push_error("Can't subtract hash and array");
#    return;
#}
#
#sub merge_HASH_HASH {
#    my ($self, $key, $l, $r) = @_;
#    my $mm = $self->merger;
#
#    my %res;
#    my $r2 = {};
#    for (keys %$r) {
#        my $k = $mm->check_prefix($_) ? $_ : $mm->add_prefix($_, 'DELETE');
#        if ($k ne $_ && exists($r->{$k})) {
#            $mm->push_error("Conflict when adding DELETE prefix on right-side hash key $_ ".
#                            "for SUBTRACT merge: key $k already exists");
#            return;
#        }
#        $r2->{$k} = $r->{$_};
#    }
#    $mm->_merge($key, $l, $r2, 'NORMAL');
#}
#
#1;
#
#__END__
#
### Data/Sah.pm ###
#package Data::Sah;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#
#our $Log_Validator_Code = $ENV{LOG_SAH_VALIDATOR_CODE} // 0;
#
#use Data::Sah::Normalize qw(
#                       $type_re
#                       $clause_name_re
#                       $clause_re
#                       $attr_re
#                       $funcset_re
#                       $compiler_re
#                       );
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(normalize_schema gen_validator);
#
#has compilers    => (is => 'rw', default => sub { {} });
#
#has _var_enumer  => (
#    is      => 'rw',
#    lazy    => 1,
#    default => sub {
#        require Language::Expr::Interpreter::VarEnumer;
#        Language::Expr::Interpreter::VarEnumer->new;
#    },
#);
#
#sub normalize_clset {
#    require Scalar::Util;
#
#    my $self;
#    if (Scalar::Util::blessed($_[0])) {
#        $self = shift;
#    } else {
#        $self = __PACKAGE__->new;
#    }
#
#    Data::Sah::Normalize::normalize_clset($_[0]);
#}
#
#sub normalize_schema {
#    require Scalar::Util;
#
#    my $self;
#    if (Scalar::Util::blessed($_[0])) {
#        $self = shift;
#    } else {
#        $self = __PACKAGE__->new;
#    }
#    my ($s) = @_;
#
#    Data::Sah::Normalize::normalize_schema($_[0]);
#}
#
#sub gen_validator {
#    require Scalar::Util;
#
#    my $self;
#    if (Scalar::Util::blessed($_[0])) {
#        $self = shift;
#    } else {
#        $self = __PACKAGE__->new;
#    }
#    my ($schema, $opts) = @_;
#    my %args = (schema => $schema, %{$opts // {}});
#    my $opt_source = delete $args{source};
#
#    $args{log_result} = 1 if $Log_Validator_Code;
#
#    my $pl = $self->get_compiler("perl");
#    my $code = $pl->expr_validator_sub(%args);
#    return $code if $opt_source;
#
#    my $res = eval $code;
#    die "Can't compile validator: $@" if $@;
#    $res;
#}
#
#sub get_compiler {
#    my ($self, $name) = @_;
#    return $self->compilers->{$name} if $self->compilers->{$name};
#
#    die "Invalid compiler name `$name`" unless $name =~ $compiler_re;
#    my $module = "Data::Sah::Compiler::$name";
#    if (!eval "require $module; 1") {
#        die "Can't load compiler module $module".($@ ? ": $@" : "");
#    }
#
#    my $obj = $module->new(main => $self);
#    $self->compilers->{$name} = $obj;
#
#    return $obj;
#}
#
#sub normalize_var {
#    my ($self, $var, $curpath) = @_;
#    die "Not yet implemented";
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce.pm ###
#package Data::Sah::Coerce;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#no warnings 'once';
#use Log::ger;
#
#use Data::Sah::CoerceCommon;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(gen_coercer);
#
#our %SPEC;
#
#our $Log_Coercer_Code = $ENV{LOG_SAH_COERCER_CODE} // 0;
#
#$SPEC{gen_coercer} = {
#    v => 1.1,
#    summary => 'Generate coercer code',
#    description => <<'_',
#
#This is mostly for testing. Normally the coercion rules will be used from
#<pm:Data::Sah>.
#
#_
#    args => {
#        %Data::Sah::CoerceCommon::gen_coercer_args,
#    },
#    result_naked => 1,
#};
#sub gen_coercer {
#    my %args = @_;
#
#    my $rt = $args{return_type} // 'val';
#
#    my $rules = Data::Sah::CoerceCommon::get_coerce_rules(
#        %args,
#        compiler=>'perl',
#        data_term=>'$data',
#    );
#
#    my $code;
#    if (@$rules) {
#        my $code_require = '';
#        my %mem;
#        for my $rule (@$rules) {
#            next unless $rule->{modules};
#            for my $mod (keys %{$rule->{modules}}) {
#                next if $mem{$mod}++;
#                $code_require .= "require $mod;\n";
#            }
#        }
#
#        my $expr;
#        for my $i (reverse 0..$#{$rules}) {
#            my $rule = $rules->[$i];
#            my $prev_term;
#            if ($i == $#{$rules}) {
#                if ($rt eq 'val') {
#                    $prev_term = '$data';
#                } elsif ($rt eq 'status+val') {
#                    $prev_term = '[undef, $data]';
#                } else { 
#                    $prev_term = '[undef, undef, $data]';
#                }
#            } else {
#                $prev_term = $expr;
#            }
#
#            if ($rt eq 'val') {
#                if ($rule->{meta}{might_fail}) {
#                    $expr = "do { if ($rule->{expr_match}) { my \$res = $rule->{expr_coerce}; \$res->[0] ? undef : \$res->[1] } else { $prev_term } }";
#                } else {
#                    $expr = "($rule->{expr_match}) ? ($rule->{expr_coerce}) : $prev_term";
#                }
#            } elsif ($rt eq 'status+val') {
#                if ($rule->{meta}{might_fail}) {
#                    $expr = "do { if ($rule->{expr_match}) { my \$res = $rule->{expr_coerce}; \$res->[0] ? [1,undef] : [1,\$res->[1]] } else { $prev_term } }";
#                } else {
#                    $expr = "($rule->{expr_match}) ? [1, $rule->{expr_coerce}] : $prev_term";
#                }
#            } else { 
#                if ($rule->{meta}{might_fail}) {
#                    $expr = "do { if ($rule->{expr_match}) { my \$res = $rule->{expr_coerce}; \$res->[0] ? [1, \$res->[0], undef] : [1, undef, \$res->[1]] } else { $prev_term } }";
#                } else {
#                    $expr = "($rule->{expr_match}) ? [1, undef, $rule->{expr_coerce}] : $prev_term";
#                }
#            }
#        }
#
#        $code = join(
#            "",
#            $code_require,
#            "sub {\n",
#            "    my \$data = shift;\n",
#            "    unless (defined \$data) {\n",
#            "        ", ($rt eq 'val' ? "return undef;" :
#                             $rt eq 'status+val' ? "return [undef, undef];" :
#                             "return [undef, undef, undef];" 
#                         ), "\n",
#            "    }\n",
#            "    $expr;\n",
#            "}",
#        );
#    } else {
#        if ($rt eq 'val') {
#            $code = 'sub { $_[0] }';
#        } elsif ($rt eq 'status+val') {
#            $code = 'sub { [undef, $_[0]] }';
#        } else {
#            $code = 'sub { [undef, undef, $_[0]] }';
#        }
#    }
#
#    if ($Log_Coercer_Code) {
#        log_trace("Coercer code (gen args: %s): %s", \%args, $code);
#    }
#
#    return $code if $args{source};
#
#    my $coercer = eval $code;
#    die if $@;
#    $coercer;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/bool/float.pm ###
#package Data::Sah::Coerce::js::bool::float;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "typeof($dt)=='number'",
#        "$dt == 0 || $dt == 1",
#    );
#
#
#    $res->{expr_coerce} = "$dt == 1 ? true : false";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/bool/str.pm ###
#package Data::Sah::Coerce::js::bool::str;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    my $re      = '/^(yes|no|true|false|on|off|1|0)$/i';
#    my $re_true = '/^(yes|true|on|1)$/i';
#
#    $res->{expr_match} = join(
#        " && ",
#        "typeof($dt)=='string'",
#        "$dt.match($re)",
#    );
#
#
#    $res->{expr_coerce} = "(function(_m) { _m = $dt.match($re); return _m[1].match($re_true) ? true : false })()";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/date/float_epoch.pm ###
#package Data::Sah::Coerce::js::date::float_epoch;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "typeof($dt)=='number'",
#        "$dt >= " . (10**8),
#        "$dt <= " . (2**31),
#    );
#
#    $res->{expr_coerce} = "(new Date($dt * 1000))";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/date/obj_Date.pm ###
#package Data::Sah::Coerce::js::date::obj_Date;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "($dt instanceof Date)",
#    );
#
#    $res->{expr_coerce} = "isNaN($dt) ? ['Invalid date'] : [null, $dt]";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/date/str.pm ###
#package Data::Sah::Coerce::js::date::str;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "typeof($dt)=='string'",
#    );
#
#    $res->{expr_coerce} = "(function (_m) { _m = new Date($dt); if (isNaN(_m)) { return ['Invalid date'] } else { return [null, _m] } })()";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/datenotime/float_epoch.pm ###
#package Data::Sah::Coerce::js::datenotime::float_epoch;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::js::date::float_epoch';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/datenotime/obj_Date.pm ###
#package Data::Sah::Coerce::js::datenotime::obj_Date;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::js::date::obj_Date';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/datenotime/str.pm ###
#package Data::Sah::Coerce::js::datenotime::str;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::js::date::str';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/datetime/float_epoch.pm ###
#package Data::Sah::Coerce::js::datetime::float_epoch;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::js::date::float_epoch';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/datetime/obj_Date.pm ###
#package Data::Sah::Coerce::js::datetime::obj_Date;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::js::date::obj_Date';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/datetime/str.pm ###
#package Data::Sah::Coerce::js::datetime::str;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::js::date::str';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/duration/float_secs.pm ###
#package Data::Sah::Coerce::js::duration::float_secs;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "(typeof($dt)=='number' || typeof($dt)=='string' && $dt.match(/^[0-9]+(?:\\.[0-9]+)?\$/))",
#        "parseFloat($dt) >= 0", 
#        "!isNaN(parseFloat($dt))",
#        "isFinite(parseFloat($dt))", 
#    );
#
#    $res->{expr_coerce} = "parseFloat($dt)";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/duration/str_iso8601.pm ###
#package Data::Sah::Coerce::js::duration::str_iso8601;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to};
#
#    my $res = {};
#
#    my $re_num = '[0-9]+(?:\\.[0-9]+)?';
#    my $expr_re_match = "$dt.match(/^P(?:($re_num)Y)?(?:($re_num)M)?(?:($re_num)W)?(?:($re_num)D)?(?:T(?:($re_num)H)?(?:($re_num)M)?(?:($re_num)S)?)?\$/)";
#    $res->{expr_match} = join(
#        " && ",
#        "typeof($dt)=='string'",
#        $expr_re_match,
#    );
#
#
#    $res->{expr_coerce} = "(function(_m) { _m = $expr_re_match; return ((_m[1]||0)*365.25*86400 + (_m[2]||0)*30.4375*86400 + (_m[3]||0)*7*86400 + (_m[4]||0)*86400 + (_m[5]||0)*3600 + (_m[6]||0)*60 + (_m[7]||0)*1) })()";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/js/timeofday/str_hms.pm ###
#package Data::Sah::Coerce::js::timeofday::str_hms;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "typeof($dt)=='string'",
#        "($dt).match(/^([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2}(?:\\.[0-9]{1,9})?))?\$/)",
#    );
#
#    $res->{expr_coerce} = join(
#        "",
#        "(function (_m) { ",
#        "  _m = ($dt).match(/^([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2}(?:\\.[0-9]{1,9})?))?\$/); ", 
#        "  _m[1] = parseInt(_m[1]);   if (_m[1] >= 24) { return ['Invalid hour '+_m[1]+', must be between 0-23'] } ",
#        "  _m[2] = parseInt(_m[2]);   if (_m[2] >= 60) { return ['Invalid minute '+_m[2]+', must be between 0-59'] } ",
#        "  _m[3] = _m[3] ? parseFloat(_m[3]) : 0; if (_m[3] >= 60) { return ['Invalid second '+_m[3]+', must be between 0-60'] } ",
#        "  return [null, _m[1]*3600 + _m[2]*60 + _m[3]] ",
#        "})()",
#    );
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/bool/str.pm ###
#package Data::Sah::Coerce::perl::bool::str;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "1",
#    );
#
#    $res->{expr_coerce} = "$dt =~ /\\A(yes|true|on)\\z/i ? 1 : $dt =~ /\\A(no|false|off|0)\\z/i ? '' : $dt";
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/date/float_epoch.pm ###
#package Data::Sah::Coerce::perl::date::float_epoch;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#        precludes => ['float_epoch_always'],
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(epoch)';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\A[0-9]{8,10}(?:\.[0-9]+)?\\z/",
#        "$dt >= 10**8",
#        "$dt <= 2**31",
#    );
#
#    if ($coerce_to eq 'float(epoch)') {
#        $res->{expr_coerce} = $dt;
#    } elsif ($coerce_to eq 'DateTime') {
#        $res->{modules}{DateTime} //= 0;
#        $res->{expr_coerce} = "DateTime->from_epoch(epoch => $dt)";
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $res->{modules}{'Time::Moment'} //= 0;
#        $res->{expr_coerce} = "Time::Moment->from_epoch($dt)";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(epoch), DateTime, or Time::Moment";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/date/float_epoch_always.pm ###
#package Data::Sah::Coerce::perl::date::float_epoch_always;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#        precludes => ['float_epoch'],
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(epoch)';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\A[0-9]+(?:\.[0-9]+)?\\z/",
#    );
#
#    if ($coerce_to eq 'float(epoch)') {
#        $res->{expr_coerce} = $dt;
#    } elsif ($coerce_to eq 'DateTime') {
#        $res->{modules}{DateTime} //= 0;
#        $res->{expr_coerce} = "DateTime->from_epoch(epoch => $dt)";
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $res->{modules}{'Time::Moment'} //= 0;
#        $res->{expr_coerce} = "Time::Moment->from_epoch($dt)";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(epoch), DateTime, or Time::Moment";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/date/obj_DateTime.pm ###
#package Data::Sah::Coerce::perl::date::obj_DateTime;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(epoch)';
#
#    my $res = {};
#
#    $res->{modules}{'Scalar::Util'} //= 0;
#
#    $res->{expr_match} = join(
#        " && ",
#        "Scalar::Util::blessed($dt)",
#        "$dt\->isa('DateTime')",
#    );
#
#    if ($coerce_to eq 'float(epoch)') {
#        $res->{expr_coerce} = "$dt\->epoch";
#    } elsif ($coerce_to eq 'DateTime') {
#        $res->{expr_coerce} = $dt;
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $res->{modules}{'Time::Moment'} //= 0;
#        $res->{expr_coerce} = "Time::Moment->from_object($dt)";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(epoch), DateTime, or Time::Moment";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/date/obj_TimeMoment.pm ###
#package Data::Sah::Coerce::perl::date::obj_TimeMoment;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(epoch)';
#
#    my $res = {};
#
#    $res->{modules}{'Scalar::Util'} //= 0;
#
#    $res->{expr_match} = join(
#        " && ",
#        "Scalar::Util::blessed($dt)",
#        "$dt\->isa('Time::Moment')",
#    );
#
#    if ($coerce_to eq 'float(epoch)') {
#        $res->{expr_coerce} = "$dt\->epoch";
#    } elsif ($coerce_to eq 'DateTime') {
#        $res->{modules}{'DateTime'} //= 0;
#        $res->{expr_coerce} = "DateTime->from_epoch(epoch => $dt\->epoch, time_zone => sprintf('%s%04d', $dt\->offset >= 0 ? '+':'-', abs(int($dt\->offset / 60)*100) + abs(int($dt\->offset % 60))))";
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $res->{expr_coerce} = $dt;
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(epoch), DateTime, or Time::Moment";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/date/str_iso8601.pm ###
#package Data::Sah::Coerce::perl::date::str_iso8601;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(epoch)';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\A([0-9]{4})-([0-9]{2})-([0-9]{2})(?:([T ])([0-9]{2}):([0-9]{2}):([0-9]{2})(Z?))?\\z/",
#    );
#
#    $res->{modules}{"Time::Local"} //= 0;
#
#    my $code_epoch = '$4 ? ($8 ? Time::Local::timegm($7, $6, $5, $3, $2-1, $1-1900) : Time::Local::timelocal($7, $6, $5, $3, $2-1, $1-1900)) : Time::Local::timelocal(0, 0, 0, $3, $2-1, $1-1900)';
#    if ($coerce_to eq 'float(epoch)') {
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, \$time] } });
#    } elsif ($coerce_to eq 'DateTime') {
#        $res->{modules}{"DateTime"} //= 0;
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, DateTime->from_epoch(epoch => \$time, time_zone => \$8 ? 'UTC' : 'local')] } });
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $res->{modules}{"Time::Moment"} //= 0;
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, Time::Moment->from_epoch(\$time)] } });
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(epoch), DateTime, or Time::Moment";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datenotime/float_epoch.pm ###
#package Data::Sah::Coerce::perl::datenotime::float_epoch;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::float_epoch';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datenotime/float_epoch_always.pm ###
#package Data::Sah::Coerce::perl::datenotime::float_epoch_always;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::float_epoch_always';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datenotime/obj_DateTime.pm ###
#package Data::Sah::Coerce::perl::datenotime::obj_DateTime;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::obj_DateTime';
#
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datenotime/obj_TimeMoment.pm ###
#package Data::Sah::Coerce::perl::datenotime::obj_TimeMoment;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::obj_TimeMoment';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datenotime/str_iso8601.pm ###
#package Data::Sah::Coerce::perl::datenotime::str_iso8601;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(epoch)';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\A([0-9]{4})-([0-9]{2})-([0-9]{2})\\z/",
#    );
#
#    $res->{modules}{"Time::Local"} //= 0;
#
#    my $code_epoch = 'Time::Local::timelocal(0, 0, 0, $3, $2-1, $1-1900)';
#    if ($coerce_to eq 'float(epoch)') {
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, \$time] } });
#    } elsif ($coerce_to eq 'DateTime') {
#        $res->{modules}{"DateTime"} //= 0;
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, DateTime->from_epoch(epoch => \$time, time_zone => 'local')] } });
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $res->{modules}{"Time::Moment"} //= 0;
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, Time::Moment->from_epoch(\$time)] } });
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(epoch), DateTime, or Time::Moment";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datetime/float_epoch.pm ###
#package Data::Sah::Coerce::perl::datetime::float_epoch;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::float_epoch';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datetime/float_epoch_always.pm ###
#package Data::Sah::Coerce::perl::datetime::float_epoch_always;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::float_epoch_always';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datetime/obj_DateTime.pm ###
#package Data::Sah::Coerce::perl::datetime::obj_DateTime;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::obj_DateTime';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datetime/obj_TimeMoment.pm ###
#package Data::Sah::Coerce::perl::datetime::obj_TimeMoment;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use subroutines 'Data::Sah::Coerce::perl::date::obj_TimeMoment';
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/datetime/str_iso8601.pm ###
#package Data::Sah::Coerce::perl::datetime::str_iso8601;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(epoch)';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\A([0-9]{4})-([0-9]{2})-([0-9]{2})([T ])([0-9]{2}):([0-9]{2}):([0-9]{2})(Z?)\\z/",
#    );
#
#    $res->{modules}{"Time::Local"} //= 0;
#
#    my $code_epoch = '$8 ? Time::Local::timegm($7, $6, $5, $3, $2-1, $1-1900) : Time::Local::timelocal($7, $6, $5, $3, $2-1, $1-1900)';
#    if ($coerce_to eq 'float(epoch)') {
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, \$time] } });
#    } elsif ($coerce_to eq 'DateTime') {
#        $res->{modules}{"DateTime"} //= 0;
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, DateTime->from_epoch(epoch => \$time, time_zone => \$8 ? 'UTC' : 'local')] } });
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $res->{modules}{"Time::Moment"} //= 0;
#        $res->{expr_coerce} = qq(do { my \$time; eval { \$time = $code_epoch }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid date/time: \$err"] } else { [undef, Time::Moment->from_epoch(\$time)] } });
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(epoch), DateTime, or Time::Moment";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/duration/float_secs.pm ###
#package Data::Sah::Coerce::perl::duration::float_secs;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(secs)';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\A[0-9]+(?:\.[0-9]+)\\z/",
#    );
#
#    if ($coerce_to eq 'float(secs)') {
#        $res->{expr_coerce} = $dt;
#    } elsif ($coerce_to eq 'DateTime::Duration') {
#        $res->{modules}{'DateTime::Duration'} //= 0;
#        $res->{expr_coerce} = "DateTime::Duration->new(seconds => $dt)";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(secs) or DateTime::Duration";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/duration/obj_DateTimeDuration.pm ###
#package Data::Sah::Coerce::perl::duration::obj_DateTimeDuration;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(secs)';
#
#    my $res = {};
#
#    $res->{modules}{'Scalar::Util'} //= 0;
#
#    $res->{expr_match} = join(
#        " && ",
#        "Scalar::Util::blessed($dt)",
#        "$dt\->isa('DateTime::Duration')",
#    );
#
#    if ($coerce_to eq 'float(secs)') {
#        $res->{expr_coerce} = "($dt\->years * 365.25*86400 + $dt\->months * 30.4375*86400 + $dt\->weeks * 7*86400 + $dt\->days * 86400 + $dt\->hours * 3600 + $dt\->minutes * 60 + $dt\->seconds + $dt\->nanoseconds * 1e-9)";
#    } elsif ($coerce_to eq 'DateTime::Duration') {
#        $res->{expr_coerce} = $dt;
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(secs) or DateTime::Duration";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/duration/str_human.pm ###
#package Data::Sah::Coerce::perl::duration::str_human;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 60,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(secs)';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\d.*[a-z]/",
#    );
#
#    $res->{modules}{"Time::Duration::Parse::AsHash"} //= 0;
#    if ($coerce_to eq 'float(secs)') {
#        $res->{expr_coerce} = qq(do { my \$p; eval { \$p = Time::Duration::Parse::AsHash::parse_duration($dt) }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid duration: \$err"] } else { [undef, (\$p->{years}||0) * 365.25*86400 + (\$p->{months}||0) * 30.4375*86400 + (\$p->{weeks}||0) * 7*86400 + (\$p->{days}||0) * 86400 + (\$p->{hours}||0) * 3600 + (\$p->{minutes}||0) * 60 + (\$p->{seconds}||0)] } });
#    } elsif ($coerce_to eq 'DateTime::Duration') {
#        $res->{modules}{"DateTime::Duration"} //= 0;
#        $res->{expr_coerce} = qq(do { my \$p; eval { \$p = Time::Duration::Parse::AsHash::parse_duration($dt) }; my \$err = \$@; if (\$err) { \$err =~ s/ at .+//s; ["Invalid duration: \$err"] } else { [undef, DateTime::Duration->new( (years=>\$p->{years}) x !!defined(\$p->{years}), (months=>\$p->{months}) x !!defined(\$p->{months}), (weeks=>\$p->{weeks}) x !!defined(\$p->{weeks}), (days=>\$p->{days}) x !!defined(\$p->{days}), (hours=>\$p->{hours}) x !!defined(\$p->{hours}), (minutes=>\$p->{minutes}) x !!defined(\$p->{minutes}), (seconds=>\$p->{seconds}) x !!defined(\$p->{seconds}))] } });
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(secs) or DateTime::Duration";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/duration/str_iso8601.pm ###
#package Data::Sah::Coerce::perl::duration::str_iso8601;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'float(secs)';
#
#    my $res = {};
#
#    my $re_num = '[0-9]+(?:\\.[0-9]+)?';
#    $res->{expr_match} = join(
#        " && ",
#        "!ref($dt)",
#        "$dt =~ /\\AP(?:($re_num)Y)? (?:($re_num)M)? (?:($re_num)W)? (?:($re_num)D)? (?: T (?:($re_num)H)? (?:($re_num)M)? (?:($re_num)S)? )?\\z/x",
#    );
#
#    if ($coerce_to eq 'float(secs)') {
#        $res->{expr_coerce} = "((\$1||0)*365.25*86400 + (\$2||0)*30.4375*86400 + (\$3||0)*7*86400 + (\$4||0)*86400 + (\$5||0)*3600 + (\$6||0)*60 + (\$7||0))";
#    } elsif ($coerce_to eq 'DateTime::Duration') {
#        $res->{modules}{"DateTime::Duration"} //= 0;
#        $res->{expr_coerce} = "DateTime::Duration->new( (years=>\$1) x !!defined(\$1), (months=>\$2) x !!defined(\$2), (weeks=>\$3) x !!defined(\$3), (days=>\$4) x !!defined(\$4), (hours=>\$5) x !!defined(\$5), (minutes=>\$6) x !!defined(\$6), (seconds=>\$7) x !!defined(\$7))";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float(secs) or DateTime::Duration";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/float/str_percent.pm ###
#package Data::Sah::Coerce::perl::float::str_percent;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "$dt =~ /\\A([+-]?\\d+(?:\\.\\d*)?)%\\z/",
#    );
#
#    $res->{expr_coerce} = "\$1/100";
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/int/str_percent.pm ###
#package Data::Sah::Coerce::perl::int::str_percent;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "$dt =~ /\\A([+-]?\\d+)%\\z/",
#    );
#
#    $res->{expr_coerce} = "\$1/100";
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/timeofday/obj_DateTimeOfDay.pm ###
#package Data::Sah::Coerce::perl::timeofday::obj_DateTimeOfDay;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'str_hms';
#
#    my $res = {};
#
#    $res->{modules}{'Scalar::Util'} //= 0;
#
#    $res->{expr_match} = join(
#        " && ",
#        "Scalar::Util::blessed($dt)",
#        "$dt\->isa('Date::TimeOfDay')",
#    );
#
#    if ($coerce_to eq 'float') {
#        $res->{expr_coerce} = "$dt\->float";
#    } elsif ($coerce_to eq 'str_hms') {
#        $res->{expr_coerce} = "$dt\->hms";
#    } elsif ($coerce_to eq 'Date::TimeOfDay') {
#        $res->{expr_coerce} = $dt;
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float, str_hms, or Date::TimeOfDay";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Coerce/perl/timeofday/str_hms.pm ###
#package Data::Sah::Coerce::perl::timeofday::str_hms;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#sub meta {
#    +{
#        v => 4,
#        might_fail => 1, 
#        prio => 50,
#    };
#}
#
#sub coerce {
#    my %args = @_;
#
#    my $dt = $args{data_term};
#    my $coerce_to = $args{coerce_to} // 'str_hms';
#
#    my $res = {};
#
#    $res->{expr_match} = join(
#        " && ",
#        "$dt =~ /\\A([0-9]{1,2}):([0-9]{1,2})(?::([0-9]{1,2})(\.[0-9]{1,9})?)?\\z/",
#    );
#
#    my $code_check = qq(if (\$1 > 23) { ["Invalid hour '\$1', must be between 0-23"] } elsif (\$2 > 59) { ["Invalid minute '\$2', must be between 0-59"] } elsif (defined \$3 && \$3 > 59) { ["Invalid second '\$3', must be between 0-59"] });
#
#    if ($coerce_to eq 'float') {
#        $res->{expr_coerce} = qq(do { $code_check else { [undef, \$1*3600 + \$2*60 + (defined \$3 ? \$3 : 0) + (defined \$4 ? \$4 : 0)] } });
#    } elsif ($coerce_to eq 'str_hms') {
#        $res->{expr_coerce} = qq(do { $code_check else { [undef, defined(\$4) && \$4 > 0 ? sprintf("%02d:%02d:%s%.11g", \$1, \$2, (!defined(\$3) || \$3 < 10 ? "0":""), (defined \$3 ? \$3:0)+\$4) : sprintf("%02d:%02d:%02d", \$1, \$2, (defined \$3 ? \$3 : 0))] } });
#    } elsif ($coerce_to eq 'Date::TimeOfDay') {
#        $res->{modules}{"Date::TimeOfDay"} //= 0.002;
#        $res->{expr_coerce} = qq([undef, Date::TimeOfDay->new(hour=>\$1, minute=>\$2, second=>(defined \$3 ? \$3 : 0), nanosecond=>(defined \$4 ? \$4*1e9 : 0))]);
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', ".
#            "please use float, str_hms, or Date::TimeOfDay";
#    }
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/CoerceCommon.pm ###
#package Data::Sah::CoerceCommon;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict 'subs', 'vars';
#
#our %Default_Rules = (
#    perl => {
#        bool       => [qw//],
#        date       => [qw/float_epoch obj_DateTime obj_TimeMoment str_iso8601/],
#        datenotime => [qw/float_epoch obj_DateTime obj_TimeMoment str_iso8601/],
#        datetime   => [qw/float_epoch obj_DateTime obj_TimeMoment str_iso8601/],
#        duration   => [qw/float_secs obj_DateTimeDuration str_human str_iso8601/],
#        timeofday  => [qw/obj_DateTimeOfDay str_hms/],
#    },
#    js => {
#        bool       => [qw/float str/],
#        date       => [qw/float_epoch obj_Date str/],
#        datetime   => [qw/float_epoch obj_Date str/],
#        datenotime => [qw/float_epoch obj_Date str/],
#        duration   => [qw/float_secs str_iso8601/],
#        timeofday  => [qw/str_hms/],
#    },
#);
#
#my %common_args = (
#    type => {
#        schema => 'str*', 
#            req => 1,
#        pos => 0,
#    },
#    coerce_to => {
#        schema => 'str*',
#        description => <<'_',
#
#Some Sah types, like `date`, can be represented in a choice of types in the
#target language. For example, in Perl you can store it as a floating number
#a.k.a. `float(epoch)`, or as a <pm:DateTime> object, or <pm:Time::Moment>
#object. Storing in DateTime can be convenient for date manipulation but requires
#an overhead of loading the module and storing in a bulky format. The choice is
#yours to make, via this setting.
#
#_
#    },
#    coerce_rules => {
#        summary => 'A specification of coercion rules to use (or avoid)',
#        schema => ['array*', of=>'str*'],
#        description => <<'_',
#
#This setting is used to specify which coercion rules to use (or avoid) in a
#flexible way. Each element is a string, in the form of either `NAME` to mean
#specifically include a rule, or `!NAME` to exclude a rule.
#
#Some coercion modules are used by default, unless explicitly avoided using the
#'!NAME' rule.
#
#To not use any rules:
#
#To use the default rules plus R1 and R2:
#
#    ['R1', 'R2']
#
#To use the default rules but not R1 and R2:
#
#    ['!R1', '!R2']
#
#_
#    },
#);
#
#my %gen_coercer_args = (
#    %common_args,
#    return_type => {
#        schema => ['str*', in=>[qw/val status+val status+err+val/]],
#        default => 'val',
#        description => <<'_',
#
#`val` means the coercer will return the input (possibly) coerced or undef if
#coercion fails.
#
#`status+val` means the coercer will return a 2-element array. The first element
#is a bool value set to 1 if coercion has been performed or 0 if otherwise. The
#second element is the (possibly) coerced input (or undef if there is a failure
#during coercion).
#
#`status+err+val` means the coercer will return a 3-element array. The first
#element is a bool value set to 1 if coercion has been performed or 0 if
#otherwise. The second element is the error message string which will be set if
#there is a failure in coercion. The third element is the (possibly) coerced
#input (or undef if there is a failure during coercion).
#
#_
#    },
#    source => {
#        summary => 'If set to true, will return coercer source code string'.
#            ' instead of compiled code',
#        schema => 'bool',
#    },
#);
#
#our %SPEC;
#
#$SPEC{get_coerce_rules} = {
#    v => 1.1,
#    summary => 'Get coerce rules',
#    description => <<'_',
#
#This routine determines coerce rule modules to use (based on the default set and
#`coerce_rules` specified), loads them, filters out modules with old/incompatible
#metadata version, and return the list of rules.
#
#This common routine is used by <pm:Data::Sah> compilers, as well as
#<pm:Data::Sah::Coerce> and <pm:Data::Sah::CoerceJS>.
#
#_
#    args => {
#        %common_args,
#        compiler => {
#            schema => 'str*',
#            req => 1,
#        },
#        data_term => {
#            schema => 'str*',
#            req => 1,
#        },
#    },
#};
#sub get_coerce_rules {
#    my %args = @_;
#
#    my $type     = $args{type};
#    my $compiler = $args{compiler};
#    my $dt       = $args{data_term};
#
#    my $typen = $type; $typen =~ s/::/__/g;
#    my $prefix = "Data::Sah::Coerce::$compiler\::$typen\::";
#
#    my @rule_names = @{ $Default_Rules{$compiler}{$typen} || [] };
#    for my $item (@{ $args{coerce_rules} // [] }) {
#        my $is_exclude = $item =~ s/\A!//;
#        $item =~ /\A[A-Za-z0-9_]+\z/
#            or die "Invalid coercion rule item '$item', please only use ".
#            "alphanumeric characters";
#        if ($is_exclude) {
#            @rule_names = grep { $_ ne $item } @rule_names;
#        } else {
#            push @rule_names, $item unless grep { $_ eq $item } @rule_names;
#        }
#    }
#
#    my @rules;
#    for my $rule_name (@rule_names) {
#        my $mod = "$prefix$rule_name";
#        (my $mod_pm = "$mod.pm") =~ s!::!/!g;
#        require $mod_pm;
#        my $rule_meta = &{"$mod\::meta"};
#        my $rule_v = ($rule_meta->{v} // 1);
#        if ($rule_v != 3 && $rule_v != 4) {
#            warn "Only coercion rule module following metadata version 3/4 is ".
#                "supported, this rule module '$mod' follows metadata version ".
#                "$rule_v and will not be used";
#            next;
#        }
#        my $rule = &{"$mod\::coerce"}(
#            data_term => $dt,
#            coerce_to => $args{coerce_to},
#        );
#        $rule->{name} = $rule_name;
#        $rule->{meta} = $rule_meta;
#        push @rules, $rule;
#    }
#
#    @rules = sort {
#        ($a->{meta}{prio}//50) <=> ($b->{meta}{prio}//50) ||
#            $a->{name} cmp $b->{name}
#        } @rules;
#
#    {
#        my $i = 0;
#        while ($i < @rules) {
#            my $rule = $rules[$i];
#            if ($rule->{meta}{precludes}) {
#                for my $j (reverse 0 .. $#rules) {
#                    next if $j == $i;
#                    my $match;
#                    for my $p (@{ $rule->{meta}{precludes} }) {
#                        if (ref($p) eq 'Regexp' && $rules[$j]{name} =~ $p ||
#                                $rules[$j]{name} eq $p) {
#                            $match = 1;
#                            last;
#                        }
#                    }
#                    next unless $match;
#                    warn "Coercion rule $rules[$j]{name} is precluded by rule $rule->{name}";
#                    splice @rules, $j, 1;
#                }
#            }
#            $i++;
#        }
#    }
#
#    \@rules;
#}
#
#1;
#
#__END__
#
### Data/Sah/CoerceJS.pm ###
#package Data::Sah::CoerceJS;
#
#our $DATE = '2019-01-26'; 
#our $VERSION = '0.033'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#use Data::Sah::CoerceCommon;
#use IPC::System::Options;
#use Nodejs::Util qw(get_nodejs_path);
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(gen_coercer);
#
#our %SPEC;
#
#our $Log_Coercer_Code = $ENV{LOG_SAH_COERCER_CODE} // 0;
#
#$SPEC{gen_coercer} = {
#    v => 1.1,
#    summary => 'Generate coercer code',
#    description => <<'_',
#
#This is mostly for testing. Normally the coercion rules will be used from
#<pm:Data::Sah>.
#
#_
#    args => {
#        %Data::Sah::CoerceCommon::gen_coercer_args,
#    },
#    result_naked => 1,
#};
#sub gen_coercer {
#    my %args = @_;
#
#    my $rt = $args{return_type} // 'val';
#
#    my $rules = Data::Sah::CoerceCommon::get_coerce_rules(
#        %args,
#        compiler=>'js',
#        data_term=>'data',
#    );
#
#    my $code;
#    if (@$rules) {
#        my $expr;
#        for my $i (reverse 0..$#{$rules}) {
#            my $rule = $rules->[$i];
#
#            my $prev_term;
#            if ($i == $#{$rules}) {
#                if ($rt eq 'val') {
#                    $prev_term = 'data';
#                } elsif ($rt eq 'status+val') {
#                    $prev_term = '[null, data]';
#                } else { 
#                    $prev_term = '[null, null, data]';
#                }
#            } else {
#                $prev_term = $expr;
#            }
#
#            if ($rt eq 'val') {
#                if ($rule->{meta}{might_fail}) {
#                    $expr = "(function() { if ($rule->{expr_match}) { var _tmp1 = $rule->{expr_coerce}; if (_tmp1[0]) { return null } else { return _tmp1[1] } } else { return $prev_term } })()";
#                } else {
#                    $expr = "($rule->{expr_match}) ? ($rule->{expr_coerce}) : $prev_term";
#                }
#            } elsif ($rt eq 'status+val') {
#                if ($rule->{meta}{might_fail}) {
#                    $expr = "(function() { if ($rule->{expr_match}) { var _tmp1 = $rule->{expr_coerce}; if (_tmp1[0]) { return [true, null] } else { return [true, _tmp1[1]] } } else { return $prev_term } })()";
#                } else {
#                    $expr = "($rule->{expr_match}) ? [true, $rule->{expr_coerce}] : $prev_term";
#                }
#            } else { 
#                if ($rule->{meta}{might_fail}) {
#                    $expr = "(function() { if ($rule->{expr_match}) { var _tmp1 = $rule->{expr_coerce}; if (_tmp1[0]) { return [true, _tmp1[0], null] } else { return [true, null, _tmp1[1]] } } else { return $prev_term } })()";
#                } else {
#                    $expr = "($rule->{expr_match}) ? [true, null, $rule->{expr_coerce}] : $prev_term";
#                }
#            }
#        }
#
#        $code = join(
#            "",
#            "function (data) {\n",
#            "    if (data === undefined || data === null) {\n",
#            "        ", ($rt eq 'val' ? "return null;" :
#                             $rt eq 'status+val' ? "return [null, null];" :
#                             "return [null, null, null];" 
#                         ), "\n",
#            "    }\n",
#            "    return ($expr);\n",
#            "}",
#        );
#    } else {
#        if ($rt eq 'val') {
#            $code = 'function (data) { return data }';
#        } elsif ($rt eq 'status+val') {
#            $code = 'function (data) { return [null, data] }';
#        } else {
#            $code = 'function (data) { return [null, null, data] }';
#        }
#    }
#
#    if ($Log_Coercer_Code) {
#        log_trace("Coercer code (gen args: %s): %s", \%args, $code);
#    }
#
#    return $code if $args{source};
#
#    state $nodejs_path = get_nodejs_path();
#    die "Can't find node.js in PATH" unless $nodejs_path;
#
#    sub {
#        require File::Temp;
#        require JSON;
#
#        my $data = shift;
#
#        state $json = JSON->new->allow_nonref;
#
#        my $src = "var coercer = $code;\n\n".
#            "console.log(JSON.stringify(coercer(".
#                $json->encode($data).")))";
#
#        my ($jsh, $jsfn) = File::Temp::tempfile();
#        print $jsh $src;
#        close($jsh) or die "Can't write JS code to file $jsfn: $!";
#
#        my $out = IPC::System::Options::readpipe($nodejs_path, $jsfn);
#        $json->decode($out);
#    };
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler.pm ###
#package Data::Sah::Compiler;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(default);
#use Role::Tiny::With;
#use Log::ger;
#use Scalar::Util qw(blessed);
#
#our %coercer_cache; 
#
#with 'Data::Sah::Compiler::TextResultRole';
#
#has main => (is => 'rw');
#
#has expr_compiler => (
#    is => 'rw',
#    lazy => 1,
#    default => sub {
#        require Language::Expr;
#        Language::Expr->new;
#    },
#);
#
#sub __linenum {
#    my ($str, $opts) = @_;
#    $opts //= {};
#    $opts->{width}      //= 4;
#    $opts->{zeropad}    //= 0;
#    $opts->{skip_empty} //= 1;
#
#    my $i = 0;
#        $str =~ s/^(([\t ]*\S)?.*)/
#        sprintf(join("",
#                     "%",
#                     ($opts->{zeropad} && !($opts->{skip_empty}
#                                                && !defined($2)) ? "0" : ""),
#                     $opts->{width}, "s",
#                     "|%s"),
#                ++$i && $opts->{skip_empty} && !defined($2) ? "" : $i,
#                $1)/meg;
#
#    $str;
#}
#
#sub name {
#    die "BUG: Please override name()";
#}
#
#sub literal {
#    die "BUG: Please override literal()";
#}
#
#sub expr {
#    die "BUG: Please override expr()";
#}
#
#sub _die {
#    my ($self, $cd, $msg) = @_;
#    die join(
#        "",
#        "Sah ". $self->name . " compiler: ",
#        "at schema:/", join("/", @{$cd->{spath} // []}), ": ",
#        $msg,
#    );
#}
#
#sub _form_deps {
#    require Language::Expr::Interpreter::VarEnumer;
#
#    my ($self, $cd, $ctbl) = @_;
#    my $main = $self->main;
#
#    my %depends;
#    for my $crec (values %$ctbl) {
#        my $cn = $crec->{name};
#        my $expr = defined($crec->{expr}) ? $crec->{value} :
#            $crec->{attrs}{expr};
#        if (defined $expr) {
#            my $vars = $main->_var_enumer->eval($expr);
#            for (@$vars) {
#                /^\w+$/ or $self->_die($cd,
#                    "Invalid variable syntax '$_', ".
#                        "currently only the form \$abc is supported");
#                $ctbl->{$_} or $self->_die($cd,
#                    "Unhandled clause specified in variable '$_'");
#            }
#            $depends{$cn} = $vars;
#            for (@$vars) {
#                push @{ $ctbl->{$_}{depended_by} }, $cn;
#            }
#        } else {
#            $depends{$cn} = [];
#        }
#    }
#    my %rsched = 
#        (); 
#    \%rsched;
#}
#
#sub _get_clauses_from_clsets {
#    my ($self, $cd, $clsets) = @_;
#    my $tn = $cd->{type};
#    my $th = $cd->{th};
#
#    my $deps;
#
#    my $sorter = sub {
#        my ($ia, $ca, $metaa) = @$a;
#        my ($ib, $cb, $metab) = @$b;
#        my $res;
#
#
#        {
#            $res = $metaa->{prio} <=> $metab->{prio};
#            last if $res;
#
#            my $sprioa = $clsets->[$ia]{"$ca.prio"} // 50;
#            my $spriob = $clsets->[$ib]{"$cb.prio"} // 50;
#            $res = $sprioa <=> $spriob;
#            last if $res;
#
#            $res = $ca cmp $cb;
#            last if $res;
#
#            $res = $ia <=> $ib;
#            last if $res;
#
#            $res = 0;
#        }
#
#        $res;
#    };
#
#    my @clauses;
#    for my $i (0..@$clsets-1) {
#        for my $k (grep {!/\A_/ && !/\./} keys %{$clsets->[$i]}) {
#            my $meta;
#            eval {
#                $meta = "Data::Sah::Type::$tn"->${\("clausemeta_$k")};
#            };
#            if ($@) {
#                for ($cd->{args}{on_unhandled_clause}) {
#                    my $msg = "Unhandled clause for type $tn: $k ($@)";
#                    next if $_ eq 'ignore';
#                    next if $_ eq 'warn'; 
#                    $self->_die($cd, $msg);
#                }
#            }
#            $meta //= {prio=>50};
#            push @clauses, [$i, $k, $meta];
#        }
#    }
#
#    my $res = [sort $sorter @clauses];
#    $res;
#}
#
#sub get_th {
#    my ($self, %args) = @_;
#    my $cd    = $args{cd};
#    my $name  = $args{name};
#
#    my $th_map = $cd->{th_map};
#    return $th_map->{$name} if $th_map->{$name};
#
#    if ($args{load} // 1) {
#        no warnings;
#        $self->_die($cd, "Invalid syntax for type name '$name', please use ".
#                        "letters/numbers/underscores only")
#            unless $name =~ $Data::Sah::type_re;
#        my $main = $self->main;
#        my $module = ref($self) . "::TH::$name";
#        if (!eval "require $module; 1") {
#            $self->_die($cd, "Can't load type handler $module".
#                            ($@ ? ": $@" : ""));
#        }
#        $self->add_compile_module($cd, $module, {category=>'type_handler'});
#
#        my $obj = $module->new(compiler=>$self);
#        $th_map->{$name} = $obj;
#    }
#    use experimental 'smartmatch';
#
#    return $th_map->{$name};
#}
#
#sub get_fsh {
#    my ($self, %args) = @_;
#    my $cd    = $args{cd};
#    my $name  = $args{name};
#
#    my $fsh_table = $cd->{fsh_table};
#    return $fsh_table->{$name} if $fsh_table->{$name};
#
#    if ($args{load} // 1) {
#        no warnings;
#        $self->_die($cd, "Invalid syntax for func set name '$name', ".
#                        "please use letters/numbers/underscores")
#            unless $name =~ $Data::Sah::funcset_re;
#        my $module = ref($self) . "::FSH::$name";
#        if (!eval "require $module; 1") {
#            $self->_die($cd, "Can't load func set handler $module".
#                            ($@ ? ": $@" : ""));
#        }
#
#        my $obj = $module->new();
#        $fsh_table->{$name} = $obj;
#    }
#    use experimental 'smartmatch';
#
#    return $fsh_table->{$name};
#}
#
#sub init_cd {
#    require Time::HiRes;
#
#    my ($self, %args) = @_;
#
#    my $cd = {};
#    $cd->{v} = 2;
#    $cd->{args} = \%args;
#    $cd->{compiler} = $self;
#    $cd->{compiler_name} = $self->name;
#
#    if (my $ocd = $args{outer_cd}) {
#        $cd->{is_inner}       = 1;
#
#        $cd->{outer_cd}     = $ocd;
#        $cd->{indent_level} = $ocd->{indent_level};
#        $cd->{th_map}       = { %{ $ocd->{th_map}  } };
#        $cd->{fsh_map}      = { %{ $ocd->{fsh_map} } };
#        $cd->{default_lang} = $ocd->{default_lang};
#        $cd->{spath}        = [@{ $ocd->{spath} }];
#    } else {
#        $cd->{indent_level} = $cd->{args}{indent_level} // 0;
#        $cd->{th_map}       = {};
#        $cd->{fsh_map}      = {};
#        $cd->{default_lang} = $ENV{LANG} || "en_US";
#        $cd->{default_lang} =~ s/\..+//; 
#        $cd->{spath}        = [];
#    }
#    $cd->{_id} = Time::HiRes::gettimeofday(); 
#    $cd->{ccls} = [];
#
#    $cd;
#}
#
#sub check_compile_args {
#    my ($self, $args) = @_;
#
#    return if $args->{_args_checked}++;
#
#    $args->{data_name} //= 'data';
#    $args->{data_name} =~ /\A[A-Za-z_]\w*\z/ or $self->_die(
#        {}, "Invalid syntax in data_name '$args->{data_name}', ".
#            "please use letters/nums only");
#    $args->{allow_expr} //= 1;
#    $args->{on_unhandled_attr}   //= 'die';
#    $args->{on_unhandled_clause} //= 'die';
#    $args->{skip_clause}         //= [];
#    $args->{mark_missing_translation} //= 1;
#    for ($args->{lang}) {
#        $_ //= $ENV{LANG} || $ENV{LANGUAGE} || "en_US";
#        s/\W.*//; 
#    }
#}
#
#sub _process_clause {
#    use experimental 'smartmatch';
#
#    my ($self, $cd, $clset_num, $clause) = @_;
#
#    my $th = $cd->{th};
#    my $tn = $cd->{type};
#    my $clsets = $cd->{clsets};
#
#    my $clset = $clsets->[$clset_num];
#    local $cd->{spath}       = [@{$cd->{spath}}, $clause];
#    local $cd->{clset}       = $clset;
#    local $cd->{clset_num}   = $clset_num;
#    local $cd->{uclset}      = $cd->{uclsets}[$clset_num];
#    local $cd->{clset_dlang} = $cd->{_clset_dlangs}[$clset_num];
#
#    delete $cd->{uclset}{$clause};
#    delete $cd->{uclset}{"$clause.prio"};
#
#    if ($clause ~~ @{ $cd->{args}{skip_clause} }) {
#        delete $cd->{uclset}{$_}
#            for grep {/^\Q$clause\E(\.|\z)/} keys(%{$cd->{uclset}});
#        return;
#    }
#
#    my $meth  = "clause_$clause";
#    my $mmeth = "clausemeta_$clause";
#    unless ($th->can($meth)) {
#        for ($cd->{args}{on_unhandled_clause}) {
#            next if $_ eq 'ignore';
#            do { warn "Can't handle clause $clause"; next }
#                if $_ eq 'warn';
#            $self->_die($cd, "Can't handle clause $clause");
#        }
#    }
#
#
#    my $meta;
#    if ($th->can($mmeth)) {
#        $meta = $th->$mmeth;
#    } else {
#        $meta = {};
#    }
#    local $cd->{cl_meta} = $meta;
#    $self->_die($cd, "Clause $clause doesn't allow expression")
#        if $clset->{"$clause.is_expr"} && !$meta->{allow_expr};
#    for my $a (keys %{ $meta->{attrs} }) {
#        my $av = $meta->{attrs}{$a};
#        $self->_die($cd, "Attribute $clause.$a doesn't allow ".
#                        "expression")
#            if $clset->{"$clause.$a.is_expr"} && !$av->{allow_expr};
#    }
#    local $cd->{clause} = $clause;
#    my $cv = $clset->{$clause};
#    my $ie = $clset->{"$clause.is_expr"};
#    my $op = $clset->{"$clause.op"};
#
#    local $cd->{cl_raw_value}   = $cv;
#
#    {
#        last if $ie;
#        my $coerce_type = $meta->{schema}[0] or last;
#        my $value_is_array;
#        if ($coerce_type eq '_same') {
#            $coerce_type = $cd->{type};
#        } elsif ($coerce_type eq '_same_elem') {
#            $coerce_type = $cd->{nschema}[1]{of} //
#                $cd->{nschema}[1]{each_elem} // 'any';
#        } elsif ($clause eq 'between' || $clause eq 'xbetween') { 
#            $coerce_type = $cd->{type};
#            $value_is_array = 1;
#        }
#        my $coercer = $coercer_cache{$coerce_type};
#        if (!$coercer) {
#            require Data::Sah::Coerce;
#            $coercer = Data::Sah::Coerce::gen_coercer(
#                type => $coerce_type,
#                return_type=>'status+err+val',
#                (coerce_to => $cd->{coerce_to}) x !!$cd->{coerce_to},
#            );
#            $coercer_cache{$coerce_type} = $coercer;
#        }
#        my ($cstatus, $cerr);
#        if ($op && ($op eq 'or' || $op eq 'and')) {
#            for my $cv2 (@$cv) {
#                if ($value_is_array) {
#                    $cv2 = [@$cv2]; 
#                    for (@$cv2) {
#                        ($cstatus, $cerr, $_) = @{ $coercer->($_) };
#                        if ($cerr) {
#                            $self->_die($cd, "Can't coerce clause value $_: $cerr");
#                        }
#                    }
#                } else {
#                    ($cstatus, $cerr, $cv) = @{ $coercer->($cv) };
#                    if ($cerr) {
#                        $self->_die($cd, "Can't coerce clause value $cv: $cerr");
#                    }
#                }
#            }
#        } else {
#            if ($value_is_array) {
#                $cv = [@$cv]; 
#                for (@$cv) {
#                    my $cf;
#                    ($cstatus, $cerr, $_) = @{ $coercer->($_) };
#                    if ($cerr) {
#                        $self->_die($cd, "Can't coerce clause value $_: $cerr");
#                    }
#                }
#            } else {
#                ($cstatus, $cerr, $cv) = @{ $coercer->($cv) };
#                if ($cerr) {
#                    $self->_die($cd, "Can't coerce clause value $cv: $cerr");
#                }
#            }
#        }
#    }
#
#    local $cd->{cl_value}   = $cv;
#    local $cd->{cl_term}    = $ie ? $self->expr($cv) : $self->literal($cv);
#    local $cd->{cl_is_expr} = $ie;
#    local $cd->{cl_op}      = $op;
#    delete $cd->{uclset}{"$clause.is_expr"};
#    delete $cd->{uclset}{"$clause.op"};
#
#    if ($self->can("before_clause")) {
#        $self->before_clause($cd);
#    }
#    if ($th->can("before_clause")) {
#        $th->before_clause($cd);
#    }
#    my $tmpnam = "before_clause_$clause";
#    if ($th->can($tmpnam)) {
#        $th->$tmpnam($cd);
#    }
#
#    my $is_multi;
#    if (defined($op) && !$ie) {
#        if ($op =~ /\A(and|or|none)\z/) {
#            $is_multi = 1;
#        } elsif ($op eq 'not') {
#            $is_multi = 0;
#        } else {
#            $self->_die($cd, "Invalid value for $clause.op, ".
#                            "must be one of and/or/not/none");
#        }
#    }
#    $self->_die($cd, "'$clause.op' attribute set to $op, ".
#                    "but value of '$clause' clause not an array")
#        if $is_multi && ref($cv) ne 'ARRAY';
#    if (!$th->can($meth)) {
#    } elsif ($cd->{CLAUSE_DO_MULTI} || !$is_multi) {
#        local $cd->{cl_is_multi} = 1 if $is_multi;
#        $th->$meth($cd);
#    } else {
#        my $i = 0;
#        for my $cv2 (@$cv) {
#            local $cd->{spath} = [@{ $cd->{spath} }, $i];
#            local $cd->{cl_value} = $cv2;
#            local $cd->{cl_term}  = $self->literal($cv2);
#            local $cd->{_debug_ccl_note} = "" if $i;
#            $i++;
#            $th->$meth($cd);
#        }
#    }
#
#    $tmpnam = "after_clause_$clause";
#    if ($th->can($tmpnam)) {
#        $th->$tmpnam($cd);
#    }
#    if ($th->can("after_clause")) {
#        $th->after_clause($cd);
#    }
#    if ($self->can("after_clause")) {
#        $self->after_clause($cd);
#    }
#
#    delete $cd->{uclset}{"$clause.err_msg"};
#    delete $cd->{uclset}{"$clause.err_level"};
#    delete $cd->{uclset}{$_} for
#        grep {/\A\Q$clause\E\.human(\..+)?\z/} keys(%{$cd->{uclset}});
#}
#
#sub _process_clsets {
#    my ($self, $cd, $which) = @_;
#
#
#    my $th = $cd->{th};
#    my $tn = $cd->{type};
#    my $clsets = $cd->{clsets};
#
#    my $cname = $self->name;
#    local $cd->{uclsets} = [];
#    $cd->{_clset_dlangs} = []; 
#    for my $clset (@$clsets) {
#        for (keys %$clset) {
#            if (!$cd->{args}{allow_expr} && /\.is_expr\z/ && $clset->{$_}) {
#                $self->_die($cd, "Expression not allowed: $_");
#            }
#        }
#        $cd->{coerce_to} //= $clset->{'x.perl.coerce_to'} if $clset->{'x.perl.coerce_to'};
#        push @{ $cd->{uclsets} }, {
#            map {$_=>$clset->{$_}}
#                grep {
#                    !/\A_|\._|\Ax\./ && (!/\Ac\./ || /\Ac\.\Q$cname\E\./)
#                } keys %$clset
#        };
#        my $dl = $clset->{default_lang} //
#            ($cd->{outer_cd} ? $cd->{outer_cd}{clset_dlang} : undef) //
#                "en_US";
#        push @{ $cd->{_clset_dlangs} }, $dl;
#    }
#
#    my $clauses = $self->_get_clauses_from_clsets($cd, $clsets);
#    $cd->{has_constraint_clause} = 0;
#    $cd->{has_subschema} = 0;
#    for my $cl (@$clauses) {
#        next if $cl->[1] =~ /\A(req|forbidden)\z/;
#        $cd->{has_subschema} = 1 if $cl->[2]{subschema};
#        if ($cl->[2]{tags} && grep {$_ eq 'constraint'} @{ $cl->[2]{tags} }) {
#            $cd->{has_constraint_clause} = 1;
#        }
#    }
#
#    if ($which) {
#        if ($self->can("before_clause_sets")) {
#            $self->before_clause_sets($cd);
#        }
#        if ($th->can("before_clause_sets")) {
#            $th->before_clause_sets($cd);
#        }
#    } else {
#        if ($self->can("before_handle_type")) {
#            $self->before_handle_type($cd);
#        }
#
#        $th->handle_type($cd);
#
#        if ($self->can("before_all_clauses")) {
#            $self->before_all_clauses($cd);
#        }
#        if ($th->can("before_all_clauses")) {
#            $th->before_all_clauses($cd);
#        }
#    }
#
#    for my $clause0 (@$clauses) {
#        my ($clset_num, $clause) = @$clause0;
#        $self->_process_clause($cd, $clset_num, $clause);
#    } 
#
#    for my $uclset (@{ $cd->{uclsets} }) {
#        if (keys %$uclset) {
#            for ($cd->{args}{on_unhandled_attr}) {
#                my $msg = "Unhandled attribute(s) for type $tn: ".
#                    join(", ", keys %$uclset);
#                next if $_ eq 'ignore';
#                do { warn $msg; next } if $_ eq 'warn';
#                $self->_die($cd, $msg);
#            }
#        }
#    }
#
#    if ($which) {
#        if ($th->can("after_clause_sets")) {
#            $th->after_clause_sets($cd);
#        }
#        if ($self->can("after_clause_sets")) {
#            $self->after_clause_sets($cd);
#        }
#    } else {
#        if ($th->can("after_all_clauses")) {
#            $th->after_all_clauses($cd);
#        }
#        if ($self->can("after_all_clauses")) {
#            $self->after_all_clauses($cd);
#        }
#    }
#}
#
#sub compile {
#    my ($self, %args) = @_;
#
#    $self->check_compile_args(\%args);
#
#    my $main   = $self->main;
#    my $cd     = $self->init_cd(%args);
#
#    if ($self->can("before_compile")) {
#        $self->before_compile($cd);
#    }
#
#    my $schema0 = $args{schema} or $self->_die($cd, "No schema");
#    my $nschema;
#    if ($args{schema_is_normalized}) {
#        $nschema = $schema0;
#    } else {
#        $nschema = $main->normalize_schema($schema0);
#    }
#    $cd->{nschema} = $nschema;
#    local $cd->{schema} = $nschema;
#
#    {
#        my $defs = $nschema->[2]{def};
#        if ($defs) {
#            for my $name (sort keys %$defs) {
#                my $def = $defs->{$name};
#                my $opt = $name =~ s/[?]\z//;
#                local $cd->{def_optional} = $opt;
#                local $cd->{def_name}     = $name;
#                $self->_die($cd, "Invalid name syntax in def: '$name'")
#                    unless $name =~ $Data::Sah::type_re;
#                local $cd->{def_def}      = $def;
#                $self->def($cd);
#            }
#        }
#    }
#
#    require Data::Sah::Resolve;
#    my $res       = Data::Sah::Resolve::resolve_schema(
#        {
#            schema_is_normalized => 1,
#        }, $nschema);
#    my $tn        = $res->[0];
#    $cd->{th}     = $self->get_th(name=>$tn, cd=>$cd);
#    $cd->{type}   = $tn;
#    $cd->{clsets} = $res->[1];
#    if ($nschema->[0] ne $tn) {
#        $self->add_compile_module($cd, "Sah::Schema::$nschema->[0]");
#    }
#
#    $self->_process_clsets($cd);
#
#    if ($self->can("after_compile")) {
#        $self->after_compile($cd);
#    }
#
#    if ($args{log_result}) {
#        log_trace(
#            "Schema compilation result:\n%s",
#            !ref($cd->{result}) && ($ENV{LINENUM} // 1) ?
#                __linenum($cd->{result}) :
#                $cd->{result}
#            );
#    }
#    return $cd;
#}
#
#sub def {
#    my ($self, $cd) = @_;
#    my $name = $cd->{def_name};
#    my $def  = $cd->{def_def};
#    my $opt  = $cd->{def_optional};
#
#    my $th = $self->get_th(cd=>$cd, name=>$name, load=>0);
#    if ($th) {
#        if ($opt) {
#            return;
#        }
#        $self->_die($cd, "Redefining existing type ($name) not allowed");
#    }
#
#    my $nschema = $self->main->normalize_schema($def);
#    $cd->{th_map}{$name} = $nschema;
#}
#
#sub _ignore_clause {
#    my ($self, $cd) = @_;
#    my $cl = $cd->{clause};
#    delete $cd->{uclset}{$cl};
#}
#
#sub _ignore_clause_and_attrs {
#    my ($self, $cd) = @_;
#    my $cl = $cd->{clause};
#    delete $cd->{uclset}{$cl};
#    delete $cd->{uclset}{$_} for grep {/\A\Q$cl\E\./} keys %{$cd->{uclset}};
#}
#
#sub _die_unimplemented_clause {
#    my ($self, $cd, $note) = @_;
#
#    $self->_die($cd, "Clause '$cd->{clause}' for type '$cd->{type}' ".
#                    ($note ? "($note) " : "") .
#                        "is currently unimplemented");
#}
#
#sub add_module {
#    my ($self, $cd, $name, $extra_keys, $allow_duplicate) = @_;
#
#    my $found;
#    for (@{ $cd->{modules} }) {
#        if ($_->{name} eq $name && $_->{phase} eq $extra_keys->{phase}) {
#            $found++;
#            last;
#        }
#    }
#    return if $found && !$allow_duplicate;
#    push @{ $cd->{modules} }, {
#        name => $name,
#        %{ $extra_keys // {} },
#    };
#}
#
#sub add_runtime_module {
#    my ($self, $cd, $name, $extra_keys, $allow_duplicate) = @_;
#
#    if ($extra_keys) {
#        $extra_keys = { %$extra_keys, phase => 'runtime' };
#    } else {
#        $extra_keys = { phase => 'runtime' };
#    }
#    $self->add_module($cd, $name, $extra_keys, $allow_duplicate);
#}
#
#sub add_compile_module {
#    my ($self, $cd, $name, $extra_keys, $allow_duplicate) = @_;
#
#    if ($extra_keys) {
#        $extra_keys = { %$extra_keys, phase => 'compile' };
#    } else {
#        $extra_keys = { phase => 'compile' };
#    }
#    $self->add_module($cd, $name, $extra_keys, $allow_duplicate);
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/Prog.pm ###
#package Data::Sah::Compiler::Prog;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Log::ger;
#
#use Mo qw(build default);
#extends 'Data::Sah::Compiler';
#
#
#has hc => (is => 'rw');
#
#has comment_style => (is => 'rw');
#
#has var_sigil => (is => 'rw');
#
#has concat_op => (is => 'rw');
#
#has logical_and_op => (is => 'rw', default => sub {'&&'});
#
#has logical_not_op => (is => 'rw', default => sub {'!'});
#
#
#sub init_cd {
#    my ($self, %args) = @_;
#
#    my $cd = $self->SUPER::init_cd(%args);
#    $cd->{vars} = {};
#
#    my $hc = $self->hc;
#    if (!$hc) {
#        $hc = $self->main->get_compiler("human");
#        $self->hc($hc);
#    }
#
#    if (my $ocd = $cd->{outer_cd}) {
#        $cd->{vars}    = $ocd->{vars};
#        $cd->{modules} = $ocd->{modules};
#        $cd->{_hc}     = $ocd->{_hc};
#        $cd->{_hcd}    = $ocd->{_hcd};
#        $cd->{_subdata_level} = $ocd->{_subdata_level};
#        $cd->{use_dpath} = 1 if $ocd->{use_dpath};
#    } else {
#        $cd->{vars}    = {};
#        $cd->{modules} = [];
#        $cd->{_hc}     = $hc;
#        $cd->{_subdata_level} = 0;
#    }
#
#    $cd;
#}
#
#sub check_compile_args {
#    my ($self, $args) = @_;
#
#    return if $args->{_args_checked_Prog}++;
#
#    $self->SUPER::check_compile_args($args);
#
#    my $ct = ($args->{code_type} //= 'validator');
#    if ($ct ne 'validator') {
#        $self->_die({}, "code_type currently can only be 'validator'");
#    }
#    my $rt = ($args->{return_type} //= 'bool');
#    if ($rt !~ /\A(bool\+val|bool|str\+val|str|full)\z/) {
#        $self->_die({}, "Invalid value for return_type, ".
#                        "use bool|bool+val|str|str+val|full");
#    }
#    $args->{var_prefix} //= "_sahv_";
#    $args->{sub_prefix} //= "_sahs_";
#    $args->{data_term}  //= $self->var_sigil . $args->{data_name};
#    $args->{data_term_is_lvalue} //= 1;
#    $args->{tmp_data_name} //= "tmp_$args->{data_name}";
#    $args->{tmp_data_term} //= $self->var_sigil . $args->{tmp_data_name};
#    $args->{comment}    //= 1;
#    $args->{err_term}   //= $self->var_sigil . "err_$args->{data_name}";
#    $args->{coerce}     //= 1;
#}
#
#sub comment {
#    my ($self, $cd, @args) = @_;
#    return '' unless $cd->{args}{comment};
#
#    my $content = join("", @args);
#    $content =~ s/\n+/ /g;
#
#    my $style = $self->comment_style;
#    if ($style eq 'shell') {
#        return join("", "# ", $content, "\n");
#    } elsif ($style eq 'shell2') {
#        return join("", "## ", $content, "\n");
#    } elsif ($style eq 'cpp') {
#        return join("", "// ", $content, "\n");
#    } elsif ($style eq 'c') {
#        return join("", "/* ", $content, '*/');
#    } elsif ($style eq 'ini') {
#        return join("", "; ", $content, "\n");
#    } else {
#        $self->_die($cd, "BUG: Unknown comment style: $style");
#    }
#}
#
#sub enclose_paren {
#    my ($self, $expr, $force) = @_;
#    if ($expr =~ /\A(\s*)(\(.+\)\s*)\z/os) {
#        return $expr if !$force;
#        return "$1($2)";
#    } else {
#        $expr =~ /\A(\s*)(.*)/os;
#        return "$1($2)";
#    }
#}
#
#sub add_var {
#    my ($self, $cd, $name, $value) = @_;
#
#    return if exists $cd->{vars}{$name};
#    $cd->{vars}{$name} = $value;
#}
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#sub expr_assign {
#    my ($self, $v, $t) = @_;
#    "$v = $t";
#}
#
#sub _xlt {
#    my ($self, $cd, $text) = @_;
#
#    my $hc  = $cd->{_hc};
#    my $hcd = $cd->{_hcd};
#    $hc->_xlt($hcd, $text);
#}
#
#sub expr_concat {
#    my ($self, @t) = @_;
#    join(" " . $self->concat_op . " ", @t);
#}
#
#sub expr_var {
#    my ($self, $v) = @_;
#    $self->var_sigil. $v;
#}
#
#sub expr_preinc {
#    my ($self, $t) = @_;
#    "++$t";
#}
#
#sub expr_preinc_var {
#    my ($self, $v) = @_;
#    "++" . $self->var_sigil. $v;
#}
#
#
#sub expr_validator_sub {
#    my ($self, %args) = @_;
#
#    my $log_result = delete $args{log_result};
#    my $dt         = $args{data_term};
#    my $vt         = delete($args{var_term}) // $dt;
#    my $do_log     = $args{debug_log} // $args{debug};
#    my $rt         = $args{return_type} // 'bool';
#
#    $args{indent_level} = 1;
#
#    my $cd = $self->compile(%args);
#    my $et = $cd->{args}{err_term};
#
#    if ($rt !~ /\Abool/) {
#        my ($ev) = $et =~ /(\w+)/; 
#        $self->add_var($cd, $ev, $rt =~ /\Astr/ ? undef : {});
#    }
#    my $resv = '_sahv_res';
#    my $rest = $self->var_sigil . $resv;
#
#    my $needs_expr_block = (grep {$_->{phase} eq 'runtime'} @{ $cd->{modules} })
#                                || $do_log;
#
#    my $code = join(
#        "",
#        ($self->stmt_require_log_module."\n") x !!$do_log,
#        (map { $self->stmt_require_module($_)."\n" }
#             grep { $_->{phase} eq 'runtime' } @{ $cd->{modules} }),
#        $self->expr_anon_sub(
#            [$vt],
#            join(
#                "",
#                (map {$self->stmt_declare_local_var(
#                    $_, $self->literal($cd->{vars}{$_}))."\n"}
#                     sort keys %{ $cd->{vars} }),
#                $self->stmt_declare_local_var($resv, "\n\n" . $cd->{result})."\n\n",
#
#                ($self->stmt_return($rest)."\n")
#                    x !!($rt eq 'bool'),
#
#                ($self->expr_set_err_str($et, $self->literal('')).";",
#                 "\n\n".$self->stmt_return($et)."\n")
#                    x !!($rt eq 'str'),
#
#                ($self->stmt_return($self->expr_array($rest, $dt))."\n")
#                    x !!($rt eq 'bool+val'),
#
#                ($self->expr_set_err_str($et, $self->literal('')).";",
#                 "\n\n".$self->stmt_return($self->expr_array($et, $dt))."\n")
#                    x !!($rt eq 'str+val'),
#
#                ($self->stmt_assign_hash_value($et, $self->literal('value'), $dt),
#                 "\n".$self->stmt_return($et)."\n")
#                    x !!($rt eq 'full'),
#            )
#        ),
#    );
#
#    if ($needs_expr_block) {
#        $code = $self->expr_block($code);
#    }
#
#    if ($log_result && log_is_trace()) {
#        log_trace("validator code:\n%s",
#                     ($ENV{LINENUM} // 1) ?
#                         Data::Sah::Compiler::__linenum($code) :
#                           $code);
#    }
#
#    $code;
#}
#
#sub add_ccl {
#    my ($self, $cd, $ccl, $opts) = @_;
#    $opts //= {};
#    my $clause = $cd->{clause} // "";
#    my $op     = $cd->{cl_op} // "";
#
#    my $el = $opts->{err_level} // $cd->{clset}{"$clause.err_level"} // "error";
#    my $err_expr = $opts->{err_expr};
#    my $err_msg  = $opts->{err_msg};
#
#    if (defined $err_expr) {
#        $self->add_var($cd, '_sahv_dpath', []) if $cd->{use_dpath};
#        $err_expr = $self->expr_prefix_dpath($err_expr) if $cd->{use_dpath};
#    } else {
#        unless (defined $err_msg) { $err_msg = $cd->{clset}{"$clause.err_msg"} }
#        unless (defined $err_msg) {
#
#            my @msgpath = @{$cd->{spath}};
#            my $msgpath;
#            my $hc  = $cd->{_hc};
#            my $hcd = $cd->{_hcd};
#            while (1) {
#                last unless @msgpath;
#                $msgpath = join("/", @msgpath);
#                my $ccls = $hcd->{result}{$msgpath};
#                pop @msgpath;
#                if ($ccls) {
#                    local $hcd->{args}{format} = 'inline_err_text';
#                    $err_msg = $hc->format_ccls($hcd, $ccls);
#                    $err_msg = "(msgpath=$msgpath) $err_msg"
#                        if $cd->{args}{debug};
#                    last;
#                }
#            }
#            if (!$err_msg) {
#                $err_msg = "ERR (clause=".($cd->{clause} // "").")";
#            } else {
#                $err_msg = ucfirst($err_msg);
#            }
#        }
#        if ($err_msg) {
#            $self->add_var($cd, '_sahv_dpath', []) if $cd->{use_dpath};
#            $err_expr = $self->literal($err_msg);
#            $err_expr = $self->expr_prefix_dpath($err_expr) if $cd->{use_dpath};
#        }
#    }
#
#    my $rt = $cd->{args}{return_type};
#    my $et = $cd->{args}{err_term};
#    my $err_code;
#    if ($rt eq 'full') {
#        $self->add_var($cd, '_sahv_dpath', []) if $cd->{use_dpath};
#        my $k = $el eq 'warn' ? 'warnings' : 'errors';
#        $err_code = $self->expr_set_err_full($et, $k, $err_expr) if $err_expr;
#    } elsif ($rt =~ /\Astr/) {
#        if ($el ne 'warn') {
#            $err_code = $self->expr_set_err_str($et, $err_expr) if $err_expr;
#        }
#    }
#
#    my $res = {
#        ccl             => $ccl,
#        err_level       => $el,
#        err_code        => $err_code,
#        (_debug_ccl_note => $cd->{_debug_ccl_note}) x !!$cd->{_debug_ccl_note},
#        subdata         => $opts->{subdata},
#    };
#    push @{ $cd->{ccls} }, $res;
#    delete $cd->{uclset}{"$clause.err_level"};
#    delete $cd->{uclset}{"$clause.err_msg"};
#}
#
#sub join_ccls {
#    my ($self, $cd, $ccls, $opts) = @_;
#    $opts //= {};
#    my $op = $opts->{op} // "and";
#
#    my ($min_ok, $max_ok, $min_nok, $max_nok);
#    if ($op eq 'and') {
#        $max_nok = 0;
#    } elsif ($op eq 'or') {
#        $min_ok = 1;
#    } elsif ($op eq 'none') {
#        $max_ok = 0;
#    } elsif ($op eq 'not') {
#
#    }
#    my $dmin_ok  = defined($min_ok);
#    my $dmax_ok  = defined($max_ok);
#    my $dmin_nok = defined($min_nok);
#    my $dmax_nok = defined($max_nok);
#
#    return "" unless @$ccls;
#
#    my $rt      = $cd->{args}{return_type};
#    my $vp      = $cd->{args}{var_prefix};
#
#    my $aop = $self->logical_and_op;
#    my $nop = $self->logical_not_op;
#
#    my $true = $self->true;
#
#    my $_ice = sub {
#        my ($ccl, $which) = @_;
#
#        return $self->enclose_paren($ccl->{ccl}) if $ccl->{assert};
#
#        my $res = "";
#
#        if ($ccl->{_debug_ccl_note}) {
#            if ($cd->{args}{debug_log} // $cd->{args}{debug}) {
#                $res .= $self->expr_log(
#                    $cd, $self->literal($ccl->{_debug_ccl_note})) . " $aop\n";
#            } else {
#                $res .= $self->comment($cd, $ccl->{_debug_ccl_note});
#            }
#        }
#
#        $which //= 0;
#        my $cc = ($which == 1 ? $nop:"") . $self->enclose_paren($ccl->{ccl});
#        my ($ec, $oec);
#        my ($ret, $oret);
#        if ($which >= 2) {
#            my @chk;
#            if ($ccl->{err_level} eq 'warn') {
#                $oret = 1;
#                $ret  = 1;
#            } elsif ($ccl->{err_level} eq 'fatal') {
#                $oret = 1;
#                $ret  = 0;
#            } else {
#                $oret = $self->expr_preinc_var("${vp}ok");
#                $ret  = $self->expr_preinc_var("${vp}nok");
#                push @chk, $self->expr_var("${vp}ok"). " <= $max_ok"
#                    if $dmax_ok;
#                push @chk, $self->expr_var("${vp}nok")." <= $max_nok"
#                    if $dmax_nok;
#                if ($which == 3) {
#                    push @chk, $self->expr_var("${vp}ok"). " >= $min_ok"
#                        if $dmin_ok;
#                    push @chk, $self->expr_var("${vp}nok")." >= $min_nok"
#                        if $dmin_nok;
#
#                    if ($rt !~ /\Abool/) {
#                        my $et = $cd->{args}{err_term};
#                        my $clerrc;
#                        if ($rt eq 'full') {
#                            $clerrc = $self->expr_reset_err_full($et);
#                        } else {
#                            $clerrc = $self->expr_reset_err_str($et);
#                        }
#                        push @chk, $clerrc;
#                    }
#                }
#            }
#            $res .= "($cc ? $oret : $ret)";
#            $res .= " $aop " . join(" $aop ", @chk) if @chk;
#        } else {
#            $ec = $ccl->{err_code};
#            $ret =
#                $ccl->{err_level} eq 'fatal' ? 0 :
#                        $ccl->{err_level} eq 'warn' ? 1 : 0;
#            if ($rt =~ /\Abool/ && $ret) {
#                $res .= $true;
#            } elsif ($rt =~ /\Abool/ || !$ec) {
#                $res .= $self->enclose_paren($cc);
#            } else {
#                $res .= $self->enclose_paren(
#                    $self->enclose_paren($cc). " ? $true : ($ec,$ret)",
#                    "force");
#            }
#        }
#
#        $res = $self->expr_push_and_pop_dpath_between_expr($res)
#            if $cd->{use_dpath} && $ccl->{subdata};
#        $res;
#
#    };
#
#    my $j = "\n\n$aop\n\n";
#    if ($op eq 'not') {
#        return $_ice->($ccls->[0], 1);
#    } elsif ($op eq 'and') {
#        return join $j, map { $_ice->($_) } @$ccls;
#    } elsif ($op eq 'none') {
#        return join $j, map { $_ice->($_, 1) } @$ccls;
#    } else {
#        my $jccl = join $j, map {$_ice->($ccls->[$_], $_ == @$ccls-1 ? 3:2)}
#            0..@$ccls-1;
#        {
#            local $cd->{ccls} = [];
#            local $cd->{_debug_ccl_note} = "op=$op";
#            $self->add_ccl(
#                $cd,
#                $self->expr_block(
#                    join(
#                        "",
#                        $self->stmt_declare_local_var("${vp}ok" , "0"), "\n",
#                        $self->stmt_declare_local_var("${vp}nok", "0"), "\n",
#                        "\n",
#                        $self->block_uses_sub ?
#                            $self->stmt_return($jccl) : $jccl,
#                    )
#                ),
#            );
#            $_ice->($cd->{ccls}[0]);
#        }
#    }
#}
#
#sub before_compile {
#    my ($self, $cd) = @_;
#
#    if ($cd->{args}{data_term_is_lvalue}) {
#        $cd->{data_term} = $cd->{args}{data_term};
#    } else {
#        my $v = $cd->{args}{var_prefix} . $cd->{args}{data_name};
#        push @{ $cd->{vars} }, $v; 
#        $cd->{data_term} = $self->var_sigil . $v;
#        die "BUG: support for non-perl compiler not yet added here"
#            unless $cd->{compiler_name} eq 'perl';
#        push @{ $cd->{ccls} }, ["(local($cd->{data_term} = $cd->{args}{data_term}), 1)"];
#    }
#}
#
#sub before_handle_type {
#    my ($self, $cd) = @_;
#
#
#    unless ($cd->{is_inner}) {
#        my $hc = $cd->{_hc};
#        my %hargs = %{$cd->{args}};
#        $hargs{format}               = 'msg_catalog';
#        $hargs{schema_is_normalized} = 1;
#        $hargs{schema}               = $cd->{nschema};
#        $hargs{on_unhandled_clause}  = 'ignore';
#        $hargs{on_unhandled_attr}    = 'ignore';
#        $hargs{hash_values}          = $cd->{args}{human_hash_values};
#        $cd->{_hcd} = $hc->compile(%hargs);
#    }
#}
#
#sub before_all_clauses {
#    my ($self, $cd) = @_;
#
#    my $rt = $cd->{args}{return_type};
#    my $rt_is_full = $rt =~ /\Afull/;
#    my $rt_is_str  = $rt =~ /\Astr/;
#
#    $cd->{use_dpath} //= (
#        $rt_is_full ||
#        ($rt_is_str && $cd->{has_subschema})
#    );
#
#
#    my $c      = $cd->{compiler};
#    my $cname  = $c->name;
#    my $dt     = $cd->{data_term};
#    my $et     = $cd->{args}{err_term};
#    my $clsets = $cd->{clsets};
#
#    for my $i (0..@$clsets-1) {
#        my $clset  = $clsets->[$i];
#        next unless exists $clset->{ok};
#        my $op = $clset->{"ok.op"} // "";
#        if ($op && $op ne 'not') {
#            $self->_die($cd, "ok can only be combined with .op=not");
#        }
#        if ($op eq 'not') {
#            local $cd->{_debug_ccl_note} = "!ok #$i";
#            $self->add_ccl($cd, $self->false);
#        } else {
#            local $cd->{_debug_ccl_note} = "ok #$i";
#            $self->add_ccl($cd, $self->true);
#        }
#        delete $cd->{uclsets}[$i]{"ok"};
#        delete $cd->{uclsets}[$i]{"ok.is_expr"};
#    }
#
#    for my $i (0..@$clsets-1) {
#        my $clset  = $clsets->[$i];
#        my $def    = $clset->{default};
#        my $defie  = $clset->{"default.is_expr"};
#        if (defined $def) {
#            local $cd->{_debug_ccl_note} = "default #$i";
#            my $ct = $defie ?
#                $self->expr($def) : $self->literal($def);
#            $self->add_ccl(
#                $cd,
#                $self->expr_list(
#                    $self->expr_setif($dt, $ct),
#                    $self->true,
#                ),
#                {err_msg => ""},
#            );
#        }
#        delete $cd->{uclsets}[$i]{"default"};
#        delete $cd->{uclsets}[$i]{"default.is_expr"};
#    }
#
#    my $has_req;
#    for my $i (0..@$clsets-1) {
#        my $clset  = $clsets->[$i];
#        my $req    = $clset->{req};
#        my $reqie  = $clset->{"req.is_expr"};
#        my $req_err_msg = $self->_xlt($cd, "Required but not specified");
#        local $cd->{_debug_ccl_note} = "req #$i";
#        if ($req && !$reqie) {
#            $has_req++;
#            $self->add_ccl(
#                $cd, $self->expr_defined($dt),
#                {
#                    err_msg   => $req_err_msg,
#                    err_level => 'fatal',
#                },
#            );
#        } elsif ($reqie) {
#            $has_req++;
#            my $ct = $self->expr($req);
#            $self->add_ccl(
#                $cd, "!($ct) || ".$self->expr_defined($dt),
#                {
#                    err_msg   => $req_err_msg,
#                    err_level => 'fatal',
#                },
#            );
#        }
#        delete $cd->{uclsets}[$i]{"req"};
#        delete $cd->{uclsets}[$i]{"req.is_expr"};
#    }
#
#    my $has_fbd;
#    for my $i (0..@$clsets-1) {
#        my $clset  = $clsets->[$i];
#        my $fbd    = $clset->{forbidden};
#        my $fbdie  = $clset->{"forbidden.is_expr"};
#        my $fbd_err_msg = $self->_xlt($cd, "Forbidden but specified");
#        local $cd->{_debug_ccl_note} = "forbidden #$i";
#        if ($fbd && !$fbdie) {
#            $has_fbd++;
#            $self->add_ccl(
#                $cd, "!".$self->expr_defined($dt),
#                {
#                    err_msg   => $fbd_err_msg,
#                    err_level => 'fatal',
#                },
#            );
#        } elsif ($fbdie) {
#            $has_fbd++;
#            my $ct = $self->expr($fbd);
#            $self->add_ccl(
#                $cd, "!($ct) || !".$self->expr_defined($dt),
#                {
#                    err_msg   => $fbd_err_msg,
#                    err_level => 'fatal',
#                },
#            );
#        }
#        delete $cd->{uclsets}[$i]{"forbidden"};
#        delete $cd->{uclsets}[$i]{"forbidden.is_expr"};
#    }
#
#    if (!$has_req && !$has_fbd) {
#        $cd->{_skip_undef} = 1;
#        $cd->{_ccls_idx1} = @{$cd->{ccls}};
#    }
#
#    my $coerce_expr;
#    my $coerce_might_fail;
#    my $coerce_ccl_note;
#  GEN_COERCE_EXPR:
#    {
#        last unless $cd->{args}{coerce};
#
#        require Data::Sah::CoerceCommon;
#
#        my @coerce_rules;
#        for my $i (0..@$clsets-1) {
#            my $clset = $clsets->[$i];
#            push @coerce_rules,
#                @{ $clset->{"x.$cname.coerce_rules"} // [] },
#                @{ $clset->{'x.coerce_rules'} // [] };
#        }
#
#        my $rules = Data::Sah::CoerceCommon::get_coerce_rules(
#            compiler => $self->name,
#            type => $cd->{type},
#            data_term => $dt,
#            coerce_to => $cd->{coerce_to},
#            coerce_rules => \@coerce_rules,
#        );
#        last unless @$rules;
#
#        $coerce_might_fail = 1 if grep { $_->{meta}{might_fail} } @$rules;
#
#        my $prev_term;
#        for my $i (reverse 0..$#{$rules}) {
#            my $rule = $rules->[$i];
#
#            $self->add_compile_module(
#                $cd, "Data::Sah::Coerce::$cname\::$cd->{type}::$rule->{name}",
#                {category => 'coerce'},
#            );
#
#            if ($rule->{modules}) {
#                for my $mod (keys %{ $rule->{modules} }) {
#                    my $modspec = $rule->{modules}{$mod};
#                    $modspec = {version=>$modspec} unless ref $modspec eq 'HASH';
#                    $self->add_runtime_module($cd, $mod, {category=>'coerce', %$modspec});
#                }
#            }
#
#            if ($i == $#{$rules}) {
#                if ($coerce_might_fail) {
#                    $prev_term = $self->expr_array($self->literal(undef), $dt);
#                } else {
#                    $prev_term = $dt;
#                }
#            } else {
#                $prev_term = "($coerce_expr)";
#            }
#
#            my $ec;
#            if ($coerce_might_fail && !$rule->{meta}{might_fail}) {
#                $ec = $self->expr_array($self->literal(undef), $rule->{expr_coerce});
#            } else {
#                $ec = "($rule->{expr_coerce})";
#            }
#
#            $coerce_expr = $self->expr_ternary(
#                "($rule->{expr_match})",
#                $ec,
#                $prev_term,
#            );
#        }
#        $coerce_ccl_note = "coerce rule(s): ".
#            join(", ", map {$_->{name}} @$rules) .
#            ($cd->{coerce_to} ? " # coerce to: $cd->{coerce_to}" : "");
#    } 
#
#  HANDLE_TYPE_CHECK:
#    {
#        $self->_die($cd, "BUG: type handler did not produce _ccl_check_type")
#            unless defined($cd->{_ccl_check_type});
#        local $cd->{_debug_ccl_note};
#
#
#        if ($coerce_expr) {
#            $cd->{_debug_ccl_note} = $coerce_ccl_note;
#            if ($coerce_might_fail) {
#
#                my $expr_fail;
#                if ($rt_is_full) {
#                    $expr_fail = $self->expr_list(
#                        $self->expr_set_err_full($et, 'errors', $self->expr_array_subscript($dt, 0)),
#                        $self->expr_set($dt, $self->literal(undef)),
#                        $self->false,
#                    );
#                } elsif ($rt_is_str) {
#                    $expr_fail = $self->expr_list(
#                        $self->expr_set_err_str($et, $self->expr_array_subscript($dt, 0)),
#                        $self->false,
#                    );
#                } else {
#                    $expr_fail = $self->false;
#                }
#
#                $self->add_ccl(
#                    $cd,
#                    $self->expr_list(
#                        $self->expr_set($dt, $coerce_expr),
#                        $self->expr_ternary(
#                            $self->expr_defined($self->expr_array_subscript($dt, 0)),
#                            $expr_fail,
#                            $self->expr_list(
#                                $self->expr_set($dt, $self->expr_array_subscript($dt, 1)),
#                                $self->true,
#                            )
#                        ),
#                    ),
#                    {
#                        err_msg => "",
#                        err_level => "fatal",
#                    },
#                );
#            } else {
#                $self->add_ccl(
#                    $cd,
#                    $self->expr_list(
#                        $self->expr_set($dt, $coerce_expr),
#                        $self->true,
#                    ),
#                    {
#                        err_msg => "",
#                        err_level => "fatal",
#                    },
#                );
#            }
#        }
#
#        $cd->{_debug_ccl_note} = "check type '$cd->{type}'";
#        $self->add_ccl(
#            $cd, $cd->{_ccl_check_type},
#            {
#                err_msg   => sprintf(
#                    $self->_xlt($cd, "Not of type %s"),
#                    $self->_xlt(
#                        $cd,
#                        $cd->{_hc}->get_th(name=>$cd->{type})->name //
#                            $cd->{type}
#                        ),
#                ),
#                err_level => 'fatal',
#            },
#        );
#    }
#}
#
#sub before_clause {
#    my ($self, $cd) = @_;
#
#    $self->_die($cd, "Sorry, .op + .is_expr not yet supported ".
#                    "(found in clause $cd->{clause})")
#        if $cd->{cl_is_expr} && $cd->{cl_op};
#
#    if ($cd->{args}{debug}) {
#        state $json = do {
#            require JSON;
#            JSON->new->allow_nonref;
#        };
#        my $clset = $cd->{clset};
#        my $cl    = $cd->{clause};
#        my $res   = $json->encode({
#            map { $_ => $clset->{$_}}
#                grep {/\A\Q$cl\E(?:\.|\z)/}
#                    keys %$clset });
#        $res =~ s/\n+/ /g;
#        $cd->{_debug_ccl_note} = "clause: $res";
#    } else {
#        $cd->{_debug_ccl_note} = "clause: $cd->{clause}";
#    }
#
#
#    push @{ $cd->{_save_ccls} }, $cd->{ccls};
#    $cd->{ccls} = [];
#}
#
#sub after_clause {
#    my ($self, $cd) = @_;
#
#    if ($cd->{args}{debug}) {
#        delete $cd->{_debug_ccl_note};
#    }
#
#    my $save = pop @{ $cd->{_save_ccls} };
#    if (@{ $cd->{ccls} }) {
#        push @$save, {
#            ccl       => $self->join_ccls($cd, $cd->{ccls}, {op=>$cd->{cl_op}}),
#            err_level => $cd->{clset}{"$cd->{clause}.err_level"} // "error",
#        }
#    }
#    $cd->{ccls} = $save;
#}
#
#sub after_clause_sets {
#    my ($self, $cd) = @_;
#
#    $cd->{result} = $self->indent(
#        $cd,
#        $self->join_ccls($cd, $cd->{ccls}, {err_msg => ''}),
#    );
#}
#
#sub after_all_clauses {
#    my ($self, $cd) = @_;
#
#
#    if (delete $cd->{_skip_undef}) {
#        my $jccl = $self->join_ccls(
#            $cd,
#            [splice(@{ $cd->{ccls} }, $cd->{_ccls_idx1})],
#        );
#        local $cd->{_debug_ccl_note} = "skip if undef";
#        $self->add_ccl(
#            $cd,
#            "!".$self->expr_defined($cd->{data_term})." ? ".$self->true." : \n\n".
#                $self->enclose_paren($jccl),
#            {err_msg => ''},
#        );
#    }
#
#    $cd->{result} = $self->indent(
#        $cd,
#        $self->join_ccls($cd, $cd->{ccls}, {err_msg => ''}),
#    );
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/Prog/TH.pm ###
#package Data::Sah::Compiler::Prog::TH;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#
#extends 'Data::Sah::Compiler::TH';
#
#
#sub clause_default {}
#sub clause_ok {}
#sub clause_req {}
#sub clause_forbidden {}
#sub clause_prefilters {}
#
#
#
#sub clause_name {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause_and_attrs($cd);
#}
#
#sub clause_summary {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause_and_attrs($cd);
#}
#
#sub clause_description {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause_and_attrs($cd);
#}
#
#sub clause_comment {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_tags {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_defhash_v {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_v {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub set_tmp_data_term {
#    my ($self, $cd, $expr) = @_;
#    my $c = $self->compiler;
#
#    $expr //= $cd->{data_term};
#
#    my $tdn = $cd->{args}{tmp_data_name};
#    my $tdt = $cd->{args}{tmp_data_term};
#    my $t = $c->expr_array_subscript($tdt, $cd->{_subdata_level});
#    unless ($cd->{_save_data_term}) {
#        $c->add_var($cd, $tdn, []);
#        $cd->{_save_data_term} = $cd->{data_term};
#        $cd->{data_term} = $t;
#    }
#    local $cd->{_debug_ccl_note} = 'set temporary data term';
#    $c->add_ccl($cd, "(".$c->expr_assign($t, $expr). ", ".$c->true.")",
#                {err_msg => ''});
#}
#
#sub restore_data_term {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $tdt = $cd->{args}{tmp_data_term};
#    if ($cd->{_save_data_term}) {
#        $cd->{data_term} = delete($cd->{_save_data_term});
#        local $cd->{_debug_ccl_note} = 'restore original data term';
#        $c->add_ccl($cd, "(".$c->expr_pop($tdt). ", ".$c->true.")",
#                    {err_msg => ''});
#    }
#}
#
#sub gen_any_or_all_of {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $dt = $cd->{data_term};
#
#    my $jccl;
#    {
#        local $cd->{ccls} = [];
#        for my $i (0..@$cv-1) {
#            local $cd->{spath} = [@{ $cd->{spath} }, $i];
#            my $sch  = $cv->[$i];
#            my %iargs = %{$cd->{args}};
#            $iargs{outer_cd}             = $cd;
#            $iargs{schema}               = $sch;
#            $iargs{schema_is_normalized} = 0;
#            $iargs{indent_level}++;
#            my $icd  = $c->compile(%iargs);
#            my @code = (
#                $icd->{result},
#            );
#            $c->add_ccl($cd, join("", @code));
#        }
#        if ($which eq 'all') {
#            $jccl = $c->join_ccls(
#                $cd, $cd->{ccls}, {err_msg=>''});
#        } else {
#            $jccl = $c->join_ccls(
#                $cd, $cd->{ccls}, {err_msg=>'', op=>'or'});
#        }
#    }
#    $c->add_ccl($cd, $jccl);
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/Prog/TH/all.pm ###
#package Data::Sah::Compiler::Prog::TH::all;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::Prog::TH';
#with 'Data::Sah::Type::all';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = $c->true;
#}
#
#sub clause_of {
#    my ($self, $cd) = @_;
#    $self->gen_any_or_all_of("all", $cd);
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/Prog/TH/any.pm ###
#package Data::Sah::Compiler::Prog::TH::any;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::Prog::TH';
#with 'Data::Sah::Type::any';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = $c->true;
#}
#
#sub clause_of {
#    my ($self, $cd) = @_;
#    $self->gen_any_or_all_of("any", $cd);
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/TH.pm ###
#package Data::Sah::Compiler::TH;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Mo qw(build default);
#
#has compiler => (is => 'rw');
#
#sub clause_v {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_defhash_v {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_schema_v {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_base_v {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_default_lang {
#    my ($self, $cd) = @_;
#    $self->compiler->_ignore_clause($cd);
#}
#
#sub clause_clause {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my ($clause, $clv) = @$cv;
#    my $meth   = "clause_$clause";
#    my $mmeth  = "clausemeta_$clause";
#
#    my $clsets = [{$clause => $clv}];
#    local $cd->{clsets} = $clsets;
#
#    $c->_process_clause($cd, 0, $clause);
#}
#
#
#sub clause_clset {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    local $cd->{clsets} = [$cv];
#    $c->_process_clsets($cd, 'from clause_clset');
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/TextResultRole.pm ###
#package Data::Sah::Compiler::TextResultRole;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(default);
#use Role::Tiny;
#
#has indent_character => (is => 'rw', default => sub {''});
#
#sub add_result {
#    my ($self, $cd, @args) = @_;
#
#    $cd->{result} //= [];
#    push @{ $cd->{result} }, $self->indent($cd, join("", @args));
#    $self;
#}
#
#sub _indent {
#    my ($indent, $str, $opts) = @_;
#    $opts //= {};
#
#    my $ibl = $opts->{indent_blank_lines} // 1;
#    my $fli = $opts->{first_line_indent} // $indent;
#    my $sli = $opts->{subsequent_lines_indent} // $indent;
#
#    my $i = 0;
#    $str =~ s/^([^\r\n]?)/$i++; !$ibl && !$1 ? "$1" : $i==1 ? "$fli$1" : "$sli$1"/egm;
#    $str;
#}
#
#sub indent {
#    my ($self, $cd, $str) = @_;
#    _indent(
#        $self->indent_character x $cd->{indent_level},
#        $str,
#    );
#}
#
#sub inc_indent {
#    my ($self, $cd) = @_;
#    $cd->{indent_level}++;
#}
#
#sub dec_indent {
#    my ($self, $cd) = @_;
#    $cd->{indent_level}--;
#}
#
#sub indent_str {
#    my ($self, $cd) = @_;
#    $self->indent_character x $cd->{indent_level};
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human.pm ###
#package Data::Sah::Compiler::human;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Data::Dmp qw(dmp);
#use Mo qw(build default);
#use POSIX qw(locale_h);
#use Text::sprintfn;
#
#extends 'Data::Sah::Compiler';
#
#our %typex; 
#
#sub name { "human" }
#
#sub _add_msg_catalog {
#    my ($self, $cd, $msg) = @_;
#    return unless $cd->{args}{format} eq 'msg_catalog';
#
#    my $spath = join("/", @{ $cd->{spath} });
#    $cd->{_msg_catalog}{$spath} = $msg;
#}
#
#sub check_compile_args {
#    use experimental 'smartmatch';
#
#    my ($self, $args) = @_;
#
#    $self->SUPER::check_compile_args($args);
#
#    my @fmts = ('inline_text', 'inline_err_text', 'markdown', 'msg_catalog');
#    $args->{format} //= $fmts[0];
#    unless ($args->{format} ~~ @fmts) {
#        $self->_die({}, "Unsupported format, use one of: ".join(", ", @fmts));
#    }
#}
#
#sub init_cd {
#    my ($self, %args) = @_;
#
#    my $cd = $self->SUPER::init_cd(%args);
#    if (($cd->{args}{format} // '') eq 'msg_catalog') {
#        $cd->{_msg_catalog} //= $cd->{outer_cd}{_msg_catalog};
#        $cd->{_msg_catalog} //= {};
#    }
#    $cd;
#}
#
#sub expr {
#    my ($self, $cd, $expr) = @_;
#
#
#    $expr;
#}
#
#sub literal {
#    my ($self, $val) = @_;
#
#    return $val unless ref($val);
#    dmp($val);
#}
#
#sub _xlt {
#    my ($self, $cd, $text) = @_;
#
#    my $lang = $cd->{args}{lang};
#
#
#    return $text if $lang eq 'en_US';
#    my $translations;
#    {
#        no strict 'refs';
#        $translations = \%{"Data::Sah::Lang::$lang\::translations"};
#    }
#    return $translations->{$text} if defined($translations->{$text});
#    if ($cd->{args}{mark_missing_translation}) {
#        return "(no $lang text:$text)";
#    } else {
#        return $text;
#    }
#}
#
#sub _ordinate {
#    my ($self, $cd, $n, $noun) = @_;
#
#    my $lang = $cd->{args}{lang};
#
#
#    if ($lang eq 'en_US') {
#        require Lingua::EN::Numbers::Ordinate;
#        return Lingua::EN::Numbers::Ordinate::ordinate($n) . " $noun";
#    } else {
#        no strict 'refs';
#        return "Data::Sah::Lang::$lang\::ordinate"->($n, $noun);
#    }
#}
#
#sub _add_ccl {
#    use experimental 'smartmatch';
#
#    my ($self, $cd, $ccl) = @_;
#
#    $ccl->{xlt} //= 1;
#
#    my $clause = $cd->{clause} // "";
#    $ccl->{type} //= "clause";
#
#    my $do_xlt = 1;
#
#    my $hvals = {
#        modal_verb     => $self->_xlt($cd, "must"),
#        modal_verb_neg => $self->_xlt($cd, "must not"),
#
#        field          => $self->_xlt($cd, "field"),
#        fields         => $self->_xlt($cd, "fields"),
#
#        %{ $cd->{args}{hash_values} // {} },
#    };
#    my $mod="";
#
#
#    {
#        my $lang   = $cd->{args}{lang};
#        my $dlang  = $cd->{clset_dlang} // "en_US"; 
#        my $suffix = $lang eq $dlang ? "" : ".alt.lang.$lang";
#        if ($clause) {
#            delete $cd->{uclset}{$_} for
#                grep {/\A\Q$clause.human\E(\.|\z)/} keys %{$cd->{uclset}};
#            if (defined $cd->{clset}{"$clause.human$suffix"}) {
#                $ccl->{type} = 'clause';
#                $ccl->{fmt}  = $cd->{clset}{"$clause.human$suffix"};
#                goto FILL_FORMAT;
#            }
#        } else {
#            delete $cd->{uclset}{$_} for
#                grep {/\A\.name(\.|\z)/} keys %{$cd->{uclset}};
#            if (defined $cd->{clset}{".name$suffix"}) {
#                $ccl->{type} = 'noun';
#                $ccl->{fmt}  = $cd->{clset}{".name$suffix"};
#                $ccl->{vals} = undef;
#                goto FILL_FORMAT;
#            }
#        }
#    }
#
#    goto TRANSLATE unless $clause;
#
#    my $ie    = $cd->{cl_is_expr};
#    my $im    = $cd->{cl_is_multi};
#    my $op    = $cd->{cl_op} // "";
#    my $cv    = $cd->{clset}{$clause};
#    my $vals  = $ccl->{vals} // [$cv];
#
#
#    if ($ie) {
#        if (!$ccl->{expr}) {
#            $ccl->{fmt} = "($clause -> %s" . ($op ? " op=$op" : "") . ")";
#            $do_xlt = 0;
#            $vals = [$self->expr($cd, $vals)];
#        }
#        goto ERR_LEVEL;
#    }
#
#
#    if ($op eq 'not') {
#        ($hvals->{modal_verb}, $hvals->{modal_verb_neg}) =
#            ($hvals->{modal_verb_neg}, $hvals->{modal_verb});
#        $vals = [map {$self->literal($_)} @$vals];
#    } elsif ($im && $op eq 'and') {
#        if (@$cv == 2) {
#            $vals = [sprintf($self->_xlt($cd, "%s and %s"),
#                             $self->literal($cv->[0]),
#                             $self->literal($cv->[1]))];
#        } else {
#            $vals = [sprintf($self->_xlt($cd, "all of %s"),
#                             $self->literal($cv))];
#        }
#    } elsif ($im && $op eq 'or') {
#        if (@$cv == 2) {
#            $vals = [sprintf($self->_xlt($cd, "%s or %s"),
#                             $self->literal($cv->[0]),
#                             $self->literal($cv->[1]))];
#        } else {
#            $vals = [sprintf($self->_xlt($cd, "one of %s"),
#                             $self->literal($cv))];
#        }
#    } elsif ($im && $op eq 'none') {
#        ($hvals->{modal_verb}, $hvals->{modal_verbneg}) =
#            ($hvals->{modal_verb_neg}, $hvals->{modal_verb});
#        if (@$cv == 2) {
#            $vals = [sprintf($self->_xlt($cd, "%s nor %s"),
#                             $self->literal($cv->[0]),
#                             $self->literal($cv->[1]))];
#        } else {
#            $vals = [sprintf($self->_xlt($cd, "any of %s"),
#                             $self->literal($cv))];
#        }
#    } else {
#        $vals = [map {$self->literal($_)} @$vals];
#    }
#
#  ERR_LEVEL:
#
#    if ($ccl->{type} eq 'clause' && 'constraint' ~~ $cd->{cl_meta}{tags}) {
#        if (($cd->{clset}{"$clause.err_level"}//'error') eq 'warn') {
#            if ($op eq 'not') {
#                $hvals->{modal_verb}     = $self->_xlt($cd, "should not");
#                $hvals->{modal_verb_neg} = $self->_xlt($cd, "should");
#            } else {
#                $hvals->{modal_verb}     = $self->_xlt($cd, "should");
#                $hvals->{modal_verb_neg} = $self->_xlt($cd, "should not");
#            }
#        }
#    }
#    delete $cd->{uclset}{"$clause.err_level"};
#
#  TRANSLATE:
#
#    if ($ccl->{xlt}) {
#        if (ref($ccl->{fmt}) eq 'ARRAY') {
#            $ccl->{fmt}  = [map {$self->_xlt($cd, $_)} @{$ccl->{fmt}}];
#        } elsif (!ref($ccl->{fmt})) {
#            $ccl->{fmt}  = $self->_xlt($cd, $ccl->{fmt});
#        }
#    }
#
#  FILL_FORMAT:
#
#    if (ref($ccl->{fmt}) eq 'ARRAY') {
#        $ccl->{text} = [map {sprintfn($_, (map {$_//""} ($hvals, @$vals)))}
#                            @{$ccl->{fmt}}];
#    } elsif (!ref($ccl->{fmt})) {
#        $ccl->{text} = sprintfn($ccl->{fmt}, (map {$_//""} ($hvals, @$vals)));
#    }
#    delete $ccl->{fmt} unless $cd->{args}{debug};
#
#  PUSH:
#    push @{$cd->{ccls}}, $ccl;
#
#    $self->_add_msg_catalog($cd, $ccl);
#}
#
#sub add_ccl {
#    my ($self, $cd, @ccls) = @_;
#
#    my $op     = $cd->{cl_op} // '';
#
#    my $ccl;
#    if (@ccls == 1) {
#        $self->_add_ccl($cd, $ccls[0]);
#    } else {
#        my $inner_cd = $self->init_cd(outer_cd => $cd);
#        $inner_cd->{args} = $cd->{args};
#        $inner_cd->{clause} = $cd->{clause};
#        for (@ccls) {
#            $self->_add_ccl($inner_cd, $_);
#        }
#
#        $ccl = {
#            type  => 'list',
#            vals  => [],
#            items => $inner_cd->{ccls},
#            multi => 0,
#        };
#        if ($op eq 'or') {
#            $ccl->{fmt} = 'any of the following %(modal_verb)s be true';
#        } elsif ($op eq 'and') {
#            $ccl->{fmt} = 'all of the following %(modal_verb)s be true';
#        } elsif ($op eq 'none') {
#            $ccl->{fmt} = 'none of the following %(modal_verb)s be true';
#        }
#        $self->_add_ccl($cd, $ccl);
#    }
#}
#
#sub format_ccls {
#    my ($self, $cd, $ccls) = @_;
#
#    local $cd->{_fmt_noun_count} = 0;
#    local $cd->{_fmt_etc_count} = 0;
#
#    my $f = $cd->{args}{format};
#    my $res;
#    if ($f eq 'inline_text' || $f eq 'inline_err_text' || $f eq 'msg_catalog') {
#        $res = $self->_format_ccls_itext($cd, $ccls);
#        if ($f eq 'inline_err_text') {
#            if ($cd->{_fmt_noun_count} == 1 && $cd->{_fmt_etc_count} == 0) {
#                $res = sprintf(
#                    $self->_xlt($cd, "Not of type %s"),
#                    $res
#                );
#            } elsif (!$cd->{_fmt_noun_count}) {
#            } else {
#                $res = sprintf(
#                    $self->_xlt(
#                        $cd, "Does not satisfy the following schema: %s"),
#                    $res
#                );
#            }
#        }
#    } else {
#        $res = $self->_format_ccls_markdown($cd, $ccls);
#    }
#    $res;
#}
#
#sub _format_ccls_itext {
#    my ($self, $cd, $ccls) = @_;
#
#    local $cd->{args}{mark_missing_translation} = 0;
#    my $c_comma = $self->_xlt($cd, ", ");
#
#    if (ref($ccls) eq 'HASH' && $ccls->{type} =~ /^(noun|clause)$/) {
#        if ($ccls->{type} eq 'noun') {
#            $cd->{_fmt_noun_count}++;
#        } else {
#            $cd->{_fmt_etc_count}++;
#        }
#        my $ccl = $ccls;
#        return ref($ccl->{text}) eq 'ARRAY' ? $ccl->{text}[0] : $ccl->{text};
#    } elsif (ref($ccls) eq 'HASH' && $ccls->{type} eq 'list') {
#        my $c_openpar  = $self->_xlt($cd, "(");
#        my $c_closepar = $self->_xlt($cd, ")");
#        my $c_colon    = $self->_xlt($cd, ": ");
#        my $ccl = $ccls;
#
#        my $txt = $ccl->{text}; $txt =~ s/\s+$//;
#        my @t = ($txt, $c_colon);
#        my $i = 0;
#        for (@{ $ccl->{items} }) {
#            push @t, $c_comma if $i;
#            my $it = $self->_format_ccls_itext($cd, $_);
#            if ($it =~ /\Q$c_comma/) {
#                push @t, $c_openpar, $it, $c_closepar;
#            } else {
#                push @t, $it;
#            }
#            $i++;
#        }
#        return join("", @t);
#    } elsif (ref($ccls) eq 'ARRAY') {
#        return join($c_comma, map {$self->_format_ccls_itext($cd, $_)} @$ccls);
#    } else {
#        $self->_die($cd, "Can't format $ccls");
#    }
#}
#
#sub _format_ccls_markdown {
#    my ($self, $cd, $ccls) = @_;
#
#    $self->_die($cd, "Sorry, markdown not yet implemented");
#}
#
#sub _load_lang_modules {
#    my ($self, $cd) = @_;
#
#    my $lang = $cd->{args}{lang};
#    die "Invalid language '$lang', please use letters only"
#        unless $lang =~ /\A\w+\z/;
#
#    my @modp;
#    unless ($lang eq 'en_US') {
#        push @modp, "Data/Sah/Lang/$lang.pm";
#        for my $cl (@{ $typex{$cd->{type}} // []}) {
#            my $modp = "Data/Sah/Lang/$lang/TypeX/$cd->{type}/$cl.pm";
#            $modp =~ s!::!/!g; 
#            push @modp, $modp;
#        }
#    }
#    my $i;
#    for my $modp (@modp) {
#        $i++;
#        unless (exists $INC{$modp}) {
#            if ($i == 1) {
#                require Module::Installed::Tiny;
#                if (!Module::Installed::Tiny::module_installed($modp)) {
#                    $cd->{args}{lang} = 'en_US';
#                    last;
#                }
#            }
#            require $modp;
#
#            $INC{$modp} = undef;
#        }
#    }
#}
#
#sub before_compile {
#    my ($self, $cd) = @_;
#
#    $cd->{_orig_locale} = setlocale(LC_ALL);
#
#    my $res = setlocale(LC_ALL, $cd->{args}{locale} // $cd->{args}{lang});
#    warn "Unsupported locale $cd->{args}{lang}"
#        if $cd->{args}{debug} && !defined($res);
#}
#
#sub before_handle_type {
#    my ($self, $cd) = @_;
#
#    $self->_load_lang_modules($cd);
#}
#
#sub before_clause {
#    my ($self, $cd) = @_;
#
#    $cd->{CLAUSE_DO_MULTI} = 1;
#}
#
#sub after_clause {
#    my ($self, $cd) = @_;
#
#    delete $cd->{CLAUSE_DO_MULTI};
#}
#
#sub after_all_clauses {
#    use experimental 'smartmatch';
#
#    my ($self, $cd) = @_;
#
#
#
#    $cd->{result} = $self->format_ccls($cd, $cd->{ccls});
#}
#
#sub after_compile {
#    my ($self, $cd) = @_;
#
#    setlocale(LC_ALL, $cd->{_orig_locale});
#
#    if ($cd->{args}{format} eq 'msg_catalog') {
#        $cd->{result} = $cd->{_msg_catalog};
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH.pm ###
#package Data::Sah::Compiler::human::TH;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::TH';
#
#sub name { undef }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $pkg = ref($self);
#    $pkg =~ s/^Data::Sah::Compiler::human::TH:://;
#
#    $c->add_ccl($cd, {type=>'noun', fmt=>$pkg});
#}
#
#
#sub clause_name {}
#sub clause_summary {}
#sub clause_description {}
#sub clause_comment {}
#sub clause_tags {}
#
#sub clause_prefilters {}
#sub clause_postfilters {}
#
#
#sub clause_ok {}
#
#
#sub clause_req {}
#sub clause_forbidden {}
#
#
#sub clause_default {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {expr=>1,
#                      fmt => 'default value %s'});
#}
#
#sub before_clause_clause {
#    my ($self, $cd) = @_;
#    $cd->{CLAUSE_DO_MULTI} = 0;
#}
#
#sub before_clause_clset {
#    my ($self, $cd) = @_;
#    $cd->{CLAUSE_DO_MULTI} = 0;
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/Comparable.pm ###
#package Data::Sah::Compiler::human::TH::Comparable;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::Comparable';
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $fmt;
#    if ($which eq 'is') {
#        $c->add_ccl($cd, {expr=>1, multi=>1,
#                          fmt => '%(modal_verb)s have the value %s'});
#    } elsif ($which eq 'in') {
#        $c->add_ccl($cd, {expr=>1, multi=>1,
#                          fmt => '%(modal_verb)s be one of %s'});
#    }
#}
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/HasElems.pm ###
#package Data::Sah::Compiler::human::TH::HasElems;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::HasElems';
#
#sub before_clause {
#    my ($self_th, $which, $cd) = @_;
#}
#
#sub before_clause_len_between {
#    my ($self, $cd) = @_;
#    $cd->{CLAUSE_DO_MULTI} = 0;
#}
#
#sub superclause_has_elems {
#    my ($self_th, $which, $cd) = @_;
#    my $c  = $self_th->compiler;
#    my $cv = $cd->{cl_value};
#
#    if ($which eq 'len') {
#        $c->add_ccl($cd, {
#            expr  => 1,
#            fmt   => q[length %(modal_verb)s be %s],
#        });
#    } elsif ($which eq 'min_len') {
#        $c->add_ccl($cd, {
#            expr  => 1,
#            fmt   => q[length %(modal_verb)s be at least %s],
#        });
#    } elsif ($which eq 'max_len') {
#        $c->add_ccl($cd, {
#            expr  => 1,
#            fmt   => q[length %(modal_verb)s be at most %s],
#        });
#    } elsif ($which eq 'len_between') {
#        $c->add_ccl($cd, {
#            fmt   => q[length %(modal_verb)s be between %s and %s],
#            vals  => $cv,
#        });
#    } elsif ($which eq 'has') {
#        $c->add_ccl($cd, {
#            expr=>1, multi=>1,
#            fmt => "%(modal_verb)s have %s in its elements"});
#    } elsif ($which eq 'each_index') {
#        $self_th->clause_each_index($cd);
#    } elsif ($which eq 'each_elem') {
#        $self_th->clause_each_elem($cd);
#    } elsif ($which eq 'check_each_index') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'check_each_elem') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'uniq') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'exists') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/Sortable.pm ###
#package Data::Sah::Compiler::human::TH::Sortable;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::Sortable';
#
#sub before_clause_between {
#    my ($self, $cd) = @_;
#    $cd->{CLAUSE_DO_MULTI} = 0;
#}
#
#sub before_clause_xbetween {
#    my ($self, $cd) = @_;
#    $cd->{CLAUSE_DO_MULTI} = 0;
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    if ($which eq 'min') {
#        $c->add_ccl($cd, {
#            expr=>1,
#            fmt => '%(modal_verb)s be at least %s',
#        });
#    } elsif ($which eq 'xmin') {
#        $c->add_ccl($cd, {
#            expr=>1,
#            fmt => '%(modal_verb)s be larger than %s',
#        });
#    } elsif ($which eq 'max') {
#        $c->add_ccl($cd, {
#            expr=>1,
#            fmt => '%(modal_verb)s be at most %s',
#        });
#    } elsif ($which eq 'xmax') {
#        $c->add_ccl($cd, {
#            expr=>1,
#            fmt => '%(modal_verb)s be smaller than %s',
#        });
#    } elsif ($which eq 'between') {
#        $c->add_ccl($cd, {
#            fmt => '%(modal_verb)s be between %s and %s',
#            vals => $cv,
#        });
#    } elsif ($which eq 'xbetween') {
#        $c->add_ccl($cd, {
#            fmt => '%(modal_verb)s be larger than %s and smaller than %s',
#            vals => $cv,
#        });
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/all.pm ###
#package Data::Sah::Compiler::human::TH::all;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Type::all';
#
#sub handle_type {
#}
#
#sub clause_of {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my @result;
#    my $i = 0;
#    for my $cv2 (@$cv) {
#        local $cd->{spath} = [@{$cd->{spath}}, $i];
#        my %iargs = %{$cd->{args}};
#        $iargs{outer_cd}             = $cd;
#        $iargs{schema}               = $cv2;
#        $iargs{schema_is_normalized} = 0;
#        my $icd = $c->compile(%iargs);
#        push @result, $icd->{ccls};
#        $c->_add_msg_catalog($cd, $icd->{ccls});
#        $i++;
#    }
#
#    my $can = 1;
#    for my $r (@result) {
#        unless (@$r == 1 && $r->[0]{type} eq 'noun') {
#            $can = 0;
#            last;
#        }
#    }
#
#    my $vals;
#    if ($can) {
#        my $c0  = $c->_xlt($cd, '%(modal_verb)s be %s');
#        my $awa = $c->_xlt($cd, 'as well as %s');
#        my $wb  = $c->_xlt($cd, ' ');
#        my $fmt;
#        my $i = 0;
#        for my $r (@result) {
#            $fmt .= $i ? $wb . $awa : $c0;
#            push @$vals, ref($r->[0]{text}) eq 'ARRAY' ?
#                $r->[0]{text}[0] : $r->[0]{text};
#            $i++;
#        }
#        $c->add_ccl($cd, {
#            fmt  => $fmt,
#            vals => $vals,
#            xlt  => 0,
#            type => 'noun',
#        });
#    } else {
#        $c->add_ccl($cd, {
#            type  => 'list',
#            fmt   => '%(modal_verb)s be all of the following',
#            items => [
#                @result,
#            ],
#            vals  => [],
#        });
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/any.pm ###
#package Data::Sah::Compiler::human::TH::any;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Type::any';
#
#sub handle_type {
#}
#
#sub clause_of {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my @result;
#    my $i = 0;
#    for my $cv2 (@$cv) {
#        local $cd->{spath} = [@{$cd->{spath}}, $i];
#        my %iargs = %{$cd->{args}};
#        $iargs{outer_cd}             = $cd;
#        $iargs{schema}               = $cv2;
#        $iargs{schema_is_normalized} = 0;
#        my $icd = $c->compile(%iargs);
#        push @result, $icd->{ccls};
#        $i++;
#    }
#
#    my $can = 1;
#    for my $r (@result) {
#        unless (@$r == 1 && $r->[0]{type} eq 'noun') {
#            $can = 0;
#            last;
#        }
#    }
#
#    my $vals;
#    if ($can) {
#        my $c0  = $c->_xlt($cd, '%(modal_verb)s be either %s');
#        my $awa = $c->_xlt($cd, 'or %s');
#        my $wb  = $c->_xlt($cd, ' ');
#        my $fmt;
#        my $i = 0;
#        for my $r (@result) {
#            $fmt .= $i ? $wb . $awa : $c0;
#            push @$vals, ref($r->[0]{text}) eq 'ARRAY' ?
#                $r->[0]{text}[0] : $r->[0]{text};
#            $i++;
#        }
#        $c->add_ccl($cd, {
#            fmt  => $fmt,
#            vals => $vals,
#            xlt  => 0,
#            type => 'noun',
#        });
#    } else {
#        $c->add_ccl($cd, {
#            type  => 'list',
#            fmt   => '%(modal_verb)s be one of the following',
#            items => [
#                @result,
#            ],
#            vals  => [],
#        });
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/array.pm ###
#package Data::Sah::Compiler::human::TH::array;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::HasElems';
#with 'Data::Sah::Type::array';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["array", "arrays"],
#        type  => 'noun',
#    });
#}
#
#sub clause_each_index {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my %iargs = %{$cd->{args}};
#    $iargs{outer_cd}             = $cd;
#    $iargs{schema}               = $cv;
#    $iargs{schema_is_normalized} = 0;
#    my $icd = $c->compile(%iargs);
#
#    $c->add_ccl($cd, {
#        type  => 'list',
#        fmt   => 'each array subscript %(modal_verb)s be',
#        items => [
#            $icd->{ccls},
#        ],
#        vals  => [],
#    });
#}
#
#sub clause_each_elem {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my %iargs = %{$cd->{args}};
#    $iargs{outer_cd}             = $cd;
#    $iargs{schema}               = $cv;
#    $iargs{schema_is_normalized} = 0;
#    my $icd = $c->compile(%iargs);
#
#    if (@{$icd->{ccls}} == 1) {
#        my $c0 = $icd->{ccls}[0];
#        if ($c0->{type} eq 'noun' && ref($c0->{text}) eq 'ARRAY' &&
#                @{$c0->{text}} > 1 && @{$cd->{ccls}} &&
#                    $cd->{ccls}[0]{type} eq 'noun') {
#            for (ref($cd->{ccls}[0]{text}) eq 'ARRAY' ?
#                     @{$cd->{ccls}[0]{text}} : ($cd->{ccls}[0]{text})) {
#                my $fmt = $c->_xlt($cd, '%s of %s');
#                $_ = sprintf $fmt, $_, $c0->{text}[1];
#            }
#            return;
#        }
#    }
#
#    $c->add_ccl($cd, {
#        type  => 'list',
#        fmt   => 'each array element %(modal_verb)s be',
#        items => [
#            $icd->{ccls},
#        ],
#        vals  => [],
#    });
#}
#
#sub clause_elems {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    for my $i (0..@$cv-1) {
#        local $cd->{spath} = [@{$cd->{spath}}, $i];
#        my $v = $cv->[$i];
#        my %iargs = %{$cd->{args}};
#        $iargs{outer_cd}             = $cd;
#        $iargs{schema}               = $v;
#        $iargs{schema_is_normalized} = 0;
#        my $icd = $c->compile(%iargs);
#        $c->add_ccl($cd, {
#            type  => 'list',
#            fmt   => '%s %(modal_verb)s be',
#            vals  => [
#                $c->_ordinate($cd, $i+1, $c->_xlt($cd, "element")),
#            ],
#            items => [ $icd->{ccls} ],
#        });
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/bool.pm ###
#package Data::Sah::Compiler::human::TH::bool;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::Sortable';
#with 'Data::Sah::Type::bool';
#
#sub name { "boolean value" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["boolean value", "boolean values"],
#        type  => 'noun',
#    });
#}
#
#sub before_clause_is_true {
#    my ($self, $cd) = @_;
#    $cd->{CLAUSE_DO_MULTI} = 0;
#}
#
#sub clause_is_true {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    $c->add_ccl($cd, {
#        fmt   => $cv ? q[%(modal_verb)s be true] : q[%(modal_verb)s be false],
#    });
#}
#
#sub clause_is_re {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s be a regex pattern],
#    });
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/buf.pm ###
#package Data::Sah::Compiler::human::TH::buf;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH::str';
#
#sub name { "buffer" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["buffer", "buffers"],
#        type  => 'noun',
#    });
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/cistr.pm ###
#package Data::Sah::Compiler::human::TH::cistr;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH::str';
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/code.pm ###
#package Data::Sah::Compiler::human::TH::code;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Type::code';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["code", "codes"],
#        type  => 'noun',
#    });
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/date.pm ###
#package Data::Sah::Compiler::human::TH::date;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::Sortable';
#with 'Data::Sah::Type::date';
#
#sub name { "date" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {type=>'noun', fmt => ["date", "dates"]});
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/datenotime.pm ###
#package Data::Sah::Compiler::human::TH::datenotime;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH::date';
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/datetime.pm ###
#package Data::Sah::Compiler::human::TH::datetime;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH::date';
#
#sub name { "datetime" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {type=>'noun', fmt => ["datetime", "datetimes"]});
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/duration.pm ###
#package Data::Sah::Compiler::human::TH::duration;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::Sortable';
#with 'Data::Sah::Type::duration';
#
#sub name { "duration" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {type=>'noun', fmt => ["duration", "durations"]});
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/float.pm ###
#package Data::Sah::Compiler::human::TH::float;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::Sortable';
#with 'Data::Sah::Type::float';
#
#sub name { "decimal number" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        type=>'noun',
#        fmt => ["decimal number", "decimal numbers"],
#    });
#}
#
#sub clause_is_nan {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $cv = $cd->{cl_value};
#    if ($cd->{cl_is_expr}) {
#        $c->add_ccl($cd, {});
#    } else {
#        $c->add_ccl($cd, {
#            fmt => $cv ?
#                q[%(modal_verb)s be a NaN] :
#                    q[%(modal_verb_neg)s be a NaN],
#        });
#    }
#}
#
#sub clause_is_inf {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $cv = $cd->{cl_value};
#    if ($cd->{cl_is_expr}) {
#        $c->add_ccl($cd, {});
#    } else {
#        $c->add_ccl($cd, {
#            fmt => $cv ?
#                q[%(modal_verb)s an infinity] :
#                    q[%(modal_verb_neg)s an infinity],
#        });
#    }
#}
#
#sub clause_is_pos_inf {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $cv = $cd->{cl_value};
#    if ($cd->{cl_is_expr}) {
#        $c->add_ccl($cd, {});
#    } else {
#        $c->add_ccl($cd, {
#            fmt => $cv ?
#                q[%(modal_verb)s a positive infinity] :
#                    q[%(modal_verb_neg)s a positive infinity],
#        });
#    }
#}
#
#sub clause_is_neg_inf {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $cv = $cd->{cl_value};
#    if ($cd->{cl_is_expr}) {
#        $c->add_ccl($cd, {});
#    } else {
#        $c->add_ccl($cd, {
#            fmt => $cv ?
#                q[%(modal_verb)s a negative infinity] :
#                    q[%(modal_verb_neg)s a negative infinity],
#        });
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/hash.pm ###
#package Data::Sah::Compiler::human::TH::hash;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::HasElems';
#with 'Data::Sah::Type::hash';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["hash", "hashes"],
#        type  => 'noun',
#    });
#}
#
#sub clause_has {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    $c->add_ccl($cd, {
#        expr=>1, multi=>1,
#        fmt => "%(modal_verb)s have %s in its %(field)s values"});
#}
#
#sub clause_each_index {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my %iargs = %{$cd->{args}};
#    $iargs{outer_cd}             = $cd;
#    $iargs{schema}               = $cv;
#    $iargs{schema_is_normalized} = 0;
#    my $icd = $c->compile(%iargs);
#
#    $c->add_ccl($cd, {
#        type  => 'list',
#        fmt   => '%(field)s name %(modal_verb)s be',
#        items => [
#            $icd->{ccls},
#        ],
#        vals  => [],
#    });
#}
#
#sub clause_each_elem {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my %iargs = %{$cd->{args}};
#    $iargs{outer_cd}             = $cd;
#    $iargs{schema}               = $cv;
#    $iargs{schema_is_normalized} = 0;
#    my $icd = $c->compile(%iargs);
#
#    $c->add_ccl($cd, {
#        type  => 'list',
#        fmt   => 'each %(field)s %(modal_verb)s be',
#        items => [
#            $icd->{ccls},
#        ],
#        vals  => [],
#    });
#}
#
#sub clause_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    for my $k (sort keys %$cv) {
#        local $cd->{spath} = [@{$cd->{spath}}, $k];
#        my $v = $cv->{$k};
#        my %iargs = %{$cd->{args}};
#        $iargs{outer_cd}             = $cd;
#        $iargs{schema}               = $v;
#        $iargs{schema_is_normalized} = 0;
#        my $icd = $c->compile(%iargs);
#        $c->add_ccl($cd, {
#            type  => 'list',
#            fmt   => '%(field)s %s %(modal_verb)s be',
#            vals  => [$k],
#            items => [ $icd->{ccls} ],
#        });
#    }
#}
#
#sub clause_re_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    for my $k (sort keys %$cv) {
#        local $cd->{spath} = [@{$cd->{spath}}, $k];
#        my $v = $cv->{$k};
#        my %iargs = %{$cd->{args}};
#        $iargs{outer_cd}             = $cd;
#        $iargs{schema}               = $v;
#        $iargs{schema_is_normalized} = 0;
#        my $icd = $c->compile(%iargs);
#        $c->add_ccl($cd, {
#            type  => 'list',
#            fmt   => '%(fields)s whose names match regex pattern %s %(modal_verb)s be',
#            vals  => [$k],
#            items => [ $icd->{ccls} ],
#        });
#    }
#}
#
#sub clause_req_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s have required %(fields)s %s],
#        expr  => 1,
#    });
#}
#
#sub clause_allowed_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s only have these allowed %(fields)s %s],
#        expr  => 1,
#    });
#}
#
#sub clause_allowed_keys_re {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s only have %(fields)s matching regex pattern %s],
#        expr  => 1,
#    });
#}
#
#sub clause_forbidden_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb_neg)s have these forbidden %(fields)s %s],
#        expr  => 1,
#    });
#}
#
#sub clause_forbidden_keys_re {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb_neg)s have %(fields)s matching regex pattern %s],
#        expr  => 1,
#    });
#}
#
#sub clause_choose_one_key {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        push @ccls, {
#            fmt   => q[%(modal_verb)s contain at most one of these %(fields)s %s],
#            vals  => [$cv],
#        };
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#sub clause_choose_all_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        push @ccls, {
#            fmt   => q[%(modal_verb)s contain either none or all of these %(fields)s %s],
#            vals  => [$cv],
#        };
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#sub clause_req_one_key {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        push @ccls, {
#            fmt   => q[%(modal_verb)s contain exactly one of these %(fields)s %s],
#            vals  => [$cv],
#        };
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#sub clause_req_some_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        push @ccls, {
#            fmt   => q[%(modal_verb)s contain between %d and %d of these %(fields)s %s],
#            vals  => [$cv->[0], $cv->[1], $cv->[2]],
#        };
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#sub clause_dep_any {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        if (@{ $cv->[1] } == 1) {
#            push @ccls, {
#                fmt   => q[%(field)s %2$s %(modal_verb)s be present before %(field)s %1$s can be present],
#                vals  => [$cv->[0], $cv->[1][0]],
#            };
#        } else {
#            push @ccls, {
#                fmt   => q[one of %(fields)s %2$s %(modal_verb)s be present before %(field)s %1$s can be present],
#                vals  => $cv,
#                multi => 0,
#            };
#        }
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#sub clause_dep_all {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        if (@{ $cv->[1] } == 1) {
#            push @ccls, {
#                fmt   => q[%(field)s %2$s %(modal_verb)s be present before %(field)s %1$s can be present],
#                vals  => [$cv->[0], $cv->[1][0]],
#            };
#        } else {
#            push @ccls, {
#                fmt   => q[all of %(fields)s %2$s %(modal_verb)s be present before %(field)s %1$s can be present],
#                vals  => $cv,
#            };
#        }
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#sub clause_req_dep_any {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        if (@{ $cv->[1] } == 1) {
#            push @ccls, {
#                fmt   => q[%(field)s %1$s %(modal_verb)s be present when %(field)s %2$s is present],
#                vals  => [$cv->[0], $cv->[1][0]],
#            };
#        } else {
#            push @ccls, {
#                fmt   => q[%(field)s %1$s %(modal_verb)s be present when one of %(fields)s %2$s is present],
#                vals  => $cv,
#            };
#        }
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#sub clause_req_dep_all {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#
#    my $multi = $cd->{cl_is_multi};
#    $cd->{cl_is_multi} = 0;
#
#    my @ccls;
#    for my $cv ($multi ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        if (@{ $cv->[1] } == 1) {
#            push @ccls, {
#                fmt   => q[%(field)s %1$s %(modal_verb)s be present when %(field)s %2$s is present],
#                vals  => [$cv->[0], $cv->[1][0]],
#            };
#        } else {
#            push @ccls, {
#                fmt   => q[%(field)s %1$s %(modal_verb)s be present when all of %(fields)s %2$s are present],
#                vals  => $cv,
#            };
#        }
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/int.pm ###
#package Data::Sah::Compiler::human::TH::int;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH::num';
#with 'Data::Sah::Type::int';
#
#sub name { "integer" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        type  => 'noun',
#        fmt   => ["integer", "integers"],
#    });
#}
#
#sub clause_div_by {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    if (!$cd->{cl_is_multi} && !$cd->{cl_is_expr} &&
#            $cv == 2) {
#        $c->add_ccl($cd, {
#            fmt   => q[%(modal_verb)s be even],
#        });
#        return;
#    }
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s be divisible by %s],
#        expr  => 1,
#    });
#}
#
#sub clause_mod {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    if (!$cd->{cl_is_multi} && !$cd->{cl_is_expr}) {
#        if ($cv->[0] == 2 && $cv->[1] == 0) {
#            $c->add_ccl($cd, {
#                fmt   => q[%(modal_verb)s be even],
#            });
#            return;
#        } elsif ($cv->[0] == 2 && $cv->[1] == 1) {
#            $c->add_ccl($cd, {
#                fmt   => q[%(modal_verb)s be odd],
#            });
#            return;
#        }
#    }
#
#    my @ccls;
#    for my $cv ($cd->{cl_is_multi} ? @{ $cd->{cl_value} } : ($cd->{cl_value})) {
#        push @ccls, {
#            fmt  => q[%(modal_verb)s leave a remainder of %2$s when divided by %1$s],
#            vals => $cv,
#        };
#    }
#    $c->add_ccl($cd, @ccls);
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/num.pm ###
#package Data::Sah::Compiler::human::TH::num;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::Sortable';
#with 'Data::Sah::Type::num';
#
#sub name { "number" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {type=>'noun', fmt => ["number", "numbers"]});
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/obj.pm ###
#package Data::Sah::Compiler::human::TH::obj;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Type::obj';
#
#sub name { "object" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["object", "objects"],
#        type  => 'noun',
#    });
#}
#
#sub clause_can {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s have method(s) %s],
#    });
#}
#
#sub clause_isa {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s be subclass of %s],
#    });
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/re.pm ###
#package Data::Sah::Compiler::human::TH::re;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Type::re';
#
#sub name { "regex pattern" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["regex pattern", "regex patterns"],
#        type  => 'noun',
#    });
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/str.pm ###
#package Data::Sah::Compiler::human::TH::str;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Sortable';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::HasElems';
#with 'Data::Sah::Type::str';
#
#sub name { "text" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["text", "texts"],
#        type  => 'noun',
#    });
#}
#
#sub clause_each_index {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my %iargs = %{$cd->{args}};
#    $iargs{outer_cd}             = $cd;
#    $iargs{schema}               = $cv;
#    $iargs{schema_is_normalized} = 0;
#    my $icd = $c->compile(%iargs);
#
#    $c->add_ccl($cd, {
#        type  => 'list',
#        fmt   => 'each subscript of text %(modal_verb)s be',
#        items => [
#            $icd->{ccls},
#        ],
#        vals  => [],
#    });
#}
#
#sub clause_each_elem {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    my %iargs = %{$cd->{args}};
#    $iargs{outer_cd}             = $cd;
#    $iargs{schema}               = $cv;
#    $iargs{schema_is_normalized} = 0;
#    my $icd = $c->compile(%iargs);
#
#    $c->add_ccl($cd, {
#        type  => 'list',
#        fmt   => 'each character of the text %(modal_verb)s be',
#        items => [
#            $icd->{ccls},
#        ],
#        vals  => [],
#    });
#}
#
#sub clause_encoding {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    $c->_die($cd, "Only 'utf8' encoding is currently supported")
#        unless $cv eq 'utf8';
#}
#
#sub clause_match {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s match regex pattern %s],
#    });
#}
#
#sub clause_is_re {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#
#    $c->add_ccl($cd, {
#        fmt   => q[%(modal_verb)s be a regex pattern],
#    });
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/timeofday.pm ###
#package Data::Sah::Compiler::human::TH::timeofday;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Compiler::human::TH::Comparable';
#with 'Data::Sah::Compiler::human::TH::Sortable';
#with 'Data::Sah::Type::timeofday';
#
#sub name { "time" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {type=>'noun', fmt => ["time", "times"]});
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/human/TH/undef.pm ###
#package Data::Sah::Compiler::human::TH::undef;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::human::TH';
#with 'Data::Sah::Type::undef';
#
#sub name { "undefined value" }
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    $c->add_ccl($cd, {
#        fmt   => ["undefined value", "undefined values"],
#        type  => 'noun',
#    });
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl.pm ###
#package Data::Sah::Compiler::perl;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Data::Dmp qw(dmp);
#use Mo qw(build default);
#
#extends 'Data::Sah::Compiler::Prog';
#
#our $PP;
#our $CORE;
#our $CORE_OR_PP;
#our $NO_MODULES;
#
#sub __indent {
#    my ($indent, $str, $opts) = @_;
#    $opts //= {};
#
#    my $ibl = $opts->{indent_blank_lines} // 1;
#    my $fli = $opts->{first_line_indent} // $indent;
#    my $sli = $opts->{subsequent_lines_indent} // $indent;
#
#    my $i = 0;
#    $str =~ s/^([^\r\n]?)/$i++; !$ibl && !$1 ? "$1" : $i==1 ? "$fli$1" : "$sli$1"/egm;
#    $str;
#}
#
#sub BUILD {
#    my ($self, $args) = @_;
#
#    $self->comment_style('shell');
#    $self->indent_character(" " x 4);
#    $self->var_sigil('$');
#    $self->concat_op(".");
#}
#
#sub name { "perl" }
#
#sub literal {
#    dmp($_[1]);
#}
#
#sub expr {
#    my ($self, $expr) = @_;
#    $self->expr_compiler->perl($expr);
#}
#
#sub compile {
#    my ($self, %args) = @_;
#
#
#
#    $args{pp} //= $PP // $ENV{DATA_SAH_PP} // 0;
#    $args{core} //= $CORE // $ENV{DATA_SAH_CORE} // 0;
#    $args{core_or_pp} //= $CORE_OR_PP // $ENV{DATA_SAH_CORE_OR_PP} // 0;
#    $args{no_modules} //= $NO_MODULES // $ENV{DATA_SAH_NO_MODULES} // 0;
#
#    $self->SUPER::compile(%args);
#}
#
#sub init_cd {
#    my ($self, %args) = @_;
#
#    my $cd = $self->SUPER::init_cd(%args);
#
#    $self->add_runtime_no($cd, 'warnings', ["'void'"]) unless $cd->{args}{no_modules};
#
#    $cd;
#}
#
#sub true { "1" }
#
#sub false { "''" }
#
#our %known_modules = (
#    'DateTime::Duration'        => {pp=>1, core=>0},
#    'DateTime'                  => {pp=>0, core=>0},
#    'DateTime::Format::Alami'     => {pp=>1, core=>0},
#    'DateTime::Format::Alami::EN' => {pp=>1, core=>0},
#    'DateTime::Format::Alami::ID' => {pp=>1, core=>0},
#    'DateTime::Format::Natural'   => {pp=>1, core=>0},
#    'experimental'              => {pp=>1, core=>0}, 
#    'List::Util'                => {pp=>0, core=>1},
#    'Scalar::Util::Numeric'     => {pp=>0, core=>0},
#    'Scalar::Util::Numeric::PP' => {pp=>1, core=>0},
#    'Scalar::Util'              => {pp=>0, core=>1},
#    'Storable'                  => {pp=>0, core=>1},
#    'Time::Duration::Parse::AsHash' => {pp=>1, core=>0},
#    'Time::Local'               => {pp=>1, core=>1},
#    'Time::Moment'              => {pp=>0, core=>0},
#    'Time::Piece'               => {pp=>0, core=>1},
#    'warnings'                  => {pp=>1, core=>1},
#);
#
#sub add_module {
#    my ($self, $cd, $name, $extra_keys, $allow_duplicate) = @_;
#
#    if (exists $extra_keys->{core}) {
#        $known_modules{$name}{core} = $extra_keys->{core};
#    }
#
#    if (exists $extra_keys->{pp}) {
#        $known_modules{$name}{pp} = $extra_keys->{pp};
#    }
#
#    if ($extra_keys->{phase} eq 'runtime') {
#        if ($cd->{args}{no_modules}) {
#            die "BUG: Use of module '$name' when compile option no_modules=1";
#        }
#
#        if ($cd->{args}{whitelist_modules} && grep { $_ eq $name } @{ $cd->{args}{whitelist_modules} }) {
#            goto PASS;
#        }
#
#        if ($cd->{args}{pp}) {
#            if (!$known_modules{$name}) {
#                die "BUG: Haven't noted about Perl module '$name' as being pp/xs";
#            } elsif (!$known_modules{$name}{pp}) {
#                die "Use of XS module '$name' when compile option pp=1";
#            }
#        }
#
#        if ($cd->{args}{core}) {
#            if (!$known_modules{$name}) {
#                die "BUG: Haven't noted about Perl module '$name' as being core/non-core";
#            } elsif (!$known_modules{$name}{core}) {
#                die "Use of non-core module '$name' when compile option core=1";
#            }
#        }
#
#        if ($cd->{args}{core_or_pp}) {
#            if (!$known_modules{$name}) {
#                die "BUG: Haven't noted about Perl module '$name' as being core/non-core or pp/xs";
#            } elsif (!$known_modules{$name}{pp} && !$known_modules{$name}{core}) {
#                die "Use of non-core XS module '$name' when compile option core_or_pp=1";
#            }
#        }
#    }
#  PASS:
#    $self->SUPER::add_module($cd, $name, $extra_keys, $allow_duplicate);
#}
#
#sub add_runtime_use {
#    my ($self, $cd, $name, $import_terms) = @_;
#    my $use_statement = "use $name".
#        ($import_terms && @$import_terms ? " (".(join ",", @$import_terms).")" : "");
#
#    for my $mod (@{ $cd->{modules} }) {
#        next unless $mod->{phase} eq 'runtime';
#        return if $mod->{use_statement} &&
#            $mod->{use_statement} eq $use_statement;
#    }
#
#    $self->add_runtime_module(
#        $cd,
#        $name,
#        {
#            use_statement => $use_statement,
#        },
#        1, 
#    );
#}
#
#sub add_runtime_no {
#    my ($self, $cd, $name, $import_terms) = @_;
#
#    my $use_statement = "no $name".
#        ($import_terms && @$import_terms ? " (".(join ",", @$import_terms).")" : "");
#
#    for my $mod (@{ $cd->{modules} }) {
#        next unless $mod->{phase} eq 'runtime';
#        return if $mod->{use_statement} &&
#            $mod->{use_statement} eq $use_statement;
#    }
#
#    $self->add_runtime_module(
#        $cd,
#        $name,
#        {
#            use_statement => $use_statement,
#        },
#        1, 
#    );
#}
#
#sub add_runtime_smartmatch_pragma {
#    my ($self, $cd) = @_;
#    $self->add_runtime_use($cd, 'experimental', ['"smartmatch"']);
#}
#
#sub add_sun_module {
#    my ($self, $cd) = @_;
#    if ($cd->{args}{pp} || $cd->{args}{core_or_pp} ||
#            !eval { require Scalar::Util::Numeric; 1 }) {
#        $cd->{_sun_module} = 'Scalar::Util::Numeric::PP';
#    } elsif ($cd->{args}{core}) {
#        $cd->{_sun_module} = 'Foo';
#    } else {
#        $cd->{_sun_module} = 'Scalar::Util::Numeric';
#    }
#    $self->add_runtime_module($cd, $cd->{_sun_module});
#}
#
#sub expr_list {
#    my ($self, @t) = @_;
#    "(".join(", ", @t).")";
#}
#
#sub expr_defined {
#    my ($self, $t) = @_;
#    "defined($t)";
#}
#
#sub expr_array {
#    my ($self, @t) = @_;
#    "[".join(",", @t)."]";
#}
#
#sub expr_array_subscript {
#    my ($self, $at, $idxt) = @_;
#    "$at->\[$idxt]";
#}
#
#sub expr_last_elem {
#    my ($self, $at, $idxt) = @_;
#    "$at->\[-1]";
#}
#
#sub expr_push {
#    my ($self, $at, $elt) = @_;
#    "push(\@{$at}, $elt)";
#}
#
#sub expr_pop {
#    my ($self, $at, $elt) = @_;
#    "pop(\@{$at})";
#}
#
#sub expr_push_and_pop_dpath_between_expr {
#    my ($self, $et) = @_;
#    join(
#        "",
#        "[",
#        $self->expr_push('$_sahv_dpath', $self->literal(undef)), ", ", 
#        "~~", $self->enclose_paren($et), ", ", 
#        $self->expr_pop('$_sahv_dpath'), 
#        "]->[1]",
#    );
#}
#
#sub expr_prefix_dpath {
#    my ($self, $t) = @_;
#    '(@$_sahv_dpath ? \'@\'.join("",map {"[$_]"} @$_sahv_dpath).": " : "") . ' . $t;
#}
#
#sub expr_set {
#    my ($self, $l, $r) = @_;
#    "($l = $r)";
#}
#
#sub expr_setif {
#    my ($self, $l, $r) = @_;
#    "($l //= $r)";
#}
#
#sub expr_set_err_str {
#    my ($self, $et, $err_expr) = @_;
#    "($et //= $err_expr)";
#}
#
#sub expr_set_err_full {
#    my ($self, $et, $k, $err_expr) = @_;
#    "($et\->{$k}{join('/',\@\$_sahv_dpath)} //= $err_expr)";
#}
#
#sub expr_reset_err_str {
#    my ($self, $et, $err_expr) = @_;
#    "($et = undef, 1)";
#}
#
#sub expr_reset_err_full {
#    my ($self, $et) = @_;
#    "(delete($et\->{errors}{join('/',\@\$_sahv_dpath)}), 1)";
#}
#
#sub expr_ternary {
#    my ($self, $cond_term, $true_term, $false_term) = @_;
#    "$cond_term ? $true_term : $false_term";
#}
#
#sub expr_log {
#    my ($self, $cd, @expr) = @_;
#
#    "log_trace('[sah validator](spath=%s) %s', " .
#        $self->literal($cd->{spath}).", " . join(", ", @expr) . ")";
#}
#
#sub expr_block {
#    my ($self, $code) = @_;
#    join(
#        "",
#        "do {\n",
#        __indent(
#            $self->indent_character,
#            $code,
#        ),
#        "}",
#    );
#}
#
#sub block_uses_sub { 0 }
#
#sub stmt_declare_local_var {
#    my ($self, $v, $vt) = @_;
#    if ($vt eq 'undef') {
#        "my \$$v;";
#    } else {
#        "my \$$v = $vt;";
#    }
#}
#
#sub expr_anon_sub {
#    my ($self, $args, $code) = @_;
#    join(
#        "",
#        "sub {\n",
#        __indent(
#            $self->indent_character,
#            join(
#                "",
#                ("my (".join(", ", @$args).") = \@_;\n") x !!@$args,
#                $code,
#            ),
#        ),
#        "}"
#    );
#}
#
#sub expr_eval {
#    my ($self, $stmt) = @_;
#    "(eval { $stmt }, !\$@)";
#}
#
#sub stmt_require_module {
#    my ($self, $mod_record) = @_;
#
#    if ($mod_record->{use_statement}) {
#        return "$mod_record->{use_statement};";
#    } else {
#        "require $mod_record->{name};";
#    }
#}
#
#sub stmt_require_log_module {
#    my ($self) = @_;
#    'use Log::ger;';
#}
#
#sub stmt_assign_hash_value {
#    my ($self, $ht, $kt, $vt) = @_;
#    "$ht\->{$kt} = $vt;";
#}
#
#sub stmt_return {
#    my $self = shift;
#    if (@_) {
#        "return($_[0]);";
#    } else {
#        'return;';
#    }
#}
#
#sub expr_validator_sub {
#    my ($self, %args) = @_;
#
#    $self->check_compile_args(\%args);
#
#    my $aref = delete $args{accept_ref};
#    if ($aref) {
#        $args{var_term}  = '$ref_'.$args{data_name};
#        $args{data_term} = '$$ref_'.$args{data_name};
#    } else {
#        $args{var_term}  = '$'.$args{data_name};
#        $args{data_term} = '$'.$args{data_name};
#    }
#
#    $self->SUPER::expr_validator_sub(%args);
#}
#
#sub _str2reliteral {
#    require Regexp::Stringify;
#
#    my ($self, $cd, $str) = @_;
#
#    my $re;
#    if (ref($str) eq 'Regexp') {
#        $re = $str;
#    } else {
#        eval { $re = qr/$str/ };
#        $self->_die($cd, "Invalid regex $str: $@") if $@;
#    }
#
#    Regexp::Stringify::stringify_regexp(regexp=>$re, plver=>5.010);
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH.pm ###
#package Data::Sah::Compiler::perl::TH;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::Prog::TH';
#
#sub gen_each {
#    my ($self, $cd, $indices_expr, $data_name, $data_term, $code_at_sub_begin) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $dt = $cd->{data_term};
#
#    local $cd->{_subdata_level} = $cd->{_subdata_level} + 1;
#
#    $c->add_runtime_module($cd, 'List::Util');
#    my %iargs = %{$cd->{args}};
#    $iargs{outer_cd}             = $cd;
#    $iargs{data_name}            = $data_name;
#    $iargs{data_term}            = $data_term;
#    $iargs{schema}               = $cv;
#    $iargs{schema_is_normalized} = 0;
#    $iargs{indent_level}++;
#    $iargs{data_term_includes_topic_var} = 1;
#    my $icd = $c->compile(%iargs);
#    my @code = (
#        "!defined(List::Util::first(sub {", ($code_at_sub_begin // ''), "!(\n",
#        ($c->indent_str($cd),
#         "(\$_sahv_dpath->[-1] = \$_),\n") x !!$cd->{use_dpath},
#         $icd->{result}, "\n",
#         $c->indent_str($icd), ")}, ",
#         $indices_expr,
#         "))",
#    );
#    $c->add_ccl($cd, join("", @code), {subdata=>1});
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/all.pm ###
#package Data::Sah::Compiler::perl::TH::all;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#
#use parent (
#    'Data::Sah::Compiler::perl::TH',
#    'Data::Sah::Compiler::Prog::TH::all',
#);
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/any.pm ###
#package Data::Sah::Compiler::perl::TH::any;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#
#use parent (
#    'Data::Sah::Compiler::perl::TH',
#    'Data::Sah::Compiler::Prog::TH::any',
#);
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/array.pm ###
#package Data::Sah::Compiler::perl::TH::array;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::array';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = "ref($dt) eq 'ARRAY'";
#}
#
#my $FRZ = "Storable::freeze";
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_runtime_module($cd, 'Storable');
#
#    if ($which eq 'is') {
#        $c->add_ccl($cd, "$FRZ($dt) eq $FRZ($ct)");
#    } elsif ($which eq 'in') {
#        $c->add_runtime_smartmatch_pragma($cd);
#        $c->add_ccl($cd, "$FRZ($dt) ~~ [map {$FRZ(\$_)} \@{ $ct }]");
#    }
#}
#
#sub superclause_has_elems {
#    my ($self_th, $which, $cd) = @_;
#    my $c  = $self_th->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'len') {
#        $c->add_ccl($cd, "\@{$dt} == $ct");
#    } elsif ($which eq 'min_len') {
#        $c->add_ccl($cd, "\@{$dt} >= $ct");
#    } elsif ($which eq 'max_len') {
#        $c->add_ccl($cd, "\@{$dt} <= $ct");
#    } elsif ($which eq 'len_between') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl(
#                $cd, "\@{$dt} >= $ct\->[0] && \@{$dt} >= $ct\->[1]");
#        } else {
#            $c->add_ccl(
#                $cd, "\@{$dt} >= $cv->[0] && \@{$dt} <= $cv->[1]");
#        }
#    } elsif ($which eq 'has') {
#        $c->add_runtime_smartmatch_pragma($cd);
#
#        $c->add_ccl($cd, "$ct ~~ $dt");
#    } elsif ($which eq 'each_index') {
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#        $self_th->gen_each($cd, "0..\@{$cd->{data_term}}-1", '_', '$_');
#        $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#    } elsif ($which eq 'each_elem') {
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#        $self_th->gen_each($cd, "0..\@{$cd->{data_term}}-1", '_', "$cd->{data_term}\->[\$_]");
#        $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#    } elsif ($which eq 'check_each_index') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'check_each_elem') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'uniq') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'exists') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    }
#}
#
#sub clause_elems {
#    my ($self_th, $cd) = @_;
#    my $c  = $self_th->compiler;
#    my $cv = $cd->{cl_value};
#    my $dt = $cd->{data_term};
#
#    local $cd->{_subdata_level} = $cd->{_subdata_level} + 1;
#
#    my $jccl;
#    {
#        local $cd->{ccls} = [];
#
#        my $cdef = $cd->{clset}{"elems.create_default"} // 1;
#        delete $cd->{uclset}{"elems.create_default"};
#
#        for my $i (0..@$cv-1) {
#            local $cd->{spath} = [@{$cd->{spath}}, $i];
#            my $sch = $c->main->normalize_schema($cv->[$i]);
#            my $edt = "$dt\->[$i]";
#            my %iargs = %{$cd->{args}};
#            $iargs{outer_cd}             = $cd;
#            $iargs{data_name}            = "$cd->{args}{data_name}_$i";
#            $iargs{data_term}            = $edt;
#            $iargs{schema}               = $sch;
#            $iargs{schema_is_normalized} = 1;
#            $iargs{indent_level}++;
#            my $icd = $c->compile(%iargs);
#            my @code = (
#                ($c->indent_str($cd), "(\$_sahv_dpath->[-1] = $i),\n") x !!$cd->{use_dpath},
#                $icd->{result}, "\n",
#            );
#            my $ires = join("", @code);
#            local $cd->{_debug_ccl_note} = "elem: $i";
#            if ($cdef && defined($sch->[1]{default})) {
#                $c->add_ccl($cd, $ires);
#            } else {
#                $c->add_ccl($cd, "\@{$dt} < ".($i+1)." || ($ires)");
#            }
#        }
#        $jccl = $c->join_ccls(
#            $cd, $cd->{ccls}, {err_msg => ''});
#    }
#    $c->add_ccl($cd, $jccl, {subdata=>1});
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/bool.pm ###
#package Data::Sah::Compiler::perl::TH::bool;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::bool';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = "!ref($dt)";
#}
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'is') {
#        $c->add_ccl($cd, "($dt ? 1:0) == ($ct ? 1:0)");
#    } elsif ($which eq 'in') {
#        $c->add_runtime_smartmatch_pragma($cd);
#        $c->add_ccl($cd, "($dt ? 1:0) ~~ [map {\$_?1:0} \@{$ct}]");
#    }
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'min') {
#        $c->add_ccl($cd, "($dt ? 1:0) >= ($ct ? 1:0)");
#    } elsif ($which eq 'xmin') {
#        $c->add_ccl($cd, "($dt ? 1:0) > ($ct ? 1:0)");
#    } elsif ($which eq 'max') {
#        $c->add_ccl($cd, "($dt ? 1:0) <= ($ct ? 1:0)");
#    } elsif ($which eq 'xmax') {
#        $c->add_ccl($cd, "($dt ? 1:0) < ($ct ? 1:0)");
#    } elsif ($which eq 'between') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "($dt ? 1:0) >= ($ct\->[0] ? 1:0) && ".
#                            "($dt ? 1:0) <= ($ct\->[1] ? 1:0)");
#        } else {
#            $c->add_ccl($cd, "($dt ? 1:0) >= ($cv->[0] ? 1:0) && ".
#                            "($dt ? 1:0) <= ($cv->[1] ? 1:0)");
#        }
#    } elsif ($which eq 'xbetween') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "($dt ? 1:0) > ($ct\->[0] ? 1:0) && ".
#                            "($dt ? 1:0) < ($ct\->[1] ? 1:0)");
#        } else {
#            $c->add_ccl($cd, "($dt ? 1:0) > ($cv->[0] ? 1:0) && ".
#                            "($dt ? 1:0) < ($cv->[1] ? 1:0)");
#        }
#    }
#}
#
#sub clause_is_true {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_ccl($cd, "($ct) ? $dt : !defined($ct) ? 1 : !$dt");
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/buf.pm ###
#package Data::Sah::Compiler::perl::TH::buf;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH::str';
#with 'Data::Sah::Type::buf';
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/cistr.pm ###
#package Data::Sah::Compiler::perl::TH::cistr;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH::str';
#with 'Data::Sah::Type::cistr';
#
#sub before_all_clauses {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#    my $dt = $cd->{data_term};
#
#
#    $self->set_tmp_data_term($cd, "lc($dt)");
#}
#
#sub after_all_clauses {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#    my $dt = $cd->{data_term};
#
#    $self->restore_data_term($cd);
#}
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'is') {
#        $c->add_ccl($cd, "$dt eq lc($ct)");
#    } elsif ($which eq 'in') {
#        $c->add_runtime_smartmatch_pragma($cd);
#        $c->add_ccl($cd, "$dt ~~ [map {lc} \@{ $ct }]");
#    }
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'min') {
#        $c->add_ccl($cd, "$dt ge lc($ct)");
#    } elsif ($which eq 'xmin') {
#        $c->add_ccl($cd, "$dt gt lc($ct)");
#    } elsif ($which eq 'max') {
#        $c->add_ccl($cd, "$dt le lc($ct)");
#    } elsif ($which eq 'xmax') {
#        $c->add_ccl($cd, "$dt lt lc($ct)");
#    } elsif ($which eq 'between') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "$dt ge lc($ct\->[0]) && ".
#                            "$dt le lc($ct\->[1])");
#        } else {
#            $c->add_ccl($cd, "$dt ge ".$c->literal(lc $cv->[0]).
#                            " && $dt le ".$c->literal(lc $cv->[1]));
#        }
#    } elsif ($which eq 'xbetween') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "$dt gt lc($ct\->[0]) && ".
#                            "$dt lt lc($ct\->[1])");
#        } else {
#            $c->add_ccl($cd, "$dt gt ".$c->literal(lc $cv->[0]).
#                            " && $dt lt ".$c->literal(lc $cv->[1]));
#        }
#    }
#}
#
#sub superclause_has_elems {
#    my ($self_th, $which, $cd) = @_;
#    my $c  = $self_th->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'has') {
#        $c->add_ccl($cd, "index($dt, lc($ct)) > -1");
#    } else {
#        $self_th->SUPER::superclause_has_elems($which, $cd);
#    }
#}
#
#sub __change_re_str_switch {
#    my $re = shift;
#
#    if ($^V ge v5.14.0) {
#        state $sub = sub { my $s = shift; $s =~ /i/ ? $s : "i$s" };
#        $re =~ s/\A\(\?\^(\w*):/"(?".$sub->($1).":"/e;
#    } else {
#        state $subl = sub { my $s = shift; $s =~ /i/ ? $s : "i$s" };
#        state $subr = sub { my $s = shift; $s =~ s/i//; $s };
#        $re =~ s/\A\(\?(\w*)-(\w*):/"(?".$subl->($1)."-".$subr->($2).":"/e;
#    }
#    return $re;
#}
#
#sub clause_match {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->add_ccl($cd, join(
#            "",
#            "ref($ct) eq 'Regexp' ? $dt =~ qr/$ct/i : ",
#            "do { my \$re = $ct; eval { \$re = /\$re/i; 1 } && ",
#            "$dt =~ \$re }",
#        ));
#    } else {
#        my $re = $c->_str2reliteral($cd, $cv);
#        $re = __change_re_str_switch($re);
#        $c->add_ccl($cd, "$dt =~ /$re/i");
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/code.pm ###
#package Data::Sah::Compiler::perl::TH::code;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::code';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = "ref($dt) eq 'CODE'";
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/date.pm ###
#package Data::Sah::Compiler::perl::TH::date;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#use Scalar::Util qw(blessed looks_like_number);
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::date';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $dt = $cd->{data_term};
#
#    $cd->{coerce_to} = $cd->{nschema}[1]{"x.perl.coerce_to"} // 'float(epoch)';
#
#    my $coerce_to = $cd->{coerce_to};
#
#    if ($coerce_to eq 'float(epoch)') {
#        $cd->{_ccl_check_type} = "!ref($dt) && $dt =~ /\\A[0-9]+\\z/";
#    } elsif ($coerce_to eq 'DateTime') {
#        $c->add_runtime_module($cd, 'Scalar::Util');
#        $cd->{_ccl_check_type} = "Scalar::Util::blessed($dt) && $dt\->isa('DateTime')";
#    } elsif ($coerce_to eq 'Time::Moment') {
#        $c->add_runtime_module($cd, 'Scalar::Util');
#        $cd->{_ccl_check_type} = "Scalar::Util::blessed($dt) && $dt\->isa('Time::Moment')";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', use either ".
#            "float(epoch), DateTime, or Time::Moment";
#    }
#}
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die($cd, "date's comparison with expression not yet supported");
#    }
#
#    my $coerce_to = $cd->{coerce_to};
#    if ($coerce_to eq 'float(epoch)') {
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "$dt == $ct");
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module($cd, 'List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{$dt == \$_}, $ct)");
#        }
#    } elsif ($coerce_to eq 'DateTime') {
#        my $ect = "DateTime->from_epoch(epoch=>".$cv->epoch.")";
#
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect)==0");
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module($cd, 'List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{DateTime->compare($dt, \$_)==0}, $ect)");
#        }
#    } elsif ($coerce_to eq 'Time::Moment') {
#        my $ect = "Time::Moment->from_epoch(".$cv->epoch.")";
#
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "$dt\->compare($ect)==0");
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module($cd, 'List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{$dt\->compare(\$_)==0}, $ect)");
#        }
#    }
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die($cd, "date's comparison with expression not yet supported");
#    }
#
#    my $coerce_to = $cd->{coerce_to};
#    if ($coerce_to eq 'float(epoch)') {
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "$dt >= $cv");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "$dt > $cv");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "$dt <= $cv");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "$dt < $cv");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "$dt >= $cv->[0] && $dt <= $cv->[1]");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "$dt >  $cv->[0] && $dt <  $cv->[1]");
#        }
#    } elsif ($coerce_to eq 'DateTime') {
#        my ($ect, $ect0, $ect1);
#        if (ref($cv) eq 'ARRAY') {
#            $ect0 = "DateTime->from_epoch(epoch=>".$cv->[0]->epoch.")";
#            $ect1 = "DateTime->from_epoch(epoch=>".$cv->[1]->epoch.")";
#        } else {
#            $ect = "DateTime->from_epoch(epoch=>".$cv->epoch.")";
#        }
#
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) >= 0");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) > 0");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) <= 0");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) < 0");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect0) >= 0 && DateTime->compare($dt, $ect1) <= 0");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect0) >  0 && DateTime->compare($dt, $ect1) <  0");
#        }
#    } elsif ($coerce_to eq 'Time::Moment') {
#        my ($ect, $ect0, $ect1);
#        if (ref($cv) eq 'ARRAY') {
#            $ect0 = "Time::Moment->from_epoch(".$cv->[0]->epoch.")";
#            $ect1 = "Time::Moment->from_epoch(".$cv->[1]->epoch.")";
#        } else {
#            $ect = "Time::Moment->from_epoch(".$cv->epoch.")";
#        }
#
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "$dt\->compare($ect) >= 0");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "$dt\->compare($ect) > 0");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "$dt\->compare($ect) <= 0");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "$dt\->compare($ect) < 0");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "$dt\->compare($ect0) >= 0 && $dt\->compare($ect1) <= 0");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "$dt\->compare($ect0) >  0 && $dt\->compare($ect1) <  0");
#        }
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/datenotime.pm ###
#package Data::Sah::Compiler::perl::TH::datenotime;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH::date';
#with 'Data::Sah::Type::datenotime';
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/datetime.pm ###
#package Data::Sah::Compiler::perl::TH::datetime;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH::date';
#with 'Data::Sah::Type::datetime';
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/duration.pm ###
#package Data::Sah::Compiler::perl::TH::duration;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#use Scalar::Util qw(blessed looks_like_number);
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::duration';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $dt = $cd->{data_term};
#
#    $cd->{coerce_to} = $cd->{nschema}[1]{"x.perl.coerce_to"} // 'float(secs)';
#
#    my $coerce_to = $cd->{coerce_to};
#
#    if ($coerce_to eq 'float(secs)') {
#        $cd->{_ccl_check_type} = "!ref($dt) && $dt =~ /\\A[0-9]+(?:\.[0-9]+)?\\z/"; 
#    } elsif ($coerce_to eq 'DateTime::Duration') {
#        $c->add_runtime_module($cd, 'Scalar::Util');
#        $cd->{_ccl_check_type} = "Scalar::Util::blessed($dt) && $dt\->isa('DateTime::Duration')";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', use either ".
#            "float(secs) or DateTime::Duration";
#    }
#}
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die($cd, "duration's comparison with expression not yet supported");
#    }
#
#    my $coerce_to = $cd->{coerce_to};
#    if ($coerce_to eq 'float(secs)') {
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "$dt == $ct"); 
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module('List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{$dt == \$_}, $ct)"); 
#        }
#    } elsif ($coerce_to eq 'DateTime::Duration') {
#        my $ect = join(
#            "",
#            "DateTime::Duration->new(",
#            "years => "  .$cv->years.",",
#            "months => " .$cv->months.",",
#            "weeks => "  .$cv->weeks.",",
#            "days => "   .$cv->days.",",
#            "hours => "  .$cv->hours.",",
#            "minutes => ".$cv->minutes.",",
#            "seconds => ".$cv->seconds.",",
#            ")",
#        );
#
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "DateTime::Duration->compare($dt, $ect)==0");
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module('List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{DateTime::Duration->compare($dt, \$_)==0}, $ect)");
#        }
#    }
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die($cd, "duration's comparison with expression not yet supported");
#    }
#
#    my $coerce_to = $cd->{coerce_to};
#    if ($coerce_to eq 'float(secs)') {
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "$dt >= $cv");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "$dt > $cv");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "$dt <= $cv");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "$dt < $cv");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "$dt >= $cv->[0] && $dt <= $cv->[1]");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "$dt >  $cv->[0] && $dt <  $cv->[1]");
#        }
#    } elsif ($coerce_to eq 'DateTime::Duration') {
#        my ($ect, $ect0, $ect1);
#        if (ref($cv) eq 'ARRAY') {
#            $ect0 = join(
#                "",
#                "DateTime::Duration->new(",
#                "years => "  .$cv->[0]->years.",",
#                "months => " .$cv->[0]->months.",",
#                "weeks => "  .$cv->[0]->weeks.",",
#                "days => "   .$cv->[0]->days.",",
#                "hours => "  .$cv->[0]->hours.",",
#                "minutes => ".$cv->[0]->minutes.",",
#                "seconds => ".$cv->[0]->seconds.",",
#                ")",
#            );
#            $ect1 = join(
#                "",
#                "DateTime::Duration->new(",
#                "years => "  .$cv->[1]->years.",",
#                "months => " .$cv->[1]->months.",",
#                "weeks => "  .$cv->[1]->weeks.",",
#                "days => "   .$cv->[1]->days.",",
#                "hours => "  .$cv->[1]->hours.",",
#                "minutes => ".$cv->[1]->minutes.",",
#                "seconds => ".$cv->[1]->seconds.",",
#                ")",
#            );
#        } else {
#            $ect = join(
#                "",
#                "DateTime::Duration->new(",
#                "years => "  .$cv->years.",",
#                "months => " .$cv->months.",",
#                "weeks => "  .$cv->weeks.",",
#                "days => "   .$cv->days.",",
#                "hours => "  .$cv->hours.",",
#                "minutes => ".$cv->minutes.",",
#                "seconds => ".$cv->seconds.",",
#                ")",
#            );
#        }
#
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) >= 0");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) > 0");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) <= 0");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect) < 0");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect0) >= 0 && DateTime->compare($dt, $ect1) <= 0");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "DateTime->compare($dt, $ect0) >  0 && DateTime->compare($dt, $ect1) <  0");
#        }
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/float.pm ###
#package Data::Sah::Compiler::perl::TH::float;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH::num';
#with 'Data::Sah::Type::float';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#        $cd->{_ccl_check_type} = "$dt =~ ".'/\A(?:[+-]?(?:0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?|((?i)\s*nan\s*)|((?i)\s*[+-]?inf(inity)?)\s*)\z/';
#    } else {
#        $c->add_sun_module($cd);
#        $cd->{_ccl_check_type} = "$cd->{_sun_module}::isnum($dt)";
#    }
#}
#
#sub clause_is_nan {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#            $c->add_ccl(
#                $cd,
#                qq[$ct ? lc($dt+0) eq "nan" : defined($ct) ? lc($dt+0) ne "nan" : 1],
#            );
#        } else {
#            $c->add_ccl(
#                $cd,
#                join(
#                    "",
#                    "$ct ? $cd->{_sun_module}::isnan($dt) : ",
#                    "defined($ct) ? !$cd->{_sun_module}::isnan($dt) : 1",
#                )
#            );
#        }
#    } else {
#        if ($cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[lc($dt+0) eq "nan"]);
#            } else {
#                $c->add_ccl($cd, "$cd->{_sun_module}::isnan($dt)");
#            }
#        } elsif (defined $cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[lc($dt+0) ne "nan"]);
#            } else {
#                $c->add_ccl($cd, "!$cd->{_sun_module}::isnan($dt)");
#            }
#        }
#    }
#}
#
#sub clause_is_neg_inf {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#            $c->add_ccl(
#                $cd, join(
#                    '',
#                    qq[$ct ? $dt =~ /\\A\\s*-inf(inity)?\\s*\\z/i : ],
#                    qq[defined($ct) ? $dt !~ /\\A\\s*inf(inity)?\\s*\\z/i : 1]
#                ));
#        } else {
#            $c->add_ccl(
#                $cd, join(
#                    '',
#                    "$ct ? $cd->{_sun_module}::isinf($dt) && $cd->{_sun_module}::isneg($dt) : ",
#                    "defined($ct) ? !($cd->{_sun_module}::isinf($dt) && $cd->{_sun_module}::isneg($dt)) : 1",
#                ));
#        }
#    } else {
#        if ($cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[$dt =~ /\\A\\s*-inf(inity)?\\s*\\z/i]);
#            } else {
#                $c->add_ccl($cd, "$cd->{_sun_module}::isinf($dt) && $cd->{_sun_module}::isneg($dt)");
#            }
#        } elsif (defined $cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[$dt !~ /\\A\\s*-inf(inity)?\\s*\\z/i]);
#            } else {
#                $c->add_ccl($cd, "!($cd->{_sun_module}::isinf($dt) && $cd->{_sun_module}::isneg($dt))");
#            }
#        }
#    }
#}
#
#sub clause_is_pos_inf {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#            $c->add_ccl(
#                $cd, join(
#                    '',
#                    qq[$ct ? $dt =~ /\\A\\s*inf(inity)?\\s*\\z/i : ],
#                    qq[defined($ct) ? $dt !~ /\\A\\s*inf(inity)?\\s*\\z/i : 1]
#                ));
#        } else {
#            $c->add_ccl(
#                $cd, join(
#                    '',
#                    "$ct ? $cd->{_sun_module}::isinf($dt) && !$cd->{_sun_module}::isneg($dt) : ",
#                    "defined($ct) ? !($cd->{_sun_module}::isinf($dt) && !$cd->{_sun_module}::isneg($dt)) : 1",
#                ));
#        }
#    } else {
#        if ($cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[$dt =~ /\\A\\s*inf(inity)?\\s*\\z/i]);
#            } else {
#                $c->add_ccl($cd, "$cd->{_sun_module}::isinf($dt) && !$cd->{_sun_module}::isneg($dt)");
#            }
#        } elsif (defined $cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[$dt !~ /\\A\\s*inf(inity)?\\s*\\z/i]);
#            } else {
#                $c->add_ccl($cd, "!($cd->{_sun_module}::isinf($dt) && !$cd->{_sun_module}::isneg($dt))");
#            }
#        }
#    }
#}
#
#sub clause_is_inf {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#            $c->add_ccl(
#                $cd, join(
#                    '',
#                    qq[$ct ? $dt =~ /\\A\\s*-?inf(inity)?\\s*\\z/i : ],
#                    qq[defined($ct) ? $dt+0 !~ /\\A-?inf\\z/ : 1]
#                ));
#        } else {
#            $c->add_ccl($cd, "$ct ? $cd->{_sun_module}::isinf($dt) : ".
#                            "defined($ct) ? $cd->{_sun_module}::isinf($dt) : 1");
#        }
#    } else {
#        if ($cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[$dt =~ /\\A\\s*-?inf(inity)?\\s*\\z/i]);
#            } else {
#                $c->add_ccl($cd, "$cd->{_sun_module}::isinf($dt)");
#            }
#        } elsif (defined $cd->{cl_value}) {
#            if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#                $c->add_ccl($cd, qq[$dt !~ /\\A\\s*-?inf(inity)?\\s*\\z/i]);
#            } else {
#                $c->add_ccl($cd, "!$cd->{_sun_module}::isinf($dt)");
#            }
#        }
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/hash.pm ###
#package Data::Sah::Compiler::perl::TH::hash;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Data::Dmp;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::hash';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = "ref($dt) eq 'HASH'";
#}
#
#my $FRZ = "Storable::freeze";
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_runtime_module($cd, 'Storable');
#
#    if ($which eq 'is') {
#        $c->add_ccl($cd, "$FRZ($dt) eq $FRZ($ct)");
#    } elsif ($which eq 'in') {
#        $c->add_runtime_smartmatch_pragma($cd);
#        $c->add_ccl($cd, "$FRZ($dt) ~~ [map {$FRZ(\$_)} \@{ $ct }]");
#    }
#}
#
#sub superclause_has_elems {
#    my ($self_th, $which, $cd) = @_;
#    my $c  = $self_th->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'len') {
#        $c->add_ccl($cd, "keys(\%{$dt}) == $ct");
#    } elsif ($which eq 'min_len') {
#        $c->add_ccl($cd, "keys(\%{$dt}) >= $ct");
#    } elsif ($which eq 'max_len') {
#        $c->add_ccl($cd, "keys(\%{$dt}) <= $ct");
#    } elsif ($which eq 'len_between') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl(
#                $cd, "keys(\%{$dt}) >= $ct\->[0] && ".
#                    "keys(\%{$dt}) >= $ct\->[1]");
#        } else {
#            $c->add_ccl(
#                $cd, "keys(\%{$dt}) >= $cv->[0] && ".
#                    "keys(\%{$dt}) <= $cv->[1]");
#        }
#    } elsif ($which eq 'has') {
#        $c->add_runtime_smartmatch_pragma($cd);
#
#        $c->add_ccl($cd, "$ct ~~ [values \%{ $dt }]");
#    } elsif ($which eq 'each_index') {
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#        $self_th->gen_each($cd, "sort keys(\%{$cd->{data_term}})", '', '$_');
#        $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#    } elsif ($which eq 'each_elem') {
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#        $self_th->gen_each($cd, "sort keys(\%{$cd->{data_term}})", '_', "$cd->{data_term}\->{\$_}");
#        $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#    } elsif ($which eq 'check_each_index') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'check_each_elem') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'uniq') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'exists') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    }
#}
#
#sub _clause_keys_or_re_keys {
#    my ($self_th, $which, $cd) = @_;
#    my $c  = $self_th->compiler;
#    my $cv = $cd->{cl_value};
#    my $dt = $cd->{data_term};
#
#    local $cd->{_subdata_level} = $cd->{_subdata_level} + 1;
#
#
#    my $jccl;
#    {
#        local $cd->{ccls} = [];
#
#        my $lit_valid_keys;
#        if ($which eq 'keys') {
#            $lit_valid_keys = $c->literal([sort keys %$cv]);
#        } else {
#            $lit_valid_keys = "[".
#                join(",", map { "qr/".$c->_str2reliteral($cd, $_)."/" }
#                         sort keys %$cv)."]";
#        }
#
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#
#        if ($cd->{clset}{"$which.restrict"} // 1) {
#            local $cd->{_debug_ccl_note} = "$which.restrict";
#            $c->add_runtime_module($cd, "List::Util");
#            $c->add_runtime_smartmatch_pragma($cd);
#            $c->add_ccl(
#                $cd,
#                "!defined(List::Util::first(sub {!(\$_ ~~ $lit_valid_keys)}, ".
#                    "keys %{$cd->{data_term}}))",
#                {
#                    err_msg => 'TMP1',
#                    err_expr => join(
#                        "",
#                        'sprintf(',
#                        $c->literal($c->_xlt(
#                            $cd, "hash contains ".
#                                "unknown field(s) (%s)")),
#                        ',',
#                        "join(', ', sort grep {!(\$_ ~~ $lit_valid_keys)} ",
#                        "keys %{$cd->{data_term}})",
#                        ')',
#                    ),
#                },
#            );
#            $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#        }
#        delete $cd->{uclset}{"$which.restrict"};
#
#        my $cdef;
#        if ($which eq 'keys') {
#            $cdef = $cd->{clset}{"keys.create_default"} // 1;
#            delete $cd->{uclset}{"keys.create_default"};
#        }
#
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#
#        my $nkeys = scalar(keys %$cv);
#        my $i = 0;
#        for my $k (sort keys %$cv) {
#            my $kre = $c->_str2reliteral($cd, $k);
#            local $cd->{spath} = [@{ $cd->{spath} }, $k];
#            ++$i;
#            my $sch = $c->main->normalize_schema($cv->{$k});
#            my $kdn = $k; $kdn =~ s/\W+/_/g;
#            my $klit = $which eq 're_keys' ? '$_' : $c->literal($k);
#            my $kdt = "$cd->{data_term}\->{$klit}";
#            my %iargs = %{$cd->{args}};
#            $iargs{outer_cd}             = $cd;
#            $iargs{data_name}            = $kdn;
#            $iargs{data_term}            = $kdt;
#            $iargs{schema}               = $sch;
#            $iargs{schema_is_normalized} = 1;
#            $iargs{indent_level}++;
#            $iargs{data_term_includes_topic_var} = 1 if $which eq 're_keys';
#            my $icd = $c->compile(%iargs);
#
#            my $sdef = $cdef && defined($sch->[1]{default});
#
#            $c->add_var($cd, '_sahv_stack', []) if $cd->{use_dpath};
#
#            my @code = (
#                ($c->indent_str($cd), "(push(@\$_sahv_dpath, undef), push(\@\$_sahv_stack, undef), \$_sahv_stack->[-1] = \n")
#                    x !!($cd->{use_dpath} && $i == 1),
#
#                ('(!defined(List::Util::first(sub {!(')
#                    x !!($which eq 're_keys'),
#
#                $which eq 're_keys' ? "\$_ !~ /$kre/ || (" :
#                    ($sdef ? "" : "!exists($kdt) || ("),
#
#                ($c->indent_str($cd), "(\$_sahv_dpath->[-1] = ".
#                     ($which eq 're_keys' ? '$_' : $klit)."),\n")
#                         x !!$cd->{use_dpath},
#                $icd->{result}, "\n",
#
#                $which eq 're_keys' || !$sdef ? ")" : "",
#
#                (")}, sort keys %{ $cd->{data_term} })))")
#                    x !!($which eq 're_keys'),
#
#                ($c->indent_str($cd), "), pop(\@\$_sahv_dpath), pop(\@\$_sahv_stack)\n")
#                    x !!($cd->{use_dpath} && $i == $nkeys),
#            );
#            my $ires = join("", @code);
#            local $cd->{_debug_ccl_note} = "$which: ".$c->literal($k);
#            $c->add_ccl($cd, $ires);
#        }
#
#        $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#
#        $jccl = $c->join_ccls(
#            $cd, $cd->{ccls}, {err_msg => ''});
#    }
#    $c->add_ccl($cd, $jccl, {});
#}
#
#sub clause_keys {
#    my ($self, $cd) = @_;
#    $self->_clause_keys_or_re_keys('keys', $cd);
#}
#
#sub clause_re_keys {
#    my ($self, $cd) = @_;
#    $self->_clause_keys_or_re_keys('re_keys', $cd);
#}
#
#sub clause_req_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; !defined(List::Util::first(sub {!exists(\$_sahv_h\->{\$_})}, \@{ $ct })) }",
#      {
#        err_msg => 'TMP',
#        err_expr =>
#          "sprintf(".
#          $c->literal($c->_xlt($cd, "hash has missing required field(s) (%s)")).
#          ",join(', ', do { my \$_sahv_h = $dt; grep { !exists(\$_sahv_h\->{\$_}) } \@{ $ct } }))"
#      }
#    );
#}
#
#sub clause_allowed_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_runtime_smartmatch_pragma($cd);
#    $c->add_ccl(
#      $cd,
#      "!defined(List::Util::first(sub {!(\$_ ~~ $ct)}, keys \%{ $dt }))",
#      {
#        err_msg => 'TMP',
#        err_expr =>
#          "sprintf(".
#          $c->literal($c->_xlt($cd, "hash contains non-allowed field(s) (%s)")).
#          ",join(', ', sort grep { !(\$_ ~~ $ct) } keys \%{ $dt }))"
#      }
#    );
#}
#
#sub clause_allowed_keys_re {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die_unimplemented_clause($cd, "with expr");
#    }
#
#    my $re = $c->_str2reliteral($cd, $cv);
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_runtime_smartmatch_pragma($cd);
#    $c->add_ccl(
#        $cd,
#        "!defined(List::Util::first(sub {\$_ !~ /$re/}, keys \%{ $dt }))",
#        {
#          err_msg => 'TMP',
#          err_expr =>
#          "sprintf(".
#          $c->literal($c->_xlt($cd, "hash contains non-allowed field(s) (%s)")).
#          ",join(', ', sort grep { \$_ !~ /$re/ } keys \%{ $dt }))"
#      }
#    );
#}
#
#sub clause_forbidden_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_runtime_smartmatch_pragma($cd);
#    $c->add_ccl(
#      $cd,
#      "!defined(List::Util::first(sub {\$_ ~~ $ct}, keys \%{ $dt }))",
#      {
#        err_msg => 'TMP',
#        err_expr =>
#          "sprintf(".
#          $c->literal($c->_xlt($cd, "hash contains forbidden field(s) (%s)")).
#          ",join(', ', sort grep { \$_ ~~ $ct } keys \%{ $dt }))"
#      }
#    );
#}
#
#sub clause_forbidden_keys_re {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die_unimplemented_clause($cd, "with expr");
#    }
#
#    my $re = $c->_str2reliteral($cd, $cv);
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_runtime_smartmatch_pragma($cd);
#    $c->add_ccl(
#        $cd,
#        "!defined(List::Util::first(sub {\$_ =~ /$re/}, keys \%{ $dt }))",
#        {
#          err_msg => 'TMP',
#          err_expr =>
#          "sprintf(".
#          $c->literal($c->_xlt($cd, "hash contains forbidden field(s) (%s)")).
#          ",join(', ', sort grep { \$_ =~ /$re/ } keys \%{ $dt }))"
#      }
#    );
#}
#
#sub clause_choose_one_key {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@{ $ct }) <= 1 }",
#      {},
#    );
#}
#
#sub clause_choose_all_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; my \$_sahv_keys = $ct; my \$_sahv_tot = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@\$_sahv_keys); \$_sahv_tot==0 || \$_sahv_tot==\@\$_sahv_keys }",
#      {},
#    );
#}
#
#sub clause_req_one_key {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@{ $ct }) == 1 }",
#      {},
#    );
#}
#
#sub clause_req_some_keys {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; my \$_sahv_n = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@{ ".$c->literal($cv->[2])." }); \$_sahv_n >= $cv->[0] && \$_sahv_n <= $cv->[1] }",
#      {},
#    );
#}
#
#sub clause_dep_any {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; my \$_sahv_ct = $ct; ".
#          "my \$_sahv_has_prereq = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@{ \$_sahv_ct->[1] }) ? 1:0; ".
#          "my \$_sahv_has_dep    = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} (ref(\$_sahv_ct->[0]) eq 'ARRAY' ? \@{ \$_sahv_ct->[0] } : (\$_sahv_ct->[0]))) ? 1:0; ".
#          "!\$_sahv_has_dep || \$_sahv_has_prereq }",
#      {},
#    );
#}
#
#sub clause_dep_all {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; my \$_sahv_ct = $ct; ".
#          "my \$_sahv_has_prereq = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@{ \$_sahv_ct->[1] }) == \@{ \$_sahv_ct->[1] } ? 1:0; ".
#          "my \$_sahv_has_dep    = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} (ref(\$_sahv_ct->[0]) eq 'ARRAY' ? \@{ \$_sahv_ct->[0] } : (\$_sahv_ct->[0]))) ? 1:0; ".
#          "!\$_sahv_has_dep || \$_sahv_has_prereq }",
#      {},
#    );
#}
#
#sub clause_req_dep_any {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; my \$_sahv_ct = $ct; ".
#          "my \$_sahv_has_prereq = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@{ \$_sahv_ct->[1] }) ? 1:0; ".
#          "my \$_sahv_has_dep    = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} (ref(\$_sahv_ct->[0]) eq 'ARRAY' ? \@{ \$_sahv_ct->[0] } : (\$_sahv_ct->[0]))) ? 1:0; ".
#          "\$_sahv_has_dep || !\$_sahv_has_prereq }",
#      {},
#    );
#}
#
#sub clause_req_dep_all {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#
#    $c->add_runtime_module($cd, "List::Util");
#    $c->add_ccl(
#      $cd,
#      "do { my \$_sahv_h = $dt; my \$_sahv_ct = $ct; ".
#          "my \$_sahv_has_prereq = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} \@{ \$_sahv_ct->[1] }) == \@{ \$_sahv_ct->[1] } ? 1:0; ".
#          "my \$_sahv_has_dep    = List::Util::sum(map {exists(\$_sahv_h\->{\$_}) ? 1:0} (ref(\$_sahv_ct->[0]) eq 'ARRAY' ? \@{ \$_sahv_ct->[0] } : (\$_sahv_ct->[0]))) ? 1:0; ".
#          "\$_sahv_has_dep || !\$_sahv_has_prereq }",
#      {},
#    );
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/int.pm ###
#package Data::Sah::Compiler::perl::TH::int;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH::num';
#with 'Data::Sah::Type::int';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#        $cd->{_ccl_check_type} = "$dt =~ ".'/\A[+-]?(?:0|[1-9][0-9]*)\z/';
#    } else {
#        $c->add_sun_module($cd);
#        $cd->{_ccl_check_type} =
#            "$cd->{_sun_module}::isint($dt)";
#    }
#}
#
#sub clause_div_by {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_ccl($cd, "$dt % $ct == 0");
#}
#
#sub clause_mod {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_ccl($cd, "$dt % $ct\->[0] == $ct\->[1]");
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/num.pm ###
#package Data::Sah::Compiler::perl::TH::num;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::num';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#    my $dt = $cd->{data_term};
#
#    if ($cd->{args}{core} || $cd->{args}{no_modules}) {
#        $cd->{_ccl_check_type} = "$dt =~ ".'/\A(?:[+-]?(?:0|[1-9][0-9]*)(\.[0-9]+)?([eE][+-]?[0-9]+)?|((?i)\s*nan\s*)|((?i)\s*[+-]?inf(inity)?)\s*)\z/';
#    } else {
#        $c->add_sun_module($cd);
#        $cd->{_ccl_check_type} = "$cd->{_sun_module}::isnum($dt)";
#    }
#}
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'is') {
#        $c->add_ccl($cd, "$dt == $ct");
#    } elsif ($which eq 'in') {
#        $c->add_runtime_smartmatch_pragma($cd);
#        $c->add_ccl($cd, "$dt ~~ $ct");
#    }
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'min') {
#        $c->add_ccl($cd, "$dt >= $ct");
#    } elsif ($which eq 'xmin') {
#        $c->add_ccl($cd, "$dt > $ct");
#    } elsif ($which eq 'max') {
#        $c->add_ccl($cd, "$dt <= $ct");
#    } elsif ($which eq 'xmax') {
#        $c->add_ccl($cd, "$dt < $ct");
#    } elsif ($which eq 'between') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "$dt >= $ct\->[0] && $dt <= $ct\->[1]");
#        } else {
#            $c->add_ccl($cd, "$dt >= $cv->[0] && $dt <= $cv->[1]");
#        }
#    } elsif ($which eq 'xbetween') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "$dt > $ct\->[0] && $dt < $ct\->[1]");
#        } else {
#            $c->add_ccl($cd, "$dt > $cv->[0] && $dt < $cv->[1]");
#        }
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/obj.pm ###
#package Data::Sah::Compiler::perl::TH::obj;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::obj';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $c->add_runtime_module($cd, 'Scalar::Util');
#    $cd->{_ccl_check_type} = "Scalar::Util::blessed($dt)";
#}
#
#sub clause_can {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_ccl($cd, "$dt->can($ct)");
#}
#
#sub clause_isa {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->add_ccl($cd, "$dt->isa($ct)");
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/re.pm ###
#package Data::Sah::Compiler::perl::TH::re;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::re';
#
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = "ref($dt) eq 'Regexp' || !ref($dt) && ".
#        "eval { my \$tmp = $dt; qr/\$tmp/; 1 }";
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/str.pm ###
#package Data::Sah::Compiler::perl::TH::str;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::str';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = "!ref($dt)";
#}
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'is') {
#        $c->add_ccl($cd, "$dt eq $ct");
#    } elsif ($which eq 'in') {
#        $c->add_runtime_smartmatch_pragma($cd);
#        $c->add_ccl($cd, "$dt ~~ $ct");
#    }
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'min') {
#        $c->add_ccl($cd, "$dt ge $ct");
#    } elsif ($which eq 'xmin') {
#        $c->add_ccl($cd, "$dt gt $ct");
#    } elsif ($which eq 'max') {
#        $c->add_ccl($cd, "$dt le $ct");
#    } elsif ($which eq 'xmax') {
#        $c->add_ccl($cd, "$dt lt $ct");
#    } elsif ($which eq 'between') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "$dt ge $ct\->[0] && $dt le $ct\->[1]");
#        } else {
#            $c->add_ccl($cd, "$dt ge ".$c->literal($cv->[0]).
#                            " && $dt le ".$c->literal($cv->[1]));
#        }
#    } elsif ($which eq 'xbetween') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl($cd, "$dt gt $ct\->[0] && $dt lt $ct\->[1]");
#        } else {
#            $c->add_ccl($cd, "$dt gt ".$c->literal($cv->[0]).
#                            " && $dt lt ".$c->literal($cv->[1]));
#        }
#    }
#}
#
#sub superclause_has_elems {
#    my ($self_th, $which, $cd) = @_;
#    my $c  = $self_th->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($which eq 'len') {
#        $c->add_ccl($cd, "length($dt) == $ct");
#    } elsif ($which eq 'min_len') {
#        $c->add_ccl($cd, "length($dt) >= $ct");
#    } elsif ($which eq 'max_len') {
#        $c->add_ccl($cd, "length($dt) <= $ct");
#    } elsif ($which eq 'len_between') {
#        if ($cd->{cl_is_expr}) {
#            $c->add_ccl(
#                $cd, "length($dt) >= $ct\->[0] && ".
#                    "length($dt) >= $ct\->[1]");
#        } else {
#            $c->add_ccl(
#                $cd, "length($dt) >= $cv->[0] && ".
#                    "length($dt) <= $cv->[1]");
#        }
#    } elsif ($which eq 'has') {
#        $c->add_ccl($cd, "index($dt, $ct) >= 0");
#    } elsif ($which eq 'each_index') {
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#        $self_th->gen_each($cd, "0..length($cd->{data_term})-1", '_', '$_');
#        $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#    } elsif ($which eq 'each_elem') {
#        $self_th->set_tmp_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#        $self_th->gen_each($cd, "0..length($cd->{data_term})-1", '_', "substr($cd->{data_term}, \$_, 1)");
#        $self_th->restore_data_term($cd) if $cd->{args}{data_term_includes_topic_var};
#    } elsif ($which eq 'check_each_index') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'check_each_elem') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'uniq') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    } elsif ($which eq 'exists') {
#        $self_th->compiler->_die_unimplemented_clause($cd);
#    }
#}
#
#sub clause_encoding {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    $c->_die($cd, "Only 'utf8' encoding is currently supported")
#        unless $cv eq 'utf8';
#}
#
#sub clause_match {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->add_ccl($cd, join(
#            "",
#            "ref($ct) eq 'Regexp' ? $dt =~ $ct : ",
#            "do { my \$re = $ct; eval { \$re = /\$re/; 1 } && ",
#            "$dt =~ \$re }",
#        ));
#    } else {
#        my $re = $c->_str2reliteral($cd, $cv);
#        $c->add_ccl($cd, "$dt =~ qr($re)");
#    }
#}
#
#sub clause_is_re {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->add_ccl($cd, join(
#            "",
#            "do { my \$re = $dt; ",
#            "(eval { \$re = qr/\$re/; 1 } ? 1:0) == ($ct ? 1:0) }",
#        ));
#    } else {
#        $c->add_ccl($cd, join(
#            "",
#            "do { my \$re = $dt; ",
#            ($cv ? "" : "!"), "(eval { \$re = qr/\$re/; 1 })",
#            "}",
#        ));
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/timeofday.pm ###
#package Data::Sah::Compiler::perl::TH::timeofday;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#use Scalar::Util qw(blessed looks_like_number);
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::timeofday';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c  = $self->compiler;
#    my $dt = $cd->{data_term};
#
#    $cd->{coerce_to} = $cd->{nschema}[1]{"x.perl.coerce_to"} // 'str_hms';
#
#    my $coerce_to = $cd->{coerce_to};
#
#    if ($coerce_to eq 'float') {
#        $cd->{_ccl_check_type} = "!ref($dt) && $dt >= 0 && $dt < 86400";
#    } elsif ($coerce_to eq 'str_hms') {
#        $cd->{_ccl_check_type} = "$dt =~ /\\A([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(?:\\.[0-9]{1,9})?\\z/";
#    } elsif ($coerce_to eq 'Date::TimeOfDay') {
#        $c->add_runtime_module($cd, 'Scalar::Util');
#        $cd->{_ccl_check_type} = "Scalar::Util::blessed($dt) && $dt\->isa('Date::TimeOfDay')";
#    } else {
#        die "BUG: Unknown coerce_to value '$coerce_to', use either ".
#            "float, str_hms, or Date::TimeOfDay";
#    }
#}
#
#sub superclause_comparable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die($cd, "timeofday's comparison with expression not yet supported");
#    }
#
#    my $coerce_to = $cd->{coerce_to};
#    if ($coerce_to eq 'float') {
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "$dt == $ct");
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module($cd, 'List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{$dt == \$_}, $ct)");
#        }
#    } elsif ($coerce_to eq 'str_hms') {
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "$dt eq $ct");
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module($cd, 'List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{$dt eq \$_}, $ct)");
#        }
#    } elsif ($coerce_to eq 'Date::TimeOfDay') {
#        if ($which eq 'is') {
#            $c->add_ccl($cd, "Date::TimeOfDay->compare($dt, $ct)==0");
#        } elsif ($which eq 'in') {
#            $c->add_runtime_module($cd, 'List::Util');
#            $c->add_ccl($cd, "List::Util::first(sub{Date::TimeOfDay->compare($dt, \$_)==0}, $ct)");
#        }
#    }
#}
#
#sub superclause_sortable {
#    my ($self, $which, $cd) = @_;
#    my $c  = $self->compiler;
#    my $cv = $cd->{cl_value};
#    my $ct = $cd->{cl_term};
#    my $dt = $cd->{data_term};
#
#    if ($cd->{cl_is_expr}) {
#        $c->_die($cd, "timeofday's comparison with expression not yet supported");
#    }
#
#    my $coerce_to = $cd->{coerce_to};
#    if ($coerce_to eq 'float') {
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "$dt >= $cv");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "$dt > $cv");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "$dt <= $cv");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "$dt < $cv");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "$dt >= $cv->[0] && $dt <= $cv->[1]");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "$dt >  $cv->[0] && $dt <  $cv->[1]");
#        }
#    } elsif ($coerce_to eq 'str_hms') {
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "$dt ge '$cv'");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "$dt gt '$cv'");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "$dt le '$cv'");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "$dt lt '$cv'");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "$dt ge '$cv->[0]' && $dt le '$cv->[1]'");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "$dt gt '$cv->[0]' && $dt lt '$cv->[1]'");
#        }
#    } elsif ($coerce_to eq 'Date::TimeOfDay') {
#        if ($which eq 'min') {
#            $c->add_ccl($cd, "Date::TimeOfDay->compare($dt, $cv) >= 0");
#        } elsif ($which eq 'xmin') {
#            $c->add_ccl($cd, "Date::TimeOfDay->compare($dt, $cv) > 0");
#        } elsif ($which eq 'max') {
#            $c->add_ccl($cd, "Date::TimeOfDay->compare($dt, $cv) <= 0");
#        } elsif ($which eq 'xmax') {
#            $c->add_ccl($cd, "Date::TimeOfDay->compare($dt, $cv) < 0");
#        } elsif ($which eq 'between') {
#            $c->add_ccl($cd, "Date::TimeOfDay->compare($dt, $cv\->[0]) >= 0 && Date::TimeOfDay->compare($dt, $ct\->[1]) <= 0");
#        } elsif ($which eq 'xbetween') {
#            $c->add_ccl($cd, "Date::TimeOfDay->compare($dt, $cv\->[0]) >  0 && Date::TimeOfDay->compare($dt, $ct\->[1]) <  0");
#        }
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Compiler/perl/TH/undef.pm ###
#package Data::Sah::Compiler::perl::TH::undef;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Mo qw(build default);
#use Role::Tiny::With;
#
#extends 'Data::Sah::Compiler::perl::TH';
#with 'Data::Sah::Type::undef';
#
#sub handle_type {
#    my ($self, $cd) = @_;
#    my $c = $self->compiler;
#
#    my $dt = $cd->{data_term};
#    $cd->{_ccl_check_type} = "!defined($dt)";
#}
#
#1;
#
#__END__
#
### Data/Sah/Human.pm ###
#package Data::Sah::Human;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#our $Log_Validator_Code = $ENV{LOG_SAH_VALIDATOR_CODE} // 0;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(gen_human_msg);
#
#sub gen_human_msg {
#    require Data::Sah;
#
#    my ($schema, $opts) = @_;
#
#    state $hc = Data::Sah->new->get_compiler("human");
#
#    my %args = (schema => $schema, %{$opts // {}});
#    my $opt_source = delete $args{source};
#
#    $args{log_result} = 1 if $Log_Validator_Code;
#
#    my $cd = $hc->compile(%args);
#    $opt_source ? $cd : $cd->{result};
#}
#
#1;
#
#__END__
#
### Data/Sah/Lang.pm ###
#package Data::Sah::Lang;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#our @ISA    = qw(Exporter);
#our @EXPORT = qw(add_translations);
#
#sub add_translations {
#    my %args = @_;
#
#}
#
#1;
#
#__END__
#
### Data/Sah/Lang/fr_FR.pm ###
#package Data::Sah::Lang::fr_FR;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Tie::IxHash;
#
#
#our %translations;
#tie %translations, 'Tie::IxHash', (
#
#
#    q[ ], 
#    q[ ],
#
#    q[, ],
#    q[, ],
#
#    q[: ],
#    q[: ],
#
#    q[. ],
#    q[. ],
#
#    q[(],
#    q[(],
#
#    q[)],
#    q[)],
#
#
#    q[must],
#    q[doit],
#
#    q[must not],
#    q[ne doit pas],
#
#    q[should],
#    q[devrait],
#
#    q[should not],
#    q[ne devrait pas],
#
#
#    q[field],
#    q[champ],
#
#    q[fields],
#    q[champs],
#
#    q[argument],
#    q[argument],
#
#    q[arguments],
#    q[arguments],
#
#
#    q[%s and %s],
#    q[%s et %s],
#
#    q[%s or %s],
#    q[%s ou %s],
#
#    q[one of %s],
#    q[une des %s],
#
#    q[all of %s],
#    q[toutes les valeurs %s],
#
#    q[%(modal_verb)s satisfy all of the following],
#    q[%(modal_verb)s satisfaire à toutes les conditions suivantes],
#
#    q[%(modal_verb)s satisfy one of the following],
#    q[%(modal_verb)s satisfaire l'une des conditions suivantes],
#
#    q[%(modal_verb)s satisfy none of the following],
#    q[%(modal_verb)s satisfaire à aucune des conditions suivantes],
#
#
#
#
#
#
#
#    q[integer],
#    q[nombre entier],
#
#    q[integers],
#    q[nombres entiers],
#
#    q[%(modal_verb)s be divisible by %s],
#    q[%(modal_verb)s être divisible par %s],
#
#    q[%(modal_verb)s leave a remainder of %2$s when divided by %1$s],
#    q[%(modal_verb)s laisser un reste %2$s si divisé par %1$s],
#
#);
#
#1;
#
#__END__
#
### Data/Sah/Lang/id_ID.pm ###
#package Data::Sah::Lang::id_ID;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Tie::IxHash;
#
#sub ordinate {
#    my ($n, $noun) = @_;
#    "$noun ke-$n";
#}
#
#our %translations;
#tie %translations, 'Tie::IxHash', (
#
#
#    q[ ], 
#    q[ ],
#
#    q[, ],
#    q[, ],
#
#    q[: ],
#    q[: ],
#
#    q[. ],
#    q[. ],
#
#    q[(],
#    q[(],
#
#    q[)],
#    q[)],
#
#
#    q[must],
#    q[harus],
#
#    q[must not],
#    q[tidak boleh],
#
#    q[should],
#    q[sebaiknya],
#
#    q[should not],
#    q[sebaiknya tidak],
#
#
#    q[field],
#    q[field],
#
#    q[fields],
#    q[field],
#
#    q[argument],
#    q[argumen],
#
#    q[arguments],
#    q[argumen],
#
#
#    q[%s and %s],
#    q[%s dan %s],
#
#    q[%s or %s],
#    q[%s atau %s],
#
#    q[%s nor %s],
#    q[%s maupun %s],
#
#    q[one of %s],
#    q[salah satu dari %s],
#
#    q[all of %s],
#    q[semua dari nilai-nilai %s],
#
#    q[any of %s],
#    q[satupun dari %s],
#
#    q[none of %s],
#    q[tak satupun dari %s],
#
#    q[%(modal_verb)s satisfy all of the following],
#    q[%(modal_verb)s memenuhi semua ketentuan ini],
#
#    q[%(modal_verb)s satisfy none all of the following],
#    q[%(modal_verb)s melanggar semua ketentuan ini],
#
#    q[%(modal_verb)s satisfy one of the following],
#    q[%(modal_verb)s memenuhi salah satu ketentuan ini],
#
#
#    q[default value is %s],
#    q[jika tidak diisi diset ke %s],
#
#    q[required %s],
#    q[%s wajib diisi],
#
#    q[optional %s],
#    q[%s opsional],
#
#    q[forbidden %s],
#    q[%s tidak boleh diisi],
#
#
#    q[%(modal_verb)s have the value %s],
#    q[%(modal_verb)s bernilai %s],
#
#    q[%(modal_verb)s be one of %s],
#    q[%(modal_verb)s salah satu dari %s],
#
#
#    q[length %(modal_verb)s be %s],
#    q[panjang %(modal_verb)s %s],
#
#    q[length %(modal_verb)s be at least %s],
#    q[panjang %(modal_verb)s minimal %s],
#
#    q[length %(modal_verb)s be at most %s],
#    q[panjang %(modal_verb)s maksimal %s],
#
#    q[length %(modal_verb)s be between %s and %s],
#    q[panjang %(modal_verb)s antara %s dan %s],
#
#    q[%(modal_verb)s have %s in its elements],
#    q[%(modal_verb)s mengandung %s di elemennya],
#
#
#    q[%(modal_verb)s be at least %s],
#    q[%(modal_verb)s minimal %s],
#
#    q[%(modal_verb)s be larger than %s],
#    q[%(modal_verb)s lebih besar dari %s],
#
#    q[%(modal_verb)s be at most %s],
#    q[%(modal_verb)s maksimal %s],
#
#    q[%(modal_verb)s be smaller than %s],
#    q[%(modal_verb)s lebih kecil dari %s],
#
#    q[%(modal_verb)s be between %s and %s],
#    q[%(modal_verb)s antara %s dan %s],
#
#    q[%(modal_verb)s be larger than %s and smaller than %s],
#    q[%(modal_verb)s lebih besar dari %s dan lebih kecil dari %s],
#
#
#    q[undefined value],
#    q[nilai tak terdefinisi],
#
#    q[undefined values],
#    q[nilai tak terdefinisi],
#
#
#    q[%(modal_verb)s be %s],
#    q[%(modal_verb)s %s],
#
#    q[as well as %s],
#    q[juga %s],
#
#    q[%(modal_verb)s be all of the following],
#    q[%(modal_verb)s merupakan semua ini],
#
#
#    q[%(modal_verb)s be either %s],
#    q[%s],
#
#    q[or %s],
#    q[atau %s],
#
#    q[%(modal_verb)s be one of the following],
#    q[%(modal_verb)s merupakan salah satu dari],
#
#
#    q[array],
#    q[larik],
#
#    q[arrays],
#    q[larik],
#
#    q[%s of %s],
#    q[%s %s],
#
#    q[each array element %(modal_verb)s be],
#    q[setiap elemen larik %(modal_verb)s],
#
#    q[%s %(modal_verb)s be],
#    q[%s %(modal_verb)s],
#
#    q[element],
#    q[elemen],
#
#    q[each array subscript %(modal_verb)s be],
#    q[setiap subskrip larik %(modal_verb)s],
#
#
#    q[boolean value],
#    q[nilai boolean],
#
#    q[boolean values],
#    q[nilai boolean],
#
#    q[%(modal_verb)s be true],
#    q[%(modal_verb)s bernilai benar],
#
#    q[%(modal_verb)s be false],
#    q[%(modal_verb)s bernilai salah],
#
#
#    q[code],
#    q[kode],
#
#    q[codes],
#    q[kode],
#
#
#    q[decimal number],
#    q[bilangan desimal],
#
#    q[decimal numbers],
#    q[bilangan desimal],
#
#    q[%(modal_verb)s be a NaN],
#    q[%(modal_verb)s NaN],
#
#    q[%(modal_verb_neg)s be a NaN],
#    q[%(modal_verb_neg)s NaN],
#
#    q[%(modal_verb)s be an infinity],
#    q[%(modal_verb)s tak hingga],
#
#    q[%(modal_verb_neg)s be an infinity],
#    q[%(modal_verb_neg)s tak hingga],
#
#    q[%(modal_verb)s be a positive infinity],
#    q[%(modal_verb)s positif tak hingga],
#
#    q[%(modal_verb_neg)s be a positive infinity],
#    q[%(modal_verb_neg)s positif tak hingga],
#
#    q[%(modal_verb)s be a negative infinity],
#    q[%(modal_verb)s negatif tak hingga],
#
#    q[%(modal_verb)s be a negative infinity],
#    q[%(modal_verb)s negatif tak hingga],
#
#
#    q[hash],
#    q[hash],
#
#    q[hashes],
#    q[hash],
#
#    q[field %s %(modal_verb)s be],
#    q[field %s %(modal_verb)s],
#
#    q[field name %(modal_verb)s be],
#    q[nama field %(modal_verb)s],
#
#    q[each field %(modal_verb)s be],
#    q[setiap field %(modal_verb)s],
#
#    q[hash contains unknown field(s) (%s)],
#    q[hash mengandung field yang tidak dikenali (%s)],
#
#    q[hash contains unknown field(s) (%s)],
#    q[hash mengandung field yang tidak dikenali (%s)],
#
#    q[%(modal_verb)s have required fields %s],
#    q[%(modal_verb)s mengandung field wajib %s],
#
#    q[hash has missing required field(s) (%s)],
#    q[hash kekurangan field wajib (%s)],
#
#    q[%(modal_verb)s have %s in its field values],
#    q[%(modal_verb)s mengandung %s di nilai field],
#
#    q[%(modal_verb)s only have these allowed fields %s],
#    q[%(modal_verb)s hanya mengandung field yang diizinkan %s],
#
#    q[%(modal_verb)s only have fields matching regex pattern %s],
#    q[%(modal_verb)s hanya mengandung field yang namanya mengikuti pola regex %s],
#
#    q[%(modal_verb_neg)s have these forbidden fields %s],
#    q[%(modal_verb_neg)s mengandung field yang dilarang %s],
#
#    q[%(modal_verb_neg)s have fields matching regex pattern %s],
#    q[%(modal_verb_neg)s mengandung field yang namanya mengikuti pola regex %s],
#
#    q[hash contains non-allowed field(s) (%s)],
#    q[hash mengandung field yang tidak diizinkan (%s)],
#
#    q[hash contains forbidden field(s) (%s)],
#    q[hash mengandung field yang dilarang (%s)],
#
#    q[fields whose names match regex pattern %s %(modal_verb)s be],
#    q[field yang namanya cocok dengan pola regex %s %(modal_verb)s],
#
#
#    q[integer],
#    q[bilangan bulat],
#
#    q[integers],
#    q[bilangan bulat],
#
#    q[%(modal_verb)s be divisible by %s],
#    q[%(modal_verb)s dapat dibagi oleh %s],
#
#    q[%(modal_verb)s be odd],
#    q[%(modal_verb)s ganjil],
#
#    q[%(modal_verb)s be even],
#    q[%(modal_verb)s genap],
#
#    q[%(modal_verb)s leave a remainder of %2$s when divided by %1$s],
#    q[jika dibagi %1$s %(modal_verb)s menyisakan %2$s],
#
#
#    q[number],
#    q[bilangan],
#
#    q[numbers],
#    q[bilangan],
#
#
#    q[object],
#    q[objek],
#
#    q[objects],
#    q[objek],
#
#
#    q[regex pattern],
#    q[pola regex],
#
#    q[regex patterns],
#    q[pola regex],
#
#
#    q[text],
#    q[teks],
#
#    q[texts],
#    q[teks],
#
#    q[%(modal_verb)s match regex pattern %s],
#    q[%(modal_verb)s cocok dengan pola regex %s],
#
#    q[%(modal_verb)s be a regex pattern],
#    q[%(modal_verb)s pola regex],
#
#    q[each subscript of text %(modal_verb)s be],
#    q[setiap subskrip dari teks %(modal_verb)s],
#
#    q[each character of the text %(modal_verb)s be],
#    q[setiap karakter dari teks %(modal_verb)s],
#
#    q[character],
#    q[karakter],
#
#
#
#    q[buffer],
#    q[buffer],
#
#    q[buffers],
#    q[buffer],
#
#
#    q[Does not satisfy the following schema: %s],
#    q[Tidak memenuhi skema ini: %s],
#
#    q[Not of type %s],
#    q[Tidak bertipe %s],
#
#    q[Required but not specified],
#    q[Wajib tapi belum diisi],
#
#    q[Forbidden but specified],
#    q[Dilarang tapi diisi],
#
#    q[Structure contains unknown field(s) [%%s]],
#    q[Struktur mengandung field yang tidak dikenal [%%s]],
#
#    q[Cannot coerce data to %s [%s]],
#    q[Data tidak dapat dikonversi ke %s [%%s]],
#);
#
#1;
#
#__END__
#
### Data/Sah/Lang/zh_CN.pm ###
#package Data::Sah::Lang::zh_CN;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use utf8;
#use warnings;
#
#use Tie::IxHash;
#
#
#our %translations;
#tie %translations, 'Tie::IxHash', (
#
#
#    q[ ], 
#    q[],
#
#    q[, ],
#    q[，],
#
#    q[: ],
#    q[：],
#
#    q[. ],
#    q[。],
#
#    q[(],
#    q[（],
#
#    q[)],
#    q[）],
#
#
#    q[must],
#    q[必须],
#
#    q[must not],
#    q[必须不],
#
#    q[should],
#    q[应],
#
#    q[should not],
#    q[应不],
#
#
#    q[field],
#    q[字段],
#
#    q[fields],
#    q[字段],
#
#    q[argument],
#    q[参数],
#
#    q[arguments],
#    q[参数],
#
#
#    q[%s and %s],
#    q[%s和%s],
#
#    q[%s or %s],
#    q[%s或%s],
#
#    q[one of %s],
#    q[这些值%s之一],
#
#    q[all of %s],
#    q[所有这些值%s],
#
#    q[%(modal_verb)s satisfy all of the following],
#    q[%(modal_verb)s满足所有这些条件],
#
#    q[%(modal_verb)s satisfy one of the following],
#    q[%(modal_verb)s满足这些条件之一],
#
#    q[%(modal_verb)s satisfy none of the following],
#    q[%(modal_verb_neg)s满足所有这些条件],
#
#
#
#
#
#
#
#    q[integer],
#    q[整数],
#
#    q[integers],
#    q[整数],
#
#    q[%(modal_verb)s be divisible by %s],
#    q[%(modal_verb)s被%s整除],
#
#    q[%(modal_verb)s leave a remainder of %2$s when divided by %1$s],
#    q[除以%1$s时余数%(modal_verb)s为%2$s],
#
#);
#
#1;
#
#__END__
#
### Data/Sah/Normalize.pm ###
#package Data::Sah::Normalize;
#
#use 5.010001;
#use strict;
#use warnings;
#
#our $DATE = '2018-09-10'; 
#our $VERSION = '0.050'; 
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       normalize_clset
#                       normalize_schema
#
#                       $type_re
#                       $clause_name_re
#                       $clause_re
#                       $attr_re
#                       $funcset_re
#                       $compiler_re
#               );
#
#our $type_re        = qr/\A(?:[A-Za-z_]\w*::)*[A-Za-z_]\w*\z/;
#our $clause_name_re = qr/\A[A-Za-z_]\w*\z/;
#our $clause_re      = qr/\A[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*\z/;
#our $attr_re        = $clause_re;
#our $funcset_re     = qr/\A(?:[A-Za-z_]\w*::)*[A-Za-z_]\w*\z/;
#our $compiler_re    = qr/\A[A-Za-z_]\w*\z/;
#our $clause_attr_on_empty_clause_re = qr/\A(?:\.[A-Za-z_]\w*)+\z/;
#
#sub normalize_clset($;$) {
#    my ($clset0, $opts) = @_;
#    $opts //= {};
#
#    my $clset = {};
#    for my $c (sort keys %$clset0) {
#        my $c0 = $c;
#
#        my $v = $clset0->{$c};
#
#        my $expr;
#        if ($c =~ s/=\z//) {
#            $expr++;
#            die "Conflict between '$c=' and '$c'" if exists $clset0->{$c};
#            $clset->{"$c.is_expr"} = 1;
#            }
#
#        my $sc = "";
#        my $cn;
#        {
#            my $errp = "Invalid clause name syntax '$c0'"; 
#            if (!$expr && $c =~ s/\A!(?=.)//) {
#                die "$errp, syntax should be !CLAUSE"
#                    unless $c =~ $clause_name_re;
#                $sc = "!";
#            } elsif (!$expr && $c =~ s/(?<=.)\|\z//) {
#                die "$errp, syntax should be CLAUSE|"
#                    unless $c =~ $clause_name_re;
#                $sc = "|";
#            } elsif (!$expr && $c =~ s/(?<=.)\&\z//) {
#                die "$errp, syntax should be CLAUSE&"
#                    unless $c =~ $clause_name_re;
#                $sc = "&";
#            } elsif (!$expr && $c =~ /\A([^.]+)(?:\.(.+))?\((\w+)\)\z/) {
#                my ($c2, $a, $lang) = ($1, $2, $3);
#                die "$errp, syntax should be CLAUSE(LANG) or C.ATTR(LANG)"
#                    unless $c2 =~ $clause_name_re &&
#                        (!defined($a) || $a =~ $attr_re);
#                $sc = "(LANG)";
#                $cn = $c2 . (defined($a) ? ".$a" : "") . ".alt.lang.$lang";
#            } elsif ($c !~ $clause_re &&
#                         $c !~ $clause_attr_on_empty_clause_re) {
#                die "$errp, please use letter/digit/underscore only";
#            }
#        }
#
#        if ($sc eq '!') {
#            die "Conflict between clause shortcuts '!$c' and '$c'"
#                if exists $clset0->{$c};
#            die "Conflict between clause shortcuts '!$c' and '$c|'"
#                if exists $clset0->{"$c|"};
#            die "Conflict between clause shortcuts '!$c' and '$c&'"
#                if exists $clset0->{"$c&"};
#            $clset->{$c} = $v;
#            $clset->{"$c.op"} = "not";
#        } elsif ($sc eq '&') {
#            die "Conflict between clause shortcuts '$c&' and '$c'"
#                if exists $clset0->{$c};
#            die "Conflict between clause shortcuts '$c&' and '$c|'"
#                if exists $clset0->{"$c|"};
#            die "Clause 'c&' value must be an array"
#                unless ref($v) eq 'ARRAY';
#            $clset->{$c} = $v;
#            $clset->{"$c.op"} = "and";
#        } elsif ($sc eq '|') {
#            die "Conflict between clause shortcuts '$c|' and '$c'"
#                if exists $clset0->{$c};
#            die "Clause 'c|' value must be an array"
#                unless ref($v) eq 'ARRAY';
#            $clset->{$c} = $v;
#            $clset->{"$c.op"} = "or";
#        } elsif ($sc eq '(LANG)') {
#            die "Conflict between clause '$c' and '$cn'"
#                if exists $clset0->{$cn};
#            $clset->{$cn} = $v;
#        } else {
#            $clset->{$c} = $v;
#        }
#
#    }
#    $clset->{req} = 1 if $opts->{has_req};
#
#
#    $clset;
#}
#
#sub normalize_schema($) {
#    my $s = shift;
#
#    my $ref = ref($s);
#    if (!defined($s)) {
#
#        die "Schema is missing";
#
#    } elsif (!$ref) {
#
#        my $has_req = $s =~ s/\*\z//;
#        $s =~ $type_re or die "Invalid type syntax $s, please use ".
#            "letter/digit/underscore only";
#        return [$s, $has_req ? {req=>1} : {}, {}];
#
#    } elsif ($ref eq 'ARRAY') {
#
#        my $t = $s->[0];
#        my $has_req = $t && $t =~ s/\*\z//;
#        if (!defined($t)) {
#            die "For array form, at least 1 element is needed for type";
#        } elsif (ref $t) {
#            die "For array form, first element must be a string";
#        }
#        $t =~ $type_re or die "Invalid type syntax $s, please use ".
#            "letter/digit/underscore only";
#
#        my $clset0;
#        my $extras;
#        if (defined($s->[1])) {
#            if (ref($s->[1]) eq 'HASH') {
#                $clset0 = $s->[1];
#                $extras = $s->[2];
#                die "For array form, there should not be more than 3 elements"
#                    if @$s > 3;
#            } else {
#                die "For array in the form of [t, c1=>1, ...], there must be ".
#                    "3 elements (or 5, 7, ...)"
#                        unless @$s % 2;
#                $clset0 = { @{$s}[1..@$s-1] };
#            }
#        } else {
#            $clset0 = {};
#        }
#
#        my $clset = normalize_clset($clset0, {has_req=>$has_req});
#        if (defined $extras) {
#            die "For array form with 3 elements, extras must be hash"
#                unless ref($extras) eq 'HASH';
#            die "'def' in extras must be a hash"
#                if exists $extras->{def} && ref($extras->{def}) ne 'HASH';
#            return [$t, $clset, { %{$extras} }];
#        } else {
#            return [$t, $clset, {}];
#        }
#    }
#
#    die "Schema must be a string or arrayref (not $ref)";
#}
#
#1;
#
#__END__
#
### Data/Sah/Resolve.pm ###
#package Data::Sah::Resolve;
#
#our $DATE = '2017-04-19'; 
#our $VERSION = '0.007'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(resolve_schema);
#
#sub _resolve {
#    my ($opts, $type, $clsets, $seen) = @_;
#
#    die "Recursive schema definition: ".join(" -> ", @$seen, $type)
#        if grep { $type eq $_ } @$seen;
#    push @$seen, $type;
#
#    (my $typemod_pm = "Data/Sah/Type/$type.pm") =~ s!::!/!g;
#    eval { require $typemod_pm; 1 };
#    my $err = $@;
#    return [$type, $clsets] unless $err;
#    die "Can't check whether $type is a builtin Sah type: $err"
#        unless $err =~ /\ACan't locate/;
#
#    my $schmod = "Sah::Schema::$type";
#    (my $schmod_pm = "$schmod.pm") =~ s!::!/!g;
#    eval { require $schmod_pm; 1 };
#    die "Not a known built-in Sah type '$type' (can't locate ".
#        "Data::Sah::Type::$type) and not a known schema name '$type' ($@)"
#            if $@;
#    no strict 'refs';
#    my $sch2 = ${"$schmod\::schema"};
#    die "BUG: Schema module $schmod doesn't contain \$schema" unless $sch2;
#    unshift @$clsets, $sch2->[1];
#    _resolve($opts, $sch2->[0], $clsets, $seen);
#}
#
#sub resolve_schema {
#    my $opts = ref($_[0]) eq 'HASH' ? shift : {};
#    my $sch = shift;
#
#    unless ($opts->{schema_is_normalized}) {
#        require Data::Sah::Normalize;
#        $sch =  Data::Sah::Normalize::normalize_schema($sch);
#    }
#    $opts->{merge_clause_sets} //= 1;
#
#    my $seen = [];
#    my $res = _resolve($opts, $sch->[0], keys(%{$sch->[1]}) ? [$sch->[1]] : [], $seen);
#
#  MERGE:
#    {
#        last unless $opts->{merge_clause_sets};
#        last if @{ $res->[1] } < 2;
#
#        my @clsets = (shift @{ $res->[1] });
#        for my $clset (@{ $res->[1] }) {
#            my $has_merge_mode_keys;
#            for (keys %$clset) {
#                if (/\Amerge\./) {
#                    $has_merge_mode_keys = 1;
#                    last;
#                }
#            }
#            if ($has_merge_mode_keys) {
#                state $merger = do {
#                    require Data::ModeMerge;
#                    my $mm = Data::ModeMerge->new(config => {
#                        recurse_array => 1,
#                    });
#                    $mm->modes->{NORMAL}  ->prefix   ('merge.normal.');
#                    $mm->modes->{NORMAL}  ->prefix_re(qr/\Amerge\.normal\./);
#                    $mm->modes->{ADD}     ->prefix   ('merge.add.');
#                    $mm->modes->{ADD}     ->prefix_re(qr/\Amerge\.add\./);
#                    $mm->modes->{CONCAT}  ->prefix   ('merge.concat.');
#                    $mm->modes->{CONCAT}  ->prefix_re(qr/\Amerge\.concat\./);
#                    $mm->modes->{SUBTRACT}->prefix   ('merge.subtract.');
#                    $mm->modes->{SUBTRACT}->prefix_re(qr/\Amerge\.subtract\./);
#                    $mm->modes->{DELETE}  ->prefix   ('merge.delete.');
#                    $mm->modes->{DELETE}  ->prefix_re(qr/\Amerge\.delete\./);
#                    $mm->modes->{KEEP}    ->prefix   ('merge.keep.');
#                    $mm->modes->{KEEP}    ->prefix_re(qr/\Amerge\.keep\./);
#                    $mm;
#                };
#                my $merge_res = $merger->merge($clsets[-1], $clset);
#                unless ($merge_res->{success}) {
#                    die "Can't merge clause set: $merge_res->{error}";
#                }
#                $clsets[-1] = $merge_res->{result};
#            } else {
#                push @clsets, $clset;
#            }
#        }
#
#        $res->[1] = \@clsets;
#    }
#
#    $res->[2] = $seen if $opts->{return_intermediates};
#
#    $res;
#}
#
#1;
#
#__END__
#
### Data/Sah/Type/BaseType.pm ###
#package Data::Sah::Type::BaseType;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#
#use 5.010;
#use strict;
#use warnings;
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#
#requires 'handle_type';
#
#has_clause 'v',
#    v => 2,
#    prio   => 0,
#    tags   => ['meta', 'defhash'],
#    schema => ['float'=>{req=>1, is=>1}, {}],
#    ;
#
#has_clause 'defhash_v',
#    v => 2,
#    prio   => 0,
#    tags   => ['meta', 'defhash'],
#    schema => ['float'=>{req=>1, is=>1}, {}],
#    ;
#
#has_clause 'schema_v',
#    v => 2,
#    prio   => 0,
#    tags   => ['meta'],
#    schema => ['float'=>{req=>1}, {}],
#    ;
#
#has_clause 'base_v',
#    v => 2,
#    prio   => 0,
#    tags   => ['meta'],
#    schema => ['float'=>{req=>1}, {}],
#    ;
#
#has_clause 'ok',
#    v => 2,
#    tags       => ['constraint'],
#    prio       => 1,
#    schema     => ['any', {}, {}],
#    allow_expr => 1,
#    ;
#has_clause 'default',
#    v => 2,
#    prio       => 1,
#    tags       => ['default'],
#    schema     => ['any', {}, {}],
#    allow_expr => 1,
#    attrs      => {
#        temp => {
#            schema     => [bool => {default=>0}, {}],
#            allow_expr => 0,
#        },
#    },
#    ;
#has_clause 'default_lang',
#    v => 2,
#    tags       => ['meta', 'defhash'],
#    prio       => 2,
#    schema     => ['str'=>{req=>1, default=>'en_US'}, {}],
#    ;
#has_clause 'name',
#    v => 2,
#    tags       => ['meta', 'defhash'],
#    prio       => 2,
#    schema     => ['str', {req=>1}, {}],
#    ;
#has_clause 'summary',
#    v => 2,
#    prio       => 2,
#    tags       => ['meta', 'defhash'],
#    schema     => ['str', {req=>1}, {}],
#    ;
#has_clause 'description',
#    v => 2,
#    tags       => ['meta', 'defhash'],
#    prio       => 2,
#    schema     => ['str', {req=>1}, {}],
#    ;
#has_clause 'tags',
#    v => 2,
#    tags       => ['meta', 'defhash'],
#    prio       => 2,
#    schema     => ['array', {of=>['str', {req=>1}, {}]}, {}],
#    ;
#has_clause 'req',
#    v => 2,
#    tags       => ['constraint'],
#    prio       => 3,
#    schema     => ['bool', {}, {}],
#    allow_expr => 1,
#    ;
#has_clause 'forbidden',
#    v => 2,
#    tags       => ['constraint'],
#    prio       => 3,
#    schema     => ['bool', {}, {}],
#    allow_expr => 1,
#    ;
#
#
#
#
#
#
#has_clause 'clause',
#    v => 2,
#    tags       => ['constraint'],
#    prio       => 50,
#    schema     => ['array' => {req=>1, len=>2, elems => [
#        ['sah::clname', {req=>1}, {}],
#        ['any', {}, {}],
#    ]}, {}],
#    ;
#has_clause 'clset',
#    v => 2,
#    prio   => 50,
#    tags   => ['constraint'],
#    schema => ['sah::clset', {req=>1}, {}],
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/Comparable.pm ###
#package Data::Sah::Type::Comparable;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#
#requires 'superclause_comparable';
#
#has_clause 'in',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, of=>['_same', {req=>1}, {}]}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_comparable('in', $cd);
#    };
#has_clause 'is',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['_same', {req=>1}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_comparable('is', $cd);
#    };
#
#1;
#
#__END__
#
### Data/Sah/Type/HasElems.pm ###
#package Data::Sah::Type::HasElems;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#
#requires 'superclause_has_elems';
#
#has_clause 'max_len',
#    v => 2,
#    prio       => 51,
#    tags       => ['constraint'],
#    schema     => ['int', {min=>0}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('max_len', $cd);
#    };
#
#has_clause 'min_len',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['int', {min=>0}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('min_len', $cd);
#    };
#
#has_clause 'len_between',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array' => {req=>1, len=>2, elems => [
#        [int => {req=>1}, {}],
#        [int => {req=>1}, {}],
#    ]}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('len_between', $cd);
#    };
#
#has_clause 'len',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['int', {min=>0}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('len', $cd);
#    };
#
#has_clause 'has',
#    v => 2,
#    tags       => ['constraint'],
#    schema       => ['_same_elem', {req=>1}, {}],
#    inspect_elem => 1,
#    prio         => 55, 
#    allow_expr   => 1,
#    code         => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('has', $cd);
#    };
#
#has_clause 'each_index',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['sah::schema', {req=>1}, {}],
#    subschema  => sub { $_[0] },
#    allow_expr => 0,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('each_index', $cd);
#    };
#
#has_clause 'each_elem',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['sah::schema', {req=>1}, {}],
#    inspect_elem => 1,
#    subschema  => sub { $_[0] },
#    allow_expr => 0,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('each_elem', $cd);
#    };
#
#has_clause 'check_each_index',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['sah::schema', {req=>1}, {}],
#    subschema  => sub { $_[0] },
#    allow_expr => 0,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('check_each_index', $cd);
#    };
#
#has_clause 'check_each_elem',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['sah::schema', {req=>1}, {}],
#    inspect_elem => 1,
#    subschema  => sub { $_[0] },
#    allow_expr => 0,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('check_each_elem', $cd);
#    };
#
#has_clause 'uniq',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['bool', {}, {}],
#    inspect_elem => 1,
#    prio         => 55, 
#    subschema  => sub { $_[0] },
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('uniq', $cd);
#    };
#
#has_clause 'exists',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['sah::schema', {req=>1}, {}],
#    inspect_elem => 1,
#    subschema  => sub { $_[0] },
#    allow_expr => 0,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_has_elems('exists', $cd);
#    };
#
#
#
#
#1;
#
#__END__
#
### Data/Sah/Type/Sortable.pm ###
#package Data::Sah::Type::Sortable;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#
#requires 'superclause_sortable';
#
#has_clause 'min',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['_same', {req=>1}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_sortable('min', $cd);
#    },
#    ;
#has_clause 'xmin',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['_same', {req=>1}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_sortable('xmin', $cd);
#    },
#    ;
#has_clause 'max',
#    v => 2,
#    prio       => 51,
#    tags       => ['constraint'],
#    schema     => ['_same', {req=>1}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_sortable('max', $cd);
#    },
#    ;
#has_clause 'xmax',
#    v => 2,
#    prio       => 51,
#    tags       => ['constraint'],
#    schema     => ['_same', {req=>1}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_sortable('xmax', $cd);
#    },
#    ;
#has_clause 'between',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, len=>2, elems=>[
#        ['_same', {req=>1}, {}],
#        ['_same', {req=>1}, {}],
#    ]}, {}],
#    allow_expr => 1,
#    code       => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_sortable('between', $cd);
#    },
#    ;
#has_clause 'xbetween',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, len=>2, elems=>[
#        ['_same', {req=>1}, {}],
#        ['_same', {req=>1}, {}],
#    ]}, {}],
#    allow_expr => 1,
#    code => sub {
#        my ($self, $cd) = @_;
#        $self->superclause_sortable('xbetween', $cd);
#    },
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/all.pm ###
#package Data::Sah::Type::all;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#
#has_clause 'of',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array' => {req=>1, min_len=>1, each_elem => ['sah::schema', {req=>1}, {}]}, {}],
#    subschema  => sub { @{ $_[0] } },
#    allow_expr => 0,
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/any.pm ###
#package Data::Sah::Type::any;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#
#has_clause 'of',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array' => {req=>1, min_len=>1, each_elem => ['sah::schema', {req=>1}, {}]}, {}],
#    subschema  => sub { @{ $_[0] } },
#    allow_expr => 0,
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/array.pm ###
#package Data::Sah::Type::array;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause', 'has_clause_alias';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::HasElems';
#
#has_clause 'elems',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array' => {req=>1, of=>['sah::schema', {req=>1}, {}]}, {}],
#    inspect_elem => 1,
#    allow_expr => 0,
#    subschema  => sub { @{ $_[0] } },
#    attrs      => {
#        create_default => {
#            schema     => [bool => {default=>1}, {}],
#            allow_expr => 0, 
#        },
#    },
#    ;
#has_clause_alias each_elem => 'of';
#
#1;
#
#__END__
#
### Data/Sah/Type/bool.pm ###
#package Data::Sah::Type::bool;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::Sortable';
#
#has_clause 'is_true',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['bool', {}, {}],
#    allow_expr => 1,
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/buf.pm ###
#package Data::Sah::Type::buf;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::str';
#
#1;
#
#__END__
#
### Data/Sah/Type/cistr.pm ###
#package Data::Sah::Type::cistr;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::str';
#
#1;
#
#__END__
#
### Data/Sah/Type/code.pm ###
#package Data::Sah::Type::code;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#
#1;
#
#__END__
#
### Data/Sah/Type/date.pm ###
#package Data::Sah::Type::date;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::Sortable';
#
#
#1;
#
#__END__
#
### Data/Sah/Type/datenotime.pm ###
#package Data::Sah::Type::datenotime;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::date';
#
#1;
#
#__END__
#
### Data/Sah/Type/datetime.pm ###
#package Data::Sah::Type::datetime;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::date';
#
#1;
#
#__END__
#
### Data/Sah/Type/duration.pm ###
#package Data::Sah::Type::duration;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::Sortable';
#
#
#1;
#
#__END__
#
### Data/Sah/Type/float.pm ###
#package Data::Sah::Type::float;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::num';
#
#has_clause 'is_nan',
#    v => 2,
#    tags        => ['constraint'],
#    schema      => ['bool', {}, {}],
#    allow_expr  => 1,
#    allow_multi => 0,
#    ;
#
#has_clause 'is_inf',
#    v => 2,
#    tags        => ['constraint'],
#    schema      => ['bool', {}, {}],
#    allow_expr  => 1,
#    allow_multi => 1,
#    ;
#
#has_clause 'is_pos_inf',
#    v => 2,
#    tags        => ['constraint'],
#    schema      => ['bool', {}, {}],
#    allow_expr  => 1,
#    allow_multi => 1,
#    ;
#
#has_clause 'is_neg_inf',
#    v => 2,
#    tags        => ['constraint'],
#    schema      => ['bool', {}, {}],
#    allow_expr  => 1,
#    allow_multi => 1,
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/hash.pm ###
#package Data::Sah::Type::hash;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause', 'has_clause_alias';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::HasElems';
#
#has_clause_alias each_elem => 'of';
#
#has_clause_alias each_index => 'each_key';
#has_clause_alias each_elem => 'each_value';
#has_clause_alias check_each_index => 'check_each_key';
#has_clause_alias check_each_elem => 'check_each_value';
#
#has_clause "keys",
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['hash' => {req=>1, values => ['sah::schema', {req=>1}, {}]}, {}],
#    inspect_elem => 1,
#    subschema  => sub { values %{ $_[0] } },
#    allow_expr => 0,
#    attrs      => {
#        restrict => {
#            schema     => [bool => default=>1],
#            allow_expr => 0, 
#        },
#        create_default => {
#            schema     => [bool => default=>1],
#            allow_expr => 0, 
#        },
#    },
#    ;
#
#has_clause "re_keys",
#    v => 2,
#    prio       => 51,
#    tags       => ['constraint'],
#    schema     => ['hash' => {
#        req=>1,
#        keys   => ['re', {req=>1}, {}],
#        values => ['sah::schema', {req=>1}, {}],
#    }, {}],
#    inspect_elem => 1,
#    subschema  => sub { values %{ $_[0] } },
#    allow_expr => 0,
#    attrs      => {
#        restrict => {
#            schema     => [bool => default=>1],
#            allow_expr => 0, 
#        },
#    },
#    ;
#
#has_clause "req_keys",
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, of=>['str', {req=>1}, {}]}, {}],
#    allow_expr => 1,
#    ;
#has_clause_alias req_keys => 'req_all_keys';
#has_clause_alias req_keys => 'req_all';
#
#has_clause "allowed_keys",
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, of=>['str', {req=>1}, {}]}, {}],
#    allow_expr => 1,
#    ;
#
#has_clause "allowed_keys_re",
#    v => 2,
#    prio       => 51,
#    tags       => ['constraint'],
#    schema     => ['re', {req=>1}, {}],
#    allow_expr => 1,
#    ;
#
#has_clause "forbidden_keys",
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, of=>['str', {req=>1}, {}]}, {}],
#    allow_expr => 1,
#    ;
#
#has_clause "forbidden_keys_re",
#    v => 2,
#    prio       => 51,
#    tags       => ['constraint'],
#    schema     => ['re', {req=>1}, {}],
#    allow_expr => 1,
#    ;
#
#has_clause "choose_one_key",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, of=>['str', {req=>1}, {}], min_len=>1}, {}],
#    allow_expr => 0, 
#    ;
#has_clause_alias choose_one_key => 'choose_one';
#
#has_clause "choose_all_keys",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, of=>['str', {req=>1}, {}], min_len=>1}, {}],
#    allow_expr => 0, 
#    ;
#has_clause_alias choose_all_keys => 'choose_all';
#
#has_clause "req_one_key",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => ['array', {req=>1, of=>['str', {req=>1}, {}], min_len=>1}, {}],
#    allow_expr => 0, 
#    ;
#has_clause_alias req_one_key => 'req_one';
#
#has_clause "req_some_keys",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => ['array', {
#        req => 1,
#        len => 3,
#        elems => [
#            [int => {req=>1, min=>0}], 
#            [int => {req=>1, min=>0}], 
#            [array => {req=>1, of=>['str', {req=>1}, {}], min_len=>1}, {}], 
#        ],
#    }, {}],
#    allow_expr => 0, 
#    ;
#has_clause_alias req_some_keys => 'req_some';
#
#my $sch_dep = ['array', {
#    req => 1,
#    elems => [
#        ['str', {req=>1}, {}],
#        ['array', {of=>['str', {req=>1}, {}]}, {}],
#    ],
#}, {}];
#
#has_clause "dep_any",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => $sch_dep,
#    allow_expr => 0, 
#    ;
#
#has_clause "dep_all",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => $sch_dep,
#    allow_expr => 0, 
#    ;
#
#has_clause "req_dep_any",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => $sch_dep,
#    allow_expr => 0, 
#    ;
#
#has_clause "req_dep_all",
#    v => 2,
#    prio       => 50,
#    tags       => ['constraint'],
#    schema     => $sch_dep,
#    allow_expr => 0, 
#    ;
#
#
#
#1;
#
#__END__
#
### Data/Sah/Type/int.pm ###
#package Data::Sah::Type::int;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::num';
#
#has_clause 'mod',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['array' => {req=>1, len=>2, elems => [
#        ['int' => {req=>1, is=>0, 'is.op'=>'not'}, {}],
#        ['int' => {req=>1}, {}],
#    ]}, {}],
#    allow_expr => 1,
#    ;
#has_clause 'div_by',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['int' => {req=>1, is=>0, 'is.op'=>'not'}, {}],
#    allow_expr => 1,
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/num.pm ###
#package Data::Sah::Type::num;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::Sortable';
#
#1;
#
#__END__
#
### Data/Sah/Type/obj.pm ###
#package Data::Sah::Type::obj;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#
#has_clause 'can',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['str', {req => 1}, {}], 
#    allow_expr => 1,
#    ;
#has_clause 'isa',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['str', {req => 1}, {}], 
#    allow_expr => 1,
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/re.pm ###
#package Data::Sah::Type::re;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#
#1;
#
#__END__
#
### Data/Sah/Type/str.pm ###
#package Data::Sah::Type::str;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::Sortable';
#with 'Data::Sah::Type::HasElems';
#
#my $t_re = ['regex', {req=>1}, {}];
#
#has_clause 'encoding',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['str', {req=>1}, {}],
#    allow_expr => 0,
#    ;
#has_clause 'match',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => $t_re,
#    allow_expr => 1,
#    ;
#has_clause 'is_re',
#    v => 2,
#    tags       => ['constraint'],
#    schema     => ['bool', {}, {}],
#    allow_expr => 1,
#    ;
#
#1;
#
#__END__
#
### Data/Sah/Type/timeofday.pm ###
#package Data::Sah::Type::timeofday;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Data::Sah::Util::Role 'has_clause';
#use Role::Tiny;
#use Role::Tiny::With;
#
#with 'Data::Sah::Type::BaseType';
#with 'Data::Sah::Type::Comparable';
#with 'Data::Sah::Type::Sortable';
#
#1;
#
#__END__
#
### Data/Sah/Type/undef.pm ###
#package Data::Sah::Type::undef;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use Role::Tiny;
#use Data::Sah::Util::Role 'has_clause';
#
#1;
#
#__END__
#
### Data/Sah/Util/Func.pm ###
#package Data::Sah::Util::Func;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       add_func
#               );
#
#sub add_func {
#    my ($funcset, $func, %opts) = @_;
#}
#
#1;
#
#__END__
#
### Data/Sah/Util/Role.pm ###
#package Data::Sah::Util::Role;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict 'subs', 'vars';
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       has_clause has_clause_alias
#                       has_func   has_func_alias
#               );
#
#sub has_clause {
#    my ($name, %args) = @_;
#    my $caller = caller;
#    my $into   = $args{into} // $caller;
#
#    my $v = $args{v} // 1;
#    if ($v != 2) {
#        die "Declaration of clause '$name' still follows version $v ".
#            "(2 expected), please make sure $caller is the latest version";
#    }
#
#    if ($args{code}) {
#        *{"$into\::clause_$name"} = $args{code};
#    } else {
#        eval "package $into; use Role::Tiny; ".
#            "requires 'clause_$name';";
#    }
#    *{"$into\::clausemeta_$name"} = sub {
#        state $meta = {
#            names        => [$name],
#            tags         => $args{tags},
#            prio         => $args{prio} // 50,
#            schema       => $args{schema},
#            allow_expr   => $args{allow_expr},
#            attrs        => $args{attrs} // {},
#            inspect_elem => $args{inspect_elem},
#            subschema    => $args{subschema},
#        };
#        $meta;
#    };
#    has_clause_alias($name, $args{alias}  , $into);
#    has_clause_alias($name, $args{aliases}, $into);
#}
#
#sub has_clause_alias {
#    my ($name, $aliases, $into) = @_;
#    my $caller   = caller;
#    $into      //= $caller;
#    my @aliases = !$aliases ? () :
#        ref($aliases) eq 'ARRAY' ? @$aliases : $aliases;
#    my $meta = $into->${\("clausemeta_$name")};
#
#    for my $alias (@aliases) {
#        push @{ $meta->{names} }, $alias;
#        eval
#            "package $into;".
#            "sub clause_$alias { shift->clause_$name(\@_) } ".
#            "sub clausemeta_$alias { shift->clausemeta_$name(\@_) } ";
#        $@ and die "Can't make clause alias $alias -> $name: $@";
#    }
#}
#
#sub has_func {
#    my ($name, %args) = @_;
#    my $caller = caller;
#    my $into   = $args{into} // $caller;
#
#    if ($args{code}) {
#        *{"$into\::func_$name"} = $args{code};
#    } else {
#        eval "package $into; use Role::Tiny; requires 'func_$name';";
#    }
#    *{"$into\::funcmeta_$name"} = sub {
#        state $meta = {
#            names => [$name],
#            args  => $args{args},
#        };
#        $meta;
#    };
#    my @aliases =
#        map { (!$args{$_} ? () :
#                   ref($args{$_}) eq 'ARRAY' ? @{ $args{$_} } : $args{$_}) }
#            qw/alias aliases/;
#    has_func_alias($name, $args{alias}  , $into);
#    has_func_alias($name, $args{aliases}, $into);
#}
#
#sub has_func_alias {
#    my ($name, $aliases, $into) = @_;
#    my $caller   = caller;
#    $into      //= $caller;
#    my @aliases = !$aliases ? () :
#        ref($aliases) eq 'ARRAY' ? @$aliases : $aliases;
#    my $meta = $into->${\("funcmeta_$name")};
#
#    for my $alias (@aliases) {
#        push @{ $meta->{names} }, $alias;
#        eval
#            "package $into;".
#            "sub func_$alias { shift->func_$name(\@_) } ".
#            "sub funcmeta_$alias { shift->funcmeta_$name(\@_) } ";
#        $@ and die "Can't make func alias $alias -> $name: $@";
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Util/Type.pm ###
#package Data::Sah::Util::Type;
#
#our $DATE = '2016-12-09'; 
#our $VERSION = '0.46'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(get_type is_type is_simple is_numeric is_collection is_ref);
#
#our $type_metas = {
#    all   => {scalar=>0, numeric=>0, ref=>0},
#    any   => {scalar=>0, numeric=>0, ref=>0},
#    array => {scalar=>0, numeric=>0, ref=>1},
#    bool  => {scalar=>1, numeric=>0, ref=>0},
#    buf   => {scalar=>1, numeric=>0, ref=>0},
#    cistr => {scalar=>1, numeric=>0, ref=>0},
#    code  => {scalar=>1, numeric=>0, ref=>1},
#    float => {scalar=>1, numeric=>1, ref=>0},
#    hash  => {scalar=>0, numeric=>0, ref=>1},
#    int   => {scalar=>1, numeric=>1, ref=>0},
#    num   => {scalar=>1, numeric=>1, ref=>0},
#    obj   => {scalar=>1, numeric=>0, ref=>1},
#    re    => {scalar=>1, numeric=>0, ref=>1, simple=>1},
#    str   => {scalar=>1, numeric=>0, ref=>0},
#    undef => {scalar=>1, numeric=>0, ref=>0},
#    date     => {scalar=>1, numeric=>0, ref=>0},
#    duration => {scalar=>1, numeric=>0, ref=>0},
#};
#
#sub get_type {
#    my $sch = shift;
#
#    if (ref($sch) eq 'ARRAY') {
#        $sch = $sch->[0];
#    }
#
#    if (defined($sch) && !ref($sch)) {
#        $sch =~ s/\*\z//;
#        return $sch;
#    } else {
#        return undef;
#    }
#}
#
#sub _normalize {
#    require Data::Sah::Normalize;
#
#    my ($sch, $opts) = @_;
#    return $sch if $opts->{schema_is_normalized};
#    return Data::Sah::Normalize::normalize_schema($sch);
#}
#
#sub _handle_any_all {
#    my ($sch, $opts, $crit) = @_;
#    $sch = _normalize($sch, $opts);
#    return 0 if $sch->[1]{'of.op'};
#    my $of = $sch->[1]{of};
#    return 0 unless $of && ref($of) eq 'ARRAY' && @$of;
#    for (@$of) {
#        return 0 unless $crit->($_);
#    }
#    1;
#}
#
#sub is_type {
#    my ($sch, $opts) = @_;
#    $opts //= {};
#
#    my $type = get_type($sch) or return undef;
#    my $tmeta = $type_metas->{$type} or return undef;
#    $type;
#}
#
#sub is_simple {
#    my ($sch, $opts) = @_;
#    $opts //= {};
#
#    my $type = get_type($sch) or return undef;
#    my $tmeta = $type_metas->{$type} or return undef;
#    if ($type eq 'any' || $type eq 'all') {
#        return _handle_any_all($sch, $opts, sub { is_simple(shift) });
#    }
#    return $tmeta->{simple} // ($tmeta->{scalar} && !$tmeta->{ref});
#}
#
#sub is_collection {
#    my ($sch, $opts) = @_;
#    $opts //= {};
#
#    my $type = get_type($sch) or return undef;
#    my $tmeta = $type_metas->{$type} or return undef;
#    if ($type eq 'any' || $type eq 'all') {
#        return _handle_any_all($sch, $opts, sub { is_collection(shift) });
#    }
#    return !$tmeta->{scalar};
#}
#
#sub is_numeric {
#    my ($sch, $opts) = @_;
#    $opts //= {};
#
#    my $type = get_type($sch) or return undef;
#    my $tmeta = $type_metas->{$type} or return undef;
#    if ($type eq 'any' || $type eq 'all') {
#        return _handle_any_all($sch, $opts, sub { is_numeric(shift) });
#    }
#    return $tmeta->{numeric};
#}
#
#sub is_ref {
#    my ($sch, $opts) = @_;
#    $opts //= {};
#
#    my $type = get_type($sch) or return undef;
#    my $tmeta = $type_metas->{$type} or return undef;
#    if ($type eq 'any' || $type eq 'all') {
#        return _handle_any_all($sch, $opts, sub { is_ref(shift) });
#    }
#    return $tmeta->{ref};
#}
#
#1;
#
#__END__
#
### Data/Sah/Util/Type/Date.pm ###
#package Data::Sah::Util::Type::Date;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Scalar::Util qw(blessed looks_like_number);
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       coerce_date
#                       coerce_duration
#               );
#
#our $DATE_MODULE = $ENV{DATA_SAH_DATE_MODULE} // $ENV{PERL_DATE_MODULE} //
#    "DateTime"; 
#
#my $re_ymd = qr/\A([0-9]{4})-([0-9]{2})-([0-9]{2})\z/;
#my $re_ymdThmsZ = qr/\A([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})Z\z/;
#
#sub coerce_date {
#    my $val = shift;
#    if (!defined($val)) {
#        return undef;
#    }
#
#    if ($DATE_MODULE eq 'DateTime') {
#        require DateTime;
#        if (blessed($val) && $val->isa('DateTime')) {
#            return $val;
#        } elsif (looks_like_number($val) && $val >= 10**8 && $val <= 2**31) {
#            return DateTime->from_epoch(epoch => $val);
#        } elsif ($val =~ $re_ymd) {
#            my $d;
#            eval { $d = DateTime->new(year=>$1, month=>$2, day=>$3, time_zone=>'UTC') };
#            return undef if $@;
#            return $d;
#        } elsif ($val =~ $re_ymdThmsZ) {
#            my $d;
#            eval { $d = DateTime->new(year=>$1, month=>$2, day=>$3, hour=>$4, minute=>$5, second=>$6, time_zone=>'UTC') };
#            return undef if $@;
#            return $d;
#        } elsif (blessed($val) && $val->isa('Time::Moment')) {
#            return DateTime->from_epoch(epoch => $val->epoch);
#        } elsif (blessed($val) && $val->isa('Time::Piece')) {
#            return DateTime->from_epoch(epoch => $val->epoch);
#        } else {
#            return undef;
#        }
#    } elsif ($DATE_MODULE eq 'Time::Moment') {
#        require Time::Moment;
#        if (blessed($val) && $val->isa('Time::Moment')) {
#            return $val;
#        } elsif (looks_like_number($val) && $val >= 10**8 && $val <= 2**31) {
#            return Time::Moment->from_epoch(int($val), $val-int($val));
#        } elsif ($val =~ $re_ymd) {
#            my $d;
#            eval { $d = Time::Moment->new(year=>$1, month=>$2, day=>$3) };
#            return undef if $@;
#            return $d;
#        } elsif ($val =~ $re_ymdThmsZ) {
#            my $d;
#            eval { $d = Time::Moment->new(year=>$1, month=>$2, day=>$3, hour=>$4, minute=>$5, second=>$6) };
#            return undef if $@;
#            return $d;
#        } elsif (blessed($val) && $val->isa('DateTime')) {
#            return Time::Moment->from_epoch($val->epoch);
#        } elsif (blessed($val) && $val->isa('Time::Piece')) {
#            return Time::Moment->from_epoch($val->epoch);
#        } else {
#            return undef;
#        }
#    } elsif ($DATE_MODULE eq 'Time::Piece') {
#        require Time::Piece;
#        if (blessed($val) && $val->isa('Time::Piece')) {
#            return $val;
#        } elsif (looks_like_number($val) && $val >= 10**8 && $val <= 2**31) {
#            return scalar Time::Piece->gmtime($val);
#        } elsif ($val =~ $re_ymd) {
#            my $d;
#            eval { $d = Time::Piece->strptime($val, "%Y-%m-%d") };
#            return undef if $@;
#            return $d;
#        } elsif ($val =~ $re_ymdThmsZ) {
#            my $d;
#            eval { $d = Time::Piece->strptime($val, "%Y-%m-%dT%H:%M:%SZ") };
#            return undef if $@;
#            return $d;
#        } elsif (blessed($val) && $val->isa('DateTime')) {
#            return scalar Time::Piece->gmtime(epoch => $val->epoch);
#        } elsif (blessed($val) && $val->isa('Time::Moment')) {
#            return scalar Time::Piece->gmtime(epoch => $val->epoch);
#        } else {
#            return undef;
#        }
#    } else {
#        die "BUG: Unknown Perl date module '$DATE_MODULE'";
#    }
#}
#
#sub coerce_duration {
#    my $val = shift;
#    if (!defined($val)) {
#        return undef;
#    } elsif (blessed($val) && $val->isa('DateTime::Duration')) {
#        return $val;
#    } elsif ($val =~ /\AP
#                      (?: ([0-9]+(?:\.[0-9]+)?)Y )?
#                      (?: ([0-9]+(?:\.[0-9]+)?)M )?
#                      (?: ([0-9]+(?:\.[0-9]+)?)W )?
#                      (?: ([0-9]+(?:\.[0-9]+)?)D )?
#                      (?:
#                          T
#                          (?: ([0-9]+(?:\.[0-9]+)?)H )?
#                          (?: ([0-9]+(?:\.[0-9]+)?)M )?
#                          (?: ([0-9]+(?:\.[0-9]+)?)S )?
#                      )?
#                      \z/x) {
#        require DateTime::Duration;
#        my $d;
#        eval {
#            $d = DateTime::Duration->new(
#                years   => $1 // 0,
#                months  => $2 // 0,
#                weeks   => $3 // 0,
#                days    => $4 // 0,
#                hours   => $5 // 0,
#                minutes => $6 // 0,
#                seconds => $7 // 0,
#            );
#        };
#        return undef if $@;
#        return $d;
#    } else {
#        return undef;
#    }
#}
#
#1;
#
#__END__
#
### Data/Sah/Util/TypeX.pm ###
#package Data::Sah::Util::TypeX;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       add_clause
#               );
#
#sub add_clause {
#    my ($type, $clause, %opts) = @_;
#
#
#}
#
#1;
#
#__END__
#
### File/Flock/Retry.pm ###
#package File::Flock::Retry;
#
#our $DATE = '2017-07-01'; 
#our $VERSION = '0.62'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Fcntl ':flock';
#
#sub lock {
#    my ($class, $path, $opts) = @_;
#    $opts //= {};
#    my %h;
#
#    defined($path) or die "Please specify path";
#    $h{path}    = $path;
#    $h{retries} = $opts->{retries} // 60;
#    $h{shared}  = $opts->{shared} // 0;
#
#    my $self = bless \%h, $class;
#    $self->_lock;
#    $self;
#}
#
#sub _lock {
#    my $self = shift;
#
#    return 0 if $self->{_fh};
#
#    my $path = $self->{path};
#    my $existed = -f $path;
#    my $exists;
#    my $tries = 0;
#  TRY:
#    while (1) {
#        $tries++;
#
#        open $self->{_fh}, ">>", $path
#            or die "Can't open lock file '$path': $!";
#
#        my @st1 = stat($self->{_fh}); 
#
#        if (flock($self->{_fh}, ($self->{shared} ? LOCK_SH : LOCK_EX) | LOCK_NB)) {
#            redo TRY unless @st1;
#
#            my @st2 = stat($path); 
#
#            redo TRY unless @st2;
#
#            redo TRY if $st1[0] != $st2[0] || $st1[1] != $st2[1];
#
#            last;
#        } else {
#            $tries <= $self->{retries}
#                or die "Can't acquire lock on '$path' after $tries seconds";
#            sleep 1;
#        }
#    }
#    $self->{_created} = !$existed;
#    1;
#}
#
#sub _unlock {
#    my ($self) = @_;
#
#    my $path = $self->{path};
#
#    return 0 unless $self->{_fh};
#
#    unlink $self->{path} if $self->{_created} && !(-s $self->{path});
#
#    {
#        no warnings;
#
#        flock $self->{_fh}, LOCK_UN;
#    }
#    close delete($self->{_fh});
#    1;
#}
#
#sub release {
#    my $self = shift;
#    $self->_unlock;
#}
#
#sub unlock {
#    my $self = shift;
#    $self->_unlock;
#}
#
#sub DESTROY {
#    my $self = shift;
#    $self->_unlock;
#}
#
#1;
#
#__END__
#
### File/RsyBak.pm ###
#package File::RsyBak;
#
#our $DATE = '2019-03-11'; 
#our $VERSION = '0.361'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#use File::chdir;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(backup);
#
#our %SPEC;
#
#sub _parse_path {
#    require Cwd;
#
#    my ($path) = @_;
#    $path =~ s!/+$!!;
#    if ($path =~ m!^(\S+)::([^/]+)/?(.*)$!) {
#        return {
#            raw=>$path, remote=>1, host=>$1,
#            proto=>"rsync", module=>$2, path=>$3,
#        };
#    } elsif ($path =~ m!([^@]+)?\@?(^\S+):(.*)$!) {
#        return {
#            raw=>$path, remote=>1, host=>$2,
#            user=>$1, proto=>"ssh", path=>$3,
#        };
#    } else {
#        return {
#            raw=>$path, remote=>0, path=>$path,
#            abs_path=>Cwd::abs_path($path)
#        };
#    }
#}
#
#sub _check_sources {
#    my ($sources) = @_;
#
#    my $all_local = 1;
#    for (@$sources) {
#        if ($_->{remote}) { $all_local = 0; last }
#    }
#
#    my $all_remote = 1;
#    for (@$sources) {
#        if (!$_->{remote}) { $all_remote = 0; last }
#    }
#
#    return [400, "Sources must be all local or all remote"]
#        unless $all_remote || $all_local;
#
#    if ($all_remote) {
#        my $host;
#        for (@$sources) {
#            $host //= $_->{host};
#            return [400, "Remote sources must all be from the same machine"]
#                if $host ne $_->{host};
#        }
#    }
#    [200, "OK"];
#}
#
#$SPEC{backup} = {
#    v             => 1.1,
#    summary       =>
#        'Backup files/directories with histories, using rsync',
#    args          => {
#        source           => {
#            summary      => 'Director(y|ies) to backup',
#            schema       => 'str*', 
#            req          => 1,
#            pos          => 0,
#        },
#        target           => {
#            summary      => 'Backup destination',
#            schema       => ['str*'   => {}],
#            req          => 1,
#            pos          => 1,
#        },
#        histories        => {
#            summary      => 'Histories/history levels',
#            schema       => ['array' => {
#                default      => [-7, 4, 3],
#                of           => 'int*',
#            }],
#            description  => <<'_',
#
#Specifies number of backup histories to keep for level 1, 2, and so on. If
#number is negative, specifies number of days to keep instead (regardless of
#number of histories).
#
#_
#        },
#        extra_dir        => {
#            summary      =>
#                'Whether to force creation of source directory in target',
#            schema       => ['bool'   => {}],
#            description  => <<'_',
#
#If set to 1, then backup(source => '/a', target => '/backup/a') will create
#another 'a' directory in target, i.e. /backup/a/current/a. Otherwise, contents
#of a/ will be directly copied under /backup/a/current/.
#
#Will always be set to 1 if source is more than one, but default to 0 if source
#is a single directory. You can set this to 1 to so that behaviour when there is
#a single source is the same as behaviour when there are several sources.
#
#_
#        },
#        backup           => {
#            summary      => 'Whether to do backup or not',
#            schema       => [bool     => {
#                default      => 1,
#            }],
#            description  => <<'_',
#
#If backup=1 and rotate=0 then will only create new backup without rotating
#histories.
#
#_
#        },
#        rotate           => {
#            summary      => 'Whether to do rotate after backup or not',
#            schema       => [bool     => {
#                default      => 1,
#            }],
#            description  => <<'_',
#
#If backup=0 and rotate=1 then will only do history rotating.
#
#_
#        },
#        extra_rsync_opts => {
#            summary      => 'Pass extra options to rsync command',
#            schema       => [array    => {
#                of           => 'str*',
#            }],
#            description  => <<'_',
#
#Extra options to pass to rsync command when doing backup. Note that the options
#will be shell quoted, , so you should pass it unquoted, e.g. ['--exclude',
#'/Program Files'].
#
#_
#        },
#    },
#
#    examples => [
#        {
#            argv         => ['/home/jajang/mydata','/backup/jajang/mydata'],
#            test         => 0,
#            'x.doc.show_result' => 0,
#            description  => <<'_',
#
#Backup /home/jajang/mydata to /backup/jajang/mydata using the default number of
#histories ([-7, 4, 3]).
#
#_
#        },
#    ],
#
#    deps => {
#        all => [
#            {prog => 'nice'},
#            {prog => 'rsync'}, 
#            {prog => 'rm'},    
#        ],
#    },
#};
#sub backup {
#    require File::Flock::Retry;
#    require File::Path;
#    require File::Which;
#
#    my %args = @_;
#
#    my $source    = $args{source} or return [400, "Please specify source"];
#    my @sources   = ref($source) eq 'ARRAY' ? @$source : ($source);
#    for (@sources) { $_ = _parse_path($_) }
#    my $res = _check_sources(\@sources);
#    return $res unless $res->[0] == 200;
#    my $target    = $args{target} or return [400, "Please specify target"];
#    $target       = _parse_path($target);
#    $target->{remote} and
#        return [400, "Sorry, target can't be remote at the moment"];
#    my $histories = $args{histories} // [-7, 4, 3];
#    ref($histories) eq 'ARRAY' or return [400, "histories must be array"];
#    my $backup    = $args{backup} // 1;
#    my $rotate    = $args{rotate} // 1;
#    my $extra_dir = $args{extra_dir} || (@sources > 1);
#
#    my $rsync_path = File::Which::which("rsync")
#        or return [500, "Can't find rsync in PATH"];
#
#    unless (-d $target->{abs_path}) {
#        log_debug("Creating target directory %s ...", $target->{abs_path});
#        File::Path::make_path($target->{abs_path})
#            or return [500, "Error: Can't create target directory ".
#                "$target->{abs_path}: $!"];
#    }
#
#    my $lock = File::Flock::Retry->lock("$target->{abs_path}/.lock");
#
#    if ($backup) {
#        _backup(
#            \@sources, $target,
#            {
#                extra_dir        => $extra_dir,
#                extra_rsync_opts => $args{extra_rsync_opts},
#            });
#    }
#
#    if ($rotate) {
#        _rotate($target->{abs_path}, $histories);
#    }
#
#    [200, "OK"];
#}
#
#sub _backup {
#    require POSIX;
#    require String::ShellQuote; String::ShellQuote->import;
#
#    my ($sources, $target, $opts) = @_;
#    log_info("Starting backup %s ==> %s ...",
#                [map {$_->{raw}} @$sources], $target);
#    my $cmd;
#    $cmd = join(
#        "",
#        "nice -n19 rsync ",
#        ($opts->{extra_rsync_opts} ? map { (shell_quote($_), " ") }
#             @{$opts->{extra_rsync_opts}} : ()),
#        "-a --del --force --ignore-errors --ignore-existing ",
#        (log_is_debug() ? "-v " : ""),
#        ((-e "$target->{abs_path}/current") ?
#             "--link-dest ".shell_quote("$target->{abs_path}/current")." "
#                 : ""),
#        map({ (shell_quote($_->{raw}), ($opts->{extra_dir} ? "" : "/"), " ") }
#                @$sources),
#        shell_quote("$target->{abs_path}/.tmp/"),
#    );
#    log_debug("Running rsync ...");
#    log_trace("system(): $cmd");
#    system $cmd;
#    log_warn("rsync didn't succeed ($?)".
#                   ", please recheck") if $?;
#
#
#    if (-e "$target->{abs_path}/current") {
#        my $tspath = "$target->{abs_path}/.current.timestamp";
#        my @st     = stat($tspath);
#        my $tstamp = POSIX::strftime(
#            "%Y-%m-%d\@%H:%M:%S+00",
#            gmtime( $st[9] || time() )); 
#        log_debug("rename $target->{abs_path}/current ==> ".
#                        "hist.$tstamp ...");
#        unless (rename "$target->{abs_path}/current",
#                "$target->{abs_path}/hist.$tstamp") {
#            log_warn("Failed renaming $target->{abs_path}/current ==> ".
#                         "hist.$tstamp: $!");
#        }
#        log_debug("touch $tspath ...");
#        system "touch ".shell_quote($tspath);
#    }
#
#    log_debug("rename $target->{abs_path}/.tmp ==> current ...");
#    unless (rename "$target->{abs_path}/.tmp",
#            "$target->{abs_path}/current") {
#        log_warn("Failed renaming $target->{abs_path}/.tmp ==> current: $!");
#    }
#
#    log_info("Finished backup %s ==> %s", $sources, $target);
#}
#
#sub _rotate {
#    require String::ShellQuote; String::ShellQuote->import;
#    require Time::Local;
#
#    my ($target, $histories) = @_;
#    log_info("Rotating backup histories in %s (%s) ...",
#                $target, $histories);
#
#    local $CWD = $target; 
#
#    my $now = time();
#    for my $level (1 .. @$histories) {
#        my $is_highest_level  = $level == @$histories;
#        my $prefix            = "hist" . ($level == 1 ? '' : $level);
#        my $prefix_next_level = "hist" . ($level + 1);
#        my $n                 = $histories->[$level - 1];
#        my $moved             = 0;
#
#        if ($n > 0) {
#            log_debug("Only keeping $n level-$level histories ...");
#            my @f = reverse sort grep { !/\.tmp$/ } glob "$prefix.*";
#            my $any_tagged = (grep {/t$/} @f) ? 1 : 0;
#            for my $f (@f[ $n .. @f - 1 ]) {
#                my ($st, $tagged) = $f =~ /[^.]+\.(.+?)(t)?$/;
#                my $f2 = "$prefix_next_level.$st";
#                if (!$is_highest_level &&
#                        !$moved && ($tagged || !$any_tagged)) {
#                    log_debug("Moving history level: $f -> $f2");
#                    rename $f, $f2;
#                    $moved++;
#                    if ($f ne $f[0]) {
#                        rename $f[0], "$f[0]t";
#                    }
#                } else {
#                    log_debug("Removing history: $f ...");
#                    system "nice -n19 rm -rf " . shell_quote($f);
#                }
#            }
#        } else {
#            $n = -$n;
#            log_debug("Only keeping $n day(s) of level-$level histories ...");
#            my @f = reverse sort grep { !/\.tmp$/ } glob "$prefix.*";
#            my $any_tagged = ( grep {/t$/} @f ) ? 1 : 0;
#            for my $f (@f) {
#                my ($st, $tagged) = $f =~ /[^.]+\.(.+?)(t)?$/;
#                my $f2 = "$prefix_next_level.$st";
#                my $t;
#                $st =~ /(\d\d\d\d)-(\d\d)-(\d\d)\@(\d\d):(\d\d):(\d\d)\+00/;
#                $t = Time::Local::timegm($6, $5, $4, $3, $2 - 1, $1) if $1;
#                unless ($st && $t) {
#                    log_warn("Wrong format of history, ignored: $f");
#                    next;
#                }
#                if ($t > $now) {
#                    log_warn("History in the future, ignored: $f");
#                    next;
#                }
#                my $delta = ($now - $t) / 86400;
#                if ($delta > $n) {
#                    if (!$is_highest_level &&
#                            !$moved && ( $tagged || !$any_tagged)) {
#                        log_debug("Moving history level: $f -> $f2");
#                        rename $f, $f2;
#                        $moved++;
#                        if ($f ne $f[0]) {
#                            rename $f[0], "$f[0]t";
#                        }
#                    } else {
#                        log_debug("Removing history: $f ...");
#                        system "nice -n19 rm -rf " . shell_quote($f);
#                    }
#                }
#            }
#        }
#    }
#}
#
#1;
#
#__END__
#
### File/RsyBak/Packed.pm ###
#package File::RsyBak::Packed;
#
#our $DATE = '2018-09-30'; 
#our $VERSION = '0.360'; 
#
#our %PACKED_MODULES = %{ {"Capture::Tiny"=>0.44,"Class::Inspector"=>1.28,"Class::Inspector::Functions"=>1.28,"Clone::PP"=>1.06,"Color::ANSI::Util"=>"0.160","Complete::Bash"=>0.31,"Complete::Common"=>0.22,"Complete::Env"=>"0.400","Complete::File"=>0.43,"Complete::Fish"=>0.05,"Complete::Getopt::Long"=>0.46,"Complete::Path"=>0.24,"Complete::Tcsh"=>0.02,"Complete::Util"=>"0.600","Complete::Zsh"=>0.03,"Config::IOD::Base"=>"0.340","Config::IOD::Expr"=>"0.340","Config::IOD::Reader"=>"0.340","Data::Check::Structure"=>0.04,"Data::Clean"=>0.49,"Data::Clean::FromJSON"=>0.38,"Data::Clean::JSON"=>0.38,"Data::Dmp"=>0.23,"Data::Dump"=>1.23,"Data::Dump::FilterContext"=>undef,"Data::Dump::Filtered"=>undef,"Data::Dump::Trace"=>0.02,"Data::ModeMerge"=>0.35,"Data::ModeMerge::Config"=>0.35,"Data::ModeMerge::Mode::ADD"=>0.35,"Data::ModeMerge::Mode::Base"=>0.35,"Data::ModeMerge::Mode::CONCAT"=>0.35,"Data::ModeMerge::Mode::DELETE"=>0.35,"Data::ModeMerge::Mode::KEEP"=>0.35,"Data::ModeMerge::Mode::NORMAL"=>0.35,"Data::ModeMerge::Mode::SUBTRACT"=>0.35,"Data::Sah"=>0.893,"Data::Sah::Coerce"=>0.026,"Data::Sah::Coerce::js::bool::float"=>0.026,"Data::Sah::Coerce::js::bool::str"=>0.026,"Data::Sah::Coerce::js::date::float_epoch"=>0.026,"Data::Sah::Coerce::js::date::obj_Date"=>0.026,"Data::Sah::Coerce::js::date::str"=>0.026,"Data::Sah::Coerce::js::duration::float_secs"=>0.026,"Data::Sah::Coerce::js::duration::str_iso8601"=>0.026,"Data::Sah::Coerce::perl::bool::str"=>0.026,"Data::Sah::Coerce::perl::date::float_epoch"=>0.026,"Data::Sah::Coerce::perl::date::obj_DateTime"=>0.026,"Data::Sah::Coerce::perl::date::obj_TimeMoment"=>0.026,"Data::Sah::Coerce::perl::date::str_iso8601"=>0.026,"Data::Sah::Coerce::perl::duration::float_secs"=>0.026,"Data::Sah::Coerce::perl::duration::obj_DateTimeDuration"=>0.026,"Data::Sah::Coerce::perl::duration::str_human"=>0.026,"Data::Sah::Coerce::perl::duration::str_iso8601"=>0.026,"Data::Sah::Coerce::perl::float::str_percent"=>0.026,"Data::Sah::Coerce::perl::int::str_percent"=>0.026,"Data::Sah::CoerceCommon"=>0.026,"Data::Sah::CoerceJS"=>0.026,"Data::Sah::Compiler"=>0.893,"Data::Sah::Compiler::Prog"=>0.893,"Data::Sah::Compiler::Prog::TH"=>0.893,"Data::Sah::Compiler::Prog::TH::all"=>0.893,"Data::Sah::Compiler::Prog::TH::any"=>0.893,"Data::Sah::Compiler::TH"=>0.893,"Data::Sah::Compiler::TextResultRole"=>0.893,"Data::Sah::Compiler::human"=>0.893,"Data::Sah::Compiler::human::TH"=>0.893,"Data::Sah::Compiler::human::TH::Comparable"=>0.893,"Data::Sah::Compiler::human::TH::HasElems"=>0.893,"Data::Sah::Compiler::human::TH::Sortable"=>0.893,"Data::Sah::Compiler::human::TH::all"=>0.893,"Data::Sah::Compiler::human::TH::any"=>0.893,"Data::Sah::Compiler::human::TH::array"=>0.893,"Data::Sah::Compiler::human::TH::bool"=>0.893,"Data::Sah::Compiler::human::TH::buf"=>0.893,"Data::Sah::Compiler::human::TH::cistr"=>0.893,"Data::Sah::Compiler::human::TH::code"=>0.893,"Data::Sah::Compiler::human::TH::date"=>0.893,"Data::Sah::Compiler::human::TH::duration"=>0.893,"Data::Sah::Compiler::human::TH::float"=>0.893,"Data::Sah::Compiler::human::TH::hash"=>0.893,"Data::Sah::Compiler::human::TH::int"=>0.893,"Data::Sah::Compiler::human::TH::num"=>0.893,"Data::Sah::Compiler::human::TH::obj"=>0.893,"Data::Sah::Compiler::human::TH::re"=>0.893,"Data::Sah::Compiler::human::TH::str"=>0.893,"Data::Sah::Compiler::human::TH::undef"=>0.893,"Data::Sah::Compiler::perl"=>0.893,"Data::Sah::Compiler::perl::TH"=>0.893,"Data::Sah::Compiler::perl::TH::all"=>0.893,"Data::Sah::Compiler::perl::TH::any"=>0.893,"Data::Sah::Compiler::perl::TH::array"=>0.893,"Data::Sah::Compiler::perl::TH::bool"=>0.893,"Data::Sah::Compiler::perl::TH::buf"=>0.893,"Data::Sah::Compiler::perl::TH::cistr"=>0.893,"Data::Sah::Compiler::perl::TH::code"=>0.893,"Data::Sah::Compiler::perl::TH::date"=>0.893,"Data::Sah::Compiler::perl::TH::duration"=>0.893,"Data::Sah::Compiler::perl::TH::float"=>0.893,"Data::Sah::Compiler::perl::TH::hash"=>0.893,"Data::Sah::Compiler::perl::TH::int"=>0.893,"Data::Sah::Compiler::perl::TH::num"=>0.893,"Data::Sah::Compiler::perl::TH::obj"=>0.893,"Data::Sah::Compiler::perl::TH::re"=>0.893,"Data::Sah::Compiler::perl::TH::str"=>0.893,"Data::Sah::Compiler::perl::TH::undef"=>0.893,"Data::Sah::Human"=>0.893,"Data::Sah::Lang"=>0.893,"Data::Sah::Lang::fr_FR"=>0.893,"Data::Sah::Lang::id_ID"=>0.893,"Data::Sah::Lang::zh_CN"=>0.893,"Data::Sah::Normalize"=>"0.050","Data::Sah::Resolve"=>0.007,"Data::Sah::Type::BaseType"=>0.893,"Data::Sah::Type::Comparable"=>0.893,"Data::Sah::Type::HasElems"=>0.893,"Data::Sah::Type::Sortable"=>0.893,"Data::Sah::Type::all"=>0.893,"Data::Sah::Type::any"=>0.893,"Data::Sah::Type::array"=>0.893,"Data::Sah::Type::bool"=>0.893,"Data::Sah::Type::buf"=>0.893,"Data::Sah::Type::cistr"=>0.893,"Data::Sah::Type::code"=>0.893,"Data::Sah::Type::date"=>0.893,"Data::Sah::Type::duration"=>0.893,"Data::Sah::Type::float"=>0.893,"Data::Sah::Type::hash"=>0.893,"Data::Sah::Type::int"=>0.893,"Data::Sah::Type::num"=>0.893,"Data::Sah::Type::obj"=>0.893,"Data::Sah::Type::re"=>0.893,"Data::Sah::Type::str"=>0.893,"Data::Sah::Type::undef"=>0.893,"Data::Sah::Util::Func"=>0.893,"Data::Sah::Util::Role"=>0.893,"Data::Sah::Util::Type"=>0.46,"Data::Sah::Util::Type::Date"=>0.893,"Data::Sah::Util::TypeX"=>0.893,"File::Flock::Retry"=>0.62,"File::RsyBak"=>"0.360","File::RsyBak::Packed"=>"0.360","File::ShareDir"=>1.102,"File::ShareDir::Tarball"=>"0.2.2","File::Slurper"=>0.009,"File::Which"=>1.21,"File::chdir"=>"0.1010","Function::Fallback::CoreOrPP"=>0.08,"Getopt::Long::Negate::EN"=>0.05,"Getopt::Long::Util"=>"0.890","HTTP::Tiny"=>"0.070","HTTP::Tiny::UNIX"=>0.051,"IO::Pty"=>1.12,"IO::Tty"=>1.12,"IPC::Run"=>0.94,"IPC::Run::Debug"=>"0.90","IPC::Run::IO"=>"0.90","IPC::Run::Timer"=>"0.90","IPC::Run::Win32Helper"=>"0.90","IPC::Run::Win32IO"=>"0.90","IPC::Run::Win32Pump"=>"0.90","IPC::System::Options"=>"0.330",JSON=>"2.90","JSON::MaybeXS"=>1.003007,"JSON::PP"=>"2.27300","JSON::PP::Boolean"=>undef,"Lingua::EN::Numbers::Ordinate"=>1.04,"Lingua::EN::PluralToSingular"=>0.18,"Log::ger"=>0.023,"Log::ger::App"=>0.006,"Log::ger::Format"=>0.023,"Log::ger::Format::None"=>0.023,"Log::ger::Heavy"=>0.023,"Log::ger::Layout"=>0.023,"Log::ger::Layout::Pattern"=>0.001,"Log::ger::Output"=>0.023,"Log::ger::Output::Array"=>0.023,"Log::ger::Output::ArrayML"=>0.023,"Log::ger::Output::Composite"=>0.007,"Log::ger::Output::File"=>0.006,"Log::ger::Output::Null"=>0.023,"Log::ger::Output::Screen"=>0.007,"Log::ger::Output::String"=>0.023,"Log::ger::Output::Syslog"=>0.001,"Log::ger::Plugin"=>0.023,"Log::ger::Plugin::MultilevelLog"=>0.023,"Log::ger::Util"=>0.023,Mo=>"0.40","Mo::Golf"=>"0.40","Mo::Inline"=>"0.40","Mo::Moose"=>"0.40","Mo::Mouse"=>"0.40","Mo::build"=>"0.40","Mo::builder"=>"0.40","Mo::chain"=>"0.40","Mo::coerce"=>"0.40","Mo::default"=>"0.40","Mo::exporter"=>"0.40","Mo::import"=>"0.40","Mo::importer"=>"0.40","Mo::is"=>"0.40","Mo::nonlazy"=>"0.40","Mo::option"=>"0.40","Mo::required"=>"0.40","Mo::xs"=>"0.40","Module::Installed::Tiny"=>0.003,"Monkey::Patch::Action"=>0.061,"Monkey::Patch::Action::Handle"=>0.061,"Nodejs::Util"=>0.012,"Number::Format::BigFloat"=>0.001,"PERLANCAR::File::HomeDir"=>0.05,"PERLANCAR::Module::List"=>0.003005,"Perinci::Access::Lite"=>0.14,"Perinci::AccessUtil"=>0.06,"Perinci::CmdLine::Base"=>1.815,"Perinci::CmdLine::Help"=>"0.170","Perinci::CmdLine::Lite"=>1.815,"Perinci::CmdLine::Util::Config"=>1.721,"Perinci::Object"=>"0.30","Perinci::Object::EnvResult"=>"0.30","Perinci::Object::EnvResultMulti"=>"0.30","Perinci::Object::EnvResultTable"=>"0.30","Perinci::Object::Function"=>"0.30","Perinci::Object::Metadata"=>"0.30","Perinci::Object::Package"=>"0.30","Perinci::Object::ResMeta"=>"0.30","Perinci::Object::Variable"=>"0.30","Perinci::Result::Format::Lite"=>0.274,"Perinci::Sub::Complete"=>0.931,"Perinci::Sub::ConvertArgs::Argv"=>"0.10","Perinci::Sub::ConvertArgs::Array"=>0.08,"Perinci::Sub::DepChecker"=>0.11,"Perinci::Sub::GetArgs::Argv"=>"0.840","Perinci::Sub::GetArgs::Array"=>0.16,"Perinci::Sub::Normalize"=>"0.200","Perinci::Sub::To::CLIDocData"=>0.28,"Perinci::Sub::Util"=>0.46,"Perinci::Sub::Util::Args"=>0.46,"Perinci::Sub::Util::ResObj"=>0.46,"Perinci::Sub::Util::Sort"=>0.46,"Proc::ChildError"=>0.04,"Progress::Any"=>0.214,"Progress::Any::Output"=>0.214,"Progress::Any::Output::Null"=>0.214,"Progress::Any::Output::TermProgressBarColor"=>0.245,"Regexp::Stringify"=>0.06,"Role::Tiny"=>2.000005,"Role::Tiny::With"=>2.000005,"Sah::Schema::rinci::function_meta"=>"1.1.82.3","Sah::Schema::rinci::meta"=>"1.1.82.3","Sah::Schema::rinci::result_meta"=>"1.1.82.3","Sah::SchemaR::rinci::function_meta"=>"1.1.82.3","Sah::SchemaR::rinci::meta"=>"1.1.82.3","Sah::SchemaR::rinci::result_meta"=>"1.1.82.3","Sah::Schemas::Rinci"=>"1.1.82.3","Scalar::Util::Numeric::PP"=>0.04,"Sort::BySpec"=>0.03,"String::Elide::Parts"=>0.07,"String::LineNumber"=>0.01,"String::PerlQuote"=>0.02,"String::ShellQuote"=>1.04,"String::Wildcard::Bash"=>0.03,"Sub::Delete"=>1.00002,"Test::Config::IOD::Common"=>"0.340","Test::Data::Sah"=>0.893,"Test::Data::Sah::Human"=>0.893,"Test::Data::Sah::Perl"=>0.893,"Text::ANSI::BaseUtil"=>0.22,"Text::ANSI::Util"=>0.22,"Text::Table::ASV"=>0.001,"Text::Table::Any"=>0.092,"Text::Table::Tiny"=>0.04,"Text::sprintfn"=>0.08,"Tie::IxHash"=>1.23,"Time::Duration"=>"1.20","YAML::Old"=>1.07,"YAML::Old::Dumper"=>undef,"YAML::Old::Dumper::Base"=>undef,"YAML::Old::Error"=>undef,"YAML::Old::Loader"=>undef,"YAML::Old::Loader::Base"=>undef,"YAML::Old::Marshall"=>undef,"YAML::Old::Mo"=>undef,"YAML::Old::Node"=>undef,"YAML::Old::Tag"=>undef,"YAML::Old::Types"=>undef,experimental=>0.016} }; 
#our @PACKED_DISTS = @{["Capture-Tiny","Class-Inspector","Clone-PP","Color-ANSI-Util","Complete-Bash","Complete-Common","Complete-Env","Complete-File","Complete-Fish","Complete-Getopt-Long","Complete-Path","Complete-Tcsh","Complete-Util","Complete-Zsh","Config-IOD-Reader","Data-Check-Structure","Data-Clean","Data-Clean-JSON","Data-Dmp","Data-Dump","Data-ModeMerge","Data-Sah","Data-Sah-Coerce","Data-Sah-Normalize","Data-Sah-Resolve","Data-Sah-Util-Type","File-Flock-Retry","File-RsyBak","File-ShareDir","File-ShareDir-Tarball","File-Slurper","File-Which","File-chdir","Function-Fallback-CoreOrPP","Getopt-Long-Negate-EN","Getopt-Long-Util","HTTP-Tiny","HTTP-Tiny-UNIX","IO-Tty","IPC-Run","IPC-System-Options","JSON","JSON-MaybeXS","JSON-PP","Lingua-EN-Numbers-Ordinate","Lingua-EN-PluralToSingular","Log-ger","Log-ger-App","Log-ger-Layout-Pattern","Log-ger-Output-Composite","Log-ger-Output-File","Log-ger-Output-Screen","Log-ger-Output-Syslog","Mo","Module-Installed-Tiny","Monkey-Patch-Action","Nodejs-Util","Number-Format-BigFloat","PERLANCAR-File-HomeDir","PERLANCAR-Module-List","Perinci-Access-Lite","Perinci-AccessUtil","Perinci-CmdLine-Help","Perinci-CmdLine-Lite","Perinci-CmdLine-Util-Config","Perinci-Object","Perinci-Result-Format-Lite","Perinci-Sub-Complete","Perinci-Sub-ConvertArgs-Argv","Perinci-Sub-ConvertArgs-Array","Perinci-Sub-DepChecker","Perinci-Sub-GetArgs-Argv","Perinci-Sub-GetArgs-Array","Perinci-Sub-Normalize","Perinci-Sub-To-CLIDocData","Perinci-Sub-Util","Proc-ChildError","Progress-Any","Progress-Any-Output-TermProgressBarColor","Regexp-Stringify","Role-Tiny","Sah-Schemas-Rinci","Scalar-Util-Numeric-PP","Sort-BySpec","String-Elide-Parts","String-LineNumber","String-PerlQuote","String-ShellQuote","String-Wildcard-Bash","Sub-Delete","Text-ANSI-Util","Text-Table-ASV","Text-Table-Any","Text-Table-Tiny","Text-sprintfn","Tie-IxHash","Time-Duration","YAML-Old","experimental"]}; 
#
#1;
#
#__END__
#
### File/ShareDir.pm ###
#package File::ShareDir;
#
#
#use 5.005;
#use strict;
#use warnings;
#
#use base ('Exporter');
#use constant IS_MACOS => !!($^O eq 'MacOS');
#use constant IS_WIN32 => !!($^O eq 'MSWin32');
#
#use Carp             ();
#use Exporter         ();
#use File::Spec       ();
#use Class::Inspector ();
#
#our %DIST_SHARE;
#our %MODULE_SHARE;
#
#our @CARP_NOT;
#our @EXPORT_OK = qw{
#  dist_dir
#  dist_file
#  module_dir
#  module_file
#  class_dir
#  class_file
#};
#our %EXPORT_TAGS = (
#    ALL => [@EXPORT_OK],
#);
#our $VERSION = '1.116';
#
#
#
#sub dist_dir
#{
#    my $dist = _DIST(shift);
#    my $dir;
#
#    $dir = _dist_dir_new($dist) || _dist_dir_old($dist);
#
#    return $dir if defined $dir;
#
#    Carp::croak("Failed to find share dir for dist '$dist'");
#}
#
#sub _dist_dir_new
#{
#    my $dist = shift;
#
#    return $DIST_SHARE{$dist} if exists $DIST_SHARE{$dist};
#
#    my $path = File::Spec->catdir('auto', 'share', 'dist', $dist);
#
#    return _search_inc_path($path);
#}
#
#sub _dist_dir_old
#{
#    my $dist = shift;
#
#    my $path = File::Spec->catdir('auto', split(/-/, $dist),);
#
#    return _search_inc_path($path);
#}
#
#
#sub module_dir
#{
#    my $module = _MODULE(shift);
#
#    return $MODULE_SHARE{$module} if exists $MODULE_SHARE{$module};
#
#    return _module_dir_new($module) || _module_dir_old($module);
#}
#
#sub _module_dir_new
#{
#    my $module = shift;
#
#    my $path = File::Spec->catdir('auto', 'share', 'module', _module_subdir($module),);
#
#    return _search_inc_path($path);
#}
#
#sub _module_dir_old
#{
#    my $module = shift;
#    my $short  = Class::Inspector->filename($module);
#    my $long   = Class::Inspector->loaded_filename($module);
#    $short =~ tr{/}{:}   if IS_MACOS;
#    $short =~ tr{\\} {/} if IS_WIN32;
#    $long =~ tr{\\} {/}  if IS_WIN32;
#    substr($short, -3, 3, '');
#    $long =~ m/^(.*)\Q$short\E\.pm\z/s or Carp::croak("Failed to find base dir");
#    my $dir = File::Spec->catdir("$1", 'auto', $short);
#
#    -d $dir or Carp::croak("Directory '$dir': No such directory");
#    -r $dir or Carp::croak("Directory '$dir': No read permission");
#
#    return $dir;
#}
#
#
#sub dist_file
#{
#    my $dist = _DIST(shift);
#    my $file = _FILE(shift);
#
#    my $path = _dist_file_new($dist, $file) || _dist_file_old($dist, $file);
#    $path or Carp::croak("Failed to find shared file '$file' for dist '$dist'");
#
#    -f $path or Carp::croak("File '$path': No such file");
#    -r $path or Carp::croak("File '$path': No read permission");
#
#    return $path;
#}
#
#sub _dist_file_new
#{
#    my $dist = shift;
#    my $file = shift;
#
#    my $dir = _dist_dir_new($dist);
#    return undef unless defined $dir;
#    my $path = File::Spec->catfile($dir, $file);
#
#    return undef unless -e $path;
#
#    return $path;
#}
#
#sub _dist_file_old
#{
#    my $dist = shift;
#    my $file = shift;
#
#    my $dir = _dist_dir_old($dist);
#    return undef unless defined $dir;
#    my $path = File::Spec->catfile($dir, $file);
#
#    return undef unless -e $path;
#
#    return $path;
#}
#
#
#sub module_file
#{
#    my $module = _MODULE(shift);
#    my $file   = _FILE(shift);
#    my $dir    = module_dir($module);
#    my $path   = File::Spec->catfile($dir, $file);
#
#    -e $path or Carp::croak("File '$path' does not exist in module dir");
#    -r $path or Carp::croak("File '$path': No read permission");
#
#    return $path;
#}
#
#
#sub class_file
#{
#    my $module = _MODULE(shift);
#    my $file   = _FILE(shift);
#
#    my @path  = ();
#    my @queue = ($module);
#    my %seen  = ($module => 1);
#    while (my $cl = shift @queue)
#    {
#        push @path, $cl;
#        no strict 'refs';    
#        unshift @queue, grep { !$seen{$_}++ }
#          map { my $s = $_; $s =~ s/^::/main::/; $s =~ s/\'/::/g; $s } (@{"${cl}::ISA"});
#    }
#
#    foreach my $class (@path)
#    {
#        my $dir = eval { module_dir($class); };
#        next if $@;
#        my $path = File::Spec->catfile($dir, $file);
#        -e $path or next;
#        -r $path or Carp::croak("File '$file' cannot be read, no read permissions");
#        return $path;
#    }
#    Carp::croak("File '$file' does not exist in class or parent shared files");
#}
#
#if (eval "use List::MoreUtils 0.428; 1;")
#{
#    List::MoreUtils->import("firstres");
#}
#else
#{
#    eval <<'END_OF_BORROWED_CODE';
#sub firstres (&@)
#{
#    my $test = shift;
#    foreach (@_)
#    {
#        my $testval = $test->();
#        $testval and return $testval;
#    }
#    return undef;
#}
#END_OF_BORROWED_CODE
#}
#
#
#sub _search_inc_path
#{
#    my $path = shift;
#
#    my $dir = firstres(
#        sub {
#            my $d;
#            $d = File::Spec->catdir($_, $path) if defined _STRING($_);
#            defined $d and -d $d ? $d : 0;
#        },
#        @INC
#    ) or return;
#
#    Carp::croak("Found directory '$dir', but no read permissions") unless -r $dir;
#
#    return $dir;
#}
#
#sub _module_subdir
#{
#    my $module = shift;
#    $module =~ s/::/-/g;
#    return $module;
#}
#
#if (eval "use Params::Util 1.07; 1;")
#{
#    Params::Util->import("_CLASS", "_STRING");
#}
#else
#{
#    eval <<'END_OF_BORROWED_CODE';
## Inlined from Params::Util pure perl version
#sub _CLASS ($)
#{
#    return (defined $_[0] and !ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
#}
#
#sub _STRING ($)
#{
#    (defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
#}
#END_OF_BORROWED_CODE
#}
#
#
#sub _DIST    
#{
#    defined _STRING($_[0]) and $_[0] =~ /^[a-z0-9+_-]+$/is and return $_[0];
#    Carp::croak("Not a valid distribution name");
#}
#
#sub _MODULE
#{
#    my $module = _CLASS(shift) or Carp::croak("Not a valid module name");
#    Class::Inspector->loaded($module) and return $module;
#    Carp::croak("Module '$module' is not loaded");
#}
#
#sub _FILE
#{
#    my $file = shift;
#    _STRING($file) or Carp::croak("Did not pass a file name");
#    File::Spec->file_name_is_absolute($file) and Carp::croak("Cannot use absolute file name '$file'");
#    return $file;
#}
#
#1;
#
### File/ShareDir/Tarball.pm ###
#package File::ShareDir::Tarball;
#BEGIN {
#  $File::ShareDir::Tarball::AUTHORITY = 'cpan:YANICK';
#}
#{
#  $File::ShareDir::Tarball::VERSION = '0.2.2';
#}
#
#
#use strict;
#use warnings;
#
#use parent qw/ Exporter /;
#
#use Carp;
#
#use File::ShareDir;
#use Archive::Tar;
#use File::Temp qw/ tempdir /;
#use File::chdir;
#
#our @EXPORT_OK   = qw{
#    dist_dir dist_file
#};
#our %EXPORT_TAGS = (
#    all => [ @EXPORT_OK ],
#);
#
#my $shared_files_tarball = 'shared-files.tar.gz';
#
#my %DIR_CACHE;
#
#sub dist_dir {
#    my $dist = shift;
#
#    return $DIR_CACHE{$dist} if $DIR_CACHE{$dist};
#
#    my $dir = File::ShareDir::dist_dir($dist);
#
#    return $DIR_CACHE{$dist} = $dir 
#        unless -f "$dir/$shared_files_tarball";
#
#    my $archive = Archive::Tar->new;
#    $archive->read("$dir/$shared_files_tarball");
#
#    croak "archive '$shared_files_tarball' contains files with absolute path, aborting"
#        if grep { m#^/# } $archive->list_files;
#
#    my $tmpdir = tempdir( CLEANUP => 1 );
#    local $CWD = $tmpdir;
#
#    $archive->extract;
#
#    return $DIR_CACHE{$dist} = $tmpdir;
#}
#
#sub dist_file {
#    my $dist = File::ShareDir::_DIST(shift);
#    my $file = File::ShareDir::_FILE(shift);
#
#    my $path = dist_dir($dist).'/'.$file;
#
#	return undef unless -e $path;
#
#    croak("Found dist_file '$path', but not a file") 
#        unless -f $path;
#
#    croak("File '$path', no read permissions") 
#        unless -r $path;
#
#	return $path;
#}
#
#
#1;
#
#__END__
#
### File/Slurper.pm ###
#package File::Slurper;
#$File::Slurper::VERSION = '0.009';
#use strict;
#use warnings;
#
#use Carp 'croak';
#use Exporter 5.57 'import';
#
#use Encode qw(:fallbacks);
#use PerlIO::encoding;
#
#our @EXPORT_OK = qw/read_binary read_text read_lines write_binary write_text read_dir/;
#
#sub read_binary {
#	my $filename = shift;
#
#	open my $fh, '<:unix', $filename or croak "Couldn't open $filename: $!";
#	if (my $size = -s $fh) {
#		my $buf;
#		my ($pos, $read) = 0;
#		do {
#			defined($read = read $fh, ${$buf}, $size - $pos, $pos) or croak "Couldn't read $filename: $!";
#			$pos += $read;
#		} while ($read && $pos < $size);
#		return ${$buf};
#	}
#	else {
#		return do { local $/; <$fh> };
#	}
#}
#
#use constant {
#	CRLF_DEFAULT => $^O eq 'MSWin32',
#	HAS_UTF8_STRICT => scalar do { local $@; eval { require PerlIO::utf8_strict } },
#};
#
#sub _text_layers {
#	my ($encoding, $crlf) = @_;
#	$crlf = CRLF_DEFAULT if $crlf && $crlf eq 'auto';
#
#	if ($encoding =~ /^(latin|iso-8859-)1$/i) {
#		return $crlf ? ':unix:crlf' : ':raw';
#	}
#	elsif (HAS_UTF8_STRICT && $encoding =~ /^utf-?8\b/i) {
#		return $crlf ? ':unix:utf8_strict:crlf' : ':unix:utf8_strict';
#	}
#	else {
#		return $crlf ? ":raw:encoding($encoding):crlf" : ":raw:encoding($encoding)";
#	}
#}
#
#sub read_text {
#	my ($filename, $encoding, $crlf) = @_;
#	$encoding ||= 'utf-8';
#	my $layer = _text_layers($encoding, $crlf);
#	return read_binary($filename) if $layer eq ':raw';
#
#	local $PerlIO::encoding::fallback = FB_CROAK;
#	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
#	return do { local $/; <$fh> };
#}
#
#sub write_text {
#	my ($filename, undef, $encoding, $crlf) = @_;
#	$encoding ||= 'utf-8';
#	my $layer = _text_layers($encoding, $crlf);
#
#	local $PerlIO::encoding::fallback = FB_CROAK;
#	open my $fh, ">$layer", $filename or croak "Couldn't open $filename: $!";
#	print $fh $_[1] or croak "Couldn't write to $filename: $!";
#	close $fh or croak "Couldn't write to $filename: $!";
#	return;
#}
#
#sub write_binary {
#	return write_text(@_[0,1], 'latin-1');
#}
#
#sub read_lines {
#	my ($filename, $encoding, $crlf, $skip_chomp) = @_;
#	$encoding ||= 'utf-8';
#	my $layer = _text_layers($encoding, $crlf);
#
#	local $PerlIO::encoding::fallback = FB_CROAK;
#	open my $fh, "<$layer", $filename or croak "Couldn't open $filename: $!";
#	return <$fh> if $skip_chomp;
#	my @buf = <$fh>;
#	close $fh;
#	chomp @buf;
#	return @buf;
#}
#
#sub read_dir {
#	my ($dirname) = @_;
#	opendir my ($dir), $dirname or croak "Could not open $dirname: $!";
#	return grep { not m/ \A \.\.? \z /x } readdir $dir;
#}
#
#1;
#
#
#__END__
#
### File/Which.pm ###
#package File::Which;
#
#use strict;
#use warnings;
#use Exporter   ();
#use File::Spec ();
#
#our $VERSION = '1.21'; 
#
#
#our @ISA       = 'Exporter';
#our @EXPORT    = 'which';
#our @EXPORT_OK = 'where';
#
#use constant IS_VMS => ($^O eq 'VMS');
#use constant IS_MAC => ($^O eq 'MacOS');
#use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
#use constant IS_CYG => ($^O eq 'cygwin');
#
#my @PATHEXT = ('');
#if ( IS_DOS ) {
#  if ( $ENV{PATHEXT} ) {
#    push @PATHEXT, split ';', $ENV{PATHEXT};
#  } else {
#    push @PATHEXT, qw{.com .exe .bat};
#  }
#} elsif ( IS_VMS ) {
#  push @PATHEXT, qw{.exe .com};
#} elsif ( IS_CYG ) {
#  push @PATHEXT, qw{.exe .com};
#}
#
#
#sub which {
#  my ($exec) = @_;
#
#  return undef unless defined $exec;
#  return undef if $exec eq '';
#
#  my $all = wantarray;
#  my @results = ();
#
#  if ( IS_VMS ) {
#    my $symbol = `SHOW SYMBOL $exec`;
#    chomp($symbol);
#    unless ( $? ) {
#      return $symbol unless $all;
#      push @results, $symbol;
#    }
#  }
#  if ( IS_MAC ) {
#    my @aliases = split /\,/, $ENV{Aliases};
#    foreach my $alias ( @aliases ) {
#      if ( lc($alias) eq lc($exec) ) {
#        chomp(my $file = `Alias $alias`);
#        last unless $file;  
#        return $file unless $all;
#        push @results, $file;
#        last;
#      }
#    }
#  }
#
#  return $exec
#          if !IS_VMS and !IS_MAC and !IS_DOS and $exec =~ /\// and -f $exec and -x $exec;
#
#  my @path = File::Spec->path;
#  if ( IS_DOS or IS_VMS or IS_MAC ) {
#    unshift @path, File::Spec->curdir;
#  }
#
#  foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
#    for my $ext ( @PATHEXT ) {
#      my $file = $base.$ext;
#
#      next if -d $file;
#
#      if (
#        -x _
#        or (
#          IS_MAC
#          ||
#          (
#            ( IS_DOS or IS_CYG )
#            and
#            grep {
#              $file =~ /$_\z/i
#            } @PATHEXT[1..$#PATHEXT]
#          )
#          and -e _
#        )
#      ) {
#        return $file unless $all;
#        push @results, $file;
#      }
#    }
#  }
#
#  if ( $all ) {
#    return @results;
#  } else {
#    return undef;
#  }
#}
#
#
#sub where {
#  my @res = which($_[0]);
#  return @res;
#}
#
#1;
#
#__END__
#
### File/chdir.pm ###
#package File::chdir;
#use 5.004;
#use strict;
#use vars qw($VERSION @ISA @EXPORT $CWD @CWD);
#
#our $VERSION = '0.1010';
#
#require Exporter;
#@ISA = qw(Exporter);
#@EXPORT = qw(*CWD);
#
#use Carp;
#use Cwd 3.16;
#use File::Spec::Functions 3.27 qw/canonpath splitpath catpath splitdir catdir/;
#
#tie $CWD, 'File::chdir::SCALAR' or die "Can't tie \$CWD";
#tie @CWD, 'File::chdir::ARRAY'  or die "Can't tie \@CWD";
#
#sub _abs_path {
#    my($cwd) = Cwd::getcwd =~ /(.*)/s;
#    return canonpath($cwd);
#}
#
#sub _split_cwd {
#    my ($vol, $dir) = splitpath(_abs_path, 1);
#    my @dirs = splitdir( $dir );
#    shift @dirs; 
#    return ($vol, @dirs);
#}
#
#sub _catpath {
#    my ($vol, @dirs) = @_;
#    return catpath($vol, catdir(q{}, @dirs), q{});
#}
#
#sub _chdir {
#    my ($new_dir) = $_[0] =~ /(.*)/s;
#
#    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
#    if ( ! CORE::chdir($new_dir) ) {
#        croak "Failed to change directory to '$new_dir': $!";
#    };
#    return 1;
#}
#
#{
#    package File::chdir::SCALAR;
#    use Carp;
#
#    BEGIN {
#        *_abs_path = \&File::chdir::_abs_path;
#        *_chdir = \&File::chdir::_chdir;
#        *_split_cwd = \&File::chdir::_split_cwd;
#        *_catpath = \&File::chdir::_catpath;
#    }
#
#    sub TIESCALAR {
#        bless [], $_[0];
#    }
#
#    sub FETCH {
#        return _abs_path;
#    }
#
#    sub STORE {
#        return unless defined $_[1];
#        _chdir($_[1]);
#    }
#}
#
#
#{
#    package File::chdir::ARRAY;
#    use Carp;
#
#    BEGIN {
#        *_abs_path = \&File::chdir::_abs_path;
#        *_chdir = \&File::chdir::_chdir;
#        *_split_cwd = \&File::chdir::_split_cwd;
#        *_catpath = \&File::chdir::_catpath;
#    }
#
#    sub TIEARRAY {
#        bless {}, $_[0];
#    }
#
#    sub FETCH {
#        my($self, $idx) = @_;
#        my ($vol, @cwd) = _split_cwd;
#        return $cwd[$idx];
#    }
#
#    sub STORE {
#        my($self, $idx, $val) = @_;
#
#        my ($vol, @cwd) = _split_cwd;
#        if( $self->{Cleared} ) {
#            @cwd = ();
#            $self->{Cleared} = 0;
#        }
#
#        $cwd[$idx] = $val;
#        my $dir = _catpath($vol,@cwd);
#
#        _chdir($dir);
#        return $cwd[$idx];
#    }
#
#    sub FETCHSIZE {
#        my ($vol, @cwd) = _split_cwd;
#        return scalar @cwd;
#    }
#    sub STORESIZE {}
#
#    sub PUSH {
#        my($self) = shift;
#
#        my $dir = _catpath(_split_cwd, @_);
#        _chdir($dir);
#        return $self->FETCHSIZE;
#    }
#
#    sub POP {
#        my($self) = shift;
#
#        my ($vol, @cwd) = _split_cwd;
#        my $popped = pop @cwd;
#        my $dir = _catpath($vol,@cwd);
#        _chdir($dir);
#        return $popped;
#    }
#
#    sub SHIFT {
#        my($self) = shift;
#
#        my ($vol, @cwd) = _split_cwd;
#        my $shifted = shift @cwd;
#        my $dir = _catpath($vol,@cwd);
#        _chdir($dir);
#        return $shifted;
#    }
#
#    sub UNSHIFT {
#        my($self) = shift;
#
#        my ($vol, @cwd) = _split_cwd;
#        my $dir = _catpath($vol, @_, @cwd);
#        _chdir($dir);
#        return $self->FETCHSIZE;
#    }
#
#    sub CLEAR  {
#        my($self) = shift;
#        $self->{Cleared} = 1;
#    }
#
#    sub SPLICE {
#        my $self = shift;
#        my $offset = shift || 0;
#        my $len = shift || $self->FETCHSIZE - $offset;
#        my @new_dirs = @_;
#
#        my ($vol, @cwd) = _split_cwd;
#        my @orig_dirs = splice @cwd, $offset, $len, @new_dirs;
#        my $dir = _catpath($vol, @cwd);
#        _chdir($dir);
#        return @orig_dirs;
#    }
#
#    sub EXTEND { }
#    sub EXISTS {
#        my($self, $idx) = @_;
#        return $self->FETCHSIZE >= $idx ? 1 : 0;
#    }
#
#    sub DELETE {
#        my($self, $idx) = @_;
#        croak "Can't delete except at the end of \@CWD"
#            if $idx < $self->FETCHSIZE - 1;
#        local $Carp::CarpLevel = $Carp::CarpLevel + 1;
#        $self->POP;
#    }
#}
#
#1;
#
#__END__
#
### Function/Fallback/CoreOrPP.pm ###
#package Function::Fallback::CoreOrPP;
#
#use 5.010001;
#use strict;
#use warnings;
#
#our $VERSION = '0.08'; 
#
#our $USE_NONCORE_XS_FIRST = 1;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       clone
#                       clone_list
#                       unbless
#                       uniq
#               );
#
#sub clone {
#    my $data = shift;
#    goto FALLBACK unless $USE_NONCORE_XS_FIRST;
#    goto FALLBACK unless eval { require Data::Clone; 1 };
#
#  STANDARD:
#    return Data::Clone::clone($data);
#
#  FALLBACK:
#    require Clone::PP;
#    return Clone::PP::clone($data);
#}
#
#sub clone_list {
#    map { clone($_) } @_;
#}
#
#sub _unbless_fallback {
#    my $ref = shift;
#
#    my $r = ref($ref);
#    return $ref unless $r;
#
#    my ($r2, $r3) = "$ref" =~ /(.+)=(.+?)\(/
#        or return $ref;
#
#    if ($r3 eq 'HASH') {
#        return { %$ref };
#    } elsif ($r3 eq 'ARRAY') {
#        return [ @$ref ];
#    } elsif ($r3 eq 'SCALAR') {
#        return \( my $copy = ${$ref} );
#    } elsif ($r3 eq 'CODE') {
#        return sub { goto &$ref };
#    } else {
#        die "Can't handle $ref";
#    }
#}
#
#sub unbless {
#    my $ref = shift;
#
#    goto FALLBACK unless $USE_NONCORE_XS_FIRST;
#    goto FALLBACK unless eval { require Acme::Damn; 1 };
#
#  STANDARD:
#    return Acme::Damn::damn($ref);
#
#  FALLBACK:
#    return _unbless_fallback($ref);
#}
#
#sub uniq {
#    goto FALLBACK unless $USE_NONCORE_XS_FIRST;
#    goto FALLBACK unless eval { require List::MoreUtils; 1 };
#
#  STANDARD:
#    return List::MoreUtils::uniq(@_);
#
#  FALLBACK:
#    my %h;
#    my @res;
#    for (@_) {
#        push @res, $_ unless $h{$_}++;
#    }
#    return @res;
#}
#
#1;
#
#__END__
#
### Getopt/Long/Negate/EN.pm ###
#package Getopt::Long::Negate::EN;
#
#our $DATE = '2016-03-01'; 
#our $VERSION = '0.05'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(negations_for_option);
#
#sub negations_for_option {
#    my $word = shift;
#
#    if    ($word =~ /\Awith([_-].+)/   ) { return ("without$1") }
#    elsif ($word =~ /\Awithout([_-].+)/) { return ("with$1")    }
#
#    elsif ($word =~ /\Ais([_-].+)/     ) { return ("isnt$1")    }
#    elsif ($word =~ /\Aisnt([_-].+)/   ) { return ("is$1")      }
#    elsif ($word =~ /\Aare([_-].+)/    ) { return ("arent$1")   }
#    elsif ($word =~ /\Aarent([_-].+)/  ) { return ("are$1")     }
#
#    elsif ($word =~ /\Ahas([_-].+)/    ) { return ("hasnt$1")   }
#    elsif ($word =~ /\Ahave([_-].+)/   ) { return ("havent$1")  }
#    elsif ($word =~ /\Ahasnt([_-].+)/  ) { return ("has$1")     }
#    elsif ($word =~ /\Ahavent([_-].+)/ ) { return ("have$1")    }
#
#    elsif ($word =~ /\Acan([_-].+)/    ) { return ("cant$1")    }
#    elsif ($word =~ /\Acant([_-].+)/   ) { return ("can$1")     }
#
#    elsif ($word =~ /\Aenabled([_-].+)/ ) { return ("disabled$1") }
#    elsif ($word =~ /\Adisabled([_-].+)/) { return ("enabled$1")  }
#    elsif ($word =~ /\Aenable([_-].+)/ )  { return ("disable$1")  }
#    elsif ($word =~ /\Adisable([_-].+)/)  { return ("enable$1")   }
#
#    elsif ($word =~ /\Aallowed([_-].+)/ )   { return ("disallowed$1") }
#    elsif ($word =~ /\Adisallowed([_-].+)/) { return ("allowed$1")    }
#    elsif ($word =~ /\Aallow([_-].+)/ )     { return ("disallow$1")   }
#    elsif ($word =~ /\Adisallow([_-].+)/)   { return ("allow$1")      }
#
#    elsif ($word =~ /\Ano[_-](.+)/     ) { return ($1)          }
#
#    else {
#        return ("no-$word", "no$word");
#    }
#}
#
#1;
#
#__END__
#
### Getopt/Long/Util.pm ###
#package Getopt::Long::Util;
#
#our $DATE = '2017-08-10'; 
#our $VERSION = '0.890'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       parse_getopt_long_opt_spec
#                       humanize_getopt_long_opt_spec
#                       detect_getopt_long_script
#                       gen_getopt_long_spec_from_getopt_std_spec
#               );
#
#our %SPEC;
#
#$SPEC{parse_getopt_long_opt_spec} = {
#    v => 1.1,
#    summary => 'Parse a single Getopt::Long option specification',
#    description => <<'_',
#
#Will produce a hash with some keys:
#
#* `is_arg` (if true, then option specification is the special `<>` for argument
#  callback)
#* `opts` (array of option names, in the order specified in the opt spec)
#* `type` (string, type name)
#* `desttype` (either '', or '@' or '%'),
#* `is_neg` (true for `--opt!`)
#* `is_inc` (true for `--opt+`)
#* `min_vals` (int, usually 0 or 1)
#* `max_vals` (int, usually 0 or 1 except for option that requires multiple
#  values)
#
#Will return undef if it can't parse the string.
#
#_
#    args => {
#        optspec => {
#            schema => 'str*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result_naked => 1,
#    result => {
#        schema => 'hash*',
#    },
#    examples => [
#        {
#            args => {optspec => 'help|h|?'},
#            result => {dash_prefix=>'', opts=>['help', 'h', '?']},
#        },
#        {
#            args => {optspec=>'--foo=s'},
#            result => {dash_prefix=>'--', opts=>['foo'], type=>'s', desttype=>''},
#        },
#    ],
#};
#sub parse_getopt_long_opt_spec {
#    my $optspec = shift;
#    return {is_arg=>1, dash_prefix=>'', opts=>[]}
#        if $optspec eq '<>';
#    $optspec =~ qr/\A
#               (?P<dash_prefix>-{0,2})
#               (?P<name>[A-Za-z0-9_][A-Za-z0-9_-]*)
#               (?P<aliases> (?: \| (?:[^:|!+=:-][^:|!+=:]*) )*)?
#               (?:
#                   (?P<is_neg>!) |
#                   (?P<is_inc>\+) |
#                   (?:
#                       =
#                       (?P<type>[siof])
#                       (?P<desttype>|[%@])?
#                       (?:
#                           \{
#                           (?: (?P<min_vals>\d+), )?
#                           (?P<max_vals>\d+)
#                           \}
#                       )?
#                   ) |
#                   (?:
#                       :
#                       (?P<opttype>[siof])
#                       (?P<desttype>|[%@])
#                   ) |
#                   (?:
#                       :
#                       (?P<optnum>\d+)
#                       (?P<desttype>|[%@])
#                   )
#                   (?:
#                       :
#                       (?P<optplus>\+)
#                       (?P<desttype>|[%@])
#                   )
#               )?
#               \z/x
#                   or return undef;
#    my %res = %+;
#
#    if ($res{aliases}) {
#        my @als;
#        for my $al (split /\|/, $res{aliases}) {
#            next unless length $al;
#            next if $al eq $res{name};
#            next if grep {$_ eq $al} @als;
#            push @als, $al;
#        }
#        $res{opts} = [$res{name}, @als];
#    } else {
#        $res{opts} = [$res{name}];
#    }
#    delete $res{name};
#    delete $res{aliases};
#
#    $res{is_neg} = 1 if $res{is_neg};
#    $res{is_inc} = 1 if $res{is_inc};
#
#    \%res;
#}
#
#$SPEC{humanize_getopt_long_opt_spec} = {
#    v => 1.1,
#    description => <<'_',
#
#Convert <pm:Getopt::Long> option specification like `help|h|?` or `--foo=s` or
#`debug!` into, respectively, `--help, -h, -?` or `--foo=s` or `--(no)debug`.
#Will die if can't parse the string. The output is suitable for including in
#help/usage text.
#
#_
#    args => {
#        optspec => {
#            schema => 'str*',
#            req => 1,
#            pos => 0,
#        },
#    },
#    args_as => 'array',
#    result_naked => 1,
#    result => {
#        schema => 'str*',
#    },
#};
#sub humanize_getopt_long_opt_spec {
#    my $optspec = shift;
#
#    my $parse = parse_getopt_long_opt_spec($optspec)
#        or die "Can't parse opt spec $optspec";
#
#    return "argument" if $parse->{is_arg};
#
#    my $res = '';
#    my $i = 0;
#    for (@{ $parse->{opts} }) {
#        $i++;
#        $res .= ", " if length($res);
#        if ($parse->{is_neg} && length($_) > 1) {
#            $res .= "--(no)$_";
#        } else {
#            if (length($_) > 1) {
#                $res .= "--$_";
#            } else {
#                $res .= "-$_";
#            }
#            $res .= "=$parse->{type}" if $i==1 && $parse->{type};
#        }
#    }
#    $res;
#}
#
#$SPEC{detect_getopt_long_script} = {
#    v => 1.1,
#    summary => 'Detect whether a file is a Getopt::Long-based CLI script',
#    description => <<'_',
#
#The criteria are:
#
#* the file must exist and readable;
#
#* (optional, if `include_noexec` is false) file must have its executable mode
#  bit set;
#
#* content must start with a shebang C<#!>;
#
#* either: must be perl script (shebang line contains 'perl') and must contain
#  something like `use Getopt::Long`;
#
#_
#    args => {
#        filename => {
#            summary => 'Path to file to be checked',
#            schema => 'str*',
#            pos => 0,
#            cmdline_aliases => {f=>{}},
#        },
#        string => {
#            summary => 'String to be checked',
#            schema => 'buf*',
#        },
#        include_noexec => {
#            summary => 'Include scripts that do not have +x mode bit set',
#            schema  => 'bool*',
#            default => 1,
#        },
#    },
#    args_rels => {
#        'req_one' => ['filename', 'string'],
#    },
#};
#sub detect_getopt_long_script {
#    my %args = @_;
#
#    (defined($args{filename}) xor defined($args{string}))
#        or return [400, "Please specify either filename or string"];
#    my $include_noexec  = $args{include_noexec}  // 1;
#
#    my $yesno = 0;
#    my $reason = "";
#    my %extrameta;
#
#    my $str = $args{string};
#  DETECT:
#    {
#        if (defined $args{filename}) {
#            my $fn = $args{filename};
#            unless (-f $fn) {
#                $reason = "'$fn' is not a file";
#                last;
#            };
#            if (!$include_noexec && !(-x _)) {
#                $reason = "'$fn' is not an executable";
#                last;
#            }
#            my $fh;
#            unless (open $fh, "<", $fn) {
#                $reason = "Can't be read";
#                last;
#            }
#            read $fh, $str, 2;
#            unless ($str eq '#!') {
#                $reason = "Does not start with a shebang (#!) sequence";
#                last;
#            }
#            my $shebang = <$fh>;
#            unless ($shebang =~ /perl/) {
#                $reason = "Does not have 'perl' in the shebang line";
#                last;
#            }
#            seek $fh, 0, 0;
#            {
#                local $/;
#                $str = <$fh>;
#            }
#            close $fh;
#        }
#        unless ($str =~ /\A#!/) {
#            $reason = "Does not start with a shebang (#!) sequence";
#            last;
#        }
#        unless ($str =~ /\A#!.*perl/) {
#            $reason = "Does not have 'perl' in the shebang line";
#            last;
#        }
#
#
#
#        for (split /^/, $str) {
#            if (/^\s*(use|require)\s+(Getopt::Long(?:::Complete|::Less|::EvenLess)?)(\s|;|$)/) {
#                $yesno = 1;
#                $extrameta{'func.module'} = $2;
#                last DETECT;
#            }
#        }
#
#        $reason = "Can't find any statement requiring Getopt::Long(?::Complete|::Less|::EvenLess)? module";
#    } 
#
#    [200, "OK", $yesno, {"func.reason"=>$reason, %extrameta}];
#}
#
#$SPEC{gen_getopt_long_spec_from_getopt_std_spec} = {
#    v => 1.1,
#    summary => 'Generate Getopt::Long spec from Getopt::Std spec',
#    args => {
#        spec => {
#            summary => 'Getopt::Std spec string',
#            schema => 'str*',
#            req => 1,
#            pos => 0,
#        },
#        is_getopt => {
#            summary => 'Whether to assume spec is for getopt() or getopts()',
#            description => <<'_',
#
#By default spec is assumed to be for getopts() instead of getopt(). This means
#that for a spec like `abc:`, `a` and `b` don't take argument while `c` does. But
#if `is_getopt` is true, the meaning of `:` is reversed: `a` and `b` take
#arguments while `c` doesn't.
#
#_
#            schema => 'bool',
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'hash*',
#    },
#};
#sub gen_getopt_long_spec_from_getopt_std_spec {
#    my %args = @_;
#
#    my $is_getopt = $args{is_getopt};
#    my $spec = {};
#
#    while ($args{spec} =~ /(.)(:?)/g) {
#        $spec->{$1 . ($is_getopt ? ($2 ? "" : "=s") : ($2 ? "=s" : ""))} =
#            sub {};
#    }
#
#    $spec;
#}
#
#1;
#
#__END__
#
### HTTP/Tiny.pm ###
#package HTTP::Tiny;
#use strict;
#use warnings;
#
#our $VERSION = '0.070';
#
#sub _croak { require Carp; Carp::croak(@_) }
#
#
#my @attributes;
#BEGIN {
#    @attributes = qw(
#        cookie_jar default_headers http_proxy https_proxy keep_alive
#        local_address max_redirect max_size proxy no_proxy
#        SSL_options verify_SSL
#    );
#    my %persist_ok = map {; $_ => 1 } qw(
#        cookie_jar default_headers max_redirect max_size
#    );
#    no strict 'refs';
#    no warnings 'uninitialized';
#    for my $accessor ( @attributes ) {
#        *{$accessor} = sub {
#            @_ > 1
#                ? do {
#                    delete $_[0]->{handle} if !$persist_ok{$accessor} && $_[1] ne $_[0]->{$accessor};
#                    $_[0]->{$accessor} = $_[1]
#                }
#                : $_[0]->{$accessor};
#        };
#    }
#}
#
#sub agent {
#    my($self, $agent) = @_;
#    if( @_ > 1 ){
#        $self->{agent} =
#            (defined $agent && $agent =~ / $/) ? $agent . $self->_agent : $agent;
#    }
#    return $self->{agent};
#}
#
#sub timeout {
#    my ($self, $timeout) = @_;
#    if ( @_ > 1 ) {
#        $self->{timeout} = $timeout;
#        if ($self->{handle}) {
#            $self->{handle}->timeout($timeout);
#        }
#    }
#    return $self->{timeout};
#}
#
#sub new {
#    my($class, %args) = @_;
#
#    my $self = {
#        max_redirect => 5,
#        timeout      => defined $args{timeout} ? $args{timeout} : 60,
#        keep_alive   => 1,
#        verify_SSL   => $args{verify_SSL} || $args{verify_ssl} || 0, 
#        no_proxy     => $ENV{no_proxy},
#    };
#
#    bless $self, $class;
#
#    $class->_validate_cookie_jar( $args{cookie_jar} ) if $args{cookie_jar};
#
#    for my $key ( @attributes ) {
#        $self->{$key} = $args{$key} if exists $args{$key}
#    }
#
#    $self->agent( exists $args{agent} ? $args{agent} : $class->_agent );
#
#    $self->_set_proxies;
#
#    return $self;
#}
#
#sub _set_proxies {
#    my ($self) = @_;
#
#
#    if (! exists $self->{proxy} ) {
#        $self->{proxy} = $ENV{all_proxy} || $ENV{ALL_PROXY};
#    }
#
#    if ( defined $self->{proxy} ) {
#        $self->_split_proxy( 'generic proxy' => $self->{proxy} ); 
#    }
#    else {
#        delete $self->{proxy};
#    }
#
#    if (! exists $self->{http_proxy} ) {
#        local $ENV{HTTP_PROXY} if $ENV{REQUEST_METHOD};
#        $self->{http_proxy} = $ENV{http_proxy} || $ENV{HTTP_PROXY} || $self->{proxy};
#    }
#
#    if ( defined $self->{http_proxy} ) {
#        $self->_split_proxy( http_proxy => $self->{http_proxy} ); 
#        $self->{_has_proxy}{http} = 1;
#    }
#    else {
#        delete $self->{http_proxy};
#    }
#
#    if (! exists $self->{https_proxy} ) {
#        $self->{https_proxy} = $ENV{https_proxy} || $ENV{HTTPS_PROXY} || $self->{proxy};
#    }
#
#    if ( $self->{https_proxy} ) {
#        $self->_split_proxy( https_proxy => $self->{https_proxy} ); 
#        $self->{_has_proxy}{https} = 1;
#    }
#    else {
#        delete $self->{https_proxy};
#    }
#
#    unless ( ref $self->{no_proxy} eq 'ARRAY' ) {
#        $self->{no_proxy} =
#            (defined $self->{no_proxy}) ? [ split /\s*,\s*/, $self->{no_proxy} ] : [];
#    }
#
#    return;
#}
#
#
#for my $sub_name ( qw/get head put post delete/ ) {
#    my $req_method = uc $sub_name;
#    no strict 'refs';
#    eval <<"HERE"; 
#    sub $sub_name {
#        my (\$self, \$url, \$args) = \@_;
#        \@_ == 2 || (\@_ == 3 && ref \$args eq 'HASH')
#        or _croak(q/Usage: \$http->$sub_name(URL, [HASHREF])/ . "\n");
#        return \$self->request('$req_method', \$url, \$args || {});
#    }
#HERE
#}
#
#
#sub post_form {
#    my ($self, $url, $data, $args) = @_;
#    (@_ == 3 || @_ == 4 && ref $args eq 'HASH')
#        or _croak(q/Usage: $http->post_form(URL, DATAREF, [HASHREF])/ . "\n");
#
#    my $headers = {};
#    while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
#        $headers->{lc $key} = $value;
#    }
#    delete $args->{headers};
#
#    return $self->request('POST', $url, {
#            %$args,
#            content => $self->www_form_urlencode($data),
#            headers => {
#                %$headers,
#                'content-type' => 'application/x-www-form-urlencoded'
#            },
#        }
#    );
#}
#
#
#sub mirror {
#    my ($self, $url, $file, $args) = @_;
#    @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
#      or _croak(q/Usage: $http->mirror(URL, FILE, [HASHREF])/ . "\n");
#
#    if ( exists $args->{headers} ) {
#        my $headers = {};
#        while ( my ($key, $value) = each %{$args->{headers} || {}} ) {
#            $headers->{lc $key} = $value;
#        }
#        $args->{headers} = $headers;
#    }
#
#    if ( -e $file and my $mtime = (stat($file))[9] ) {
#        $args->{headers}{'if-modified-since'} ||= $self->_http_date($mtime);
#    }
#    my $tempfile = $file . int(rand(2**31));
#
#    require Fcntl;
#    sysopen my $fh, $tempfile, Fcntl::O_CREAT()|Fcntl::O_EXCL()|Fcntl::O_WRONLY()
#       or _croak(qq/Error: Could not create temporary file $tempfile for downloading: $!\n/);
#    binmode $fh;
#    $args->{data_callback} = sub { print {$fh} $_[0] };
#    my $response = $self->request('GET', $url, $args);
#    close $fh
#        or _croak(qq/Error: Caught error closing temporary file $tempfile: $!\n/);
#
#    if ( $response->{success} ) {
#        rename $tempfile, $file
#            or _croak(qq/Error replacing $file with $tempfile: $!\n/);
#        my $lm = $response->{headers}{'last-modified'};
#        if ( $lm and my $mtime = $self->_parse_http_date($lm) ) {
#            utime $mtime, $mtime, $file;
#        }
#    }
#    $response->{success} ||= $response->{status} eq '304';
#    unlink $tempfile;
#    return $response;
#}
#
#
#my %idempotent = map { $_ => 1 } qw/GET HEAD PUT DELETE OPTIONS TRACE/;
#
#sub request {
#    my ($self, $method, $url, $args) = @_;
#    @_ == 3 || (@_ == 4 && ref $args eq 'HASH')
#      or _croak(q/Usage: $http->request(METHOD, URL, [HASHREF])/ . "\n");
#    $args ||= {}; 
#
#    my $response;
#    for ( 0 .. 1 ) {
#        $response = eval { $self->_request($method, $url, $args) };
#        last unless $@ && $idempotent{$method}
#            && $@ =~ m{^(?:Socket closed|Unexpected end)};
#    }
#
#    if (my $e = $@) {
#        if ( ref $e eq 'HASH' && exists $e->{status} ) {
#            $e->{redirects} = delete $args->{_redirects} if @{ $args->{_redirects} || []};
#            return $e;
#        }
#
#        $e = "$e";
#        $response = {
#            url     => $url,
#            success => q{},
#            status  => 599,
#            reason  => 'Internal Exception',
#            content => $e,
#            headers => {
#                'content-type'   => 'text/plain',
#                'content-length' => length $e,
#            },
#            ( @{$args->{_redirects} || []} ? (redirects => delete $args->{_redirects}) : () ),
#        };
#    }
#    return $response;
#}
#
#
#sub www_form_urlencode {
#    my ($self, $data) = @_;
#    (@_ == 2 && ref $data)
#        or _croak(q/Usage: $http->www_form_urlencode(DATAREF)/ . "\n");
#    (ref $data eq 'HASH' || ref $data eq 'ARRAY')
#        or _croak("form data must be a hash or array reference\n");
#
#    my @params = ref $data eq 'HASH' ? %$data : @$data;
#    @params % 2 == 0
#        or _croak("form data reference must have an even number of terms\n");
#
#    my @terms;
#    while( @params ) {
#        my ($key, $value) = splice(@params, 0, 2);
#        if ( ref $value eq 'ARRAY' ) {
#            unshift @params, map { $key => $_ } @$value;
#        }
#        else {
#            push @terms, join("=", map { $self->_uri_escape($_) } $key, $value);
#        }
#    }
#
#    return join("&", (ref $data eq 'ARRAY') ? (@terms) : (sort @terms) );
#}
#
#
#sub can_ssl {
#    my ($self) = @_;
#
#    my($ok, $reason) = (1, '');
#
#    local @INC = @INC;
#    pop @INC if $INC[-1] eq '.';
#    unless (eval {require IO::Socket::SSL; IO::Socket::SSL->VERSION(1.42)}) {
#        $ok = 0;
#        $reason .= qq/IO::Socket::SSL 1.42 must be installed for https support\n/;
#    }
#
#    unless (eval {require Net::SSLeay; Net::SSLeay->VERSION(1.49)}) {
#        $ok = 0;
#        $reason .= qq/Net::SSLeay 1.49 must be installed for https support\n/;
#    }
#
#    if ( ref($self) && ( $self->{verify_SSL} || $self->{SSL_options}{SSL_verify_mode} ) ) {
#        my $handle = HTTP::Tiny::Handle->new(
#            SSL_options => $self->{SSL_options},
#            verify_SSL  => $self->{verify_SSL},
#        );
#        unless ( eval { $handle->_find_CA_file; 1 } ) {
#            $ok = 0;
#            $reason .= "$@";
#        }
#    }
#
#    wantarray ? ($ok, $reason) : $ok;
#}
#
#
#sub connected {
#    my ($self) = @_;
#
#    if ($self->{handle} && $self->{handle}{fh}) {
#        my $socket = $self->{handle}{fh};
#
#        if ($socket->connected) {
#            return wantarray
#                ? ($socket->peerhost, $socket->peerport)
#                : join(':', $socket->peerhost, $socket->peerport);
#        }
#    }
#    return;
#}
#
#
#my %DefaultPort = (
#    http => 80,
#    https => 443,
#);
#
#sub _agent {
#    my $class = ref($_[0]) || $_[0];
#    (my $default_agent = $class) =~ s{::}{-}g;
#    return $default_agent . "/" . $class->VERSION;
#}
#
#sub _request {
#    my ($self, $method, $url, $args) = @_;
#
#    my ($scheme, $host, $port, $path_query, $auth) = $self->_split_url($url);
#
#    my $request = {
#        method    => $method,
#        scheme    => $scheme,
#        host      => $host,
#        port      => $port,
#        host_port => ($port == $DefaultPort{$scheme} ? $host : "$host:$port"),
#        uri       => $path_query,
#        headers   => {},
#    };
#
#    my $peer = $args->{peer} || $host;
#
#    my $handle = delete $self->{handle};
#    if ( $handle ) {
#        unless ( $handle->can_reuse( $scheme, $host, $port, $peer ) ) {
#            $handle->close;
#            undef $handle;
#        }
#    }
#    $handle ||= $self->_open_handle( $request, $scheme, $host, $port, $peer );
#
#    $self->_prepare_headers_and_cb($request, $args, $url, $auth);
#    $handle->write_request($request);
#
#    my $response;
#    do { $response = $handle->read_response_header }
#        until (substr($response->{status},0,1) ne '1');
#
#    $self->_update_cookie_jar( $url, $response ) if $self->{cookie_jar};
#    my @redir_args = $self->_maybe_redirect($request, $response, $args);
#
#    my $known_message_length;
#    if ($method eq 'HEAD' || $response->{status} =~ /^[23]04/) {
#        $known_message_length = 1;
#    }
#    else {
#        my $cb_args = @redir_args ? +{} : $args;
#        my $data_cb = $self->_prepare_data_cb($response, $cb_args);
#        $known_message_length = $handle->read_body($data_cb, $response);
#    }
#
#    if ( $self->{keep_alive}
#        && $known_message_length
#        && $response->{protocol} eq 'HTTP/1.1'
#        && ($response->{headers}{connection} || '') ne 'close'
#    ) {
#        $self->{handle} = $handle;
#    }
#    else {
#        $handle->close;
#    }
#
#    $response->{success} = substr( $response->{status}, 0, 1 ) eq '2';
#    $response->{url} = $url;
#
#    if (@redir_args) {
#        push @{$args->{_redirects}}, $response;
#        return $self->_request(@redir_args, $args);
#    }
#
#    $response->{redirects} = delete $args->{_redirects}
#      if @{$args->{_redirects}};
#    return $response;
#}
#
#sub _open_handle {
#    my ($self, $request, $scheme, $host, $port, $peer) = @_;
#
#    my $handle  = HTTP::Tiny::Handle->new(
#        timeout         => $self->{timeout},
#        SSL_options     => $self->{SSL_options},
#        verify_SSL      => $self->{verify_SSL},
#        local_address   => $self->{local_address},
#        keep_alive      => $self->{keep_alive}
#    );
#
#    if ($self->{_has_proxy}{$scheme} && ! grep { $host =~ /\Q$_\E$/ } @{$self->{no_proxy}}) {
#        return $self->_proxy_connect( $request, $handle );
#    }
#    else {
#        return $handle->connect($scheme, $host, $port, $peer);
#    }
#}
#
#sub _proxy_connect {
#    my ($self, $request, $handle) = @_;
#
#    my @proxy_vars;
#    if ( $request->{scheme} eq 'https' ) {
#        _croak(qq{No https_proxy defined}) unless $self->{https_proxy};
#        @proxy_vars = $self->_split_proxy( https_proxy => $self->{https_proxy} );
#        if ( $proxy_vars[0] eq 'https' ) {
#            _croak(qq{Can't proxy https over https: $request->{uri} via $self->{https_proxy}});
#        }
#    }
#    else {
#        _croak(qq{No http_proxy defined}) unless $self->{http_proxy};
#        @proxy_vars = $self->_split_proxy( http_proxy => $self->{http_proxy} );
#    }
#
#    my ($p_scheme, $p_host, $p_port, $p_auth) = @proxy_vars;
#
#    if ( length $p_auth && ! defined $request->{headers}{'proxy-authorization'} ) {
#        $self->_add_basic_auth_header( $request, 'proxy-authorization' => $p_auth );
#    }
#
#    $handle->connect($p_scheme, $p_host, $p_port, $p_host);
#
#    if ($request->{scheme} eq 'https') {
#        $self->_create_proxy_tunnel( $request, $handle );
#    }
#    else {
#        $request->{uri} = "$request->{scheme}://$request->{host_port}$request->{uri}";
#    }
#
#    return $handle;
#}
#
#sub _split_proxy {
#    my ($self, $type, $proxy) = @_;
#
#    my ($scheme, $host, $port, $path_query, $auth) = eval { $self->_split_url($proxy) };
#
#    unless(
#        defined($scheme) && length($scheme) && length($host) && length($port)
#        && $path_query eq '/'
#    ) {
#        _croak(qq{$type URL must be in format http[s]://[auth@]<host>:<port>/\n});
#    }
#
#    return ($scheme, $host, $port, $auth);
#}
#
#sub _create_proxy_tunnel {
#    my ($self, $request, $handle) = @_;
#
#    $handle->_assert_ssl;
#
#    my $agent = exists($request->{headers}{'user-agent'})
#        ? $request->{headers}{'user-agent'} : $self->{agent};
#
#    my $connect_request = {
#        method    => 'CONNECT',
#        uri       => "$request->{host}:$request->{port}",
#        headers   => {
#            host => "$request->{host}:$request->{port}",
#            'user-agent' => $agent,
#        }
#    };
#
#    if ( $request->{headers}{'proxy-authorization'} ) {
#        $connect_request->{headers}{'proxy-authorization'} =
#            delete $request->{headers}{'proxy-authorization'};
#    }
#
#    $handle->write_request($connect_request);
#    my $response;
#    do { $response = $handle->read_response_header }
#        until (substr($response->{status},0,1) ne '1');
#
#    unless (substr($response->{status},0,1) eq '2') {
#        die $response;
#    }
#
#    $handle->start_ssl( $request->{host} );
#
#    return;
#}
#
#sub _prepare_headers_and_cb {
#    my ($self, $request, $args, $url, $auth) = @_;
#
#    for ($self->{default_headers}, $args->{headers}) {
#        next unless defined;
#        while (my ($k, $v) = each %$_) {
#            $request->{headers}{lc $k} = $v;
#            $request->{header_case}{lc $k} = $k;
#        }
#    }
#
#    if (exists $request->{headers}{'host'}) {
#        die(qq/The 'Host' header must not be provided as header option\n/);
#    }
#
#    $request->{headers}{'host'}         = $request->{host_port};
#    $request->{headers}{'user-agent'} ||= $self->{agent};
#    $request->{headers}{'connection'}   = "close"
#        unless $self->{keep_alive};
#
#    if ( defined $args->{content} ) {
#        if (ref $args->{content} eq 'CODE') {
#            $request->{headers}{'content-type'} ||= "application/octet-stream";
#            $request->{headers}{'transfer-encoding'} = 'chunked'
#              unless $request->{headers}{'content-length'}
#                  || $request->{headers}{'transfer-encoding'};
#            $request->{cb} = $args->{content};
#        }
#        elsif ( length $args->{content} ) {
#            my $content = $args->{content};
#            if ( $] ge '5.008' ) {
#                utf8::downgrade($content, 1)
#                    or die(qq/Wide character in request message body\n/);
#            }
#            $request->{headers}{'content-type'} ||= "application/octet-stream";
#            $request->{headers}{'content-length'} = length $content
#              unless $request->{headers}{'content-length'}
#                  || $request->{headers}{'transfer-encoding'};
#            $request->{cb} = sub { substr $content, 0, length $content, '' };
#        }
#        $request->{trailer_cb} = $args->{trailer_callback}
#            if ref $args->{trailer_callback} eq 'CODE';
#    }
#
#    if ( $self->{cookie_jar} ) {
#        my $cookies = $self->cookie_jar->cookie_header( $url );
#        $request->{headers}{cookie} = $cookies if length $cookies;
#    }
#
#    if ( length $auth && ! defined $request->{headers}{authorization} ) {
#        $self->_add_basic_auth_header( $request, 'authorization' => $auth );
#    }
#
#    return;
#}
#
#sub _add_basic_auth_header {
#    my ($self, $request, $header, $auth) = @_;
#    require MIME::Base64;
#    $request->{headers}{$header} =
#        "Basic " . MIME::Base64::encode_base64($auth, "");
#    return;
#}
#
#sub _prepare_data_cb {
#    my ($self, $response, $args) = @_;
#    my $data_cb = $args->{data_callback};
#    $response->{content} = '';
#
#    if (!$data_cb || $response->{status} !~ /^2/) {
#        if (defined $self->{max_size}) {
#            $data_cb = sub {
#                $_[1]->{content} .= $_[0];
#                die(qq/Size of response body exceeds the maximum allowed of $self->{max_size}\n/)
#                  if length $_[1]->{content} > $self->{max_size};
#            };
#        }
#        else {
#            $data_cb = sub { $_[1]->{content} .= $_[0] };
#        }
#    }
#    return $data_cb;
#}
#
#sub _update_cookie_jar {
#    my ($self, $url, $response) = @_;
#
#    my $cookies = $response->{headers}->{'set-cookie'};
#    return unless defined $cookies;
#
#    my @cookies = ref $cookies ? @$cookies : $cookies;
#
#    $self->cookie_jar->add( $url, $_ ) for @cookies;
#
#    return;
#}
#
#sub _validate_cookie_jar {
#    my ($class, $jar) = @_;
#
#    for my $method ( qw/add cookie_header/ ) {
#        _croak(qq/Cookie jar must provide the '$method' method\n/)
#            unless ref($jar) && ref($jar)->can($method);
#    }
#
#    return;
#}
#
#sub _maybe_redirect {
#    my ($self, $request, $response, $args) = @_;
#    my $headers = $response->{headers};
#    my ($status, $method) = ($response->{status}, $request->{method});
#    $args->{_redirects} ||= [];
#
#    if (($status eq '303' or ($status =~ /^30[1278]/ && $method =~ /^GET|HEAD$/))
#        and $headers->{location}
#        and @{$args->{_redirects}} < $self->{max_redirect}
#    ) {
#        my $location = ($headers->{location} =~ /^\//)
#            ? "$request->{scheme}://$request->{host_port}$headers->{location}"
#            : $headers->{location} ;
#        return (($status eq '303' ? 'GET' : $method), $location);
#    }
#    return;
#}
#
#sub _split_url {
#    my $url = pop;
#
#    my ($scheme, $host, $path_query) = $url =~ m<\A([^:/?#]+)://([^/?#]*)([^#]*)>
#      or die(qq/Cannot parse URL: '$url'\n/);
#
#    $scheme     = lc $scheme;
#    $path_query = "/$path_query" unless $path_query =~ m<\A/>;
#
#    my $auth = '';
#    if ( (my $i = index $host, '@') != -1 ) {
#        $auth = substr $host, 0, $i, ''; 
#        substr $host, 0, 1, '';          
#
#        $auth =~ s/%([0-9A-Fa-f]{2})/chr(hex($1))/eg;
#    }
#    my $port = $host =~ s/:(\d*)\z// && length $1 ? $1
#             : $scheme eq 'http'                  ? 80
#             : $scheme eq 'https'                 ? 443
#             : undef;
#
#    return ($scheme, (length $host ? lc $host : "localhost") , $port, $path_query, $auth);
#}
#
#my $DoW = "Sun|Mon|Tue|Wed|Thu|Fri|Sat";
#my $MoY = "Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec";
#sub _http_date {
#    my ($sec, $min, $hour, $mday, $mon, $year, $wday) = gmtime($_[1]);
#    return sprintf("%s, %02d %s %04d %02d:%02d:%02d GMT",
#        substr($DoW,$wday*4,3),
#        $mday, substr($MoY,$mon*4,3), $year+1900,
#        $hour, $min, $sec
#    );
#}
#
#sub _parse_http_date {
#    my ($self, $str) = @_;
#    require Time::Local;
#    my @tl_parts;
#    if ($str =~ /^[SMTWF][a-z]+, +(\d{1,2}) ($MoY) +(\d\d\d\d) +(\d\d):(\d\d):(\d\d) +GMT$/) {
#        @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
#    }
#    elsif ($str =~ /^[SMTWF][a-z]+, +(\d\d)-($MoY)-(\d{2,4}) +(\d\d):(\d\d):(\d\d) +GMT$/ ) {
#        @tl_parts = ($6, $5, $4, $1, (index($MoY,$2)/4), $3);
#    }
#    elsif ($str =~ /^[SMTWF][a-z]+ +($MoY) +(\d{1,2}) +(\d\d):(\d\d):(\d\d) +(?:[^0-9]+ +)?(\d\d\d\d)$/ ) {
#        @tl_parts = ($5, $4, $3, $2, (index($MoY,$1)/4), $6);
#    }
#    return eval {
#        my $t = @tl_parts ? Time::Local::timegm(@tl_parts) : -1;
#        $t < 0 ? undef : $t;
#    };
#}
#
#my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
#$escapes{' '}="+";
#my $unsafe_char = qr/[^A-Za-z0-9\-\._~]/;
#
#sub _uri_escape {
#    my ($self, $str) = @_;
#    if ( $] ge '5.008' ) {
#        utf8::encode($str);
#    }
#    else {
#        $str = pack("U*", unpack("C*", $str)) 
#            if ( length $str == do { use bytes; length $str } );
#        $str = pack("C*", unpack("C*", $str)); 
#    }
#    $str =~ s/($unsafe_char)/$escapes{$1}/ge;
#    return $str;
#}
#
#package
#    HTTP::Tiny::Handle; 
#use strict;
#use warnings;
#
#use Errno      qw[EINTR EPIPE];
#use IO::Socket qw[SOCK_STREAM];
#use Socket     qw[SOL_SOCKET SO_KEEPALIVE];
#
#my $SOCKET_CLASS =
#    $ENV{PERL_HTTP_TINY_IPV4_ONLY} ? 'IO::Socket::INET' :
#    eval { require IO::Socket::IP; IO::Socket::IP->VERSION(0.25) } ? 'IO::Socket::IP' :
#    'IO::Socket::INET';
#
#sub BUFSIZE () { 32768 } 
#
#my $Printable = sub {
#    local $_ = shift;
#    s/\r/\\r/g;
#    s/\n/\\n/g;
#    s/\t/\\t/g;
#    s/([^\x20-\x7E])/sprintf('\\x%.2X', ord($1))/ge;
#    $_;
#};
#
#my $Token = qr/[\x21\x23-\x27\x2A\x2B\x2D\x2E\x30-\x39\x41-\x5A\x5E-\x7A\x7C\x7E]/;
#my $Field_Content = qr/[[:print:]]+ (?: [\x20\x09]+ [[:print:]]+ )*/x;
#
#sub new {
#    my ($class, %args) = @_;
#    return bless {
#        rbuf             => '',
#        timeout          => 60,
#        max_line_size    => 16384,
#        max_header_lines => 64,
#        verify_SSL       => 0,
#        SSL_options      => {},
#        %args
#    }, $class;
#}
#
#sub timeout {
#    my ($self, $timeout) = @_;
#    if ( @_ > 1 ) {
#        $self->{timeout} = $timeout;
#        if ( $self->{fh} && $self->{fh}->can('timeout') ) {
#            $self->{fh}->timeout($timeout);
#        }
#    }
#    return $self->{timeout};
#}
#
#sub connect {
#    @_ == 5 || die(q/Usage: $handle->connect(scheme, host, port, peer)/ . "\n");
#    my ($self, $scheme, $host, $port, $peer) = @_;
#
#    if ( $scheme eq 'https' ) {
#        $self->_assert_ssl;
#    }
#    elsif ( $scheme ne 'http' ) {
#      die(qq/Unsupported URL scheme '$scheme'\n/);
#    }
#    $self->{fh} = $SOCKET_CLASS->new(
#        PeerHost  => $peer,
#        PeerPort  => $port,
#        $self->{local_address} ?
#            ( LocalAddr => $self->{local_address} ) : (),
#        Proto     => 'tcp',
#        Type      => SOCK_STREAM,
#        Timeout   => $self->{timeout},
#    ) or die(qq/Could not connect to '$host:$port': $@\n/);
#
#    binmode($self->{fh})
#      or die(qq/Could not binmode() socket: '$!'\n/);
#
#    if ( $self->{keep_alive} ) {
#        unless ( defined( $self->{fh}->setsockopt( SOL_SOCKET, SO_KEEPALIVE, 1 ) ) ) {
#            CORE::close($self->{fh});
#            die(qq/Could not set SO_KEEPALIVE on socket: '$!'\n/);
#        }
#    }
#
#    $self->start_ssl($host) if $scheme eq 'https';
#
#    $self->{scheme} = $scheme;
#    $self->{host} = $host;
#    $self->{peer} = $peer;
#    $self->{port} = $port;
#    $self->{pid} = $$;
#    $self->{tid} = _get_tid();
#
#    return $self;
#}
#
#sub start_ssl {
#    my ($self, $host) = @_;
#
#    if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
#        unless ( $self->{fh}->stop_SSL ) {
#            my $ssl_err = IO::Socket::SSL->errstr;
#            die(qq/Error halting prior SSL connection: $ssl_err/);
#        }
#    }
#
#    my $ssl_args = $self->_ssl_args($host);
#    IO::Socket::SSL->start_SSL(
#        $self->{fh},
#        %$ssl_args,
#        SSL_create_ctx_callback => sub {
#            my $ctx = shift;
#            Net::SSLeay::CTX_set_mode($ctx, Net::SSLeay::MODE_AUTO_RETRY());
#        },
#    );
#
#    unless ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
#        my $ssl_err = IO::Socket::SSL->errstr;
#        die(qq/SSL connection failed for $host: $ssl_err\n/);
#    }
#}
#
#sub close {
#    @_ == 1 || die(q/Usage: $handle->close()/ . "\n");
#    my ($self) = @_;
#    CORE::close($self->{fh})
#      or die(qq/Could not close socket: '$!'\n/);
#}
#
#sub write {
#    @_ == 2 || die(q/Usage: $handle->write(buf)/ . "\n");
#    my ($self, $buf) = @_;
#
#    if ( $] ge '5.008' ) {
#        utf8::downgrade($buf, 1)
#            or die(qq/Wide character in write()\n/);
#    }
#
#    my $len = length $buf;
#    my $off = 0;
#
#    local $SIG{PIPE} = 'IGNORE';
#
#    while () {
#        $self->can_write
#          or die(qq/Timed out while waiting for socket to become ready for writing\n/);
#        my $r = syswrite($self->{fh}, $buf, $len, $off);
#        if (defined $r) {
#            $len -= $r;
#            $off += $r;
#            last unless $len > 0;
#        }
#        elsif ($! == EPIPE) {
#            die(qq/Socket closed by remote server: $!\n/);
#        }
#        elsif ($! != EINTR) {
#            if ($self->{fh}->can('errstr')){
#                my $err = $self->{fh}->errstr();
#                die (qq/Could not write to SSL socket: '$err'\n /);
#            }
#            else {
#                die(qq/Could not write to socket: '$!'\n/);
#            }
#
#        }
#    }
#    return $off;
#}
#
#sub read {
#    @_ == 2 || @_ == 3 || die(q/Usage: $handle->read(len [, allow_partial])/ . "\n");
#    my ($self, $len, $allow_partial) = @_;
#
#    my $buf  = '';
#    my $got = length $self->{rbuf};
#
#    if ($got) {
#        my $take = ($got < $len) ? $got : $len;
#        $buf  = substr($self->{rbuf}, 0, $take, '');
#        $len -= $take;
#    }
#
#    while ($len > 0) {
#        $self->can_read
#          or die(q/Timed out while waiting for socket to become ready for reading/ . "\n");
#        my $r = sysread($self->{fh}, $buf, $len, length $buf);
#        if (defined $r) {
#            last unless $r;
#            $len -= $r;
#        }
#        elsif ($! != EINTR) {
#            if ($self->{fh}->can('errstr')){
#                my $err = $self->{fh}->errstr();
#                die (qq/Could not read from SSL socket: '$err'\n /);
#            }
#            else {
#                die(qq/Could not read from socket: '$!'\n/);
#            }
#        }
#    }
#    if ($len && !$allow_partial) {
#        die(qq/Unexpected end of stream\n/);
#    }
#    return $buf;
#}
#
#sub readline {
#    @_ == 1 || die(q/Usage: $handle->readline()/ . "\n");
#    my ($self) = @_;
#
#    while () {
#        if ($self->{rbuf} =~ s/\A ([^\x0D\x0A]* \x0D?\x0A)//x) {
#            return $1;
#        }
#        if (length $self->{rbuf} >= $self->{max_line_size}) {
#            die(qq/Line size exceeds the maximum allowed size of $self->{max_line_size}\n/);
#        }
#        $self->can_read
#          or die(qq/Timed out while waiting for socket to become ready for reading\n/);
#        my $r = sysread($self->{fh}, $self->{rbuf}, BUFSIZE, length $self->{rbuf});
#        if (defined $r) {
#            last unless $r;
#        }
#        elsif ($! != EINTR) {
#            if ($self->{fh}->can('errstr')){
#                my $err = $self->{fh}->errstr();
#                die (qq/Could not read from SSL socket: '$err'\n /);
#            }
#            else {
#                die(qq/Could not read from socket: '$!'\n/);
#            }
#        }
#    }
#    die(qq/Unexpected end of stream while looking for line\n/);
#}
#
#sub read_header_lines {
#    @_ == 1 || @_ == 2 || die(q/Usage: $handle->read_header_lines([headers])/ . "\n");
#    my ($self, $headers) = @_;
#    $headers ||= {};
#    my $lines   = 0;
#    my $val;
#
#    while () {
#         my $line = $self->readline;
#
#         if (++$lines >= $self->{max_header_lines}) {
#             die(qq/Header lines exceeds maximum number allowed of $self->{max_header_lines}\n/);
#         }
#         elsif ($line =~ /\A ([^\x00-\x1F\x7F:]+) : [\x09\x20]* ([^\x0D\x0A]*)/x) {
#             my ($field_name) = lc $1;
#             if (exists $headers->{$field_name}) {
#                 for ($headers->{$field_name}) {
#                     $_ = [$_] unless ref $_ eq "ARRAY";
#                     push @$_, $2;
#                     $val = \$_->[-1];
#                 }
#             }
#             else {
#                 $val = \($headers->{$field_name} = $2);
#             }
#         }
#         elsif ($line =~ /\A [\x09\x20]+ ([^\x0D\x0A]*)/x) {
#             $val
#               or die(qq/Unexpected header continuation line\n/);
#             next unless length $1;
#             $$val .= ' ' if length $$val;
#             $$val .= $1;
#         }
#         elsif ($line =~ /\A \x0D?\x0A \z/x) {
#            last;
#         }
#         else {
#            die(q/Malformed header line: / . $Printable->($line) . "\n");
#         }
#    }
#    return $headers;
#}
#
#sub write_request {
#    @_ == 2 || die(q/Usage: $handle->write_request(request)/ . "\n");
#    my($self, $request) = @_;
#    $self->write_request_header(@{$request}{qw/method uri headers header_case/});
#    $self->write_body($request) if $request->{cb};
#    return;
#}
#
#my @rfc_request_headers = qw(
#  Accept Accept-Charset Accept-Encoding Accept-Language Authorization
#  Cache-Control Connection Content-Length Expect From Host
#  If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since
#  Max-Forwards Pragma Proxy-Authorization Range Referer TE Trailer
#  Transfer-Encoding Upgrade User-Agent Via
#);
#
#my @other_request_headers = qw(
#  Content-Encoding Content-MD5 Content-Type Cookie DNT Date Origin
#  X-XSS-Protection
#);
#
#my %HeaderCase = map { lc($_) => $_ } @rfc_request_headers, @other_request_headers;
#
#sub write_header_lines {
#    (@_ >= 2 && @_ <= 4 && ref $_[1] eq 'HASH') || die(q/Usage: $handle->write_header_lines(headers, [header_case, prefix])/ . "\n");
#    my($self, $headers, $header_case, $prefix_data) = @_;
#    $header_case ||= {};
#
#    my $buf = (defined $prefix_data ? $prefix_data : '');
#
#    my %seen;
#    for my $k ( qw/host cache-control expect max-forwards pragma range te/ ) {
#        next unless exists $headers->{$k};
#        $seen{$k}++;
#        my $field_name = $HeaderCase{$k};
#        my $v = $headers->{$k};
#        for (ref $v eq 'ARRAY' ? @$v : $v) {
#            $_ = '' unless defined $_;
#            $buf .= "$field_name: $_\x0D\x0A";
#        }
#    }
#
#    while (my ($k, $v) = each %$headers) {
#        my $field_name = lc $k;
#        next if $seen{$field_name};
#        if (exists $HeaderCase{$field_name}) {
#            $field_name = $HeaderCase{$field_name};
#        }
#        else {
#            if (exists $header_case->{$field_name}) {
#                $field_name = $header_case->{$field_name};
#            }
#            else {
#                $field_name =~ s/\b(\w)/\u$1/g;
#            }
#            $field_name =~ /\A $Token+ \z/xo
#              or die(q/Invalid HTTP header field name: / . $Printable->($field_name) . "\n");
#            $HeaderCase{lc $field_name} = $field_name;
#        }
#        for (ref $v eq 'ARRAY' ? @$v : $v) {
#            s/\x0D?\x0A\s+/ /g;
#            die(qq/Invalid HTTP header field value ($field_name): / . $Printable->($_). "\n")
#              unless $_ eq '' || /\A $Field_Content \z/xo;
#            $_ = '' unless defined $_;
#            $buf .= "$field_name: $_\x0D\x0A";
#        }
#    }
#    $buf .= "\x0D\x0A";
#    return $self->write($buf);
#}
#
#sub read_body {
#    @_ == 3 || die(q/Usage: $handle->read_body(callback, response)/ . "\n");
#    my ($self, $cb, $response) = @_;
#    my $te = $response->{headers}{'transfer-encoding'} || '';
#    my $chunked = grep { /chunked/i } ( ref $te eq 'ARRAY' ? @$te : $te ) ;
#    return $chunked
#        ? $self->read_chunked_body($cb, $response)
#        : $self->read_content_body($cb, $response);
#}
#
#sub write_body {
#    @_ == 2 || die(q/Usage: $handle->write_body(request)/ . "\n");
#    my ($self, $request) = @_;
#    if ($request->{headers}{'content-length'}) {
#        return $self->write_content_body($request);
#    }
#    else {
#        return $self->write_chunked_body($request);
#    }
#}
#
#sub read_content_body {
#    @_ == 3 || @_ == 4 || die(q/Usage: $handle->read_content_body(callback, response, [read_length])/ . "\n");
#    my ($self, $cb, $response, $content_length) = @_;
#    $content_length ||= $response->{headers}{'content-length'};
#
#    if ( defined $content_length ) {
#        my $len = $content_length;
#        while ($len > 0) {
#            my $read = ($len > BUFSIZE) ? BUFSIZE : $len;
#            $cb->($self->read($read, 0), $response);
#            $len -= $read;
#        }
#        return length($self->{rbuf}) == 0;
#    }
#
#    my $chunk;
#    $cb->($chunk, $response) while length( $chunk = $self->read(BUFSIZE, 1) );
#
#    return;
#}
#
#sub write_content_body {
#    @_ == 2 || die(q/Usage: $handle->write_content_body(request)/ . "\n");
#    my ($self, $request) = @_;
#
#    my ($len, $content_length) = (0, $request->{headers}{'content-length'});
#    while () {
#        my $data = $request->{cb}->();
#
#        defined $data && length $data
#          or last;
#
#        if ( $] ge '5.008' ) {
#            utf8::downgrade($data, 1)
#                or die(qq/Wide character in write_content()\n/);
#        }
#
#        $len += $self->write($data);
#    }
#
#    $len == $content_length
#      or die(qq/Content-Length mismatch (got: $len expected: $content_length)\n/);
#
#    return $len;
#}
#
#sub read_chunked_body {
#    @_ == 3 || die(q/Usage: $handle->read_chunked_body(callback, $response)/ . "\n");
#    my ($self, $cb, $response) = @_;
#
#    while () {
#        my $head = $self->readline;
#
#        $head =~ /\A ([A-Fa-f0-9]+)/x
#          or die(q/Malformed chunk head: / . $Printable->($head) . "\n");
#
#        my $len = hex($1)
#          or last;
#
#        $self->read_content_body($cb, $response, $len);
#
#        $self->read(2) eq "\x0D\x0A"
#          or die(qq/Malformed chunk: missing CRLF after chunk data\n/);
#    }
#    $self->read_header_lines($response->{headers});
#    return 1;
#}
#
#sub write_chunked_body {
#    @_ == 2 || die(q/Usage: $handle->write_chunked_body(request)/ . "\n");
#    my ($self, $request) = @_;
#
#    my $len = 0;
#    while () {
#        my $data = $request->{cb}->();
#
#        defined $data && length $data
#          or last;
#
#        if ( $] ge '5.008' ) {
#            utf8::downgrade($data, 1)
#                or die(qq/Wide character in write_chunked_body()\n/);
#        }
#
#        $len += length $data;
#
#        my $chunk  = sprintf '%X', length $data;
#           $chunk .= "\x0D\x0A";
#           $chunk .= $data;
#           $chunk .= "\x0D\x0A";
#
#        $self->write($chunk);
#    }
#    $self->write("0\x0D\x0A");
#    if ( ref $request->{trailer_cb} eq 'CODE' ) {
#        $self->write_header_lines($request->{trailer_cb}->())
#    }
#    else {
#        $self->write("\x0D\x0A");
#    }
#    return $len;
#}
#
#sub read_response_header {
#    @_ == 1 || die(q/Usage: $handle->read_response_header()/ . "\n");
#    my ($self) = @_;
#
#    my $line = $self->readline;
#
#    $line =~ /\A (HTTP\/(0*\d+\.0*\d+)) [\x09\x20]+ ([0-9]{3}) [\x09\x20]+ ([^\x0D\x0A]*) \x0D?\x0A/x
#      or die(q/Malformed Status-Line: / . $Printable->($line). "\n");
#
#    my ($protocol, $version, $status, $reason) = ($1, $2, $3, $4);
#
#    die (qq/Unsupported HTTP protocol: $protocol\n/)
#        unless $version =~ /0*1\.0*[01]/;
#
#    return {
#        status       => $status,
#        reason       => $reason,
#        headers      => $self->read_header_lines,
#        protocol     => $protocol,
#    };
#}
#
#sub write_request_header {
#    @_ == 5 || die(q/Usage: $handle->write_request_header(method, request_uri, headers, header_case)/ . "\n");
#    my ($self, $method, $request_uri, $headers, $header_case) = @_;
#
#    return $self->write_header_lines($headers, $header_case, "$method $request_uri HTTP/1.1\x0D\x0A");
#}
#
#sub _do_timeout {
#    my ($self, $type, $timeout) = @_;
#    $timeout = $self->{timeout}
#        unless defined $timeout && $timeout >= 0;
#
#    my $fd = fileno $self->{fh};
#    defined $fd && $fd >= 0
#      or die(qq/select(2): 'Bad file descriptor'\n/);
#
#    my $initial = time;
#    my $pending = $timeout;
#    my $nfound;
#
#    vec(my $fdset = '', $fd, 1) = 1;
#
#    while () {
#        $nfound = ($type eq 'read')
#            ? select($fdset, undef, undef, $pending)
#            : select(undef, $fdset, undef, $pending) ;
#        if ($nfound == -1) {
#            $! == EINTR
#              or die(qq/select(2): '$!'\n/);
#            redo if !$timeout || ($pending = $timeout - (time - $initial)) > 0;
#            $nfound = 0;
#        }
#        last;
#    }
#    $! = 0;
#    return $nfound;
#}
#
#sub can_read {
#    @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_read([timeout])/ . "\n");
#    my $self = shift;
#    if ( ref($self->{fh}) eq 'IO::Socket::SSL' ) {
#        return 1 if $self->{fh}->pending;
#    }
#    return $self->_do_timeout('read', @_)
#}
#
#sub can_write {
#    @_ == 1 || @_ == 2 || die(q/Usage: $handle->can_write([timeout])/ . "\n");
#    my $self = shift;
#    return $self->_do_timeout('write', @_)
#}
#
#sub _assert_ssl {
#    my($ok, $reason) = HTTP::Tiny->can_ssl();
#    die $reason unless $ok;
#}
#
#sub can_reuse {
#    my ($self,$scheme,$host,$port,$peer) = @_;
#    return 0 if
#        $self->{pid} != $$
#        || $self->{tid} != _get_tid()
#        || length($self->{rbuf})
#        || $scheme ne $self->{scheme}
#        || $host ne $self->{host}
#        || $port ne $self->{port}
#        || $peer ne $self->{peer}
#        || eval { $self->can_read(0) }
#        || $@ ;
#        return 1;
#}
#
#sub _find_CA_file {
#    my $self = shift();
#
#    my $ca_file =
#      defined( $self->{SSL_options}->{SSL_ca_file} )
#      ? $self->{SSL_options}->{SSL_ca_file}
#      : $ENV{SSL_CERT_FILE};
#
#    if ( defined $ca_file ) {
#        unless ( -r $ca_file ) {
#            die qq/SSL_ca_file '$ca_file' not found or not readable\n/;
#        }
#        return $ca_file;
#    }
#
#    local @INC = @INC;
#    pop @INC if $INC[-1] eq '.';
#    return Mozilla::CA::SSL_ca_file()
#        if eval { require Mozilla::CA; 1 };
#
#    foreach my $ca_bundle (
#        "/etc/ssl/certs/ca-certificates.crt",     
#        "/etc/pki/tls/certs/ca-bundle.crt",       
#        "/etc/ssl/ca-bundle.pem",                 
#        "/etc/openssl/certs/ca-certificates.crt", 
#        "/etc/ssl/cert.pem",                      
#        "/usr/local/share/certs/ca-root-nss.crt", 
#        "/etc/pki/tls/cacert.pem",                
#        "/etc/certs/ca-certificates.crt",         
#    ) {
#        return $ca_bundle if -e $ca_bundle;
#    }
#
#    die qq/Couldn't find a CA bundle with which to verify the SSL certificate.\n/
#      . qq/Try installing Mozilla::CA from CPAN\n/;
#}
#
#sub _get_tid {
#    no warnings 'reserved'; 
#    return threads->can("tid") ? threads->tid : 0;
#}
#
#sub _ssl_args {
#    my ($self, $host) = @_;
#
#    my %ssl_args;
#
#    if ( Net::SSLeay::OPENSSL_VERSION_NUMBER() >= 0x01000000 ) {
#        $ssl_args{SSL_hostname} = $host,          
#    }
#
#    if ($self->{verify_SSL}) {
#        $ssl_args{SSL_verifycn_scheme}  = 'http'; 
#        $ssl_args{SSL_verifycn_name}    = $host;  
#        $ssl_args{SSL_verify_mode}      = 0x01;   
#        $ssl_args{SSL_ca_file}          = $self->_find_CA_file;
#    }
#    else {
#        $ssl_args{SSL_verifycn_scheme}  = 'none'; 
#        $ssl_args{SSL_verify_mode}      = 0x00;   
#    }
#
#    for my $k ( keys %{$self->{SSL_options}} ) {
#        $ssl_args{$k} = $self->{SSL_options}{$k} if $k =~ m/^SSL_/;
#    }
#
#    return \%ssl_args;
#}
#
#1;
#
#__END__
#
### HTTP/Tiny/UNIX.pm ###
#package HTTP::Tiny::UNIX;
#
#use 5.010001;
#use strict;
#use warnings;
#
#our $DATE = '2018-05-08'; 
#our $VERSION = '0.051'; 
#
#
#use parent qw(HTTP::Tiny);
#
#use IO::Socket::UNIX;
#
#sub _split_url {
#    my ($self, $url) = @_;
#
#    if ($url =~ m<\A[^:/?#]+://>) {
#        $self->{_unix} = 0;
#        return $self->SUPER::_split_url($url);
#    }
#
#    my ($scheme, $sock_path, $path_query) =
#        $url =~ m<\A(\w+):(.+?)/(/[^#]*)>
#            or die "Cannot parse HTTP-over-Unix URL: '$url'\n";
#
#    $self->{_unix} = 1;
#    $self->{_path_query} = $path_query;
#
#    $scheme = lc $scheme;
#    die "Only http scheme is supported\n" unless $scheme eq 'http';
#
#    return  ($scheme, $sock_path, -1,    $path_query, '');
#}
#
#sub _open_handle {
#    my ($self, $request, $scheme, $host, $port) = @_;
#
#    return $self->SUPER::_open_handle($request, $scheme, $host, $port)
#        unless $self->{_unix};
#
#    my $handle = HTTP::Tiny::Handle::UNIX->new(
#        timeout => $self->{timeout},
#    );
#
#    $handle->connect($scheme, $host, $port, $self);
#}
#
#package
#    HTTP::Tiny::Handle::UNIX;
#
#use parent -norequire, 'HTTP::Tiny::Handle';
#
#use IO::Socket;
#
#sub connect {
#    my ($self, $scheme, $host, $port, $tiny) = @_;
#
#    my $path = $host;
#
#    local($^W) = 0;
#    my $sock = IO::Socket::UNIX->new(
#        Peer    => $path,
#        Type    => SOCK_STREAM,
#        Timeout => $self->{timeout},
#        Host    => 'localhost',
#    );
#
#    unless ($sock) {
#        $@ =~ s/^.*?: //;
#        die "Can't open Unix socket $path\: $@";
#    }
#
#    eval { $sock->blocking(0); };
#
#    $self->{fh} = $sock;
#
#    $self->{scheme} = $scheme;
#    $self->{host} = $host;
#    $self->{port} = $port;
#    $self->{_unix} = 1;
#    $self->{_tiny} = $tiny;
#    $self;
#}
#
#sub write_request_header {
#    my ($self, $method, $request_uri, $headers, $header_case) = @_;
#
#    return $self->SUPER::write_request_header(@_)
#        unless $self->{_unix};
#
#    return $self->write_header_lines($headers, $header_case, "$method $self->{_tiny}{_path_query} HTTP/1.1\x0D\x0A");
#}
#
#1;
#
#__END__
#
### IO/Pty.pm ###
#
#package IO::Pty;
#
#use strict;
#use Carp;
#use IO::Tty qw(TIOCSCTTY TCSETCTTY TIOCNOTTY);
#use IO::File;
#require POSIX;
#
#use vars qw(@ISA $VERSION);
#
#$VERSION = '1.12'; 
#
#@ISA = qw(IO::Handle);
#eval { local $^W = 0; undef local $SIG{__DIE__}; require IO::Stty };
#push @ISA, "IO::Stty" if (not $@);  
#
#sub new {
#  my ($class) = $_[0] || "IO::Pty";
#  $class = ref($class) if ref($class);
#  @_ <= 1 or croak 'usage: new $class';
#
#  my ($ptyfd, $ttyfd, $ttyname) = pty_allocate();
#
#  croak "Cannot open a pty" if not defined $ptyfd;
#
#  my $pty = $class->SUPER::new_from_fd($ptyfd, "r+");
#  croak "Cannot create a new $class from fd $ptyfd: $!" if not $pty;
#  $pty->autoflush(1);
#  bless $pty => $class;
#
#  my $slave = IO::Tty->new_from_fd($ttyfd, "r+");
#  croak "Cannot create a new IO::Tty from fd $ttyfd: $!" if not $slave;
#  $slave->autoflush(1);
#
#  ${*$pty}{'io_pty_slave'} = $slave;
#  ${*$pty}{'io_pty_ttyname'} = $ttyname;
#  ${*$slave}{'io_tty_ttyname'} = $ttyname;
#
#  return $pty;
#}
#
#sub ttyname {
#  @_ == 1 or croak 'usage: $pty->ttyname();';
#  my $pty = shift;
#  ${*$pty}{'io_pty_ttyname'};
#}
#
#
#sub close_slave {
#  @_ == 1 or croak 'usage: $pty->close_slave();';
#
#  my $master = shift;
#
#  if (exists ${*$master}{'io_pty_slave'}) {
#    close ${*$master}{'io_pty_slave'};
#    delete ${*$master}{'io_pty_slave'};
#  }
#}
#
#sub slave {
#  @_ == 1 or croak 'usage: $pty->slave();';
#
#  my $master = shift;
#
#  if (exists ${*$master}{'io_pty_slave'}) {
#    return ${*$master}{'io_pty_slave'};
#  }
#
#  my $tty = ${*$master}{'io_pty_ttyname'};
#
#  my $slave = new IO::Tty;
#
#  $slave->open($tty, O_RDWR | O_NOCTTY) ||
#    croak "Cannot open slave $tty: $!";
#
#  return $slave;
#}
#
#sub make_slave_controlling_terminal {
#  @_ == 1 or croak 'usage: $pty->make_slave_controlling_terminal();';
#
#  my $self = shift;
#  local(*DEVTTY);
#
#  if (defined TIOCNOTTY) {
#    if (open (\*DEVTTY, "/dev/tty")) {
#      ioctl( \*DEVTTY, TIOCNOTTY, 0 );
#      close \*DEVTTY;
#    }
#  }
#
#  if (not POSIX::setsid()) {
#    warn "setsid() failed, strange behavior may result: $!\r\n" if $^W;
#  }
#
#  if (open(\*DEVTTY, "/dev/tty")) {
#    warn "Could not disconnect from controlling terminal?!\n" if $^W;
#    close \*DEVTTY;
#  }
#
#  my $ttyname = ${*$self}{'io_pty_ttyname'};
#  my $slv = new IO::Tty;
#  $slv->open($ttyname, O_RDWR)
#    or croak "Cannot open slave $ttyname: $!";
#
#  if (not exists ${*$self}{'io_pty_slave'}) {
#    ${*$self}{'io_pty_slave'} = $slv;
#  } else {
#    $slv->close;
#  }
#
#  if (not open(\*DEVTTY, "/dev/tty")) {
#    if (defined TIOCSCTTY) {
#      if (not defined ioctl( ${*$self}{'io_pty_slave'}, TIOCSCTTY, 0 )) {
#        warn "warning: TIOCSCTTY failed, slave might not be set as controlling terminal: $!" if $^W;
#      }
#    } elsif (defined TCSETCTTY) {
#      if (not defined ioctl( ${*$self}{'io_pty_slave'}, TCSETCTTY, 0 )) {
#        warn "warning: TCSETCTTY failed, slave might not be set as controlling terminal: $!" if $^W;
#      }
#    } else {
#      warn "warning: You have neither TIOCSCTTY nor TCSETCTTY on your system\n" if $^W;
#      return 0;
#    }
#  }
#
#  if (not open(\*DEVTTY, "/dev/tty")) {
#    warn "Error: could not connect pty as controlling terminal!\n";
#    return undef;
#  } else {
#    close \*DEVTTY;
#  }
#  
#  return 1;
#}
#
#*clone_winsize_from = \&IO::Tty::clone_winsize_from;
#*get_winsize = \&IO::Tty::get_winsize;
#*set_winsize = \&IO::Tty::set_winsize;
#*set_raw = \&IO::Tty::set_raw;
#
#1;
#
#__END__
#
#
### IO/Tty.pm ###
#
#package IO::Tty;
#
#use IO::Handle;
#use IO::File;
#use IO::Tty::Constant;
#use Carp;
#
#require POSIX;
#require DynaLoader;
#
#use vars qw(@ISA $VERSION $XS_VERSION $CONFIG $DEBUG);
#
#$VERSION = '1.12';
#$XS_VERSION = "1.12";
#@ISA = qw(IO::Handle);
#
#eval { local $^W = 0; undef local $SIG{__DIE__}; require IO::Stty };
#push @ISA, "IO::Stty" if (not $@);  
#
#BOOT_XS: {
#    require DynaLoader;
#
#    *dl_load_flags = DynaLoader->can('dl_load_flags');
#
#    do {
#	defined(&bootstrap)
#		? \&bootstrap
#		: \&DynaLoader::bootstrap
#    }->(__PACKAGE__);
#}
#
#sub import {
#    IO::Tty::Constant->export_to_level(1, @_);
#}
#
#sub open {
#    my($tty,$dev,$mode) = @_;
#
#    IO::File::open($tty,$dev,$mode) or
#	return undef;
#
#    $tty->autoflush;
#
#    1;
#}
#
#sub clone_winsize_from {
#  my ($self, $fh) = @_;
#  croak "Given filehandle is not a tty in clone_winsize_from, called"
#    if not POSIX::isatty($fh);  
#  return 1 if not POSIX::isatty($self);  
#  my $winsize = " "x1024; 
#  ioctl($fh, &IO::Tty::Constant::TIOCGWINSZ, $winsize)
#    and ioctl($self, &IO::Tty::Constant::TIOCSWINSZ, $winsize)
#      and return 1;
#  warn "clone_winsize_from: error: $!" if $^W;
#  return undef;
#}
#
#my $SIZEOF_WINSIZE = length IO::Tty::pack_winsize(0,0,0,0);
#
#sub get_winsize {
#  my $self = shift;
#  ioctl($self, IO::Tty::Constant::TIOCGWINSZ(), my $winsize)
#    or croak "Cannot TIOCGWINSZ - $!";
#  substr($winsize, $SIZEOF_WINSIZE) = "";
#  return IO::Tty::unpack_winsize($winsize);
#}
#
#sub set_winsize {
#  my $self = shift;
#  my $winsize = IO::Tty::pack_winsize(@_);
#  ioctl($self, IO::Tty::Constant::TIOCSWINSZ(), $winsize)
#    or croak "Cannot TIOCSWINSZ - $!";
#}
#
#sub set_raw($) {
#  require POSIX;
#  my $self = shift;
#  return 1 if not POSIX::isatty($self);
#  my $ttyno = fileno($self);
#  my $termios = new POSIX::Termios;
#  unless ($termios) {
#    warn "set_raw: new POSIX::Termios failed: $!";
#    return undef;
#  }
#  unless ($termios->getattr($ttyno)) {
#    warn "set_raw: getattr($ttyno) failed: $!";
#    return undef;
#  }
#  $termios->setiflag(0);
#  $termios->setoflag(0);
#  $termios->setlflag(0);
#  $termios->setcc(&POSIX::VMIN, 1);
#  $termios->setcc(&POSIX::VTIME, 0);
#  unless ($termios->setattr($ttyno, &POSIX::TCSANOW)) {
#    warn "set_raw: setattr($ttyno) failed: $!";
#    return undef;
#  }
#  return 1;
#}
#
#
#1;
#
#__END__
#
### IPC/Run.pm ###
#package IPC::Run;
#use bytes;
#
#
#use strict;
#use Exporter ();
#use vars qw{$VERSION @ISA @FILTER_IMP @FILTERS @API @EXPORT_OK %EXPORT_TAGS};
#
#BEGIN {
#    $VERSION = '0.96';
#    @ISA     = qw{ Exporter };
#
#    @FILTER_IMP = qw( input_avail get_more_input );
#    @FILTERS    = qw(
#      new_appender
#      new_chunker
#      new_string_source
#      new_string_sink
#    );
#    @API = qw(
#      run
#      harness start pump pumpable finish
#      signal kill_kill reap_nb
#      io timer timeout
#      close_terminal
#      binary
#    );
#    @EXPORT_OK = ( @API, @FILTER_IMP, @FILTERS, qw( Win32_MODE ) );
#    %EXPORT_TAGS = (
#        'filter_imp' => \@FILTER_IMP,
#        'all'        => \@EXPORT_OK,
#        'filters'    => \@FILTERS,
#        'api'        => \@API,
#    );
#
#}
#
#use strict;
#use IPC::Run::Debug;
#use Exporter;
#use Fcntl;
#use POSIX ();
#
#BEGIN {
#    if ( $] < 5.008 ) { require Symbol; }
#}
#use Carp;
#use File::Spec ();
#use IO::Handle;
#require IPC::Run::IO;
#require IPC::Run::Timer;
#
#use constant Win32_MODE => $^O =~ /os2|Win32/i;
#
#BEGIN {
#    if (Win32_MODE) {
#        eval "use IPC::Run::Win32Helper; 1;"
#          or ( $@ && die )
#          or die "$!";
#    }
#    else {
#        eval "use File::Basename; 1;" or die $!;
#    }
#}
#
#sub input_avail();
#sub get_more_input();
#
#
#use vars qw( $_EIO $_EAGAIN );
#use Errno qw(   EIO   EAGAIN );
#
#BEGIN {
#    local $!;
#    $!       = EIO;
#    $_EIO    = qr/^$!/;
#    $!       = EAGAIN;
#    $_EAGAIN = qr/^$!/;
#}
#
#sub _newed()     { 0 }
#sub _harnessed() { 1 }
#sub _finished()  { 2 }    
#sub _started()   { 3 }
#
#my %fds;
#
#
#use vars qw( $cur_self );
#
#sub _debug_fd {
#    return fileno STDERR unless defined $cur_self;
#
#    if ( _debugging && !defined $cur_self->{DEBUG_FD} ) {
#        my $fd = select STDERR;
#        $| = 1;
#        select $fd;
#        $cur_self->{DEBUG_FD} = POSIX::dup fileno STDERR;
#        _debug("debugging fd is $cur_self->{DEBUG_FD}\n")
#          if _debugging_details;
#    }
#
#    return fileno STDERR unless defined $cur_self->{DEBUG_FD};
#
#    return $cur_self->{DEBUG_FD};
#}
#
#sub DESTROY {
#    my IPC::Run $self = shift;
#    POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
#    $self->{DEBUG_FD} = undef;
#}
#
#my %cmd_cache;
#
#sub _search_path {
#    my ($cmd_name) = @_;
#    if ( File::Spec->file_name_is_absolute($cmd_name) && -x $cmd_name ) {
#        _debug "'", $cmd_name, "' is absolute"
#          if _debugging_details;
#        return $cmd_name;
#    }
#
#    my $dirsep = (
#          Win32_MODE     ? '[/\\\\]'
#        : $^O =~ /MacOS/ ? ':'
#        : $^O =~ /VMS/   ? '[\[\]]'
#        :                  '/'
#    );
#
#    if (
#        Win32_MODE
#        && ( $cmd_name =~ /$dirsep/ )
#
#        && ( $cmd_name !~ m!\.[^\\/\.]+$! )
#      ) {
#
#        _debug "no extension(.exe), checking ENV{PATHEXT}" if _debugging;
#        for ( split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE" ) {
#            my $name = "$cmd_name$_";
#            $cmd_name = $name, last if -f $name && -x _;
#        }
#        _debug "cmd_name is now '$cmd_name'" if _debugging;
#    }
#
#    if ( $cmd_name =~ /($dirsep)/ ) {
#        _debug "'$cmd_name' contains '$1'" if _debugging;
#        croak "file not found: $cmd_name"    unless -e $cmd_name;
#        croak "not a file: $cmd_name"        unless -f $cmd_name;
#        croak "permission denied: $cmd_name" unless -x $cmd_name;
#        return $cmd_name;
#    }
#
#    if ( exists $cmd_cache{$cmd_name} ) {
#        _debug "'$cmd_name' found in cache: '$cmd_cache{$cmd_name}'"
#          if _debugging;
#        return $cmd_cache{$cmd_name} if -x $cmd_cache{$cmd_name};
#        _debug "'$cmd_cache{$cmd_name}' no longer executable, searching..."
#          if _debugging;
#        delete $cmd_cache{$cmd_name};
#    }
#
#    my @searched_in;
#
#    my $re = Win32_MODE ? qr/;/ : qr/:/;
#
#  LOOP:
#    for ( split( $re, $ENV{PATH} || '', -1 ) ) {
#        $_ = "." unless length $_;
#        push @searched_in, $_;
#
#        my $prospect = File::Spec->catfile( $_, $cmd_name );
#        my @prospects;
#
#        @prospects =
#          ( Win32_MODE && !( -f $prospect && -x _ ) )
#          ? map "$prospect$_", split /;/, $ENV{PATHEXT} || ".COM;.BAT;.EXE"
#          : ($prospect);
#
#        for my $found (@prospects) {
#            if ( -f $found && -x _ ) {
#                $cmd_cache{$cmd_name} = $found;
#                last LOOP;
#            }
#        }
#    }
#
#    if ( exists $cmd_cache{$cmd_name} ) {
#        _debug "'", $cmd_name, "' added to cache: '", $cmd_cache{$cmd_name}, "'"
#          if _debugging_details;
#        return $cmd_cache{$cmd_name};
#    }
#
#    croak "Command '$cmd_name' not found in " . join( ", ", @searched_in );
#}
#
#sub _empty($) { !( defined $_[0] && length $_[0] ) }
#
#sub _close {
#    confess 'undef' unless defined $_[0];
#    my $fd = $_[0] =~ /^\d+$/ ? $_[0] : fileno $_[0];
#    my $r = POSIX::close $fd;
#    $r = $r ? '' : " ERROR $!";
#    delete $fds{$fd};
#    _debug "close( $fd ) = " . ( $r || 0 ) if _debugging_details;
#}
#
#sub _dup {
#    confess 'undef' unless defined $_[0];
#    my $r = POSIX::dup( $_[0] );
#    croak "$!: dup( $_[0] )" unless defined $r;
#    $r = 0 if $r eq '0 but true';
#    _debug "dup( $_[0] ) = $r" if _debugging_details;
#    $fds{$r} = 1;
#    return $r;
#}
#
#sub _dup2_rudely {
#    confess 'undef' unless defined $_[0] && defined $_[1];
#    my $r = POSIX::dup2( $_[0], $_[1] );
#    croak "$!: dup2( $_[0], $_[1] )" unless defined $r;
#    $r = 0 if $r eq '0 but true';
#    _debug "dup2( $_[0], $_[1] ) = $r" if _debugging_details;
#    $fds{$r} = 1;
#    return $r;
#}
#
#sub _exec {
#    confess 'undef passed' if grep !defined, @_;
#
#    _debug 'exec()ing ', join " ", map "'$_'", @_ if _debugging_details;
#
#    exec { $_[0] } @_;
#
#}
#
#sub _sysopen {
#    confess 'undef' unless defined $_[0] && defined $_[1];
#    _debug sprintf( "O_RDONLY=0x%02x ", O_RDONLY ),
#      sprintf( "O_WRONLY=0x%02x ", O_WRONLY ),
#      sprintf( "O_RDWR=0x%02x ",   O_RDWR ),
#      sprintf( "O_TRUNC=0x%02x ",  O_TRUNC ),
#      sprintf( "O_CREAT=0x%02x ",  O_CREAT ),
#      sprintf( "O_APPEND=0x%02x ", O_APPEND ),
#      if _debugging_details;
#    my $r = POSIX::open( $_[0], $_[1], 0644 );
#    croak "$!: open( $_[0], ", sprintf( "0x%03x", $_[1] ), " )" unless defined $r;
#    _debug "open( $_[0], ", sprintf( "0x%03x", $_[1] ), " ) = $r"
#      if _debugging_data;
#    $fds{$r} = 1;
#    return $r;
#}
#
#sub _pipe {
#    my ( $r, $w ) = POSIX::pipe;
#    croak "$!: pipe()" unless defined $r;
#    _debug "pipe() = ( $r, $w ) " if _debugging_details;
#    $fds{$r} = $fds{$w} = 1;
#    return ( $r, $w );
#}
#
#sub _pipe_nb {
#    local ( *R, *W );
#    my $f = pipe( R, W );
#    croak "$!: pipe()" unless defined $f;
#    my ( $r, $w ) = ( fileno R, fileno W );
#    _debug "pipe_nb pipe() = ( $r, $w )" if _debugging_details;
#    unless (Win32_MODE) {
#        my $fres = fcntl( W, &F_SETFL, O_WRONLY | O_NONBLOCK );
#        croak "$!: fcntl( $w, F_SETFL, O_NONBLOCK )" unless $fres;
#        _debug "fcntl( $w, F_SETFL, O_NONBLOCK )" if _debugging_details;
#    }
#    ( $r, $w ) = ( _dup($r), _dup($w) );
#    _debug "pipe_nb() = ( $r, $w )" if _debugging_details;
#    return ( $r, $w );
#}
#
#sub _pty {
#    require IO::Pty;
#    my $pty = IO::Pty->new();
#    croak "$!: pty ()" unless $pty;
#    $pty->autoflush();
#    $pty->blocking(0) or croak "$!: pty->blocking ( 0 )";
#    _debug "pty() = ( ", $pty->fileno, ", ", $pty->slave->fileno, " )"
#      if _debugging_details;
#    $fds{ $pty->fileno } = $fds{ $pty->slave->fileno } = 1;
#    return $pty;
#}
#
#sub _read {
#    confess 'undef' unless defined $_[0];
#    my $s = '';
#    my $r = POSIX::read( $_[0], $s, 10_000 );
#    croak "$!: read( $_[0] )" if not($r) and $! != POSIX::EINTR();
#    $r ||= 0;
#    _debug "read( $_[0] ) = $r chars '$s'" if _debugging_data;
#    return $s;
#}
#
#sub _spawn {
#    my IPC::Run $self = shift;
#    my ($kid) = @_;
#
#    _debug "opening sync pipe ", $kid->{PID} if _debugging_details;
#    my $sync_reader_fd;
#    ( $sync_reader_fd, $self->{SYNC_WRITER_FD} ) = _pipe;
#    $kid->{PID} = fork();
#    croak "$! during fork" unless defined $kid->{PID};
#
#    unless ( $kid->{PID} ) {
#        $self->_do_kid_and_exit($kid);
#    }
#    _debug "fork() = ", $kid->{PID} if _debugging_details;
#
#    _close $self->{SYNC_WRITER_FD};
#    my $sync_pulse = _read $sync_reader_fd;
#    _close $sync_reader_fd;
#
#    if ( !defined $sync_pulse || length $sync_pulse ) {
#        if ( waitpid( $kid->{PID}, 0 ) >= 0 ) {
#            $kid->{RESULT} = $?;
#        }
#        else {
#            $kid->{RESULT} = -1;
#        }
#        $sync_pulse = "error reading synchronization pipe for $kid->{NUM}, pid $kid->{PID}"
#          unless length $sync_pulse;
#        croak $sync_pulse;
#    }
#    return $kid->{PID};
#
#    if ( keys %{ $self->{PTYS} } && $IO::Pty::VERSION < 0.9 ) {
#        _debug "sleeping to give pty a chance to init, will fix when newer IO::Pty arrives.";
#        sleep 1;
#    }
#}
#
#sub _write {
#    confess 'undef' unless defined $_[0] && defined $_[1];
#    my $r = POSIX::write( $_[0], $_[1], length $_[1] );
#    croak "$!: write( $_[0], '$_[1]' )" unless $r;
#    _debug "write( $_[0], '$_[1]' ) = $r" if _debugging_data;
#    return $r;
#}
#
#
#use vars qw( $in_run );    
#
#sub run {
#    local $in_run = 1;     
#    my IPC::Run $self = start(@_);
#    my $r = eval {
#        $self->{clear_ins} = 0;
#        $self->finish;
#    };
#    if ($@) {
#        my $x = $@;
#        $self->kill_kill;
#        die $x;
#    }
#    return $r;
#}
#
#
#sub signal {
#    my IPC::Run $self = shift;
#
#    local $cur_self = $self;
#
#    $self->_kill_kill_kill_pussycat_kill unless @_;
#
#    Carp::cluck "Ignoring extra parameters passed to kill()" if @_ > 1;
#
#    my ($signal) = @_;
#    croak "Undefined signal passed to signal" unless defined $signal;
#    for ( grep $_->{PID} && !defined $_->{RESULT}, @{ $self->{KIDS} } ) {
#        _debug "sending $signal to $_->{PID}"
#          if _debugging;
#        kill $signal, $_->{PID}
#          or _debugging && _debug "$! sending $signal to $_->{PID}";
#    }
#
#    return;
#}
#
#
#sub kill_kill {
#    my IPC::Run $self = shift;
#
#    my %options = @_;
#    my $grace   = $options{grace};
#    $grace = 30 unless defined $grace;
#    ++$grace;    
#
#    my $coup_d_grace = $options{coup_d_grace};
#    $coup_d_grace = "KILL" unless defined $coup_d_grace;
#
#    delete $options{$_} for qw( grace coup_d_grace );
#    Carp::cluck "Ignoring unknown options for kill_kill: ",
#      join " ", keys %options
#      if keys %options;
#
#    $self->signal("TERM");
#
#    my $quitting_time = time + $grace;
#    my $delay         = 0.01;
#    my $accum_delay;
#
#    my $have_killed_before;
#
#    while () {
#        select undef, undef, undef, $delay;
#        $accum_delay += $delay;
#
#        $self->reap_nb;
#        last unless $self->_running_kids;
#
#        if ( $accum_delay >= $grace * 0.8 ) {
#            if ( time >= $quitting_time ) {
#                if ( !$have_killed_before ) {
#                    $self->signal($coup_d_grace);
#                    $have_killed_before = 1;
#                    $quitting_time += $grace;
#                    $delay       = 0.01;
#                    $accum_delay = 0;
#                    next;
#                }
#                croak "Unable to reap all children, even after KILLing them";
#            }
#        }
#
#        $delay *= 2;
#        $delay = 0.5 if $delay >= 0.5;
#    }
#
#    $self->_cleanup;
#    return $have_killed_before;
#}
#
#
#my $harness_id = 0;
#
#sub harness {
#    my $options;
#    if ( @_ && ref $_[-1] eq 'HASH' ) {
#        $options = pop;
#        require Data::Dumper;
#        carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
#    }
#
#
#    my @args;
#    if ( @_ == 1 && !ref $_[0] ) {
#        if (Win32_MODE) {
#            my $command = $ENV{ComSpec} || 'cmd';
#            @args = ( [ $command, '/c', win32_parse_cmd_line $_[0] ] );
#        }
#        else {
#            @args = ( [ qw( sh -c ), @_ ] );
#        }
#    }
#    elsif ( @_ > 1 && !grep ref $_, @_ ) {
#        @args = ( [@_] );
#    }
#    else {
#        @args = @_;
#    }
#
#    my @errs;    
#
#    my $succinct;    
#
#    my $cur_kid;     
#
#    my $assumed_fd = 0;    
#    my $handle_num = 0;    
#
#    my IPC::Run $self = bless {}, __PACKAGE__;
#
#    local $cur_self = $self;
#
#    $self->{ID}    = ++$harness_id;
#    $self->{IOS}   = [];
#    $self->{KIDS}  = [];
#    $self->{PIPES} = [];
#    $self->{PTYS}  = {};
#    $self->{STATE} = _newed;
#
#    if ($options) {
#        $self->{$_} = $options->{$_} for keys %$options;
#    }
#
#    _debug "****** harnessing *****" if _debugging;
#
#    my $first_parse;
#    local $_;
#    my $arg_count = @args;
#    while (@args) {
#        for ( shift @args ) {
#            eval {
#                $first_parse = 1;
#                _debug(
#                    "parsing ",
#                    defined $_
#                    ? ref $_ eq 'ARRAY'
#                          ? ( '[ ', join( ', ', map "'$_'", @$_ ), ' ]' )
#                          : (
#                              ref $_
#                                || (
#                                  length $_ < 50
#                                  ? "'$_'"
#                                  : join( '', "'", substr( $_, 0, 10 ), "...'" )
#                                )
#                          )
#                    : '<undef>'
#                ) if _debugging;
#
#              REPARSE:
#                if ( ref eq 'ARRAY' || ( !$cur_kid && ref eq 'CODE' ) ) {
#                    croak "Process control symbol ('|', '&') missing" if $cur_kid;
#                    croak "Can't spawn a subroutine on Win32"
#                      if Win32_MODE && ref eq "CODE";
#                    $cur_kid = {
#                        TYPE   => 'cmd',
#                        VAL    => $_,
#                        NUM    => @{ $self->{KIDS} } + 1,
#                        OPS    => [],
#                        PID    => '',
#                        RESULT => undef,
#                    };
#                    push @{ $self->{KIDS} }, $cur_kid;
#                    $succinct = 1;
#                }
#
#                elsif ( UNIVERSAL::isa( $_, 'IPC::Run::IO' ) ) {
#                    push @{ $self->{IOS} }, $_;
#                    $cur_kid  = undef;
#                    $succinct = 1;
#                }
#
#                elsif ( UNIVERSAL::isa( $_, 'IPC::Run::Timer' ) ) {
#                    push @{ $self->{TIMERS} }, $_;
#                    $cur_kid  = undef;
#                    $succinct = 1;
#                }
#
#                elsif (/^(\d*)>&(\d+)$/) {
#                    croak "No command before '$_'" unless $cur_kid;
#                    push @{ $cur_kid->{OPS} }, {
#                        TYPE => 'dup',
#                        KFD1 => $2,
#                        KFD2 => length $1 ? $1 : 1,
#                    };
#                    _debug "redirect operators now required" if _debugging_details;
#                    $succinct = !$first_parse;
#                }
#
#                elsif (/^(\d*)<&(\d+)$/) {
#                    croak "No command before '$_'" unless $cur_kid;
#                    push @{ $cur_kid->{OPS} }, {
#                        TYPE => 'dup',
#                        KFD1 => $2,
#                        KFD2 => length $1 ? $1 : 0,
#                    };
#                    $succinct = !$first_parse;
#                }
#
#                elsif (/^(\d*)<&-$/) {
#                    croak "No command before '$_'" unless $cur_kid;
#                    push @{ $cur_kid->{OPS} }, {
#                        TYPE => 'close',
#                        KFD => length $1 ? $1 : 0,
#                    };
#                    $succinct = !$first_parse;
#                }
#
#                elsif (/^(\d*) (<pipe)()            ()  ()  $/x
#                    || /^(\d*) (<pty) ((?:\s+\S+)?) (<) ()  $/x
#                    || /^(\d*) (<)    ()            ()  (.*)$/x ) {
#                    croak "No command before '$_'" unless $cur_kid;
#
#                    $succinct = !$first_parse;
#
#                    my $type = $2 . $4;
#
#                    my $kfd = length $1 ? $1 : 0;
#
#                    my $pty_id;
#                    if ( $type eq '<pty<' ) {
#                        $pty_id = length $3 ? $3 : '0';
#                        require IO::Pty;
#                        $self->{PTYS}->{$pty_id} = undef;
#                    }
#
#                    my $source = $5;
#
#                    my @filters;
#                    my $binmode;
#
#                    unless ( length $source ) {
#                        if ( !$succinct ) {
#                            while ( @args > 1
#                                && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
#                                if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
#                                    $binmode = shift(@args)->();
#                                }
#                                else {
#                                    push @filters, shift @args;
#                                }
#                            }
#                        }
#                        $source = shift @args;
#                        croak "'$_' missing a source" if _empty $source;
#
#                        _debug(
#                            'Kid ',  $cur_kid->{NUM},  "'s input fd ", $kfd,
#                            ' has ', scalar(@filters), ' filters.'
#                        ) if _debugging_details && @filters;
#                    }
#
#                    my IPC::Run::IO $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $source, $binmode, @filters );
#
#                    if ( ( ref $source eq 'GLOB' || UNIVERSAL::isa $source, 'IO::Handle' )
#                        && $type !~ /^<p(ty<|ipe)$/ ) {
#                        _debug "setting DONT_CLOSE" if _debugging_details;
#                        $pipe->{DONT_CLOSE} = 1;    
#                        _dont_inherit($source) if Win32_MODE;
#                    }
#
#                    push @{ $cur_kid->{OPS} }, $pipe;
#                }
#
#                elsif (
#                       /^()   (>>?)  (&)     ()      (.*)$/x
#                    || /^()   (&)    (>pipe) ()      ()  $/x
#                    || /^()   (>pipe)(&)     ()      ()  $/x
#                    || /^(\d*)()     (>pipe) ()      ()  $/x
#                    || /^()   (&)    (>pty)  ( \w*)> ()  $/x
#                    || /^(\d*)()     (>pty)  ( \w*)> ()  $/x
#                    || /^()   (&)    (>>?)   ()      (.*)$/x || /^(\d*)()     (>>?)   ()      (.*)$/x
#                  ) {
#                    croak "No command before '$_'" unless $cur_kid;
#
#                    $succinct = !$first_parse;
#
#                    my $type = (
#                          $2 eq '>pipe' || $3 eq '>pipe' ? '>pipe'
#                        : $2 eq '>pty'  || $3 eq '>pty'  ? '>pty>'
#                        :                                  '>'
#                    );
#                    my $kfd = length $1 ? $1 : 1;
#                    my $trunc = !( $2 eq '>>' || $3 eq '>>' );
#                    my $pty_id = (
#                          $2 eq '>pty' || $3 eq '>pty'
#                        ? length $4
#                              ? $4
#                              : 0
#                        : undef
#                    );
#
#                    my $stderr_too =
#                         $2 eq '&'
#                      || $3 eq '&'
#                      || ( !length $1 && substr( $type, 0, 4 ) eq '>pty' );
#
#                    my $dest = $5;
#                    my @filters;
#                    my $binmode = 0;
#                    unless ( length $dest ) {
#                        if ( !$succinct ) {
#                            while ( @args > 1
#                                && ( ( ref $args[1] && !UNIVERSAL::isa $args[1], "IPC::Run::Timer" ) || UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) ) {
#                                if ( UNIVERSAL::isa $args[0], "IPC::Run::binmode_pseudo_filter" ) {
#                                    $binmode = shift(@args)->();
#                                }
#                                else {
#                                    unshift @filters, shift @args;
#                                }
#                            }
#                        }
#
#                        $dest = shift @args;
#
#                        _debug(
#                            'Kid ',  $cur_kid->{NUM},  "'s output fd ", $kfd,
#                            ' has ', scalar(@filters), ' filters.'
#                        ) if _debugging_details && @filters;
#
#                        if ( $type eq '>pty>' ) {
#                            require IO::Pty;
#                            $self->{PTYS}->{$pty_id} = undef;
#                        }
#                    }
#
#                    croak "'$_' missing a destination" if _empty $dest;
#                    my $pipe = IPC::Run::IO->_new_internal( $type, $kfd, $pty_id, $dest, $binmode, @filters );
#                    $pipe->{TRUNC} = $trunc;
#
#                    if ( ( UNIVERSAL::isa( $dest, 'GLOB' ) || UNIVERSAL::isa( $dest, 'IO::Handle' ) )
#                        && $type !~ /^>(pty>|pipe)$/ ) {
#                        _debug "setting DONT_CLOSE" if _debugging_details;
#                        $pipe->{DONT_CLOSE} = 1;    
#                    }
#                    push @{ $cur_kid->{OPS} }, $pipe;
#                    push @{ $cur_kid->{OPS} }, {
#                        TYPE => 'dup',
#                        KFD1 => 1,
#                        KFD2 => 2,
#                    } if $stderr_too;
#                }
#
#                elsif ( $_ eq "|" ) {
#                    croak "No command before '$_'" unless $cur_kid;
#                    unshift @{ $cur_kid->{OPS} }, {
#                        TYPE => '|',
#                        KFD  => 1,
#                    };
#                    $succinct   = 1;
#                    $assumed_fd = 1;
#                    $cur_kid    = undef;
#                }
#
#                elsif ( $_ eq "&" ) {
#                    croak "No command before '$_'" unless $cur_kid;
#                    unshift @{ $cur_kid->{OPS} }, {
#                        TYPE => 'close',
#                        KFD  => 0,
#                    };
#                    $succinct   = 1;
#                    $assumed_fd = 0;
#                    $cur_kid    = undef;
#                }
#
#                elsif ( $_ eq 'init' ) {
#                    croak "No command before '$_'" unless $cur_kid;
#                    push @{ $cur_kid->{OPS} }, {
#                        TYPE => 'init',
#                        SUB  => shift @args,
#                    };
#                }
#
#                elsif ( !ref $_ ) {
#                    $self->{$_} = shift @args;
#                }
#
#                elsif ( $_ eq 'init' ) {
#                    croak "No command before '$_'" unless $cur_kid;
#                    push @{ $cur_kid->{OPS} }, {
#                        TYPE => 'init',
#                        SUB  => shift @args,
#                    };
#                }
#
#                elsif ( $succinct && $first_parse ) {
#                    unshift @args, $_;
#                    if ( !$assumed_fd ) {
#                        $_ = "$assumed_fd<",
#                    }
#                    else {
#                        $_ = "$assumed_fd>",
#                    }
#                    _debug "assuming '", $_, "'" if _debugging_details;
#                    ++$assumed_fd;
#                    $first_parse = 0;
#                    goto REPARSE;
#                }
#
#                else {
#                    croak join(
#                        '',
#                        'Unexpected ',
#                        ( ref() ? $_ : 'scalar' ),
#                        ' in harness() parameter ',
#                        $arg_count - @args
#                    );
#                }
#            };
#            if ($@) {
#                push @errs, $@;
#                _debug 'caught ', $@ if _debugging;
#            }
#        }
#    }
#
#    die join( '', @errs ) if @errs;
#
#    $self->{STATE} = _harnessed;
#
#    return $self;
#}
#
#sub _open_pipes {
#    my IPC::Run $self = shift;
#
#    my @errs;
#
#    my @close_on_fail;
#
#    my $pipe_read_fd;
#
#    my @output_fds_accum;
#
#    for ( sort keys %{ $self->{PTYS} } ) {
#        _debug "opening pty '", $_, "'" if _debugging_details;
#        my $pty = _pty;
#        $self->{PTYS}->{$_} = $pty;
#    }
#
#    for ( @{ $self->{IOS} } ) {
#        eval { $_->init; };
#        if ($@) {
#            push @errs, $@;
#            _debug 'caught ', $@ if _debugging;
#        }
#        else {
#            push @close_on_fail, $_;
#        }
#    }
#
#    for my $kid ( @{ $self->{KIDS} } ) {
#        unless ( ref $kid->{VAL} eq 'CODE' ) {
#            $kid->{PATH} = _search_path $kid->{VAL}->[0];
#        }
#        if ( defined $pipe_read_fd ) {
#            _debug "placing write end of pipe on kid $kid->{NUM}'s stdin"
#              if _debugging_details;
#            unshift @{ $kid->{OPS} }, {
#                TYPE => 'PIPE',          
#                KFD  => 0,
#                TFD  => $pipe_read_fd,
#            };
#            $pipe_read_fd = undef;
#        }
#        @output_fds_accum = ();
#        for my $op ( @{ $kid->{OPS} } ) {
#
#            my $ok = eval {
#                if ( $op->{TYPE} eq '<' ) {
#                    my $source = $op->{SOURCE};
#                    if ( !ref $source ) {
#                        _debug(
#                            "kid ",              $kid->{NUM}, " to read ", $op->{KFD},
#                            " from '" . $source, "' (read only)"
#                        ) if _debugging_details;
#                        croak "simulated open failure"
#                          if $self->{_simulate_open_failure};
#                        $op->{TFD} = _sysopen( $source, O_RDONLY );
#                        push @close_on_fail, $op->{TFD};
#                    }
#                    elsif (UNIVERSAL::isa( $source, 'GLOB' )
#                        || UNIVERSAL::isa( $source, 'IO::Handle' ) ) {
#                        croak "Unopened filehandle in input redirect for $op->{KFD}"
#                          unless defined fileno $source;
#                        $op->{TFD} = fileno $source;
#                        _debug(
#                            "kid ",      $kid->{NUM}, " to read ", $op->{KFD},
#                            " from fd ", $op->{TFD}
#                        ) if _debugging_details;
#                    }
#                    elsif ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
#                        _debug(
#                            "kid ", $kid->{NUM}, " to read ", $op->{KFD},
#                            " from SCALAR"
#                        ) if _debugging_details;
#
#                        $op->open_pipe( $self->_debug_fd );
#                        push @close_on_fail, $op->{KFD}, $op->{FD};
#
#                        my $s = '';
#                        $op->{KIN_REF} = \$s;
#                    }
#                    elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
#                        _debug( 'kid ', $kid->{NUM}, ' to read ', $op->{KFD}, ' from CODE' ) if _debugging_details;
#
#                        $op->open_pipe( $self->_debug_fd );
#                        push @close_on_fail, $op->{KFD}, $op->{FD};
#
#                        my $s = '';
#                        $op->{KIN_REF} = \$s;
#                    }
#                    else {
#                        croak( "'" . ref($source) . "' not allowed as a source for input redirection" );
#                    }
#                    $op->_init_filters;
#                }
#                elsif ( $op->{TYPE} eq '<pipe' ) {
#                    _debug(
#                        'kid to read ', $op->{KFD},
#                        ' from a pipe IPC::Run opens and returns',
#                    ) if _debugging_details;
#
#                    my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{SOURCE} );
#                    _debug "caller will write to ", fileno $op->{SOURCE}
#                      if _debugging_details;
#
#                    $op->{TFD} = $r;
#                    $op->{FD}  = undef;    
#                    $op->_init_filters;
#                }
#                elsif ( $op->{TYPE} eq '<pty<' ) {
#                    _debug(
#                        'kid to read ', $op->{KFD}, " from pty '", $op->{PTY_ID}, "'",
#                    ) if _debugging_details;
#
#                    for my $source ( $op->{SOURCE} ) {
#                        if ( UNIVERSAL::isa( $source, 'SCALAR' ) ) {
#                            _debug(
#                                "kid ",                   $kid->{NUM},   " to read ", $op->{KFD},
#                                " from SCALAR via pty '", $op->{PTY_ID}, "'"
#                            ) if _debugging_details;
#
#                            my $s = '';
#                            $op->{KIN_REF} = \$s;
#                        }
#                        elsif ( UNIVERSAL::isa( $source, 'CODE' ) ) {
#                            _debug(
#                                "kid ",                 $kid->{NUM},   " to read ", $op->{KFD},
#                                " from CODE via pty '", $op->{PTY_ID}, "'"
#                            ) if _debugging_details;
#                            my $s = '';
#                            $op->{KIN_REF} = \$s;
#                        }
#                        else {
#                            croak( "'" . ref($source) . "' not allowed as a source for '<pty<' redirection" );
#                        }
#                    }
#                    $op->{FD}  = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
#                    $op->{TFD} = undef;                                      
#                    $op->_init_filters;
#                }
#                elsif ( $op->{TYPE} eq '>' ) {
#                    my $dest = $op->{DEST};
#                    if ( !ref $dest ) {
#                        _debug(
#                            "kid ",  $kid->{NUM}, " to write ", $op->{KFD},
#                            " to '", $dest,       "' (write only, create, ",
#                            ( $op->{TRUNC} ? 'truncate' : 'append' ),
#                            ")"
#                        ) if _debugging_details;
#                        croak "simulated open failure"
#                          if $self->{_simulate_open_failure};
#                        $op->{TFD} = _sysopen(
#                            $dest,
#                            ( O_WRONLY | O_CREAT | ( $op->{TRUNC} ? O_TRUNC : O_APPEND ) )
#                        );
#                        if (Win32_MODE) {
#                            POSIX::lseek( $op->{TFD}, 0, POSIX::SEEK_END() );
#                        }
#                        push @close_on_fail, $op->{TFD};
#                    }
#                    elsif ( UNIVERSAL::isa( $dest, 'GLOB' ) ) {
#                        croak("Unopened filehandle in output redirect, command $kid->{NUM}") unless defined fileno $dest;
#                        my $old_fh = select($dest);
#                        $| = 1;
#                        select($old_fh);
#                        $op->{TFD} = fileno $dest;
#                        _debug( 'kid to write ', $op->{KFD}, ' to handle ', $op->{TFD} ) if _debugging_details;
#                    }
#                    elsif ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
#                        _debug( "kid ", $kid->{NUM}, " to write $op->{KFD} to SCALAR" ) if _debugging_details;
#
#                        $op->open_pipe( $self->_debug_fd );
#                        push @close_on_fail, $op->{FD}, $op->{TFD};
#                        $$dest = '' if $op->{TRUNC};
#                    }
#                    elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
#                        _debug("kid $kid->{NUM} to write $op->{KFD} to CODE") if _debugging_details;
#
#                        $op->open_pipe( $self->_debug_fd );
#                        push @close_on_fail, $op->{FD}, $op->{TFD};
#                    }
#                    else {
#                        croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
#                    }
#                    $output_fds_accum[ $op->{KFD} ] = $op;
#                    $op->_init_filters;
#                }
#
#                elsif ( $op->{TYPE} eq '>pipe' ) {
#                    _debug(
#                        "kid ", $kid->{NUM}, " to write ", $op->{KFD},
#                        ' to a pipe IPC::Run opens and returns'
#                    ) if _debugging_details;
#
#                    my ( $r, $w ) = $op->open_pipe( $self->_debug_fd, $op->{DEST} );
#                    _debug "caller will read from ", fileno $op->{DEST}
#                      if _debugging_details;
#
#                    $op->{TFD} = $w;
#                    $op->{FD}  = undef;    
#                    $op->_init_filters;
#
#                    $output_fds_accum[ $op->{KFD} ] = $op;
#                }
#                elsif ( $op->{TYPE} eq '>pty>' ) {
#                    my $dest = $op->{DEST};
#                    if ( UNIVERSAL::isa( $dest, 'SCALAR' ) ) {
#                        _debug(
#                            "kid ",                 $kid->{NUM},   " to write ", $op->{KFD},
#                            " to SCALAR via pty '", $op->{PTY_ID}, "'"
#                        ) if _debugging_details;
#
#                        $$dest = '' if $op->{TRUNC};
#                    }
#                    elsif ( UNIVERSAL::isa( $dest, 'CODE' ) ) {
#                        _debug(
#                            "kid ",               $kid->{NUM},   " to write ", $op->{KFD},
#                            " to CODE via pty '", $op->{PTY_ID}, "'"
#                        ) if _debugging_details;
#                    }
#                    else {
#                        croak( "'" . ref($dest) . "' not allowed as a sink for output redirection" );
#                    }
#
#                    $op->{FD}                       = $self->{PTYS}->{ $op->{PTY_ID} }->fileno;
#                    $op->{TFD}                      = undef;                                      
#                    $output_fds_accum[ $op->{KFD} ] = $op;
#                    $op->_init_filters;
#                }
#                elsif ( $op->{TYPE} eq '|' ) {
#                    _debug( "pipelining $kid->{NUM} and " . ( $kid->{NUM} + 1 ) ) if _debugging_details;
#                    ( $pipe_read_fd, $op->{TFD} ) = _pipe;
#                    if (Win32_MODE) {
#                        _dont_inherit($pipe_read_fd);
#                        _dont_inherit( $op->{TFD} );
#                    }
#                    @output_fds_accum = ();
#                }
#                elsif ( $op->{TYPE} eq '&' ) {
#                    @output_fds_accum = ();
#                }    
#                1;
#            };    
#            unless ($ok) {
#                push @errs, $@;
#                _debug 'caught ', $@ if _debugging;
#            }
#        }    
#    }
#
#    if (@errs) {
#        for (@close_on_fail) {
#            _close($_);
#            $_ = undef;
#        }
#        for ( keys %{ $self->{PTYS} } ) {
#            next unless $self->{PTYS}->{$_};
#            close $self->{PTYS}->{$_};
#            $self->{PTYS}->{$_} = undef;
#        }
#        die join( '', @errs );
#    }
#
#    for ( my $num = 0; $num < $#{ $self->{KIDS} }; ++$num ) {
#        for ( reverse @output_fds_accum ) {
#            next unless defined $_;
#            _debug(
#                'kid ', $self->{KIDS}->[$num]->{NUM}, ' also to write ', $_->{KFD},
#                ' to ', ref $_->{DEST}
#            ) if _debugging_details;
#            unshift @{ $self->{KIDS}->[$num]->{OPS} }, $_;
#        }
#    }
#
#    @{ $self->{PIPES} } = ();
#    $self->{RIN} = '';
#    $self->{WIN} = '';
#    $self->{EIN} = '';
#    $self->{PIN} = '';
#    for my $kid ( @{ $self->{KIDS} } ) {
#        for ( @{ $kid->{OPS} } ) {
#            if ( defined $_->{FD} ) {
#                _debug(
#                    'kid ',    $kid->{NUM}, '[', $kid->{PID}, "]'s ", $_->{KFD},
#                    ' is my ', $_->{FD}
#                ) if _debugging_details;
#                vec( $self->{ $_->{TYPE} =~ /^</ ? 'WIN' : 'RIN' }, $_->{FD}, 1 ) = 1;
#
#                push @{ $self->{PIPES} }, $_;
#            }
#        }
#    }
#
#    for my $io ( @{ $self->{IOS} } ) {
#        my $fd = $io->fileno;
#        vec( $self->{RIN}, $fd, 1 ) = 1 if $io->mode =~ /r/;
#        vec( $self->{WIN}, $fd, 1 ) = 1 if $io->mode =~ /w/;
#
#        push @{ $self->{PIPES} }, $io;
#    }
#
#    for my $pipe ( @{ $self->{PIPES} } ) {
#        $pipe->{SOURCE_EMPTY} = 0;
#        $pipe->{PAUSED}       = 0;
#        if ( $pipe->{TYPE} =~ /^>/ ) {
#            my $pipe_reader = sub {
#                my ( undef, $out_ref ) = @_;
#
#                return undef unless defined $pipe->{FD};
#                return 0 unless vec( $self->{ROUT}, $pipe->{FD}, 1 );
#
#                vec( $self->{ROUT}, $pipe->{FD}, 1 ) = 0;
#
#                _debug_desc_fd( 'reading from', $pipe ) if _debugging_details;
#                my $in = eval { _read( $pipe->{FD} ) };
#                if ($@) {
#                    $in = '';
#                    die $@
#                      unless $@ =~ $_EIO
#                      || ( $@ =~ /input or output/ && $^O =~ /aix/ )
#                      || ( Win32_MODE && $@ =~ /Bad file descriptor/ );
#                }
#
#                unless ( length $in ) {
#                    $self->_clobber($pipe);
#                    return undef;
#                }
#
#                my $pos = pos $$out_ref;
#                $$out_ref .= $in;
#                pos($$out_ref) = $pos;
#                return 1;
#            };
#            push @{ $pipe->{FILTERS} },      $pipe_reader;
#            push @{ $self->{TEMP_FILTERS} }, $pipe_reader;
#        }
#        else {
#            my $pipe_writer = sub {
#                my ( $in_ref, $out_ref ) = @_;
#                return undef unless defined $pipe->{FD};
#                return 0
#                  unless vec( $self->{WOUT}, $pipe->{FD}, 1 )
#                  || $pipe->{PAUSED};
#
#                vec( $self->{WOUT}, $pipe->{FD}, 1 ) = 0;
#
#                if ( !length $$in_ref ) {
#                    if ( !defined get_more_input ) {
#                        $self->_clobber($pipe);
#                        return undef;
#                    }
#                }
#
#                unless ( length $$in_ref ) {
#                    unless ( $pipe->{PAUSED} ) {
#                        _debug_desc_fd( 'pausing', $pipe ) if _debugging_details;
#                        vec( $self->{WIN}, $pipe->{FD}, 1 ) = 0;
#
#                        vec( $self->{PIN}, $pipe->{FD}, 1 ) = 1;
#                        $pipe->{PAUSED} = 1;
#                    }
#                    return 0;
#                }
#                _debug_desc_fd( 'writing to', $pipe ) if _debugging_details;
#
#                my $c = _write( $pipe->{FD}, $$in_ref );
#                substr( $$in_ref, 0, $c, '' );
#                return 1;
#            };
#            unshift @{ $pipe->{FILTERS} }, $pipe_writer;
#            push @{ $self->{TEMP_FILTERS} }, $pipe_writer;
#        }
#    }
#}
#
#sub _dup2_gently {
#    my IPC::Run $self = shift;
#    my ( $files, $fd1, $fd2 ) = @_;
#    for (@$files) {
#        next unless defined $_->{TFD};
#        $_->{TFD} = _dup( $_->{TFD} ) if $_->{TFD} == $fd2;
#    }
#    $self->{DEBUG_FD} = _dup $self->{DEBUG_FD}
#      if defined $self->{DEBUG_FD} && $self->{DEBUG_FD} == $fd2;
#
#    _dup2_rudely( $fd1, $fd2 );
#}
#
#
#sub close_terminal {
#
#    POSIX::setsid() || croak "POSIX::setsid() failed";
#    _debug "closing stdin, out, err"
#      if _debugging_details;
#    close STDIN;
#    close STDERR;
#    close STDOUT;
#}
#
#sub _do_kid_and_exit {
#    my IPC::Run $self = shift;
#    my ($kid) = @_;
#
#    my ( $s1, $s2 );
#    if ( $] < 5.008 ) {
#        $s1 = Symbol::gensym();
#        $s2 = Symbol::gensym();
#    }
#
#    eval {
#        local $cur_self = $self;
#
#        if (_debugging) {
#            _set_child_debug_name(
#                ref $kid->{VAL} eq "CODE"
#                ? "CODE"
#                : basename( $kid->{VAL}->[0] )
#            );
#        }
#
#        my @needed = $self->{noinherit} ? () : ( 1, 1, 1 );
#        $needed[ $self->{SYNC_WRITER_FD} ] = 1;
#        $needed[ $self->{DEBUG_FD} ] = 1 if defined $self->{DEBUG_FD};
#
#        for ( @{ $kid->{OPS} } ) {
#            $needed[ $_->{TFD} ] = 1 if defined $_->{TFD};
#        }
#
#        my @closed;
#        if ( %{ $self->{PTYS} } ) {
#            for ( keys %{ $self->{PTYS} } ) {
#                _debug "Cleaning up parent's ptty '$_'" if _debugging_details;
#                my $slave = $self->{PTYS}->{$_}->slave;
#                $closed[ $self->{PTYS}->{$_}->fileno ] = 1;
#                close $self->{PTYS}->{$_};
#                $self->{PTYS}->{$_} = $slave;
#            }
#
#            close_terminal;
#            $closed[$_] = 1 for ( 0 .. 2 );
#        }
#
#        for my $sibling ( @{ $self->{KIDS} } ) {
#            for ( @{ $sibling->{OPS} } ) {
#                if ( $_->{TYPE} =~ /^.pty.$/ ) {
#                    $_->{TFD} = $self->{PTYS}->{ $_->{PTY_ID} }->fileno;
#                    $needed[ $_->{TFD} ] = 1;
#                }
#
#            }
#        }
#
#        _debug "open fds: ", join " ", keys %fds if _debugging_details;
#        for ( keys %fds ) {
#            if ( !$closed[$_] && !$needed[$_] ) {
#                _close($_);
#                $closed[$_] = 1;
#            }
#        }
#
#        my @lazy_close;
#        for ( @{ $kid->{OPS} } ) {
#            if ( defined $_->{TFD} ) {
#                unless ( $_->{TFD} == $_->{KFD} ) {
#                    $self->_dup2_gently( $kid->{OPS}, $_->{TFD}, $_->{KFD} );
#                    push @lazy_close, $_->{TFD};
#                }
#            }
#            elsif ( $_->{TYPE} eq 'dup' ) {
#                $self->_dup2_gently( $kid->{OPS}, $_->{KFD1}, $_->{KFD2} )
#                  unless $_->{KFD1} == $_->{KFD2};
#            }
#            elsif ( $_->{TYPE} eq 'close' ) {
#                for ( $_->{KFD} ) {
#                    if ( !$closed[$_] ) {
#                        _close($_);
#                        $closed[$_] = 1;
#                        $_ = undef;
#                    }
#                }
#            }
#            elsif ( $_->{TYPE} eq 'init' ) {
#                $_->{SUB}->();
#            }
#        }
#
#        for (@lazy_close) {
#            unless ( $closed[$_] ) {
#                _close($_);
#                $closed[$_] = 1;
#            }
#        }
#
#        if ( ref $kid->{VAL} ne 'CODE' ) {
#            open $s1, ">&=$self->{SYNC_WRITER_FD}"
#              or croak "$! setting filehandle to fd SYNC_WRITER_FD";
#            fcntl $s1, F_SETFD, 1;
#
#            if ( defined $self->{DEBUG_FD} ) {
#                open $s2, ">&=$self->{DEBUG_FD}"
#                  or croak "$! setting filehandle to fd DEBUG_FD";
#                fcntl $s2, F_SETFD, 1;
#            }
#
#            if (_debugging) {
#                my @cmd = ( $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] );
#                _debug 'execing ', join " ", map { /[\s\"]/ ? "'$_'" : $_ } @cmd;
#            }
#
#            die "exec failed: simulating exec() failure"
#              if $self->{_simulate_exec_failure};
#
#            _exec $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ];
#
#            croak "exec failed: $!";
#        }
#    };
#    if ($@) {
#        _write $self->{SYNC_WRITER_FD}, $@;
#        POSIX::exit 1;
#    }
#
#    _close $self->{SYNC_WRITER_FD};
#    _debug 'calling fork()ed CODE ref' if _debugging;
#    POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
#    $kid->{VAL}->();
#
#    $kid->{VAL} = undef;
#
#    POSIX::exit 0;
#}
#
#
#sub start {
#
#    my $options;
#    if ( @_ && ref $_[-1] eq 'HASH' ) {
#        $options = pop;
#        require Data::Dumper;
#        carp "Passing in options as a hash is deprecated:\n", Data::Dumper::Dumper($options);
#    }
#
#    my IPC::Run $self;
#    if ( @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ ) ) {
#        $self = shift;
#        $self->{$_} = $options->{$_} for keys %$options;
#    }
#    else {
#        $self = harness( @_, $options ? $options : () );
#    }
#
#    local $cur_self = $self;
#
#    $self->kill_kill if $self->{STATE} == _started;
#
#    _debug "** starting" if _debugging;
#
#    $_->{RESULT} = undef for @{ $self->{KIDS} };
#
#    $self->{clear_ins} = 1;
#
#    IPC::Run::Win32Helper::optimize $self
#      if Win32_MODE && $in_run;
#
#    my @errs;
#
#    for ( @{ $self->{TIMERS} } ) {
#        eval { $_->start };
#        if ($@) {
#            push @errs, $@;
#            _debug 'caught ', $@ if _debugging;
#        }
#    }
#
#    eval { $self->_open_pipes };
#    if ($@) {
#        push @errs, $@;
#        _debug 'caught ', $@ if _debugging;
#    }
#
#    if ( !@errs ) {
#        { my $ofh = select STDOUT; my $of = $|; $| = 1; $| = $of; select $ofh; }
#        { my $ofh = select STDERR; my $of = $|; $| = 1; $| = $of; select $ofh; }
#        for my $kid ( @{ $self->{KIDS} } ) {
#            $kid->{RESULT} = undef;
#            _debug "child: ",
#              ref( $kid->{VAL} ) eq "CODE"
#              ? "CODE ref"
#              : (
#                "`",
#                join( " ", map /[^\w.-]/ ? "'$_'" : $_, @{ $kid->{VAL} } ),
#                "`"
#              ) if _debugging_details;
#            eval {
#                croak "simulated failure of fork"
#                  if $self->{_simulate_fork_failure};
#                unless (Win32_MODE) {
#                    $self->_spawn($kid);
#                }
#                else {
#                    _debug(
#                        'spawning ',
#                        join(
#                            ' ',
#                            map( "'$_'",
#                                ( $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] ) )
#                        )
#                    ) if _debugging;
#                    _dont_inherit( $self->{DEBUG_FD} );
#                    ( $kid->{PID}, $kid->{PROCESS} ) = IPC::Run::Win32Helper::win32_spawn(
#                        [ $kid->{PATH}, @{ $kid->{VAL} }[ 1 .. $#{ $kid->{VAL} } ] ],
#                        $kid->{OPS},
#                    );
#                    _debug "spawn() = ", $kid->{PID} if _debugging;
#                }
#            };
#            if ($@) {
#                push @errs, $@;
#                _debug 'caught ', $@ if _debugging;
#            }
#        }
#    }
#
#    for my $pty ( values %{ $self->{PTYS} } ) {
#        close $pty->slave;
#    }
#
#    my @closed;
#    for my $kid ( @{ $self->{KIDS} } ) {
#        for ( @{ $kid->{OPS} } ) {
#            my $close_it = eval {
#                     defined $_->{TFD}
#                  && !$_->{DONT_CLOSE}
#                  && !$closed[ $_->{TFD} ]
#                  && ( !Win32_MODE || !$_->{RECV_THROUGH_TEMP_FILE} )    
#            };
#            if ($@) {
#                push @errs, $@;
#                _debug 'caught ', $@ if _debugging;
#            }
#            if ( $close_it || $@ ) {
#                eval {
#                    _close( $_->{TFD} );
#                    $closed[ $_->{TFD} ] = 1;
#                    $_->{TFD} = undef;
#                };
#                if ($@) {
#                    push @errs, $@;
#                    _debug 'caught ', $@ if _debugging;
#                }
#            }
#        }
#    }
#    confess "gak!" unless defined $self->{PIPES};
#
#    if (@errs) {
#        eval { $self->_cleanup };
#        warn $@ if $@;
#        die join( '', @errs );
#    }
#
#    $self->{STATE} = _started;
#    return $self;
#}
#
#
#sub adopt {
#    my IPC::Run $self = shift;
#
#    for my $adoptee (@_) {
#        push @{ $self->{IOS} }, @{ $adoptee->{IOS} };
#        push @{ $self->{KIDS} },  @{ $adoptee->{KIDS} };
#        push @{ $self->{PIPES} }, @{ $adoptee->{PIPES} };
#        $self->{PTYS}->{$_} = $adoptee->{PTYS}->{$_} for keys %{ $adoptee->{PYTS} };
#        push @{ $self->{TIMERS} }, @{ $adoptee->{TIMERS} };
#        $adoptee->{STATE} = _finished;
#    }
#}
#
#sub _clobber {
#    my IPC::Run $self = shift;
#    my ($file) = @_;
#    _debug_desc_fd( "closing", $file ) if _debugging_details;
#    my $doomed = $file->{FD};
#    my $dir = $file->{TYPE} =~ /^</ ? 'WIN' : 'RIN';
#    vec( $self->{$dir}, $doomed, 1 ) = 0;
#
#    vec( $self->{PIN}, $doomed, 1 ) = 0;
#    if ( $file->{TYPE} =~ /^(.)pty.$/ ) {
#        if ( $1 eq '>' ) {
#            _debug_desc_fd "closing pty", $file if _debugging_details;
#            close $self->{PTYS}->{ $file->{PTY_ID} }
#              if defined $self->{PTYS}->{ $file->{PTY_ID} };
#            $self->{PTYS}->{ $file->{PTY_ID} } = undef;
#        }
#    }
#    elsif ( UNIVERSAL::isa( $file, 'IPC::Run::IO' ) ) {
#        $file->close unless $file->{DONT_CLOSE};
#    }
#    else {
#        _close($doomed);
#    }
#
#    @{ $self->{PIPES} } = grep
#      defined $_->{FD} && ( $_->{TYPE} ne $file->{TYPE} || $_->{FD} ne $doomed ),
#      @{ $self->{PIPES} };
#
#    $file->{FD} = undef;
#}
#
#sub _select_loop {
#    my IPC::Run $self = shift;
#
#    my $io_occurred;
#
#    my $not_forever = 0.01;
#
#  SELECT:
#    while ( $self->pumpable ) {
#        if ( $io_occurred && $self->{break_on_io} ) {
#            _debug "exiting _select(): io occurred and break_on_io set"
#              if _debugging_details;
#            last;
#        }
#
#        my $timeout = $self->{non_blocking} ? 0 : undef;
#
#        if ( @{ $self->{TIMERS} } ) {
#            my $now = time;
#            my $time_left;
#            for ( @{ $self->{TIMERS} } ) {
#                next unless $_->is_running;
#                $time_left = $_->check($now);
#                return if defined $time_left && !$time_left;
#                $timeout = $time_left
#                  if !defined $timeout || $time_left < $timeout;
#            }
#        }
#
#        my $paused = 0;
#
#        for my $file ( @{ $self->{PIPES} } ) {
#            next unless $file->{PAUSED} && $file->{TYPE} =~ /^</;
#
#            _debug_desc_fd( "checking for more input", $file ) if _debugging_details;
#            my $did;
#            1 while $did = $file->_do_filters($self);
#            if ( defined $file->{FD} && !defined($did) || $did ) {
#                _debug_desc_fd( "unpausing", $file ) if _debugging_details;
#                $file->{PAUSED} = 0;
#                vec( $self->{WIN}, $file->{FD}, 1 ) = 1;
#
#                vec( $self->{PIN}, $file->{FD}, 1 ) = 0;
#            }
#            else {
#                ++$paused;
#            }
#        }
#
#        if (_debugging_details) {
#            my $map = join(
#                '',
#                map {
#                    my $out;
#                    $out = 'r' if vec( $self->{RIN}, $_, 1 );
#                    $out = $out ? 'b' : 'w' if vec( $self->{WIN}, $_, 1 );
#                    $out = 'p' if !$out && vec( $self->{PIN}, $_, 1 );
#                    $out = $out ? uc($out) : 'x' if vec( $self->{EIN}, $_, 1 );
#                    $out = '-' unless $out;
#                    $out;
#                } ( 0 .. 1024 )
#            );
#            $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
#            _debug 'fds for select: ', $map if _debugging_details;
#        }
#
#        my $p = $self->pumpable;
#        last unless $p;
#        if ( $p != 0 && ( !defined $timeout || $timeout > 0.1 ) ) {
#            $timeout = $not_forever;
#            $not_forever *= 2;
#            $not_forever = 0.5 if $not_forever >= 0.5;
#        }
#
#        if ( !defined $timeout && !( @{ $self->{PIPES} } - $paused ) ) {
#            if ( $self->{break_on_io} ) {
#                _debug "exiting _select(): no I/O to do and timeout=forever"
#                  if _debugging;
#                last;
#            }
#
#            $timeout = $not_forever;
#            $not_forever *= 2;
#            $not_forever = 0.5 if $not_forever >= 0.5;
#        }
#
#        _debug 'timeout=', defined $timeout ? $timeout : 'forever'
#          if _debugging_details;
#
#        my $nfound;
#        unless (Win32_MODE) {
#            $nfound = select(
#                $self->{ROUT} = $self->{RIN},
#                $self->{WOUT} = $self->{WIN},
#                $self->{EOUT} = $self->{EIN},
#                $timeout
#            );
#        }
#        else {
#            my @in = map $self->{$_}, qw( RIN WIN EIN );
#            for (@in) {
#                $_ = undef unless index( ( unpack "b*", $_ ), 1 ) >= 0;
#            }
#
#            $nfound = select(
#                $self->{ROUT} = $in[0],
#                $self->{WOUT} = $in[1],
#                $self->{EOUT} = $in[2],
#                $timeout
#            );
#
#            for ( $self->{ROUT}, $self->{WOUT}, $self->{EOUT} ) {
#                $_ = "" unless defined $_;
#            }
#        }
#        last if !$nfound && $self->{non_blocking};
#
#        if ( $nfound < 0 ) {
#            if ( $! == POSIX::EINTR() ) {
#
#                $self->{ROUT} = $self->{WOUT} = $self->{EOUT} = '';
#                $nfound = 0;
#            }
#            else {
#                croak "$! in select";
#            }
#        }
#
#        if (_debugging_details) {
#            my $map = join(
#                '',
#                map {
#                    my $out;
#                    $out = 'r' if vec( $self->{ROUT}, $_, 1 );
#                    $out = $out ? 'b'      : 'w' if vec( $self->{WOUT}, $_, 1 );
#                    $out = $out ? uc($out) : 'x' if vec( $self->{EOUT}, $_, 1 );
#                    $out = '-' unless $out;
#                    $out;
#                } ( 0 .. 128 )
#            );
#            $map =~ s/((?:[a-zA-Z-]|\([^\)]*\)){12,}?)-*$/$1/;
#            _debug "selected  ", $map;
#        }
#
#        my @pipes = @{ $self->{PIPES} };
#        $io_occurred = $_->poll($self) ? 1 : $io_occurred for @pipes;
#
#    }
#
#    return;
#}
#
#sub _cleanup {
#    my IPC::Run $self = shift;
#    _debug "cleaning up" if _debugging_details;
#
#    for ( values %{ $self->{PTYS} } ) {
#        next unless ref $_;
#        eval {
#            _debug "closing slave fd ", fileno $_->slave if _debugging_data;
#            close $_->slave;
#        };
#        carp $@ . " while closing ptys" if $@;
#        eval {
#            _debug "closing master fd ", fileno $_ if _debugging_data;
#            close $_;
#        };
#        carp $@ . " closing ptys" if $@;
#    }
#
#    _debug "cleaning up pipes" if _debugging_details;
#    $self->_clobber( $self->{PIPES}->[0] ) while @{ $self->{PIPES} };
#
#    for my $kid ( @{ $self->{KIDS} } ) {
#        _debug "cleaning up kid ", $kid->{NUM} if _debugging_details;
#        if ( !length $kid->{PID} ) {
#            _debug 'never ran child ', $kid->{NUM}, ", can't reap"
#              if _debugging;
#            for my $op ( @{ $kid->{OPS} } ) {
#                _close( $op->{TFD} )
#                  if defined $op->{TFD} && !defined $op->{TEMP_FILE_HANDLE};
#            }
#        }
#        elsif ( !defined $kid->{RESULT} ) {
#            _debug 'reaping child ', $kid->{NUM}, ' (pid ', $kid->{PID}, ')'
#              if _debugging;
#            my $pid = waitpid $kid->{PID}, 0;
#            $kid->{RESULT} = $?;
#            _debug 'reaped ', $pid, ', $?=', $kid->{RESULT}
#              if _debugging;
#        }
#
#
#        _debug "cleaning up filters" if _debugging_details;
#        for my $op ( @{ $kid->{OPS} } ) {
#            @{ $op->{FILTERS} } = grep {
#                my $filter = $_;
#                !grep $filter == $_, @{ $self->{TEMP_FILTERS} };
#            } @{ $op->{FILTERS} };
#        }
#
#        for my $op ( @{ $kid->{OPS} } ) {
#            $op->_cleanup($self) if UNIVERSAL::isa( $op, "IPC::Run::IO" );
#        }
#    }
#    $self->{STATE} = _finished;
#    @{ $self->{TEMP_FILTERS} } = ();
#    _debug "done cleaning up" if _debugging_details;
#
#    POSIX::close $self->{DEBUG_FD} if defined $self->{DEBUG_FD};
#    $self->{DEBUG_FD} = undef;
#}
#
#
#sub pump {
#    die "pump() takes only a single harness as a parameter"
#      unless @_ == 1 && UNIVERSAL::isa( $_[0], __PACKAGE__ );
#
#    my IPC::Run $self = shift;
#
#    local $cur_self = $self;
#
#    _debug "** pumping"
#      if _debugging;
#
#    $self->start if $self->{STATE} < _started;
#    croak "process ended prematurely" unless $self->pumpable;
#
#    $self->{auto_close_ins} = 0;
#    $self->{break_on_io}    = 1;
#    $self->_select_loop;
#    return $self->pumpable;
#
#}
#
#
#sub pump_nb {
#    my IPC::Run $self = shift;
#
#    $self->{non_blocking} = 1;
#    my $r = eval { $self->pump };
#    $self->{non_blocking} = 0;
#    die $@ if $@;
#    return $r;
#}
#
#
#sub pumpable {
#    my IPC::Run $self = shift;
#
#    return -1 if grep !$_->{PAUSED}, @{ $self->{PIPES} };
#
#    $self->reap_nb;
#    return 0 unless $self->_running_kids;
#
#    select undef, undef, undef, 0.0001;
#
#    $self->reap_nb;
#    return 0 unless $self->_running_kids;
#
#    return -1;    
#}
#
#sub _running_kids {
#    my IPC::Run $self = shift;
#    return grep
#      defined $_->{PID} && !defined $_->{RESULT},
#      @{ $self->{KIDS} };
#}
#
#
#my $still_runnings;
#
#sub reap_nb {
#    my IPC::Run $self = shift;
#
#    local $cur_self = $self;
#
#    for my $kid ( @{ $self->{KIDS} } ) {
#        if (Win32_MODE) {
#            next if !defined $kid->{PROCESS} || defined $kid->{RESULT};
#            unless ( $kid->{PROCESS}->Wait(0) ) {
#                _debug "kid $kid->{NUM} ($kid->{PID}) still running"
#                  if _debugging_details;
#                next;
#            }
#
#            _debug "kid $kid->{NUM} ($kid->{PID}) exited"
#              if _debugging;
#
#            $kid->{PROCESS}->GetExitCode( $kid->{RESULT} )
#              or croak "$! while GetExitCode()ing for Win32 process";
#
#            unless ( defined $kid->{RESULT} ) {
#                $kid->{RESULT} = "0 but true";
#                $? = $kid->{RESULT} = 0x0F;
#            }
#            else {
#                $? = $kid->{RESULT} << 8;
#            }
#        }
#        else {
#            next if !defined $kid->{PID} || defined $kid->{RESULT};
#            my $pid = waitpid $kid->{PID}, POSIX::WNOHANG();
#            unless ($pid) {
#                _debug "$kid->{NUM} ($kid->{PID}) still running"
#                  if _debugging_details;
#                next;
#            }
#
#            if ( $pid < 0 ) {
#                _debug "No such process: $kid->{PID}\n" if _debugging;
#                $kid->{RESULT} = "unknown result, unknown PID";
#            }
#            else {
#                _debug "kid $kid->{NUM} ($kid->{PID}) exited"
#                  if _debugging;
#
#                confess "waitpid returned the wrong PID: $pid instead of $kid->{PID}"
#                  unless $pid == $kid->{PID};
#                _debug "$kid->{PID} returned $?\n" if _debugging;
#                $kid->{RESULT} = $?;
#            }
#        }
#    }
#}
#
#
#sub finish {
#    my IPC::Run $self = shift;
#    my $options = @_ && ref $_[-1] eq 'HASH' ? pop : {};
#
#    local $cur_self = $self;
#
#    _debug "** finishing" if _debugging;
#
#    $self->{non_blocking}   = 0;
#    $self->{auto_close_ins} = 1;
#    $self->{break_on_io}    = 0;
#
#
#    while ( $self->pumpable ) {
#        $self->_select_loop($options);
#    }
#    $self->_cleanup;
#
#    return !$self->full_result;
#}
#
#
#sub _assert_finished {
#    my IPC::Run $self = $_[0];
#
#    croak "Harness not run" unless $self->{STATE} >= _finished;
#    croak "Harness not finished running" unless $self->{STATE} == _finished;
#}
#
#sub result {
#    &_assert_finished;
#    my IPC::Run $self = shift;
#
#    if (@_) {
#        my ($which) = @_;
#        croak(
#            "Only ",
#            scalar( @{ $self->{KIDS} } ),
#            " child processes, no process $which"
#        ) unless $which >= 0 && $which <= $#{ $self->{KIDS} };
#        return $self->{KIDS}->[$which]->{RESULT} >> 8;
#    }
#    else {
#        return undef unless @{ $self->{KIDS} };
#        for ( @{ $self->{KIDS} } ) {
#            return $_->{RESULT} >> 8 if $_->{RESULT} >> 8;
#        }
#    }
#}
#
#
#sub results {
#    &_assert_finished;
#    my IPC::Run $self = shift;
#
#    return map { ( 0 + $_->{RESULT} ) >> 8 } @{ $self->{KIDS} };
#}
#
#
#sub full_result {
#    goto &result if @_ > 1;
#    &_assert_finished;
#
#    my IPC::Run $self = shift;
#
#    return undef unless @{ $self->{KIDS} };
#    for ( @{ $self->{KIDS} } ) {
#        return $_->{RESULT} if $_->{RESULT};
#    }
#}
#
#
#sub full_results {
#    &_assert_finished;
#    my IPC::Run $self = shift;
#
#    croak "Harness not run" unless $self->{STATE} >= _finished;
#    croak "Harness not finished running" unless $self->{STATE} == _finished;
#
#    return map $_->{RESULT}, @{ $self->{KIDS} };
#}
#
#use vars (
#    '$filter_op',     
#    '$filter_num',    
#);
#
#
#
#sub binary(;$) {
#    my $enable = @_ ? shift : 1;
#    return bless sub { $enable }, "IPC::Run::binmode_pseudo_filter";
#}
#
#
#sub new_chunker(;$) {
#    my ($re) = @_;
#    $re = $/ if _empty $re;
#    $re = quotemeta($re) unless ref $re eq 'Regexp';
#    $re = qr/\A(.*?$re)/s;
#
#    return sub {
#        my ( $in_ref, $out_ref ) = @_;
#
#        return 0 if length $$out_ref;
#
#        return input_avail && do {
#            while (1) {
#                if ( $$in_ref =~ s/$re// ) {
#                    $$out_ref .= $1;
#                    return 1;
#                }
#                my $hmm = get_more_input;
#                unless ( defined $hmm ) {
#                    $$out_ref = $$in_ref;
#                    $$in_ref  = '';
#                    return length $$out_ref ? 1 : 0;
#                }
#                return 0 if $hmm eq 0;
#            }
#          }
#    };
#}
#
#
#sub new_appender($) {
#    my ($suffix) = @_;
#    croak "\$suffix undefined" unless defined $suffix;
#
#    return sub {
#        my ( $in_ref, $out_ref ) = @_;
#
#        return input_avail && do {
#            $$out_ref = join( '', $$out_ref, $$in_ref, $suffix );
#            $$in_ref = '';
#            1;
#          }
#    };
#}
#
#
#sub new_string_source {
#    my $ref;
#    if ( @_ > 1 ) {
#        $ref = [@_],
#    }
#    else {
#        $ref = shift;
#    }
#
#    return ref $ref eq 'SCALAR'
#      ? sub {
#        my ( $in_ref, $out_ref ) = @_;
#
#        return defined $$ref
#          ? do {
#            $$out_ref .= $$ref;
#            my $r = length $$ref ? 1 : 0;
#            $$ref = undef;
#            $r;
#          }
#          : undef;
#      }
#      : sub {
#        my ( $in_ref, $out_ref ) = @_;
#
#        return @$ref
#          ? do {
#            my $s = shift @$ref;
#            $$out_ref .= $s;
#            length $s ? 1 : 0;
#          }
#          : undef;
#      }
#}
#
#
#sub new_string_sink {
#    my ($string_ref) = @_;
#
#    return sub {
#        my ( $in_ref, $out_ref ) = @_;
#
#        return input_avail && do {
#            $$string_ref .= $$in_ref;
#            $$in_ref = '';
#            1;
#          }
#    };
#}
#
#
#
#sub io {
#    require IPC::Run::IO;
#    IPC::Run::IO->new(@_);
#}
#
#
#sub timer;
#*timer = \&IPC::Run::Timer::timer;
#
#
#sub timeout;
#*timeout = \&IPC::Run::Timer::timeout;
#
#
#sub input_avail() {
#    confess "Undefined FBUF ref for $filter_num+1"
#      unless defined $filter_op->{FBUFS}->[ $filter_num + 1 ];
#    length ${ $filter_op->{FBUFS}->[ $filter_num + 1 ] } || get_more_input;
#}
#
#
#sub get_more_input() {
#    ++$filter_num;
#    my $r = eval {
#        confess "get_more_input() called and no more filters in chain"
#          unless defined $filter_op->{FILTERS}->[$filter_num];
#        $filter_op->{FILTERS}->[$filter_num]->(
#            $filter_op->{FBUFS}->[ $filter_num + 1 ],
#            $filter_op->{FBUFS}->[$filter_num],
#        );    
#    };
#    --$filter_num;
#    die $@ if $@;
#    return $r;
#}
#
#1;
#
### IPC/Run/Debug.pm ###
#package IPC::Run::Debug;
#
#
#
#use strict;
#use Exporter;
#use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK %EXPORT_TAGS};
#
#BEGIN {
#    $VERSION = '0.96';
#    @ISA     = qw( Exporter );
#    @EXPORT  = qw(
#      _debug
#      _debug_desc_fd
#      _debugging
#      _debugging_data
#      _debugging_details
#      _debugging_gory_details
#      _debugging_not_optimized
#      _set_child_debug_name
#    );
#
#    @EXPORT_OK = qw(
#      _debug_init
#      _debugging_level
#      _map_fds
#    );
#    %EXPORT_TAGS = (
#        default => \@EXPORT,
#        all => [ @EXPORT, @EXPORT_OK ],
#    );
#}
#
#my $disable_debugging = defined $ENV{IPCRUNDEBUG}
#  && ( !$ENV{IPCRUNDEBUG}
#    || lc $ENV{IPCRUNDEBUG} eq "none" );
#
#eval( $disable_debugging ? <<'STUBS' : <<'SUBS' ) or die $@;
#sub _map_fds()                 { "" }
#sub _debug                     {}
#sub _debug_desc_fd             {}
#sub _debug_init                {}
#sub _set_child_debug_name      {}
#sub _debugging()               { 0 }
#sub _debugging_level()         { 0 }
#sub _debugging_data()          { 0 }
#sub _debugging_details()       { 0 }
#sub _debugging_gory_details()  { 0 }
#sub _debugging_not_optimized() { 0 }
#
#1;
#STUBS
#
#use POSIX ();
#
#sub _map_fds {
#   my $map = '';
#   my $digit = 0;
#   my $in_use;
#   my $dummy;
#   for my $fd (0..63) {
#      ## I'd like a quicker way (less user, cpu & especially sys and kernel
#      ## calls) to detect open file descriptors.  Let me know...
#      ## Hmmm, could do a 0 length read and check for bad file descriptor...
#      ## but that segfaults on Win32
#      my $test_fd = POSIX::dup( $fd );
#      $in_use = defined $test_fd;
#      POSIX::close $test_fd if $in_use;
#      $map .= $in_use ? $digit : '-';
#      $digit = 0 if ++$digit > 9;
#   }
#   warn "No fds open???" unless $map =~ /\d/;
#   $map =~ s/(.{1,12})-*$/$1/;
#   return $map;
#}
#
#use vars qw( $parent_pid );
#
#$parent_pid = $$;
#
### TODO: move debugging to its own module and make it compile-time
### optimizable.
#
### Give kid process debugging nice names
#my $debug_name;
#
#sub _set_child_debug_name {
#   $debug_name = shift;
#}
#
### There's a bit of hackery going on here.
###
### We want to have any code anywhere be able to emit
### debugging statements without knowing what harness the code is
### being called in/from, since we'd need to pass a harness around to
### everything.
###
### Thus, $cur_self was born.
##
#my %debug_levels = (
#   none    => 0,
#   basic   => 1,
#   data    => 2,
#   details => 3,
#   gore           => 4,
#   gory_details   => 4,
#   "gory details" => 4,
#   gory           => 4,
#   gorydetails    => 4,
#   all     => 10,
#   notopt  => 0,
#);
#
#my $warned;
#
#sub _debugging_level() {
#   my $level = 0;
#
#   $level = $IPC::Run::cur_self->{debug} || 0
#      if $IPC::Run::cur_self
#         && ( $IPC::Run::cur_self->{debug} || 0 ) >= $level;
#
#   if ( defined $ENV{IPCRUNDEBUG} ) {
#      my $v = $ENV{IPCRUNDEBUG};
#      $v = $debug_levels{lc $v} if $v =~ /[a-zA-Z]/;
#      unless ( defined $v ) {
#	 $warned ||= warn "Unknown debug level $ENV{IPCRUNDEBUG}, assuming 'basic' (1)\n";
#	 $v = 1;
#      }
#      $level = $v if $v > $level;
#   }
#   return $level;
#}
#
#sub _debugging_atleast($) {
#   my $min_level = shift || 1;
#
#   my $level = _debugging_level;
#   
#   return $level >= $min_level ? $level : 0;
#}
#
#sub _debugging()               { _debugging_atleast 1 }
#sub _debugging_data()          { _debugging_atleast 2 }
#sub _debugging_details()       { _debugging_atleast 3 }
#sub _debugging_gory_details()  { _debugging_atleast 4 }
#sub _debugging_not_optimized() { ( $ENV{IPCRUNDEBUG} || "" ) eq "notopt" }
#
#sub _debug_init {
#   ## This routine is called only in spawned children to fake out the
#   ## debug routines so they'll emit debugging info.
#   $IPC::Run::cur_self = {};
#   (  $parent_pid,
#      $^T, 
#      $IPC::Run::cur_self->{debug}, 
#      $IPC::Run::cur_self->{DEBUG_FD}, 
#      $debug_name 
#   ) = @_;
#}
#
#
#sub _debug {
##   return unless _debugging || _debugging_not_optimized;
#
#   my $fd = defined &IPC::Run::_debug_fd
#      ? IPC::Run::_debug_fd()
#      : fileno STDERR;
#
#   my $s;
#   my $debug_id;
#   $debug_id = join( 
#      " ",
#      join(
#         "",
#         defined $IPC::Run::cur_self ? "#$IPC::Run::cur_self->{ID}" : (),
#         "($$)",
#      ),
#      defined $debug_name && length $debug_name ? $debug_name        : (),
#   );
#   my $prefix = join(
#      "",
#      "IPC::Run",
#      sprintf( " %04d", time - $^T ),
#      ( _debugging_details ? ( " ", _map_fds ) : () ),
#      length $debug_id ? ( " [", $debug_id, "]" ) : (),
#      ": ",
#   );
#
#   my $msg = join( '', map defined $_ ? $_ : "<undef>", @_ );
#   chomp $msg;
#   $msg =~ s{^}{$prefix}gm;
#   $msg .= "\n";
#   POSIX::write( $fd, $msg, length $msg );
#}
#
#
#my @fd_descs = ( 'stdin', 'stdout', 'stderr' );
#
#sub _debug_desc_fd {
#   return unless _debugging;
#   my $text = shift;
#   my $op = pop;
#   my $kid = $_[0];
#
#Carp::carp join " ", caller(0), $text, $op  if defined $op  && UNIVERSAL::isa( $op, "IO::Pty" );
#
#   _debug(
#      $text,
#      ' ',
#      ( defined $op->{FD}
#         ? $op->{FD} < 3
#            ? ( $fd_descs[$op->{FD}] )
#            : ( 'fd ', $op->{FD} )
#         : $op->{FD}
#      ),
#      ( defined $op->{KFD}
#         ? (
#            ' (kid',
#            ( defined $kid ? ( ' ', $kid->{NUM}, ) : () ),
#            "'s ",
#            ( $op->{KFD} < 3
#               ? $fd_descs[$op->{KFD}]
#               : defined $kid
#                  && defined $kid->{DEBUG_FD}
#                  && $op->{KFD} == $kid->{DEBUG_FD}
#                  ? ( 'debug (', $op->{KFD}, ')' )
#                  : ( 'fd ', $op->{KFD} )
#            ),
#            ')',
#         )
#         : ()
#      ),
#   );
#}
#
#1;
#
#SUBS
#
### IPC/Run/IO.pm ###
#package IPC::Run::IO;
#
#
#
#use strict;
#use Carp;
#use Fcntl;
#use Symbol;
#
#use IPC::Run::Debug;
#use IPC::Run qw( Win32_MODE );
#
#use vars qw{$VERSION};
#
#BEGIN {
#    $VERSION = '0.96';
#    if (Win32_MODE) {
#        eval "use IPC::Run::Win32Helper; require IPC::Run::Win32IO; 1"
#          or ( $@ && die )
#          or die "$!";
#    }
#}
#
#sub _empty($);
#*_empty = \&IPC::Run::_empty;
#
#
#sub new {
#    my $class = shift;
#    $class = ref $class || $class;
#
#    my ( $external, $type, $internal ) = ( shift, shift, pop );
#
#    croak "$class: '$_' is not a valid I/O operator"
#      unless $type =~ /^(?:<<?|>>?)$/;
#
#    my IPC::Run::IO $self = $class->_new_internal( $type, undef, undef, $internal, undef, @_ );
#
#    if ( !ref $external ) {
#        $self->{FILENAME} = $external;
#    }
#    elsif ( ref eq 'GLOB' || UNIVERSAL::isa( $external, 'IO::Handle' ) ) {
#        $self->{HANDLE}     = $external;
#        $self->{DONT_CLOSE} = 1;
#    }
#    else {
#        croak "$class: cannot accept " . ref($external) . " to do I/O with";
#    }
#
#    return $self;
#}
#
#sub _new_internal {
#    my $class = shift;
#    $class = ref $class || $class;
#
#    $class = "IPC::Run::Win32IO"
#      if Win32_MODE && $class eq "IPC::Run::IO";
#
#    my IPC::Run::IO $self;
#    $self = bless {}, $class;
#
#    my ( $type, $kfd, $pty_id, $internal, $binmode, @filters ) = @_;
#
#    $self->{TYPE}   = $type;
#    $self->{KFD}    = $kfd;
#    $self->{PTY_ID} = $pty_id;
#    $self->binmode($binmode);
#    $self->{FILTERS} = [@filters];
#
#    if ( $self->op =~ />/ ) {
#        croak "'$_' missing a destination" if _empty $internal;
#        $self->{DEST} = $internal;
#        if ( UNIVERSAL::isa( $self->{DEST}, 'CODE' ) ) {
#            unshift(
#                @{ $self->{FILTERS} },
#                sub {
#                    my ($in_ref) = @_;
#
#                    return IPC::Run::input_avail() && do {
#                        $self->{DEST}->($$in_ref);
#                        $$in_ref = '';
#                        1;
#                      }
#                }
#            );
#        }
#    }
#    else {
#        croak "'$_' missing a source" if _empty $internal;
#        $self->{SOURCE} = $internal;
#        if ( UNIVERSAL::isa( $internal, 'CODE' ) ) {
#            push(
#                @{ $self->{FILTERS} },
#                sub {
#                    my ( $in_ref, $out_ref ) = @_;
#                    return 0 if length $$out_ref;
#
#                    return undef
#                      if $self->{SOURCE_EMPTY};
#
#                    my $in = $internal->();
#                    unless ( defined $in ) {
#                        $self->{SOURCE_EMPTY} = 1;
#                        return undef;
#                    }
#                    return 0 unless length $in;
#                    $$out_ref = $in;
#
#                    return 1;
#                }
#            );
#        }
#        elsif ( UNIVERSAL::isa( $internal, 'SCALAR' ) ) {
#            push(
#                @{ $self->{FILTERS} },
#                sub {
#                    my ( $in_ref, $out_ref ) = @_;
#                    return 0 if length $$out_ref;
#
#                    return $self->{HARNESS}->{auto_close_ins} ? undef : 0
#                      if IPC::Run::_empty ${ $self->{SOURCE} }
#                      || $self->{SOURCE_EMPTY};
#
#                    $$out_ref = $$internal;
#                    eval { $$internal = '' }
#                      if $self->{HARNESS}->{clear_ins};
#
#                    $self->{SOURCE_EMPTY} = $self->{HARNESS}->{auto_close_ins};
#
#                    return 1;
#                }
#            );
#        }
#    }
#
#    return $self;
#}
#
#
#sub filename {
#    my IPC::Run::IO $self = shift;
#    $self->{FILENAME} = shift if @_;
#    return $self->{FILENAME};
#}
#
#
#sub init {
#    my IPC::Run::IO $self = shift;
#
#    $self->{SOURCE_EMPTY} = 0;
#    ${ $self->{DEST} } = ''
#      if $self->mode =~ /r/ && ref $self->{DEST} eq 'SCALAR';
#
#    $self->open if defined $self->filename;
#    $self->{FD} = $self->fileno;
#
#    if ( !$self->{FILTERS} ) {
#        $self->{FBUFS} = undef;
#    }
#    else {
#        @{ $self->{FBUFS} } = map {
#            my $s = "";
#            \$s;
#        } ( @{ $self->{FILTERS} }, '' );
#
#        $self->{FBUFS}->[0] = $self->{DEST}
#          if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
#        push @{ $self->{FBUFS} }, $self->{SOURCE};
#    }
#
#    return undef;
#}
#
#
#my %open_flags = (
#    '>'  => O_RDONLY,
#    '>>' => O_RDONLY,
#    '<'  => O_WRONLY | O_CREAT | O_TRUNC,
#    '<<' => O_WRONLY | O_CREAT | O_APPEND,
#);
#
#sub open {
#    my IPC::Run::IO $self = shift;
#
#    croak "IPC::Run::IO: Can't open() a file with no name"
#      unless defined $self->{FILENAME};
#    $self->{HANDLE} = gensym unless $self->{HANDLE};
#
#    _debug "opening '", $self->filename, "' mode '", $self->mode, "'"
#      if _debugging_data;
#    sysopen(
#        $self->{HANDLE},
#        $self->filename,
#        $open_flags{ $self->op },
#    ) or croak "IPC::Run::IO: $! opening '$self->{FILENAME}', mode '" . $self->mode . "'";
#
#    return undef;
#}
#
#
#sub _do_open {
#    my $self = shift;
#    my ( $child_debug_fd, $parent_handle ) = @_;
#
#    if ( $self->dir eq "<" ) {
#        ( $self->{TFD}, $self->{FD} ) = IPC::Run::_pipe_nb;
#        if ($parent_handle) {
#            CORE::open $parent_handle, ">&=$self->{FD}"
#              or croak "$! duping write end of pipe for caller";
#        }
#    }
#    else {
#        ( $self->{FD}, $self->{TFD} ) = IPC::Run::_pipe;
#        if ($parent_handle) {
#            CORE::open $parent_handle, "<&=$self->{FD}"
#              or croak "$! duping read end of pipe for caller";
#        }
#    }
#}
#
#sub open_pipe {
#    my IPC::Run::IO $self = shift;
#
#    croak "IPC::Run::IO: Can't pipe() when a file name has been set"
#      if defined $self->{FILENAME};
#
#    $self->_do_open(@_);
#
#    return $self->dir eq "<"
#      ? ( $self->{TFD}, $self->{FD} )
#      : ( $self->{FD}, $self->{TFD} );
#}
#
#sub _cleanup {    
#    my $self = shift;
#    undef $self->{FAKE_PIPE};
#}
#
#
#sub close {
#    my IPC::Run::IO $self = shift;
#
#    if ( defined $self->{HANDLE} ) {
#        close $self->{HANDLE}
#          or croak(
#            "IPC::Run::IO: $! closing "
#              . (
#                defined $self->{FILENAME}
#                ? "'$self->{FILENAME}'"
#                : "handle"
#              )
#          );
#    }
#    else {
#        IPC::Run::_close( $self->{FD} );
#    }
#
#    $self->{FD} = undef;
#
#    return undef;
#}
#
#
#sub fileno {
#    my IPC::Run::IO $self = shift;
#
#    my $fd = fileno $self->{HANDLE};
#    croak(
#        "IPC::Run::IO: $! "
#          . (
#            defined $self->{FILENAME}
#            ? "'$self->{FILENAME}'"
#            : "handle"
#          )
#    ) unless defined $fd;
#
#    return $fd;
#}
#
#
#sub mode {
#    my IPC::Run::IO $self = shift;
#
#    croak "IPC::Run::IO: unexpected arguments for mode(): @_" if @_;
#
#    return ( $self->{TYPE} =~ /</ ? 'w' : 'r' ) . ( $self->{TYPE} =~ /<<|>>/ ? 'a' : '' );
#}
#
#
#sub op {
#    my IPC::Run::IO $self = shift;
#
#    croak "IPC::Run::IO: unexpected arguments for op(): @_" if @_;
#
#    return $self->{TYPE};
#}
#
#
#sub binmode {
#    my IPC::Run::IO $self = shift;
#
#    $self->{BINMODE} = shift if @_;
#
#    return $self->{BINMODE};
#}
#
#
#sub dir {
#    my IPC::Run::IO $self = shift;
#
#    croak "IPC::Run::IO: unexpected arguments for dir(): @_" if @_;
#
#    return substr $self->{TYPE}, 0, 1;
#}
#
#
#use vars (
#    '$filter_op',    
#    '$filter_num'    
#);
#
#sub _init_filters {
#    my IPC::Run::IO $self = shift;
#
#    confess "\$self not an IPC::Run::IO" unless UNIVERSAL::isa( $self, "IPC::Run::IO" );
#    $self->{FBUFS} = [];
#
#    $self->{FBUFS}->[0] = $self->{DEST}
#      if $self->{DEST} && ref $self->{DEST} eq 'SCALAR';
#
#    return unless $self->{FILTERS} && @{ $self->{FILTERS} };
#
#    push @{ $self->{FBUFS} }, map {
#        my $s = "";
#        \$s;
#    } ( @{ $self->{FILTERS} }, '' );
#
#    push @{ $self->{FBUFS} }, $self->{SOURCE};
#}
#
#
#sub poll {
#    my IPC::Run::IO $self = shift;
#    my ($harness) = @_;
#
#    if ( defined $self->{FD} ) {
#        my $d = $self->dir;
#        if ( $d eq "<" ) {
#            if ( vec $harness->{WOUT}, $self->{FD}, 1 ) {
#                _debug_desc_fd( "filtering data to", $self )
#                  if _debugging_details;
#                return $self->_do_filters($harness);
#            }
#        }
#        elsif ( $d eq ">" ) {
#            if ( vec $harness->{ROUT}, $self->{FD}, 1 ) {
#                _debug_desc_fd( "filtering data from", $self )
#                  if _debugging_details;
#                return $self->_do_filters($harness);
#            }
#        }
#    }
#    return 0;
#}
#
#sub _do_filters {
#    my IPC::Run::IO $self = shift;
#
#    ( $self->{HARNESS} ) = @_;
#
#    my ( $saved_op, $saved_num ) = ( $IPC::Run::filter_op, $IPC::Run::filter_num );
#    $IPC::Run::filter_op  = $self;
#    $IPC::Run::filter_num = -1;
#    my $redos = 0;
#    my $r;
#    {
#        $@ = '';
#        $r = eval { IPC::Run::get_more_input(); };
#
#        if ( ( $@ || '' ) =~ $IPC::Run::_EAGAIN && $redos++ < 200 ) {
#            select( undef, undef, undef, 0.01 );
#            redo;
#        }
#    }
#    ( $IPC::Run::filter_op, $IPC::Run::filter_num ) = ( $saved_op, $saved_num );
#    $self->{HARNESS} = undef;
#    die "ack ", $@ if $@;
#    return $r;
#}
#
#
#1;
### IPC/Run/Timer.pm ###
#package IPC::Run::Timer;
#
#
#use strict;
#use Carp;
#use Fcntl;
#use Symbol;
#use Exporter;
#use Scalar::Util ();
#use vars qw( $VERSION @ISA @EXPORT_OK %EXPORT_TAGS );
#
#BEGIN {
#    $VERSION   = '0.96';
#    @ISA       = qw( Exporter );
#    @EXPORT_OK = qw(
#      check
#      end_time
#      exception
#      expire
#      interval
#      is_expired
#      is_reset
#      is_running
#      name
#      reset
#      start
#      timeout
#      timer
#    );
#
#    %EXPORT_TAGS = ( 'all' => \@EXPORT_OK );
#}
#
#require IPC::Run;
#use IPC::Run::Debug;
#
#my $resolution = 1;
#
#sub _parse_time {
#    for ( $_[0] ) {
#        my $val;
#        if ( not defined $_ ) {
#            $val = $_;
#        }
#        else {
#            my @f = split( /:/, $_, -1 );
#            if ( scalar @f > 4 ) {
#                croak "IPC::Run: expected <= 4 elements in time string '$_'";
#            }
#            for (@f) {
#                if ( not Scalar::Util::looks_like_number($_) ) {
#                    croak "IPC::Run: non-numeric element '$_' in time string '$_'";
#                }
#            }
#            my ( $s, $m, $h, $d ) = reverse @f;
#            $val = ( ( ( $d || 0 ) * 24 + ( $h || 0 ) ) * 60 + ( $m || 0 ) ) * 60 + ( $s || 0 );
#        }
#        return $val;
#    }
#}
#
#sub _calc_end_time {
#    my IPC::Run::Timer $self = shift;
#    my $interval = $self->interval;
#    $interval += $resolution if $interval;
#    $self->end_time( $self->start_time + $interval );
#}
#
#
#sub timer {
#    return IPC::Run::Timer->new(@_);
#}
#
#
#sub timeout {
#    my $t = IPC::Run::Timer->new(@_);
#    $t->exception( "IPC::Run: timeout on " . $t->name )
#      unless defined $t->exception;
#    return $t;
#}
#
#
#my $timer_counter;
#
#sub new {
#    my $class = shift;
#    $class = ref $class || $class;
#
#    my IPC::Run::Timer $self = bless {}, $class;
#
#    $self->{STATE} = 0;
#    $self->{DEBUG} = 0;
#    $self->{NAME}  = "timer #" . ++$timer_counter;
#
#    while (@_) {
#        my $arg = shift;
#        if ( $arg eq 'exception' ) {
#            $self->exception(shift);
#        }
#        elsif ( $arg eq 'name' ) {
#            $self->name(shift);
#        }
#        elsif ( $arg eq 'debug' ) {
#            $self->debug(shift);
#        }
#        else {
#            $self->interval($arg);
#        }
#    }
#
#    _debug $self->name . ' constructed'
#      if $self->{DEBUG} || _debugging_details;
#
#    return $self;
#}
#
#
#sub check {
#    my IPC::Run::Timer $self = shift;
#    return undef if !$self->is_running;
#    return 0     if $self->is_expired;
#
#    my ($now) = @_;
#    $now = _parse_time($now);
#    $now = time unless defined $now;
#
#    _debug( "checking ", $self->name, " (end time ", $self->end_time, ") at ", $now ) if $self->{DEBUG} || _debugging_details;
#
#    my $left = $self->end_time - $now;
#    return $left if $left > 0;
#
#    $self->expire;
#    return 0;
#}
#
#
#sub debug {
#    my IPC::Run::Timer $self = shift;
#    $self->{DEBUG} = shift if @_;
#    return $self->{DEBUG};
#}
#
#
#sub end_time {
#    my IPC::Run::Timer $self = shift;
#    if (@_) {
#        $self->{END_TIME} = shift;
#        _debug $self->name, ' end_time set to ', $self->{END_TIME}
#          if $self->{DEBUG} > 2 || _debugging_details;
#    }
#    return $self->{END_TIME};
#}
#
#
#sub exception {
#    my IPC::Run::Timer $self = shift;
#    if (@_) {
#        $self->{EXCEPTION} = shift;
#        _debug $self->name, ' exception set to ', $self->{EXCEPTION}
#          if $self->{DEBUG} || _debugging_details;
#    }
#    return $self->{EXCEPTION};
#}
#
#
#sub interval {
#    my IPC::Run::Timer $self = shift;
#    if (@_) {
#        $self->{INTERVAL} = _parse_time(shift);
#        _debug $self->name, ' interval set to ', $self->{INTERVAL}
#          if $self->{DEBUG} > 2 || _debugging_details;
#
#        $self->_calc_end_time if $self->state;
#    }
#    return $self->{INTERVAL};
#}
#
#
#sub expire {
#    my IPC::Run::Timer $self = shift;
#    if ( defined $self->state ) {
#        _debug $self->name . ' expired'
#          if $self->{DEBUG} || _debugging;
#
#        $self->state(undef);
#        croak $self->exception if $self->exception;
#    }
#    return undef;
#}
#
#
#sub is_running {
#    my IPC::Run::Timer $self = shift;
#    return $self->state ? 1 : 0;
#}
#
#
#sub is_reset {
#    my IPC::Run::Timer $self = shift;
#    return defined $self->state && $self->state == 0;
#}
#
#
#sub is_expired {
#    my IPC::Run::Timer $self = shift;
#    return !defined $self->state;
#}
#
#
#sub name {
#    my IPC::Run::Timer $self = shift;
#
#    $self->{NAME} = shift if @_;
#    return
#        defined $self->{NAME}      ? $self->{NAME}
#      : defined $self->{EXCEPTION} ? 'timeout'
#      :                              'timer';
#}
#
#
#sub reset {
#    my IPC::Run::Timer $self = shift;
#    $self->state(0);
#    $self->end_time(undef);
#    _debug $self->name . ' reset'
#      if $self->{DEBUG} || _debugging;
#
#    return undef;
#}
#
#
#sub start {
#    my IPC::Run::Timer $self = shift;
#
#    my ( $interval, $now ) = map { _parse_time($_) } @_;
#    $now = _parse_time($now);
#    $now = time unless defined $now;
#
#    $self->interval($interval) if defined $interval;
#
#    $self->end_time(undef) if !$self->is_reset || $interval;
#
#    croak "IPC::Run: no timer interval or end_time defined for " . $self->name
#      unless defined $self->interval || defined $self->end_time;
#
#    $self->state(1);
#    $self->start_time($now);
#    $self->_calc_end_time
#      unless defined $self->end_time;
#
#    _debug(
#        $self->name, " started at ", $self->start_time,
#        ", with interval ", $self->interval, ", end_time ", $self->end_time
#    ) if $self->{DEBUG} || _debugging;
#    return undef;
#}
#
#
#sub start_time {
#    my IPC::Run::Timer $self = shift;
#    if (@_) {
#        $self->{START_TIME} = _parse_time(shift);
#        _debug $self->name, ' start_time set to ', $self->{START_TIME}
#          if $self->{DEBUG} > 2 || _debugging;
#    }
#
#    return $self->{START_TIME};
#}
#
#
#sub state {
#    my IPC::Run::Timer $self = shift;
#    if (@_) {
#        $self->{STATE} = shift;
#        _debug $self->name, ' state set to ', $self->{STATE}
#          if $self->{DEBUG} > 2 || _debugging;
#    }
#    return $self->{STATE};
#}
#
#1;
#
### IPC/Run/Win32Helper.pm ###
#package IPC::Run::Win32Helper;
#
#
#use strict;
#use Carp;
#use IO::Handle;
#use vars qw{ $VERSION @ISA @EXPORT };
#
#BEGIN {
#    $VERSION = '0.96';
#    @ISA     = qw( Exporter );
#    @EXPORT  = qw(
#      win32_spawn
#      win32_parse_cmd_line
#      _dont_inherit
#      _inherit
#    );
#}
#
#require POSIX;
#
#use Text::ParseWords;
#use Win32::Process;
#use IPC::Run::Debug;
#use Win32API::File qw(
#  FdGetOsFHandle
#  SetHandleInformation
#  HANDLE_FLAG_INHERIT
#  INVALID_HANDLE_VALUE
#);
#
#sub _dont_inherit {
#    for (@_) {
#        next unless defined $_;
#        my $fd = $_;
#        $fd = fileno $fd if ref $fd;
#        _debug "disabling inheritance of ", $fd if _debugging_details;
#        my $osfh = FdGetOsFHandle $fd;
#        croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;
#
#        SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 0 );
#    }
#}
#
#sub _inherit {    
#    for (@_) {    
#        next unless defined $_;    
#        my $fd = $_;               
#        $fd = fileno $fd if ref $fd;    
#        _debug "enabling inheritance of ", $fd if _debugging_details;    
#        my $osfh = FdGetOsFHandle $fd;                                   
#        croak $^E if !defined $osfh || $osfh == INVALID_HANDLE_VALUE;    
#        SetHandleInformation( $osfh, HANDLE_FLAG_INHERIT, 1 );           
#    }    
#}    
#
#
#sub optimize {
#    my ($h) = @_;
#
#    my @kids = @{ $h->{KIDS} };
#
#    my $saw_pipe;
#
#    my ( $ok_to_optimize_outputs, $veto_output_optimization );
#
#    for my $kid (@kids) {
#        ( $ok_to_optimize_outputs, $veto_output_optimization ) = ()
#          unless $saw_pipe;
#
#        _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over ok of non-SCALAR output optimization"
#          if _debugging_details && $ok_to_optimize_outputs;
#        _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN piped, carrying over veto of non-SCALAR output optimization"
#          if _debugging_details && $veto_output_optimization;
#
#        if ( $h->{noinherit} && !$ok_to_optimize_outputs ) {
#            _debug "Win32 optimizer: (kid $kid->{NUM}) STDIN not inherited from parent oking non-SCALAR output optimization"
#              if _debugging_details && $ok_to_optimize_outputs;
#            $ok_to_optimize_outputs = 1;
#        }
#
#        for ( @{ $kid->{OPS} } ) {
#            if ( substr( $_->{TYPE}, 0, 1 ) eq "<" ) {
#                if ( $_->{TYPE} eq "<" ) {
#                    if ( @{ $_->{FILTERS} } > 1 ) {
#                    }
#                    elsif (ref $_->{SOURCE} eq "SCALAR"
#                        || ref $_->{SOURCE} eq "GLOB"
#                        || UNIVERSAL::isa( $_, "IO::Handle" ) ) {
#                        if ( $_->{KFD} == 0 ) {
#                            _debug
#                              "Win32 optimizer: (kid $kid->{NUM}) 0$_->{TYPE}",
#                              ref $_->{SOURCE},
#                              ", ok to optimize outputs"
#                              if _debugging_details;
#                            $ok_to_optimize_outputs = 1;
#                        }
#                        $_->{SEND_THROUGH_TEMP_FILE} = 1;
#                        next;
#                    }
#                    elsif ( !ref $_->{SOURCE} && defined $_->{SOURCE} ) {
#                        if ( $_->{KFD} == 0 ) {
#                            _debug
#                              "Win32 optimizer: (kid $kid->{NUM}) 0<$_->{SOURCE}, ok to optimize outputs",
#                              if _debugging_details;
#                            $ok_to_optimize_outputs = 1;
#                        }
#                        next;
#                    }
#                }
#                _debug
#                  "Win32 optimizer: (kid $kid->{NUM}) ",
#                  $_->{KFD},
#                  $_->{TYPE},
#                  defined $_->{SOURCE}
#                  ? ref $_->{SOURCE}
#                      ? ref $_->{SOURCE}
#                      : $_->{SOURCE}
#                  : defined $_->{FILENAME} ? $_->{FILENAME}
#                  : "",
#                  @{ $_->{FILTERS} } > 1 ? " with filters" : (),
#                  ", VETOING output opt."
#                  if _debugging_details || _debugging_not_optimized;
#                $veto_output_optimization = 1;
#            }
#            elsif ( $_->{TYPE} eq "close" && $_->{KFD} == 0 ) {
#                $ok_to_optimize_outputs = 1;
#                _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&-, ok to optimize outputs"
#                  if _debugging_details;
#            }
#            elsif ( $_->{TYPE} eq "dup" && $_->{KFD2} == 0 ) {
#                $veto_output_optimization = 1;
#                _debug "Win32 optimizer: (kid $kid->{NUM}) saw 0<&$_->{KFD2}, VETOING output opt."
#                  if _debugging_details || _debugging_not_optimized;
#            }
#            elsif ( $_->{TYPE} eq "|" ) {
#                $saw_pipe = 1;
#            }
#        }
#
#        if ( !$ok_to_optimize_outputs && !$veto_output_optimization ) {
#            _debug "Win32 optimizer: (kid $kid->{NUM}) child STDIN not redirected, VETOING non-SCALAR output opt."
#              if _debugging_details || _debugging_not_optimized;
#            $veto_output_optimization = 1;
#        }
#
#        if ( $ok_to_optimize_outputs && $veto_output_optimization ) {
#            $ok_to_optimize_outputs = 0;
#            _debug "Win32 optimizer: (kid $kid->{NUM}) non-SCALAR output optimizations VETOed"
#              if _debugging_details || _debugging_not_optimized;
#        }
#
#
#        for ( @{ $kid->{OPS} } ) {
#            if ( $_->{TYPE} eq ">" ) {
#                if (
#                    ref $_->{DEST} eq "SCALAR"
#                    || (
#                        (
#                               @{ $_->{FILTERS} } > 1
#                            || ref $_->{DEST} eq "CODE"
#                            || ref $_->{DEST} eq "ARRAY"    
#                        )
#                        && ( $ok_to_optimize_outputs && !$veto_output_optimization )
#                    )
#                  ) {
#                    $_->{RECV_THROUGH_TEMP_FILE} = 1;
#                    next;
#                }
#                _debug
#                  "Win32 optimizer: NOT optimizing (kid $kid->{NUM}) ",
#                  $_->{KFD},
#                  $_->{TYPE},
#                  defined $_->{DEST}
#                  ? ref $_->{DEST}
#                      ? ref $_->{DEST}
#                      : $_->{SOURCE}
#                  : defined $_->{FILENAME} ? $_->{FILENAME}
#                  : "",
#                  @{ $_->{FILTERS} } ? " with filters" : (),
#                  if _debugging_details;
#            }
#        }
#    }
#
#}
#
#
#sub win32_parse_cmd_line {
#    my $line = shift;
#    $line =~ s{(\\[\w\s])}{\\$1}g;
#    return shellwords $line;
#}
#
#
#sub _save {
#    my ( $saved, $saved_as, $fd ) = @_;
#
#    return if exists $saved->{$fd};
#
#    my $saved_fd = IPC::Run::_dup($fd);
#    _dont_inherit $saved_fd;
#
#    $saved->{$fd}          = $saved_fd;
#    $saved_as->{$saved_fd} = $fd;
#
#    _dont_inherit $saved->{$fd};
#}
#
#sub _dup2_gently {
#    my ( $saved, $saved_as, $fd1, $fd2 ) = @_;
#    _save $saved, $saved_as, $fd2;
#
#    if ( exists $saved_as->{$fd2} ) {
#        my $orig_fd  = delete $saved_as->{$fd2};
#        my $saved_fd = IPC::Run::_dup($fd2);
#        _dont_inherit $saved_fd;
#
#        $saved->{$orig_fd}     = $saved_fd;
#        $saved_as->{$saved_fd} = $orig_fd;
#    }
#    _debug "moving $fd1 to kid's $fd2" if _debugging_details;
#    IPC::Run::_dup2_rudely( $fd1, $fd2 );
#}
#
#sub win32_spawn {
#    my ( $cmd, $ops ) = @_;
#
#
#    my %saved;       
#    my %saved_as;    
#
#    for my $op (@$ops) {
#        _dont_inherit $op->{FD} if defined $op->{FD};
#
#        if ( defined $op->{KFD} && $op->{KFD} > 2 ) {
#            croak "Can't redirect fd #", $op->{KFD}, " on Win32";
#        }
#
#        if ( defined $op->{TFD} ) {
#            unless ( $op->{TFD} == $op->{KFD} ) {
#                _dup2_gently \%saved, \%saved_as, $op->{TFD}, $op->{KFD};
#                _dont_inherit $op->{TFD};
#            }
#        }
#        elsif ( $op->{TYPE} eq "dup" ) {
#            _dup2_gently \%saved, \%saved_as, $op->{KFD1}, $op->{KFD2}
#              unless $op->{KFD1} == $op->{KFD2};
#        }
#        elsif ( $op->{TYPE} eq "close" ) {
#            _save \%saved, \%saved_as, $op->{KFD};
#            IPC::Run::_close( $op->{KFD} );
#        }
#        elsif ( $op->{TYPE} eq "init" ) {
#            croak "init subs not allowed on Win32";
#        }
#    }
#
#    my $process;
#    my $cmd_line = join " ", map {
#        ( my $s = $_ ) =~ s/"/"""/g;
#        $s = qq{"$s"} if /[\"\s]|^$/;
#        $s;
#    } @$cmd;
#
#    _debug "cmd line: ", $cmd_line
#      if _debugging;
#
#    Win32::Process::Create(
#        $process,
#        $cmd->[0],
#        $cmd_line,
#        1,    
#        NORMAL_PRIORITY_CLASS,
#        ".",
#    ) or croak "$!: Win32::Process::Create()";
#
#    for my $orig_fd ( keys %saved ) {
#        IPC::Run::_dup2_rudely( $saved{$orig_fd}, $orig_fd );
#        IPC::Run::_close( $saved{$orig_fd} );
#    }
#
#    return ( $process->GetProcessID(), $process );
#}
#
#1;
#
### IPC/Run/Win32IO.pm ###
#package IPC::Run::Win32IO;
#
#
#use strict;
#use Carp;
#use IO::Handle;
#use Socket;
#require POSIX;
#
#use vars qw{$VERSION};
#
#BEGIN {
#    $VERSION = '0.96';
#}
#
#use Socket qw( IPPROTO_TCP TCP_NODELAY );
#use Symbol;
#use Text::ParseWords;
#use Win32::Process;
#use IPC::Run::Debug qw( :default _debugging_level );
#use IPC::Run::Win32Helper qw( _inherit _dont_inherit );
#use Fcntl qw( O_TEXT O_RDONLY );
#
#use base qw( IPC::Run::IO );
#my @cleanup_fields;
#
#BEGIN {
#    @cleanup_fields = (
#        'SEND_THROUGH_TEMP_FILE',    
#        'RECV_THROUGH_TEMP_FILE',    
#        'TEMP_FILE_NAME',            
#
#        'PARENT_HANDLE',             
#        'PUMP_SOCKET_HANDLE',        
#        'PUMP_PIPE_HANDLE',          
#        'CHILD_HANDLE',              
#
#        'TEMP_FILE_HANDLE',          
#    );
#}
#
#use Win32API::File qw(
#  GetOsFHandle
#  OsFHandleOpenFd
#  OsFHandleOpen
#  FdGetOsFHandle
#  SetHandleInformation
#  SetFilePointer
#  HANDLE_FLAG_INHERIT
#  INVALID_HANDLE_VALUE
#
#  createFile
#  WriteFile
#  ReadFile
#  CloseHandle
#
#  FILE_ATTRIBUTE_TEMPORARY
#  FILE_FLAG_DELETE_ON_CLOSE
#  FILE_FLAG_WRITE_THROUGH
#
#  FILE_BEGIN
#);
#
#
#BEGIN {
#    () = (
#        SOL_SOCKET,
#        SO_REUSEADDR,
#        IPPROTO_TCP,
#        TCP_NODELAY,
#        HANDLE_FLAG_INHERIT,
#        INVALID_HANDLE_VALUE,
#    );
#}
#
#use constant temp_file_flags => ( FILE_ATTRIBUTE_TEMPORARY() | FILE_FLAG_DELETE_ON_CLOSE() | FILE_FLAG_WRITE_THROUGH() );
#
#my $tmp_file_counter;
#my $tmp_dir;
#
#sub _cleanup {
#    my IPC::Run::Win32IO $self = shift;
#    my ($harness) = @_;
#
#    $self->_recv_through_temp_file($harness)
#      if $self->{RECV_THROUGH_TEMP_FILE};
#
#    CloseHandle( $self->{TEMP_FILE_HANDLE} )
#      if defined $self->{TEMP_FILE_HANDLE};
#
#    close( $self->{CHILD_HANDLE} )
#      if defined $self->{CHILD_HANDLE};
#
#    $self->{$_} = undef for @cleanup_fields;
#}
#
#sub _create_temp_file {
#    my IPC::Run::Win32IO $self = shift;
#
#    unless ( defined $tmp_dir ) {
#        $tmp_dir = File::Spec->catdir( File::Spec->tmpdir, "IPC-Run.tmp" );
#
#        unless ( -d $tmp_dir ) {
#            mkdir $tmp_dir or croak "$!: $tmp_dir";
#        }
#    }
#
#    $self->{TEMP_FILE_NAME} = File::Spec->catfile(
#        $tmp_dir, sprintf "Win32io-%06d-%08d", $$, $tmp_file_counter++
#    );
#
#    $self->{TEMP_FILE_HANDLE} = createFile(
#        $self->{TEMP_FILE_NAME},
#        "trw",    
#        {
#            Flags => temp_file_flags,
#        },
#    ) or croak "Can't create temporary file, $self->{TEMP_FILE_NAME}: $^E";
#
#    $self->{TFD} = OsFHandleOpenFd $self->{TEMP_FILE_HANDLE}, 0;
#    $self->{FD} = undef;
#
#    _debug
#      "Win32 Optimizer: temp file (",
#      $self->{KFD},
#      $self->{TYPE},
#      $self->{TFD},
#      ", fh ",
#      $self->{TEMP_FILE_HANDLE},
#      "): ",
#      $self->{TEMP_FILE_NAME}
#      if _debugging_details;
#}
#
#sub _reset_temp_file_pointer {
#    my $self = shift;
#    SetFilePointer( $self->{TEMP_FILE_HANDLE}, 0, 0, FILE_BEGIN )
#      or confess "$^E seeking on (fd $self->{TFD}) $self->{TEMP_FILE_NAME} for kid's fd $self->{KFD}";
#}
#
#sub _send_through_temp_file {
#    my IPC::Run::Win32IO $self = shift;
#
#    _debug "Win32 optimizer: optimizing " . " $self->{KFD} $self->{TYPE} temp file instead of ",
#      ref $self->{SOURCE} || $self->{SOURCE}
#      if _debugging_details;
#
#    $self->_create_temp_file;
#
#    if ( defined ${ $self->{SOURCE} } ) {
#        my $bytes_written = 0;
#        my $data_ref;
#        if ( $self->binmode ) {
#            $data_ref = $self->{SOURCE};
#        }
#        else {
#            my $data = ${ $self->{SOURCE} };    
#            $data =~ s/(?<!\r)\n/\r\n/g;
#            $data_ref = \$data;
#        }
#
#        WriteFile(
#            $self->{TEMP_FILE_HANDLE},
#            $$data_ref,
#            0,                                  
#            $bytes_written,
#            [],                                 
#        ) or croak "$^E writing $self->{TEMP_FILE_NAME} for kid to read on fd $self->{KFD}";
#        _debug "Win32 optimizer: wrote $bytes_written to temp file $self->{TEMP_FILE_NAME}"
#          if _debugging_data;
#
#        $self->_reset_temp_file_pointer;
#
#    }
#
#    _debug "Win32 optimizer: kid to read $self->{KFD} from temp file on $self->{TFD}"
#      if _debugging_details;
#}
#
#sub _init_recv_through_temp_file {
#    my IPC::Run::Win32IO $self = shift;
#
#    $self->_create_temp_file;
#}
#
#sub _recv_through_temp_file {
#    my IPC::Run::Win32IO $self = shift;
#
#    return undef unless defined $self->{TEMP_FILE_HANDLE};
#
#    push @{ $self->{FILTERS} }, sub {
#        my ( undef, $out_ref ) = @_;
#
#        return undef unless defined $self->{TEMP_FILE_HANDLE};
#
#        my $r;
#        my $s;
#        ReadFile(
#            $self->{TEMP_FILE_HANDLE},
#            $s,
#            999_999,    
#            $r,
#            []
#        ) or croak "$^E reading from $self->{TEMP_FILE_NAME}";
#
#        _debug "ReadFile( $self->{TFD} ) = $r chars '$s'" if _debugging_data;
#
#        return undef unless $r;
#
#        $s =~ s/\r\n/\n/g unless $self->binmode;
#
#        my $pos = pos $$out_ref;
#        $$out_ref .= $s;
#        pos($out_ref) = $pos;
#        return 1;
#    };
#
#    my ($harness) = @_;
#
#    $self->_reset_temp_file_pointer;
#
#    1 while $self->_do_filters($harness);
#
#    pop @{ $self->{FILTERS} };
#
#    IPC::Run::_close( $self->{TFD} );
#}
#
#
#sub poll {
#    my IPC::Run::Win32IO $self = shift;
#
#    return if $self->{SEND_THROUGH_TEMP_FILE} || $self->{RECV_THROUGH_TEMP_FILE};
#
#    return $self->SUPER::poll(@_);
#}
#
#
#sub _spawn_pumper {
#    my ( $stdin, $stdout, $debug_fd, $binmode, $child_label, @opts ) = @_;
#    my ( $stdin_fd, $stdout_fd ) = ( fileno $stdin, fileno $stdout );
#
#    _debug "pumper stdin = ",  $stdin_fd  if _debugging_details;
#    _debug "pumper stdout = ", $stdout_fd if _debugging_details;
#    _inherit $stdin_fd, $stdout_fd, $debug_fd;
#    my @I_options = map qq{"-I$_"}, @INC;
#
#    my $cmd_line = join(
#        " ",
#        qq{"$^X"},
#        @I_options,
#        qw(-MIPC::Run::Win32Pump -e 1 ),
#        FdGetOsFHandle($stdin_fd),     
#        FdGetOsFHandle($stdout_fd),    
#        FdGetOsFHandle($debug_fd),     
#        $binmode ? 1 : 0,
#        $$, $^T, _debugging_level, qq{"$child_label"},
#        @opts
#    );
#
#
#    _debug "pump cmd line: ", $cmd_line if _debugging_details;
#
#    my $process;
#    Win32::Process::Create(
#        $process,
#        $^X,
#        $cmd_line,
#        1,    
#        NORMAL_PRIORITY_CLASS,
#        ".",
#    ) or croak "$!: Win32::Process::Create()";
#
#
#    close $stdin  or croak "$! closing pumper's stdin in parent";
#    close $stdout or croak "$! closing pumper's stdout in parent";
#
#
#
#    _debug "_spawn_pumper pid = ", $process->GetProcessID
#      if _debugging_data;
#}
#
#my $loopback  = inet_aton "127.0.0.1";
#my $tcp_proto = getprotobyname('tcp');
#croak "$!: getprotobyname('tcp')" unless defined $tcp_proto;
#
#sub _socket {
#    my ($server) = @_;
#    $server ||= gensym;
#    my $client = gensym;
#
#    my $listener = gensym;
#    socket $listener, PF_INET, SOCK_STREAM, $tcp_proto
#      or croak "$!: socket()";
#    setsockopt $listener, SOL_SOCKET, SO_REUSEADDR, pack( "l", 0 )
#      or croak "$!: setsockopt()";
#
#    unless ( bind $listener, sockaddr_in( 0, $loopback ) ) {
#        croak "Error binding: $!";
#    }
#
#    my ($port) = sockaddr_in( getsockname($listener) );
#
#    _debug "win32 port = $port" if _debugging_details;
#
#    listen $listener, my $queue_size = 1
#      or croak "$!: listen()";
#
#    {
#        socket $client, PF_INET, SOCK_STREAM, $tcp_proto
#          or croak "$!: socket()";
#
#        my $paddr = sockaddr_in( $port, $loopback );
#
#        connect $client, $paddr
#          or croak "$!: connect()";
#
#        croak "$!: accept" unless defined $paddr;
#
#        setsockopt $client, IPPROTO_TCP, TCP_NODELAY, pack( "l", 0 )
#          or croak "$!: setsockopt()";
#    }
#
#    {
#        _debug "accept()ing on port $port" if _debugging_details;
#        my $paddr = accept( $server, $listener );
#        croak "$!: accept()" unless defined $paddr;
#    }
#
#    _debug "win32 _socket = ( ", fileno $server, ", ", fileno $client, " ) on port $port"
#      if _debugging_details;
#    return ( $server, $client );
#}
#
#sub _open_socket_pipe {
#    my IPC::Run::Win32IO $self = shift;
#    my ( $debug_fd, $parent_handle ) = @_;
#
#    my $is_send_to_child = $self->dir eq "<";
#
#    $self->{CHILD_HANDLE}     = gensym;
#    $self->{PUMP_PIPE_HANDLE} = gensym;
#
#    (
#        $self->{PARENT_HANDLE},
#        $self->{PUMP_SOCKET_HANDLE}
#    ) = _socket $parent_handle;
#
#    binmode $self->{PARENT_HANDLE}      or die $!;
#    binmode $self->{PUMP_SOCKET_HANDLE} or die $!;
#
#    _debug "PUMP_SOCKET_HANDLE = ", fileno $self->{PUMP_SOCKET_HANDLE}
#      if _debugging_details;
#
#    if ($is_send_to_child) {
#        pipe $self->{CHILD_HANDLE}, $self->{PUMP_PIPE_HANDLE}
#          or croak "$! opening child pipe";
#        _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
#          if _debugging_details;
#        _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
#          if _debugging_details;
#    }
#    else {
#        pipe $self->{PUMP_PIPE_HANDLE}, $self->{CHILD_HANDLE}
#          or croak "$! opening child pipe";
#        _debug "CHILD_HANDLE = ", fileno $self->{CHILD_HANDLE}
#          if _debugging_details;
#        _debug "PUMP_PIPE_HANDLE = ", fileno $self->{PUMP_PIPE_HANDLE}
#          if _debugging_details;
#    }
#
#    binmode $self->{CHILD_HANDLE};
#    binmode $self->{PUMP_PIPE_HANDLE};
#
#    _dont_inherit $self->{PARENT_HANDLE};
#
#    _dont_inherit $self->{PUMP_SOCKET_HANDLE};
#    _dont_inherit $self->{PUMP_PIPE_HANDLE};
#    _dont_inherit $self->{CHILD_HANDLE};
#
#    my ( $parent_fd, $child_fd ) = (
#        fileno $self->{PARENT_HANDLE},
#        fileno $self->{CHILD_HANDLE}
#    );
#
#    _debug "binmode on" if _debugging_data && $self->binmode;
#    _spawn_pumper(
#        $is_send_to_child
#        ? ( $self->{PUMP_SOCKET_HANDLE}, $self->{PUMP_PIPE_HANDLE} )
#        : ( $self->{PUMP_PIPE_HANDLE}, $self->{PUMP_SOCKET_HANDLE} ),
#        $debug_fd,
#        $self->binmode,
#        $child_fd . $self->dir . "pump" . $self->dir . $parent_fd,
#    );
#
#    {
#        my $foo;
#        confess "PARENT_HANDLE no longer open"
#          unless POSIX::read( $parent_fd, $foo, 0 );
#    }
#
#    _debug "win32_fake_pipe = ( $parent_fd, $child_fd )"
#      if _debugging_details;
#
#    $self->{FD}  = $parent_fd;
#    $self->{TFD} = $child_fd;
#}
#
#sub _do_open {
#    my IPC::Run::Win32IO $self = shift;
#
#    if ( $self->{SEND_THROUGH_TEMP_FILE} ) {
#        return $self->_send_through_temp_file(@_);
#    }
#    elsif ( $self->{RECV_THROUGH_TEMP_FILE} ) {
#        return $self->_init_recv_through_temp_file(@_);
#    }
#    else {
#        return $self->_open_socket_pipe(@_);
#    }
#}
#
#1;
#
### IPC/Run/Win32Pump.pm ###
#package IPC::Run::Win32Pump;
#
#
#use strict;
#use vars qw{$VERSION};
#
#BEGIN {
#    $VERSION = '0.96';
#}
#
#use Win32API::File qw(
#  OsFHandleOpen
#);
#
#my ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label );
#
#BEGIN {
#    ( $stdin_fh, $stdout_fh, $debug_fh, $binmode, $parent_pid, $parent_start_time, $debug, $child_label ) = @ARGV;
#    if ($debug) {
#        eval "use IPC::Run::Debug qw( :default _debug_init ); 1;"
#          or die $@;
#    }
#    else {
#        eval <<STUBS_END or die $@;
#	 sub _debug {}
#	 sub _debug_init {}
#	 sub _debugging() { 0 }
#	 sub _debugging_data() { 0 }
#	 sub _debugging_details() { 0 }
#	 sub _debugging_gory_details() { 0 }
#	 1;
#STUBS_END
#    }
#}
#
#if ($debug) {    
#    close STDERR;    
#    OsFHandleOpen( \*STDERR, $debug_fh, "w" )    
#      or print "$! opening STDERR as Win32 handle $debug_fh in pumper $$";    
#}               
#close STDIN;    
#OsFHandleOpen( \*STDIN, $stdin_fh, "r" )    
#  or die "$! opening STDIN as Win32 handle $stdin_fh in pumper $$";    
#close STDOUT;                                                          
#OsFHandleOpen( \*STDOUT, $stdout_fh, "w" )                             
#  or die "$! opening STDOUT as Win32 handle $stdout_fh in pumper $$";  
#
#binmode STDIN;
#binmode STDOUT;
#$| = 1;
#select STDERR;
#$| = 1;
#select STDOUT;
#
#$child_label ||= "pump";
#_debug_init(
#    $parent_pid,
#    $parent_start_time,
#    $debug,
#    fileno STDERR,
#    $child_label,
#);
#
#_debug "Entered" if _debugging_details;
#
#$| = 1;
#my $buf;
#my $total_count = 0;
#while (1) {
#    my $count = sysread STDIN, $buf, 10_000;
#    last unless $count;
#    if (_debugging_gory_details) {
#        my $msg = "'$buf'";
#        substr( $msg, 100, -1 ) = '...' if length $msg > 100;
#        $msg =~ s/\n/\\n/g;
#        $msg =~ s/\r/\\r/g;
#        $msg =~ s/\t/\\t/g;
#        $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
#        _debug sprintf( "%5d chars revc: ", $count ), $msg;
#    }
#    $total_count += $count;
#    $buf =~ s/\r//g unless $binmode;
#    if (_debugging_gory_details) {
#        my $msg = "'$buf'";
#        substr( $msg, 100, -1 ) = '...' if length $msg > 100;
#        $msg =~ s/\n/\\n/g;
#        $msg =~ s/\r/\\r/g;
#        $msg =~ s/\t/\\t/g;
#        $msg =~ s/([\000-\037\177-\277])/sprintf "\0x%02x", ord $1/eg;
#        _debug sprintf( "%5d chars sent: ", $count ), $msg;
#    }
#    print $buf;
#}
#
#_debug "Exiting, transferred $total_count chars" if _debugging_details;
#
#close STDOUT;
#close STDERR;
#
#1;
#
### IPC/System/Options.pm ###
#package IPC::System::Options;
#
#our $DATE = '2019-01-07'; 
#our $VERSION = '0.331'; 
#
#use strict;
#use warnings;
#
#use Proc::ChildError qw(explain_child_error);
#use String::ShellQuote;
#
#my $log;
#our %Global_Opts;
#
#sub import {
#    my $self = shift;
#
#    my $caller = caller();
#    my $i = 0;
#    while ($i < @_) {
#        if ($_[$i] =~ /\A(system|readpipe|backtick|run|import)\z/) {
#            no strict 'refs';
#            *{"$caller\::$_[$i]"} = \&{"$self\::" . $_[$i]};
#        } elsif ($_[$i] =~ /\A-(.+)/) {
#            die "$_[$i] requires an argument" unless $i < @_-1;
#            $Global_Opts{$1} = $_[$i+1];
#            $i++;
#        } else {
#            die "$_[$i] is not exported by ".__PACKAGE__;
#        }
#        $i++;
#    }
#}
#
#sub _quote {
#    if (@_ == 1) {
#        return $_[0];
#    }
#
#    if ($^O eq 'MSWin32') {
#        require Win32::ShellQuote;
#        return Win32::ShellQuote::quote_system_string(
#            map { ref($_) eq 'SCALAR' ? $$_ : $_ } @_);
#    } else {
#        return join(
#            " ",
#            map { ref($_) eq 'SCALAR' ? $$_ : shell_quote($_) } @_
#        );
#    }
#}
#
#sub _system_or_readpipe_or_run {
#    my $which = shift;
#    my $opts = ref($_[0]) eq 'HASH' ? shift : {};
#    for (keys %Global_Opts) {
#        $opts->{$_} = $Global_Opts{$_} if !defined($opts->{$_});
#    }
#    my @args = @_;
#
#    for (keys %$opts) {
#        die "Unknown option '$_'"
#            unless /\A(
#                        capture_stdout|capture_stderr|capture_merged|
#                        tee_stdout|tee_stderr|tee_merged|
#                        chdir|dies?|dry_run|env|lang|log||max_log_output|shell|
#                        stdin # XXX: only for run()
#                    )\z/x;
#    }
#
#    my $opt_die = $opts->{die} || $opts->{dies};
#
#    my $exit_code;
#    my $os_error = "";
#    my $extra_error;
#
#    if ($opts->{log}) {
#        require Log::ger;
#        Log::ger->import;
#    }
#
#    my $cwd;
#    if ($opts->{chdir}) {
#        require Cwd;
#        $cwd = Cwd::getcwd();
#        if (!defined $cwd) { 
#            $log->error("Can't getcwd: $!") if $log;
#            $exit_code = -1;
#            $os_error = $!;
#            $extra_error = "Can't getcwd";
#            goto CHECK_RESULT;
#        }
#        unless (chdir $opts->{chdir}) {
#            $log->error("Can't chdir to '$opts->{chdir}': $!") if $log;
#            $exit_code = -1;
#            $os_error = $!;
#            $extra_error = "Can't chdir";
#            goto CHECK_RESULT;
#        }
#    }
#
#    my %save_env;
#    my %set_env;
#    if ($opts->{lang}) {
#        $set_env{LC_ALL}   = $opts->{lang};
#        $set_env{LANGUAGE} = $opts->{lang};
#        $set_env{LANG}     = $opts->{lang};
#    }
#    if ($opts->{env}) {
#        $set_env{$_} = $opts->{env}{$_} for keys %{ $opts->{env} };
#    }
#    if (%set_env) {
#        for (keys %set_env) {
#            $save_env{$_} = $ENV{$_};
#            $ENV{$_} = $set_env{$_};
#        }
#    }
#
#    my $wa;
#    my $res;
#
#    my $code_capture = sub {
#        my $doit = shift;
#
#        if ($opts->{capture_stdout} && $opts->{capture_stderr}) {
#            require Capture::Tiny;
#            (${ $opts->{capture_stdout} }, ${ $opts->{capture_stderr} }) =
#                &Capture::Tiny::capture($doit);
#        } elsif ($opts->{capture_merged}) {
#            require Capture::Tiny;
#            ${ $opts->{capture_merged} } =
#                &Capture::Tiny::capture_merged($doit);
#        } elsif ($opts->{capture_stdout}) {
#            require Capture::Tiny;
#            ${ $opts->{capture_stdout} } =
#                &Capture::Tiny::capture_stdout($doit);
#        } elsif ($opts->{capture_stderr}) {
#            require Capture::Tiny;
#            ${ $opts->{capture_stderr} } =
#                &Capture::Tiny::capture_stderr($doit);
#
#        } elsif ($opts->{tee_stdout} && $opts->{tee_stderr}) {
#            require Capture::Tiny;
#            (${ $opts->{tee_stdout} }, ${ $opts->{tee_stderr} }) =
#                &Capture::Tiny::tee($doit);
#        } elsif ($opts->{tee_merged}) {
#            require Capture::Tiny;
#            ${ $opts->{tee_merged} } =
#                &Capture::Tiny::tee_merged($doit);
#        } elsif ($opts->{tee_stdout}) {
#            require Capture::Tiny;
#            ${ $opts->{tee_stdout} } =
#                &Capture::Tiny::tee_stdout($doit);
#        } elsif ($opts->{tee_stderr}) {
#            require Capture::Tiny;
#            ${ $opts->{tee_stderr} } =
#                &Capture::Tiny::tee_stderr($doit);
#        } else {
#            $doit->();
#        }
#    };
#
#    if ($which eq 'system') {
#
#        if ($opts->{log} || $opts->{dry_run}) {
#            if ($opts->{log}) {
#                no strict 'refs';
#                my $routine;
#                my $label = "";
#                if ($opts->{dry_run}) {
#                    $label = "[DRY RUN] ";
#                    $routine = "log_info";
#                } else {
#                    $routine = "log_trace";
#                }
#                $routine->("%ssystem(%s), env=%s", $label, \@args, \%set_env);
#            } else {
#                warn "[DRY RUN] system(".join(", ", @args).")\n";
#            }
#            if ($opts->{dry_run}) {
#                $exit_code = 0;
#                $res = "";
#                goto CHECK_RESULT;
#            }
#        }
#
#        my $doit = sub {
#            if ($opts->{shell}) {
#                $res = system _quote(@args);
#            } elsif (defined $opts->{shell}) {
#                $res = system {$args[0]} @args;
#            } else {
#                $res = system @args;
#            }
#            $exit_code = $?;
#            $os_error = $!;
#        };
#        $code_capture->($doit);
#
#    } elsif ($which eq 'readpipe') {
#
#        $wa = wantarray;
#        my $cmd = _quote(@args);
#
#        if ($opts->{log} || $opts->{dry_run}) {
#            if ($opts->{log}) {
#                no strict 'refs';
#                my $routine;
#                my $label = "";
#                if ($opts->{dry_run}) {
#                    $label = "[DRY RUN] ";
#                    $routine = "log_info";
#                } else {
#                    $routine = "log_trace";
#                }
#                $routine->("%sreadpipe(%s), env=%s", $label, $cmd, \%set_env);
#            } else {
#                warn "[DRY RUN] readpipe($cmd)\n";
#            }
#            if ($opts->{dry_run}) {
#                $exit_code = 0;
#                $res = "";
#                goto CHECK_RESULT;
#            }
#        }
#
#        my $doit = sub {
#            if ($wa) {
#                $res = [`$cmd`];
#            } else {
#                $res = `$cmd`;
#            }
#            $exit_code = $?;
#            $os_error = $!;
#        };
#        $code_capture->($doit);
#
#        if ($opts->{log}) {
#            my $res_show;
#            if (defined $opts->{max_log_output}) {
#                $res_show = '';
#                if ($wa) {
#                    for (@$res) {
#                        if (length($res_show) + length($_) >=
#                                $opts->{max_log_output}) {
#                            $res_show .= substr(
#                                $_,0,$opts->{max_log_output}-length($res_show));
#                            last;
#                        } else {
#                            $res_show .= $_;
#                        }
#                    }
#                } else {
#                    if (length($res) > $opts->{max_log_output}) {
#                        $res_show = substr($res, 0, $opts->{max_log_output});
#                    }
#                }
#            }
#            log_trace("result of readpipe(): %s (%d bytes)",
#                      defined($res_show) ? $res_show : $res,
#                      defined($res_show) ?
#                          $opts->{max_log_output} : length($res))
#                unless $exit_code;
#        }
#
#    } else {
#
#        if ($opts->{log} || $opts->{dry_run}) {
#            if ($opts->{log}) {
#                no strict 'refs';
#                my $routine;
#                my $label = "";
#                if ($opts->{dry_run}) {
#                    $label = "[DRY RUN] ";
#                    $routine = "log_info";
#                } else {
#                    $routine = "log_trace";
#                }
#                $routine->("%srun(%s), env=%s", $label,
#                           join(", ", @args), \%set_env);
#            } else {
#                warn "[DRY RUN] run(".join(", ", @args).")\n";
#            }
#            if ($opts->{dry_run}) {
#                $exit_code = 0;
#                $res = "";
#                goto CHECK_RESULT;
#            }
#        }
#
#        require IPC::Run;
#        $res = IPC::Run::run(
#            \@args,
#            defined($opts->{stdin}) ? \$opts->{stdin} : \*STDIN,
#            sub {
#                if ($opts->{capture_stdout}) {
#                    ${$opts->{capture_stdout}} .= $_[0];
#                } else {
#                    print $_[0];
#                }
#            }, 
#            sub {
#                if ($opts->{capture_stderr}) {
#                    ${$opts->{capture_stderr}} .= $_[0];
#                } else {
#                    print STDERR $_[0];
#                }
#            }, 
#        );
#        $exit_code = $?;
#        $os_error = $!;
#
#    } 
#
#    if (%save_env) {
#        for (keys %save_env) {
#            if (defined $save_env{$_}) {
#                $ENV{$_} = $save_env{$_};
#            } else {
#                undef $ENV{$_};
#            }
#        }
#    }
#
#    if ($cwd) {
#        unless (chdir $cwd) {
#            $log->error("Can't chdir back to '$cwd': $!") if $log;
#            $exit_code ||= -1;
#            $os_error = $!;
#            $extra_error = "Can't chdir back";
#            goto CHECK_RESULT;
#        }
#    }
#
#  CHECK_RESULT:
#    if ($exit_code) {
#        if ($opts->{log} || $opt_die) {
#            my $msg = sprintf(
#                "%s(%s) failed: %s (%s)%s%s%s",
#                $which,
#                join(" ", @args),
#                defined $extra_error ? "" : $exit_code,
#                defined $extra_error ? "$extra_error: $os_error" : explain_child_error($exit_code, $os_error),
#                (ref($opts->{capture_stdout}) ?
#                     ", captured stdout: <<" .
#                     (defined ${$opts->{capture_stdout}} ? ${$opts->{capture_stdout}} : ''). ">>" : ""),
#                (ref($opts->{capture_stderr}) ?
#                     ", captured stderr: <<" .
#                     (defined ${$opts->{capture_stderr}} ? ${$opts->{capture_stderr}} : ''). ">>" : ""),
#                (ref($opts->{capture_merged}) ?
#                     ", captured merged: <<" .
#                     (defined ${$opts->{capture_merged}} ? ${$opts->{capture_merged}} : ''). ">>" : ""),
#            );
#            log_error($msg) if $opts->{log};
#            die $msg if $opt_die;
#        }
#    }
#
#    $? = $exit_code;
#
#    return $wa && $which ne 'run' ? @$res : $res;
#}
#
#sub system {
#    _system_or_readpipe_or_run('system', @_);
#}
#
#sub backtick {
#    _system_or_readpipe_or_run('readpipe', @_);
#}
#
#sub readpipe {
#    _system_or_readpipe_or_run('readpipe', @_);
#}
#
#sub run {
#    _system_or_readpipe_or_run('run', @_);
#}
#
#1;
#
#__END__
#
### JSON.pm ###
#package JSON;
#
#
#use strict;
#use Carp ();
#use Exporter;
#BEGIN { @JSON::ISA = 'Exporter' }
#
#@JSON::EXPORT = qw(from_json to_json jsonToObj objToJson encode_json decode_json);
#
#BEGIN {
#    $JSON::VERSION = '2.94';
#    $JSON::DEBUG   = 0 unless (defined $JSON::DEBUG);
#    $JSON::DEBUG   = $ENV{ PERL_JSON_DEBUG } if exists $ENV{ PERL_JSON_DEBUG };
#}
#
#my %RequiredVersion = (
#    'JSON::PP' => '2.27203',
#    'JSON::XS' => '2.34',
#);
#
#
#my @PublicMethods = qw/
#    ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref 
#    allow_blessed convert_blessed filter_json_object filter_json_single_key_object 
#    shrink max_depth max_size encode decode decode_prefix allow_unknown
#/;
#
#my @Properties = qw/
#    ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref
#    allow_blessed convert_blessed shrink max_depth max_size allow_unknown
#/;
#
#my @XSOnlyMethods = qw/allow_tags/; 
#
#my @PPOnlyMethods = qw/
#    indent_length sort_by
#    allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed
#/; 
#
#
#my $_INSTALL_DONT_DIE  = 1; 
#my $_ALLOW_UNSUPPORTED = 0;
#my $_UNIV_CONV_BLESSED = 0;
#
#
#
#unless ($JSON::Backend) {
#    $JSON::DEBUG and  Carp::carp("Check used worker module...");
#
#    my $backend = exists $ENV{PERL_JSON_BACKEND} ? $ENV{PERL_JSON_BACKEND} : 1;
#
#    if ($backend eq '1') {
#        $backend = 'JSON::XS,JSON::PP';
#    }
#    elsif ($backend eq '0') {
#        $backend = 'JSON::PP';
#    }
#    elsif ($backend eq '2') {
#        $backend = 'JSON::XS';
#    }
#    $backend =~ s/\s+//g;
#
#    my @backend_modules = split /,/, $backend;
#    while(my $module = shift @backend_modules) {
#        if ($module =~ /JSON::XS/) {
#            _load_xs($module, @backend_modules ? $_INSTALL_DONT_DIE : 0);
#        }
#        elsif ($module =~ /JSON::PP/) {
#            _load_pp($module);
#        }
#        elsif ($module =~ /JSON::backportPP/) {
#            _load_pp($module);
#        }
#        else {
#            Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid.";
#        }
#        last if $JSON::Backend;
#    }
#}
#
#
#sub import {
#    my $pkg = shift;
#    my @what_to_export;
#    my $no_export;
#
#    for my $tag (@_) {
#        if ($tag eq '-support_by_pp') {
#            if (!$_ALLOW_UNSUPPORTED++) {
#                JSON::Backend::XS
#                    ->support_by_pp(@PPOnlyMethods) if ($JSON::Backend->is_xs);
#            }
#            next;
#        }
#        elsif ($tag eq '-no_export') {
#            $no_export++, next;
#        }
#        elsif ( $tag eq '-convert_blessed_universally' ) {
#            my $org_encode = $JSON::Backend->can('encode');
#            eval q|
#                require B;
#                local $^W;
#                no strict 'refs';
#                *{"${JSON::Backend}\::encode"} = sub {
#                    # only works with Perl 5.18+
#                    local *UNIVERSAL::TO_JSON = sub {
#                        my $b_obj = B::svref_2object( $_[0] );
#                        return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
#                                : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
#                                : undef
#                                ;
#                    };
#                    $org_encode->(@_);
#                };
#            | if ( !$_UNIV_CONV_BLESSED++ );
#            next;
#        }
#        push @what_to_export, $tag;
#    }
#
#    return if ($no_export);
#
#    __PACKAGE__->export_to_level(1, $pkg, @what_to_export);
#}
#
#
#
#sub jsonToObj {
#    my $alternative = 'from_json';
#    if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
#        shift @_; $alternative = 'decode';
#    }
#    Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";
#    return JSON::from_json(@_);
#};
#
#sub objToJson {
#    my $alternative = 'to_json';
#    if (defined $_[0] and UNIVERSAL::isa($_[0], 'JSON')) {
#        shift @_; $alternative = 'encode';
#    }
#    Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";
#    JSON::to_json(@_);
#};
#
#
#
#sub to_json ($@) {
#    if (
#        ref($_[0]) eq 'JSON'
#        or (@_ > 2 and $_[0] eq 'JSON')
#    ) {
#        Carp::croak "to_json should not be called as a method.";
#    }
#    my $json = JSON->new;
#
#    if (@_ == 2 and ref $_[1] eq 'HASH') {
#        my $opt  = $_[1];
#        for my $method (keys %$opt) {
#            $json->$method( $opt->{$method} );
#        }
#    }
#
#    $json->encode($_[0]);
#}
#
#
#sub from_json ($@) {
#    if ( ref($_[0]) eq 'JSON' or $_[0] eq 'JSON' ) {
#        Carp::croak "from_json should not be called as a method.";
#    }
#    my $json = JSON->new;
#
#    if (@_ == 2 and ref $_[1] eq 'HASH') {
#        my $opt  = $_[1];
#        for my $method (keys %$opt) {
#            $json->$method( $opt->{$method} );
#        }
#    }
#
#    return $json->decode( $_[0] );
#}
#
#
#
#sub true  { $JSON::true  }
#
#sub false { $JSON::false }
#
#sub null  { undef; }
#
#
#sub require_xs_version { $RequiredVersion{'JSON::XS'}; }
#
#sub backend {
#    my $proto = shift;
#    $JSON::Backend;
#}
#
#
#
#sub is_xs {
#    return $_[0]->backend->is_xs;
#}
#
#
#sub is_pp {
#    return $_[0]->backend->is_pp;
#}
#
#
#sub pureperl_only_methods { @PPOnlyMethods; }
#
#
#sub property {
#    my ($self, $name, $value) = @_;
#
#    if (@_ == 1) {
#        my %props;
#        for $name (@Properties) {
#            my $method = 'get_' . $name;
#            if ($name eq 'max_size') {
#                my $value = $self->$method();
#                $props{$name} = $value == 1 ? 0 : $value;
#                next;
#            }
#            $props{$name} = $self->$method();
#        }
#        return \%props;
#    }
#    elsif (@_ > 3) {
#        Carp::croak('property() can take only the option within 2 arguments.');
#    }
#    elsif (@_ == 2) {
#        if ( my $method = $self->can('get_' . $name) ) {
#            if ($name eq 'max_size') {
#                my $value = $self->$method();
#                return $value == 1 ? 0 : $value;
#            }
#            $self->$method();
#        }
#    }
#    else {
#        $self->$name($value);
#    }
#
#}
#
#
#
#
#sub __load_xs {
#    my ($module, $opt) = @_;
#
#    $JSON::DEBUG and Carp::carp "Load $module.";
#    my $required_version = $RequiredVersion{$module} || '';
#
#    eval qq|
#        use $module $required_version ();
#    |;
#
#    if ($@) {
#        if (defined $opt and $opt & $_INSTALL_DONT_DIE) {
#            $JSON::DEBUG and Carp::carp "Can't load $module...($@)";
#            return 0;
#        }
#        Carp::croak $@;
#    }
#    $JSON::BackendModuleXS = $module;
#    return 1;
#}
#
#sub _load_xs {
#    my ($module, $opt) = @_;
#    __load_xs($module, $opt) or return;
#
#    my $data = join("", <DATA>); 
#    close(DATA);
#    eval $data;
#    JSON::Backend::XS->init($module);
#
#    return 1;
#};
#
#
#sub __load_pp {
#    my ($module, $opt) = @_;
#
#    $JSON::DEBUG and Carp::carp "Load $module.";
#    my $required_version = $RequiredVersion{$module} || '';
#
#    eval qq| use $module $required_version () |;
#
#    if ($@) {
#        if ( $module eq 'JSON::PP' ) {
#            $JSON::DEBUG and Carp::carp "Can't load $module ($@), so try to load JSON::backportPP";
#            $module = 'JSON::backportPP';
#            local $^W; 
#            eval qq| require $module |;
#        }
#        Carp::croak $@ if $@;
#    }
#    $JSON::BackendModulePP = $module;
#    return 1;
#}
#
#sub _load_pp {
#    my ($module, $opt) = @_;
#    __load_pp($module, $opt);
#
#    JSON::Backend::PP->init($module);
#};
#
#
#package JSON::Backend::PP;
#
#sub init {
#    my ($class, $module) = @_;
#
#
#    local $^W;
#    no strict qw(refs); 
#    *{"JSON::decode_json"} = \&{"JSON::PP::decode_json"};
#    *{"JSON::encode_json"} = \&{"JSON::PP::encode_json"};
#    *{"JSON::is_bool"} = \&{"JSON::PP::is_bool"};
#
#    $JSON::true  = ${"JSON::PP::true"};
#    $JSON::false = ${"JSON::PP::false"};
#
#    push @JSON::Backend::PP::ISA, 'JSON::PP';
#    push @JSON::ISA, $class;
#    $JSON::Backend = $class;
#    $JSON::BackendModule = $module;
#    ${"$class\::VERSION"} = $module->VERSION;
#
#    for my $method (@XSOnlyMethods) {
#        *{"JSON::$method"} = sub {
#            Carp::carp("$method is not supported in $module.");
#            $_[0];
#        };
#    }
#
#    return 1;
#}
#
#sub is_xs { 0 };
#sub is_pp { 1 };
#
#
#package JSON;
#
#1;
#__DATA__
#
#
##
## Helper classes for Backend Module (XS)
##
#
#package JSON::Backend::XS;
#
#sub init {
#    my ($class, $module) = @_;
#
#    local $^W;
#    no strict qw(refs);
#    *{"JSON::decode_json"} = \&{"$module\::decode_json"};
#    *{"JSON::encode_json"} = \&{"$module\::encode_json"};
#    *{"JSON::is_bool"} = \&{"$module\::is_bool"};
#
#    $JSON::true  = ${"$module\::true"};
#    $JSON::false = ${"$module\::false"};
#
#    push @JSON::Backend::XS::ISA, $module;
#    push @JSON::ISA, $class;
#    $JSON::Backend = $class;
#    $JSON::BackendModule = $module;
#    ${"$class\::VERSION"} = $module->VERSION;
#
#    if ( $module->VERSION < 3 ) {
#        eval 'package JSON::PP::Boolean';
#        push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
#    }
#
#    for my $method (@PPOnlyMethods) {
#        *{"JSON::$method"} = sub {
#            Carp::carp("$method is not supported in $module.");
#            $_[0];
#        };
#    }
#
#    return 1;
#}
#
#sub is_xs { 1 };
#sub is_pp { 0 };
#
#sub support_by_pp {
#    my ($class, @methods) = @_;
#
#    JSON::__load_pp('JSON::PP');
#
#    local $^W;
#    no strict qw(refs);
#
#    for my $method (@methods) {
#        my $pp_method = JSON::PP->can($method) or next;
#        *{"JSON::$method"} = sub {
#            if (!$_[0]->isa('JSON::PP')) {
#                my $xs_self = $_[0];
#                my $pp_self = JSON::PP->new;
#                for (@Properties) {
#                     my $getter = "get_$_";
#                    $pp_self->$_($xs_self->$getter);
#                }
#                $_[0] = $pp_self;
#            }
#            $pp_method->(@_);
#        };
#    }
#
#    $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
#}
#
#1;
#__END__
#
#=head1 NAME
#
#JSON - JSON (JavaScript Object Notation) encoder/decoder
#
#=head1 SYNOPSIS
#
# use JSON; # imports encode_json, decode_json, to_json and from_json.
# 
# # simple and fast interfaces (expect/generate UTF-8)
# 
# $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
# $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
# 
# # OO-interface
# 
# $json = JSON->new->allow_nonref;
# 
# $json_text   = $json->encode( $perl_scalar );
# $perl_scalar = $json->decode( $json_text );
# 
# $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
#
#=head1 VERSION
#
#    2.93
#
#=head1 DESCRIPTION
#
#This module is a thin wrapper for L<JSON::XS>-compatible modules with a few
#additional features. All the backend modules convert a Perl data structure
#to a JSON text as of RFC4627 (which we know is obsolete but we still stick
#to; see below for an option to support part of RFC7159) and vice versa.
#This module uses L<JSON::XS> by default, and when JSON::XS is not available,
#this module falls back on L<JSON::PP>, which is in the Perl core since 5.14.
#If JSON::PP is not available either, this module then falls back on
#JSON::backportPP (which is actually JSON::PP in a different .pm file)
#bundled in the same distribution as this module. You can also explicitly
#specify to use L<Cpanel::JSON::XS>, a fork of JSON::XS by Reini Urban.
#
#All these backend modules have slight incompatibilities between them,
#including extra features that other modules don't support, but as long as you
#use only common features (most important ones are described below), migration
#from backend to backend should be reasonably easy. For details, see each
#backend module you use.
#
#=head1 CHOOSING BACKEND
#
#This module respects an environmental variable called C<PERL_JSON_BACKEND>
#when it decides a backend module to use. If this environmental variable is
#not set, it tries to load JSON::XS, and if JSON::XS is not available, it
#falls back on JSON::PP, and then JSON::backportPP if JSON::PP is not available
#either.
#
#If you always don't want it to fall back on pure perl modules, set the
#variable like this (C<export> may be C<setenv>, C<set> and the likes,
#depending on your environment):
#
#  > export PERL_JSON_BACKEND=JSON::XS
#
#If you prefer Cpanel::JSON::XS to JSON::XS, then:
#
#  > export PERL_JSON_BACKEND=Cpanel::JSON::XS,JSON::XS,JSON::PP
#
#You may also want to set this variable at the top of your test files, in order
#not to be bothered with incompatibilities between backends (you need to wrap
#this in C<BEGIN>, and set before actually C<use>-ing JSON module, as it decides
#its backend as soon as it's loaded):
#
#  BEGIN { $ENV{PERL_JSON_BACKEND}='JSON::backportPP'; }
#  use JSON;
#
#=head1 USING OPTIONAL FEATURES
#
#There are a few options you can set when you C<use> this module:
#
#=over
#
#=item -support_by_pp
#
#   BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
#   
#   use JSON -support_by_pp;
#   
#   my $json = JSON->new;
#   # escape_slash is for JSON::PP only.
#   $json->allow_nonref->escape_slash->encode("/");
#
#With this option, this module loads its pure perl backend along with
#its XS backend (if available), and lets the XS backend to watch if you set
#a flag only JSON::PP supports. When you do, the internal JSON::XS object
#is replaced with a newly created JSON::PP object with the setting copied
#from the XS object, so that you can use JSON::PP flags (and its slower
#C<decode>/C<encode> methods) from then on. In other words, this is not
#something that allows you to hook JSON::XS to change its behavior while
#keeping its speed. JSON::XS and JSON::PP objects are quite different
#(JSON::XS object is a blessed scalar reference, while JSON::PP object is
#a blessed hash reference), and can't share their internals.
#
#To avoid needless overhead (by copying settings), you are advised not
#to use this option and just to use JSON::PP explicitly when you need
#JSON::PP features.
#
#=item -convert_blessed_universally
#
#   use JSON -convert_blessed_universally;
#
#   my $json = JSON->new->allow_nonref->convert_blessed;
#   my $object = bless {foo => 'bar'}, 'Foo';
#   $json->encode($object); # => {"foo":"bar"}
#
#JSON::XS-compatible backend modules don't encode blessed objects by
#default (except for their boolean values, which are typically blessed
#JSON::PP::Boolean objects). If you need to encode a data structure
#that may contain objects, you usually need to look into the structure
#and replace objects with alternative non-blessed values, or enable
#C<convert_blessed> and provide a C<TO_JSON> method for each object's
#(base) class that may be found in the structure, in order to let the
#methods replace the objects with whatever scalar values the methods
#return.
#
#If you need to serialise data structures that may contain arbitrary
#objects, it's probably better to use other serialisers (such as
#L<Sereal> or L<Storable> for example), but if you do want to use
#this module for that purpose, C<-convert_blessed_universally> option
#may help, which tweaks C<encode> method of the backend to install
#C<UNIVERSAL::TO_JSON> method (locally) before encoding, so that
#all the objects that don't have their own C<TO_JSON> method can
#fall back on the method in the C<UNIVERSAL> namespace. Note that you
#still need to enable C<convert_blessed> flag to actually encode
#objects in a data structure, and C<UNIVERSAL::TO_JSON> method
#installed by this option only converts blessed hash/array references
#into their unblessed clone (including private keys/values that are
#not supposed to be exposed). Other blessed references will be
#converted into null.
#
#This feature is experimental and may be removed in the future.
#
#=item -no_export
#
#When you don't want to import functional interfaces from a module, you
#usually supply C<()> to its C<use> statement.
#
#    use JSON (); # no functional interfaces
#
#If you don't want to import functional interfaces, but you also want to
#use any of the above options, add C<-no_export> to the option list.
#
#   # no functional interfaces, while JSON::PP support is enabled.
#   use JSON -support_by_pp, -no_export;
#
#=back
#
#=head1 FUNCTIONAL INTERFACE
#
#This section is taken from JSON::XS. C<encode_json> and C<decode_json>
#are exported by default.
#
#This module also exports C<to_json> and C<from_json> for backward
#compatibility. These are slower, and may expect/generate different stuff
#from what C<encode_json> and C<decode_json> do, depending on their
#options. It's better just to use Object-Oriented interfaces than using
#these two functions.
#
#=head2 encode_json
#
#    $json_text = encode_json $perl_scalar
#
#Converts the given Perl data structure to a UTF-8 encoded, binary string
#(that is, the string contains octets only). Croaks on error.
#
#This function call is functionally identical to:
#
#    $json_text = JSON->new->utf8->encode($perl_scalar)
#
#Except being faster.
#
#=head2 decode_json
#
#    $perl_scalar = decode_json $json_text
#
#The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
#to parse that as an UTF-8 encoded JSON text, returning the resulting
#reference. Croaks on error.
#
#This function call is functionally identical to:
#
#    $perl_scalar = JSON->new->utf8->decode($json_text)
#
#Except being faster.
#
#=head2 to_json
#
#   $json_text = to_json($perl_scalar[, $optional_hashref])
#
#Converts the given Perl data structure to a Unicode string by default.
#Croaks on error.
#
#Basically, this function call is functionally identical to:
#
#   $json_text = JSON->new->encode($perl_scalar)
#
#Except being slower.
#
#You can pass an optional hash reference to modify its behavior, but
#that may change what C<to_json> expects/generates (see
#C<ENCODING/CODESET FLAG NOTES> for details).
#
#   $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
#   # => JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
#
#=head2 from_json
#
#   $perl_scalar = from_json($json_text[, $optional_hashref])
#
#The opposite of C<to_json>: expects a Unicode string and tries
#to parse it, returning the resulting reference. Croaks on error.
#
#Basically, this function call is functionally identical to:
#
#    $perl_scalar = JSON->new->decode($json_text)
#
#You can pass an optional hash reference to modify its behavior, but
#that may change what C<from_json> expects/generates (see
#C<ENCODING/CODESET FLAG NOTES> for details).
#
#    $perl_scalar = from_json($json_text, {utf8 => 1})
#    # => JSON->new->utf8(1)->decode($json_text)
#
#=head2 JSON::is_bool
#
#    $is_boolean = JSON::is_bool($scalar)
#
#Returns true if the passed scalar represents either JSON::true or
#JSON::false, two constants that act like C<1> and C<0> respectively
#and are also used to represent JSON C<true> and C<false> in Perl strings.
#
#See L<MAPPING>, below, for more information on how JSON values are mapped to
#Perl.
#
#=head1 COMMON OBJECT-ORIENTED INTERFACE
#
#This section is also taken from JSON::XS.
#
#The object oriented interface lets you configure your own encoding or
#decoding style, within the limits of supported formats.
#
#=head2 new
#
#    $json = JSON->new
#
#Creates a new JSON::XS-compatible backend object that can be used to de/encode JSON
#strings. All boolean flags described below are by default I<disabled>.
#
#The mutators for flags all return the backend object again and thus calls can
#be chained:
#
#   my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
#   => {"a": [1, 2]}
#
#=head2 ascii
#
#    $json = $json->ascii([$enable])
#    
#    $enabled = $json->get_ascii
#
#If C<$enable> is true (or missing), then the C<encode> method will not
#generate characters outside the code range C<0..127> (which is ASCII). Any
#Unicode characters outside that range will be escaped using either a
#single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
#as per RFC4627. The resulting encoded JSON text can be treated as a native
#Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
#or any other superset of ASCII.
#
#If C<$enable> is false, then the C<encode> method will not escape Unicode
#characters unless required by the JSON syntax or other flags. This results
#in a faster and more compact format.
#
#See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
#
#The main use for this flag is to produce JSON texts that can be
#transmitted over a 7-bit channel, as the encoded JSON texts will not
#contain any 8 bit characters.
#
#  JSON->new->ascii(1)->encode([chr 0x10401])
#  => ["\ud801\udc01"]
#
#=head2 latin1
#
#    $json = $json->latin1([$enable])
#    
#    $enabled = $json->get_latin1
#
#If C<$enable> is true (or missing), then the C<encode> method will encode
#the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
#outside the code range C<0..255>. The resulting string can be treated as a
#latin1-encoded JSON text or a native Unicode string. The C<decode> method
#will not be affected in any way by this flag, as C<decode> by default
#expects Unicode, which is a strict superset of latin1.
#
#If C<$enable> is false, then the C<encode> method will not escape Unicode
#characters unless required by the JSON syntax or other flags.
#
#See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
#
#The main use for this flag is efficiently encoding binary data as JSON
#text, as most octets will not be escaped, resulting in a smaller encoded
#size. The disadvantage is that the resulting JSON text is encoded
#in latin1 (and must correctly be treated as such when storing and
#transferring), a rare encoding for JSON. It is therefore most useful when
#you want to store data structures known to contain binary data efficiently
#in files or databases, not when talking to other JSON encoders/decoders.
#
#  JSON->new->latin1->encode (["\x{89}\x{abc}"]
#  => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
#
#=head2 utf8
#
#    $json = $json->utf8([$enable])
#    
#    $enabled = $json->get_utf8
#
#If C<$enable> is true (or missing), then the C<encode> method will encode
#the JSON result into UTF-8, as required by many protocols, while the
#C<decode> method expects to be handled an UTF-8-encoded string.  Please
#note that UTF-8-encoded strings do not contain any characters outside the
#range C<0..255>, they are thus useful for bytewise/binary I/O. In future
#versions, enabling this option might enable autodetection of the UTF-16
#and UTF-32 encoding families, as described in RFC4627.
#
#If C<$enable> is false, then the C<encode> method will return the JSON
#string as a (non-encoded) Unicode string, while C<decode> expects thus a
#Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
#to be done yourself, e.g. using the Encode module.
#
#See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
#
#Example, output UTF-16BE-encoded JSON:
#
#  use Encode;
#  $jsontext = encode "UTF-16BE", JSON->new->encode ($object);
#
#Example, decode UTF-32LE-encoded JSON:
#
#  use Encode;
#  $object = JSON->new->decode (decode "UTF-32LE", $jsontext);
#
#=head2 pretty
#
#    $json = $json->pretty([$enable])
#
#This enables (or disables) all of the C<indent>, C<space_before> and
#C<space_after> (and in the future possibly more) flags in one call to
#generate the most readable (or most compact) form possible.
#
#=head2 indent
#
#    $json = $json->indent([$enable])
#    
#    $enabled = $json->get_indent
#
#If C<$enable> is true (or missing), then the C<encode> method will use a multiline
#format as output, putting every array member or object/hash key-value pair
#into its own line, indenting them properly.
#
#If C<$enable> is false, no newlines or indenting will be produced, and the
#resulting JSON text is guaranteed not to contain any C<newlines>.
#
#This setting has no effect when decoding JSON texts.
#
#=head2 space_before
#
#    $json = $json->space_before([$enable])
#    
#    $enabled = $json->get_space_before
#
#If C<$enable> is true (or missing), then the C<encode> method will add an extra
#optional space before the C<:> separating keys from values in JSON objects.
#
#If C<$enable> is false, then the C<encode> method will not add any extra
#space at those places.
#
#This setting has no effect when decoding JSON texts. You will also
#most likely combine this setting with C<space_after>.
#
#Example, space_before enabled, space_after and indent disabled:
#
#   {"key" :"value"}
#
#=head2 space_after
#
#    $json = $json->space_after([$enable])
#    
#    $enabled = $json->get_space_after
#
#If C<$enable> is true (or missing), then the C<encode> method will add an extra
#optional space after the C<:> separating keys from values in JSON objects
#and extra whitespace after the C<,> separating key-value pairs and array
#members.
#
#If C<$enable> is false, then the C<encode> method will not add any extra
#space at those places.
#
#This setting has no effect when decoding JSON texts.
#
#Example, space_before and indent disabled, space_after enabled:
#
#   {"key": "value"}
#
#=head2 relaxed
#
#    $json = $json->relaxed([$enable])
#    
#    $enabled = $json->get_relaxed
#
#If C<$enable> is true (or missing), then C<decode> will accept some
#extensions to normal JSON syntax (see below). C<encode> will not be
#affected in anyway. I<Be aware that this option makes you accept invalid
#JSON texts as if they were valid!>. I suggest only to use this option to
#parse application-specific files written by humans (configuration files,
#resource files etc.)
#
#If C<$enable> is false (the default), then C<decode> will only accept
#valid JSON texts.
#
#Currently accepted extensions are:
#
#=over 4
#
#=item * list items can have an end-comma
#
#JSON I<separates> array elements and key-value pairs with commas. This
#can be annoying if you write JSON texts manually and want to be able to
#quickly append elements, so this extension accepts comma at the end of
#such items not just between them:
#
#   [
#      1,
#      2, <- this comma not normally allowed
#   ]
#   {
#      "k1": "v1",
#      "k2": "v2", <- this comma not normally allowed
#   }
#
#=item * shell-style '#'-comments
#
#Whenever JSON allows whitespace, shell-style comments are additionally
#allowed. They are terminated by the first carriage-return or line-feed
#character, after which more white-space and comments are allowed.
#
#  [
#     1, # this comment not allowed in JSON
#        # neither this one...
#  ]
#
#=back
#
#=head2 canonical
#
#    $json = $json->canonical([$enable])
#    
#    $enabled = $json->get_canonical
#
#If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
#by sorting their keys. This is adding a comparatively high overhead.
#
#If C<$enable> is false, then the C<encode> method will output key-value
#pairs in the order Perl stores them (which will likely change between runs
#of the same script, and can change even within the same run from 5.18
#onwards).
#
#This option is useful if you want the same data structure to be encoded as
#the same JSON text (given the same overall settings). If it is disabled,
#the same hash might be encoded differently even if contains the same data,
#as key-value pairs have no inherent ordering in Perl.
#
#This setting has no effect when decoding JSON texts.
#
#This setting has currently no effect on tied hashes.
#
#=head2 allow_nonref
#
#    $json = $json->allow_nonref([$enable])
#    
#    $enabled = $json->get_allow_nonref
#
#If C<$enable> is true (or missing), then the C<encode> method can convert a
#non-reference into its corresponding string, number or null JSON value,
#which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
#values instead of croaking.
#
#If C<$enable> is false, then the C<encode> method will croak if it isn't
#passed an arrayref or hashref, as JSON texts must either be an object
#or array. Likewise, C<decode> will croak if given something that is not a
#JSON object or array.
#
#Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
#resulting in an invalid JSON text:
#
#   JSON->new->allow_nonref->encode ("Hello, World!")
#   => "Hello, World!"
#
#=head2 allow_unknown
#
#    $json = $json->allow_unknown ([$enable])
#    
#    $enabled = $json->get_allow_unknown
#
#If C<$enable> is true (or missing), then C<encode> will I<not> throw an
#exception when it encounters values it cannot represent in JSON (for
#example, filehandles) but instead will encode a JSON C<null> value. Note
#that blessed objects are not included here and are handled separately by
#c<allow_nonref>.
#
#If C<$enable> is false (the default), then C<encode> will throw an
#exception when it encounters anything it cannot encode as JSON.
#
#This option does not affect C<decode> in any way, and it is recommended to
#leave it off unless you know your communications partner.
#
#=head2 allow_blessed
#
#    $json = $json->allow_blessed([$enable])
#    
#    $enabled = $json->get_allow_blessed
#
#See L<OBJECT SERIALISATION> for details.
#
#If C<$enable> is true (or missing), then the C<encode> method will not
#barf when it encounters a blessed reference that it cannot convert
#otherwise. Instead, a JSON C<null> value is encoded instead of the object.
#
#If C<$enable> is false (the default), then C<encode> will throw an
#exception when it encounters a blessed object that it cannot convert
#otherwise.
#
#This setting has no effect on C<decode>.
#
#=head2 convert_blessed
#
#    $json = $json->convert_blessed([$enable])
#    
#    $enabled = $json->get_convert_blessed
#
#See L<OBJECT SERIALISATION> for details.
#
#If C<$enable> is true (or missing), then C<encode>, upon encountering a
#blessed object, will check for the availability of the C<TO_JSON> method
#on the object's class. If found, it will be called in scalar context and
#the resulting scalar will be encoded instead of the object.
#
#The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
#returns other blessed objects, those will be handled in the same
#way. C<TO_JSON> must take care of not causing an endless recursion cycle
#(== crash) in this case. The name of C<TO_JSON> was chosen because other
#methods called by the Perl core (== not by the user of the object) are
#usually in upper case letters and to avoid collisions with any C<to_json>
#function or method.
#
#If C<$enable> is false (the default), then C<encode> will not consider
#this type of conversion.
#
#This setting has no effect on C<decode>.
#
#=head2 filter_json_object
#
#    $json = $json->filter_json_object([$coderef])
#
#When C<$coderef> is specified, it will be called from C<decode> each
#time it decodes a JSON object. The only argument is a reference to the
#newly-created hash. If the code references returns a single scalar (which
#need not be a reference), this value (i.e. a copy of that scalar to avoid
#aliasing) is inserted into the deserialised data structure. If it returns
#an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
#original deserialised hash will be inserted. This setting can slow down
#decoding considerably.
#
#When C<$coderef> is omitted or undefined, any existing callback will
#be removed and C<decode> will not change the deserialised hash in any
#way.
#
#Example, convert all JSON objects into the integer 5:
#
#   my $js = JSON->new->filter_json_object (sub { 5 });
#   # returns [5]
#   $js->decode ('[{}]'); # the given subroutine takes a hash reference.
#   # throw an exception because allow_nonref is not enabled
#   # so a lone 5 is not allowed.
#   $js->decode ('{"a":1, "b":2}');
#
#=head2 filter_json_single_key_object
#
#    $json = $json->filter_json_single_key_object($key [=> $coderef])
#
#Works remotely similar to C<filter_json_object>, but is only called for
#JSON objects having a single key named C<$key>.
#
#This C<$coderef> is called before the one specified via
#C<filter_json_object>, if any. It gets passed the single value in the JSON
#object. If it returns a single value, it will be inserted into the data
#structure. If it returns nothing (not even C<undef> but the empty list),
#the callback from C<filter_json_object> will be called next, as if no
#single-key callback were specified.
#
#If C<$coderef> is omitted or undefined, the corresponding callback will be
#disabled. There can only ever be one callback for a given key.
#
#As this callback gets called less often then the C<filter_json_object>
#one, decoding speed will not usually suffer as much. Therefore, single-key
#objects make excellent targets to serialise Perl objects into, especially
#as single-key JSON objects are as close to the type-tagged value concept
#as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
#support this in any way, so you need to make sure your data never looks
#like a serialised Perl hash.
#
#Typical names for the single object key are C<__class_whatever__>, or
#C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
#things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
#with real hashes.
#
#Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
#into the corresponding C<< $WIDGET{<id>} >> object:
#
#   # return whatever is in $WIDGET{5}:
#   JSON
#      ->new
#      ->filter_json_single_key_object (__widget__ => sub {
#            $WIDGET{ $_[0] }
#         })
#      ->decode ('{"__widget__": 5')
#
#   # this can be used with a TO_JSON method in some "widget" class
#   # for serialisation to json:
#   sub WidgetBase::TO_JSON {
#      my ($self) = @_;
#
#      unless ($self->{id}) {
#         $self->{id} = ..get..some..id..;
#         $WIDGET{$self->{id}} = $self;
#      }
#
#      { __widget__ => $self->{id} }
#   }
#
#=head2 max_depth
#
#    $json = $json->max_depth([$maximum_nesting_depth])
#    
#    $max_depth = $json->get_max_depth
#
#Sets the maximum nesting level (default C<512>) accepted while encoding
#or decoding. If a higher nesting level is detected in JSON text or a Perl
#data structure, then the encoder and decoder will stop and croak at that
#point.
#
#Nesting level is defined by number of hash- or arrayrefs that the encoder
#needs to traverse to reach a given point or the number of C<{> or C<[>
#characters without their matching closing parenthesis crossed to reach a
#given character in a string.
#
#Setting the maximum depth to one disallows any nesting, so that ensures
#that the object is only a single hash/object or array.
#
#If no argument is given, the highest possible setting will be used, which
#is rarely useful.
#
#=head2 max_size
#
#    $json = $json->max_size([$maximum_string_size])
#    
#    $max_size = $json->get_max_size
#
#Set the maximum length a JSON text may have (in bytes) where decoding is
#being attempted. The default is C<0>, meaning no limit. When C<decode>
#is called on a string that is longer then this many bytes, it will not
#attempt to decode the string but throw an exception. This setting has no
#effect on C<encode> (yet).
#
#If no argument is given, the limit check will be deactivated (same as when
#C<0> is specified).
#
#=head2 encode
#
#    $json_text = $json->encode($perl_scalar)
#
#Converts the given Perl value or data structure to its JSON
#representation. Croaks on error.
#
#=head2 decode
#
#    $perl_scalar = $json->decode($json_text)
#
#The opposite of C<encode>: expects a JSON text and tries to parse it,
#returning the resulting simple scalar or reference. Croaks on error.
#
#=head2 decode_prefix
#
#    ($perl_scalar, $characters) = $json->decode_prefix($json_text)
#
#This works like the C<decode> method, but instead of raising an exception
#when there is trailing garbage after the first JSON object, it will
#silently stop parsing there and return the number of characters consumed
#so far.
#
#This is useful if your JSON texts are not delimited by an outer protocol
#and you need to know where the JSON text ends.
#
#   JSON->new->decode_prefix ("[1] the tail")
#   => ([1], 3)
#
#=head1 ADDITIONAL METHODS
#
#The following methods are for this module only.
#
#=head2 backend
#
#    $backend = $json->backend
#
#Since 2.92, C<backend> method returns an abstract backend module used currently,
#which should be JSON::Backend::XS (which inherits JSON::XS or Cpanel::JSON::XS),
#or JSON::Backend::PP (which inherits JSON::PP), not to monkey-patch the actual
#backend module globally.
#
#If you need to know what is used actually, use C<isa>, instead of string comparison.
#
#=head2 is_xs
#
#    $boolean = $json->is_xs
#
#Returns true if the backend inherits JSON::XS or Cpanel::JSON::XS.
#
#=head2 is_pp
#
#    $boolean = $json->is_pp
#
#Returns true if the backend inherits JSON::PP.
#
#=head2 property
#
#    $settings = $json->property()
#
#Returns a reference to a hash that holds all the common flag settings.
#
#    $json = $json->property('utf8' => 1)
#    $value = $json->property('utf8') # 1
#
#You can use this to get/set a value of a particular flag.
#
#=head1 INCREMENTAL PARSING
#
#This section is also taken from JSON::XS.
#
#In some cases, there is the need for incremental parsing of JSON
#texts. While this module always has to keep both JSON text and resulting
#Perl data structure in memory at one time, it does allow you to parse a
#JSON stream incrementally. It does so by accumulating text until it has
#a full JSON object, which it then can decode. This process is similar to
#using C<decode_prefix> to see if a full JSON object is available, but
#is much more efficient (and can be implemented with a minimum of method
#calls).
#
#This module will only attempt to parse the JSON text once it is sure it
#has enough text to get a decisive result, using a very simple but
#truly incremental parser. This means that it sometimes won't stop as
#early as the full parser, for example, it doesn't detect mismatched
#parentheses. The only thing it guarantees is that it starts decoding as
#soon as a syntactically valid JSON text has been seen. This means you need
#to set resource limits (e.g. C<max_size>) to ensure the parser will stop
#parsing in the presence if syntax errors.
#
#The following methods implement this incremental parser.
#
#=head2 incr_parse
#
#    $json->incr_parse( [$string] ) # void context
#    
#    $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
#    
#    @obj_or_empty = $json->incr_parse( [$string] ) # list context
#
#This is the central parsing function. It can both append new text and
#extract objects from the stream accumulated so far (both of these
#functions are optional).
#
#If C<$string> is given, then this string is appended to the already
#existing JSON fragment stored in the C<$json> object.
#
#After that, if the function is called in void context, it will simply
#return without doing anything further. This can be used to add more text
#in as many chunks as you want.
#
#If the method is called in scalar context, then it will try to extract
#exactly I<one> JSON object. If that is successful, it will return this
#object, otherwise it will return C<undef>. If there is a parse error,
#this method will croak just as C<decode> would do (one can then use
#C<incr_skip> to skip the erroneous part). This is the most common way of
#using the method.
#
#And finally, in list context, it will try to extract as many objects
#from the stream as it can find and return them, or the empty list
#otherwise. For this to work, there must be no separators (other than
#whitespace) between the JSON objects or arrays, instead they must be
#concatenated back-to-back. If an error occurs, an exception will be
#raised as in the scalar context case. Note that in this case, any
#previously-parsed JSON texts will be lost.
#
#Example: Parse some JSON arrays/objects in a given string and return
#them.
#
#    my @objs = JSON->new->incr_parse ("[5][7][1,2]");
#
#=head2 incr_text
#
#    $lvalue_string = $json->incr_text
#
#This method returns the currently stored JSON fragment as an lvalue, that
#is, you can manipulate it. This I<only> works when a preceding call to
#C<incr_parse> in I<scalar context> successfully returned an object. Under
#all other circumstances you must not call this function (I mean it.
#although in simple tests it might actually work, it I<will> fail under
#real world conditions). As a special exception, you can also call this
#method before having parsed anything.
#
#That means you can only use this function to look at or manipulate text
#before or after complete JSON objects, not while the parser is in the
#middle of parsing a JSON object.
#
#This function is useful in two cases: a) finding the trailing text after a
#JSON object or b) parsing multiple JSON objects separated by non-JSON text
#(such as commas).
#
#=head2 incr_skip
#
#    $json->incr_skip
#
#This will reset the state of the incremental parser and will remove
#the parsed text from the input buffer so far. This is useful after
#C<incr_parse> died, in which case the input buffer and incremental parser
#state is left unchanged, to skip the text parsed so far and to reset the
#parse state.
#
#The difference to C<incr_reset> is that only text until the parse error
#occurred is removed.
#
#=head2 incr_reset
#
#    $json->incr_reset
#
#This completely resets the incremental parser, that is, after this call,
#it will be as if the parser had never parsed anything.
#
#This is useful if you want to repeatedly parse JSON objects and want to
#ignore any trailing data, which means you have to reset the parser after
#each successful decode.
#
#=head1 MAPPING
#
#Most of this section is also taken from JSON::XS.
#
#This section describes how the backend modules map Perl values to JSON values and
#vice versa. These mappings are designed to "do the right thing" in most
#circumstances automatically, preserving round-tripping characteristics
#(what you put in comes out as something equivalent).
#
#For the more enlightened: note that in the following descriptions,
#lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
#refers to the abstract Perl language itself.
#
#=head2 JSON -> PERL
#
#=over 4
#
#=item object
#
#A JSON object becomes a reference to a hash in Perl. No ordering of object
#keys is preserved (JSON does not preserver object key ordering itself).
#
#=item array
#
#A JSON array becomes a reference to an array in Perl.
#
#=item string
#
#A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
#are represented by the same codepoints in the Perl string, so no manual
#decoding is necessary.
#
#=item number
#
#A JSON number becomes either an integer, numeric (floating point) or
#string scalar in perl, depending on its range and any fractional parts. On
#the Perl level, there is no difference between those as Perl handles all
#the conversion details, but an integer may take slightly less memory and
#might represent more values exactly than floating point numbers.
#
#If the number consists of digits only, this module will try to represent
#it as an integer value. If that fails, it will try to represent it as
#a numeric (floating point) value if that is possible without loss of
#precision. Otherwise it will preserve the number as a string value (in
#which case you lose roundtripping ability, as the JSON number will be
#re-encoded to a JSON string).
#
#Numbers containing a fractional or exponential part will always be
#represented as numeric (floating point) values, possibly at a loss of
#precision (in which case you might lose perfect roundtripping ability, but
#the JSON number will still be re-encoded as a JSON number).
#
#Note that precision is not accuracy - binary floating point values cannot
#represent most decimal fractions exactly, and when converting from and to
#floating point, this module only guarantees precision up to but not including
#the least significant bit.
#
#=item true, false
#
#These JSON atoms become C<JSON::true> and C<JSON::false>,
#respectively. They are overloaded to act almost exactly like the numbers
#C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
#the C<JSON::is_bool> function.
#
#=item null
#
#A JSON null atom becomes C<undef> in Perl.
#
#=item shell-style comments (C<< # I<text> >>)
#
#As a nonstandard extension to the JSON syntax that is enabled by the
#C<relaxed> setting, shell-style comments are allowed. They can start
#anywhere outside strings and go till the end of the line.
#
#=back
#
#
#=head2 PERL -> JSON
#
#The mapping from Perl to JSON is slightly more difficult, as Perl is a
#truly typeless language, so we can only guess which JSON type is meant by
#a Perl value.
#
#=over 4
#
#=item hash references
#
#Perl hash references become JSON objects. As there is no inherent
#ordering in hash keys (or JSON objects), they will usually be encoded
#in a pseudo-random order. This module can optionally sort the hash keys
#(determined by the I<canonical> flag), so the same data structure will
#serialise to the same JSON text (given same settings and version of
#the same backend), but this incurs a runtime overhead and is only rarely useful,
#e.g. when you want to compare some JSON text against another for equality.
#
#=item array references
#
#Perl array references become JSON arrays.
#
#=item other references
#
#Other unblessed references are generally not allowed and will cause an
#exception to be thrown, except for references to the integers C<0> and
#C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
#also use C<JSON::false> and C<JSON::true> to improve readability.
#
#   encode_json [\0,JSON::true]      # yields [false,true]
#
#=item JSON::true, JSON::false, JSON::null
#
#These special values become JSON true and JSON false values,
#respectively. You can also use C<\1> and C<\0> directly if you want.
#
#=item blessed objects
#
#Blessed objects are not directly representable in JSON, but C<JSON::XS>
#allows various ways of handling objects. See L<OBJECT SERIALISATION>,
#below, for details.
#
#=item simple scalars
#
#Simple Perl scalars (any scalar that is not a reference) are the most
#difficult objects to encode: this module will encode undefined scalars as
#JSON C<null> values, scalars that have last been used in a string context
#before encoding as JSON strings, and anything else as number value:
#
#   # dump as number
#   encode_json [2]                      # yields [2]
#   encode_json [-3.0e17]                # yields [-3e+17]
#   my $value = 5; encode_json [$value]  # yields [5]
#
#   # used as string, so dump as string
#   print $value;
#   encode_json [$value]                 # yields ["5"]
#
#   # undef becomes null
#   encode_json [undef]                  # yields [null]
#
#You can force the type to be a string by stringifying it:
#
#   my $x = 3.1; # some variable containing a number
#   "$x";        # stringified
#   $x .= "";    # another, more awkward way to stringify
#   print $x;    # perl does it for you, too, quite often
#
#You can force the type to be a number by numifying it:
#
#   my $x = "3"; # some variable containing a string
#   $x += 0;     # numify it, ensuring it will be dumped as a number
#   $x *= 1;     # same thing, the choice is yours.
#
#You can not currently force the type in other, less obscure, ways. Tell me
#if you need this capability (but don't forget to explain why it's needed
#:).
#
#Note that numerical precision has the same meaning as under Perl (so
#binary to decimal conversion follows the same rules as in Perl, which
#can differ to other languages). Also, your perl interpreter might expose
#extensions to the floating point numbers of your platform, such as
#infinities or NaN's - these cannot be represented in JSON, and it is an
#error to pass those in.
#
#=back
#
#=head2 OBJECT SERIALISATION
#
#As for Perl objects, this module only supports a pure JSON representation
#(without the ability to deserialise the object automatically again).
#
#=head3 SERIALISATION
#
#What happens when this module encounters a Perl object depends on the
#C<allow_blessed> and C<convert_blessed> settings, which are used in
#this order:
#
#=over 4
#
#=item 1. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
#
#In this case, the C<TO_JSON> method of the object is invoked in scalar
#context. It must return a single scalar that can be directly encoded into
#JSON. This scalar replaces the object in the JSON text.
#
#For example, the following C<TO_JSON> method will convert all L<URI>
#objects to JSON strings when serialised. The fact that these values
#originally were L<URI> objects is lost.
#
#   sub URI::TO_JSON {
#      my ($uri) = @_;
#      $uri->as_string
#   }
#
#=item 2. C<allow_blessed> is enabled.
#
#The object will be serialised as a JSON null value.
#
#=item 3. none of the above
#
#If none of the settings are enabled or the respective methods are missing,
#this module throws an exception.
#
#=back
#
#=head1 ENCODING/CODESET FLAG NOTES
#
#This section is taken from JSON::XS.
#
#The interested reader might have seen a number of flags that signify
#encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
#some confusion on what these do, so here is a short comparison:
#
#C<utf8> controls whether the JSON text created by C<encode> (and expected
#by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
#control whether C<encode> escapes character values outside their respective
#codeset range. Neither of these flags conflict with each other, although
#some combinations make less sense than others.
#
#Care has been taken to make all flags symmetrical with respect to
#C<encode> and C<decode>, that is, texts encoded with any combination of
#these flag values will be correctly decoded when the same flags are used
#- in general, if you use different flag settings while encoding vs. when
#decoding you likely have a bug somewhere.
#
#Below comes a verbose discussion of these flags. Note that a "codeset" is
#simply an abstract set of character-codepoint pairs, while an encoding
#takes those codepoint numbers and I<encodes> them, in our case into
#octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
#and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
#the same time, which can be confusing.
#
#=over 4
#
#=item C<utf8> flag disabled
#
#When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
#and expect Unicode strings, that is, characters with high ordinal Unicode
#values (> 255) will be encoded as such characters, and likewise such
#characters are decoded as-is, no changes to them will be done, except
#"(re-)interpreting" them as Unicode codepoints or Unicode characters,
#respectively (to Perl, these are the same thing in strings unless you do
#funny/weird/dumb stuff).
#
#This is useful when you want to do the encoding yourself (e.g. when you
#want to have UTF-16 encoded JSON texts) or when some other layer does
#the encoding for you (for example, when printing to a terminal using a
#filehandle that transparently encodes to UTF-8 you certainly do NOT want
#to UTF-8 encode your data first and have Perl encode it another time).
#
#=item C<utf8> flag enabled
#
#If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
#characters using the corresponding UTF-8 multi-byte sequence, and will
#expect your input strings to be encoded as UTF-8, that is, no "character"
#of the input string must have any value > 255, as UTF-8 does not allow
#that.
#
#The C<utf8> flag therefore switches between two modes: disabled means you
#will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
#octet/binary string in Perl.
#
#=item C<latin1> or C<ascii> flags enabled
#
#With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
#with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
#characters as specified by the C<utf8> flag.
#
#If C<utf8> is disabled, then the result is also correctly encoded in those
#character sets (as both are proper subsets of Unicode, meaning that a
#Unicode string with all character values < 256 is the same thing as a
#ISO-8859-1 string, and a Unicode string with all character values < 128 is
#the same thing as an ASCII string in Perl).
#
#If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
#regardless of these flags, just some more characters will be escaped using
#C<\uXXXX> then before.
#
#Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
#encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
#encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
#a subset of Unicode), while ASCII is.
#
#Surprisingly, C<decode> will ignore these flags and so treat all input
#values as governed by the C<utf8> flag. If it is disabled, this allows you
#to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
#Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
#
#So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
#they only govern when the JSON output engine escapes a character or not.
#
#The main use for C<latin1> is to relatively efficiently store binary data
#as JSON, at the expense of breaking compatibility with most JSON decoders.
#
#The main use for C<ascii> is to force the output to not contain characters
#with values > 127, which means you can interpret the resulting string
#as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
#8-bit-encoding, and still get the same data structure back. This is useful
#when your channel for JSON transfer is not 8-bit clean or the encoding
#might be mangled in between (e.g. in mail), and works because ASCII is a
#proper subset of most 8-bit and multibyte encodings in use in the world.
#
#=back
#
#=head1 BACKWARD INCOMPATIBILITY
#
#Since version 2.90, stringification (and string comparison) for
#C<JSON::true> and C<JSON::false> has not been overloaded. It shouldn't
#matter as long as you treat them as boolean values, but a code that
#expects they are stringified as "true" or "false" doesn't work as
#you have expected any more.
#
#    if (JSON::true eq 'true') {  # now fails
#
#    print "The result is $JSON::true now."; # => The result is 1 now.
#
#And now these boolean values don't inherit JSON::Boolean, either.
#When you need to test a value is a JSON boolean value or not, use
#C<JSON::is_bool> function, instead of testing the value inherits
#a particular boolean class or not.
#
#=head1 BUGS
#
#Please report bugs on backend selection and additional features
#this module provides to RT or GitHub issues for this module:
#
#=over 4
#
#=item https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON
#
#=item https://github.com/makamaka/JSON/issues
#
#=back
#
#Please report bugs and feature requests on decoding/encoding
#and boolean behaviors to the author of the backend module you
#are using.
#
#=head1 SEE ALSO
#
#L<JSON::XS>, L<Cpanel::JSON::XS>, L<JSON::PP> for backends.
#
#L<JSON::MaybeXS>, an alternative that prefers Cpanel::JSON::XS.
#
#C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
#
#=head1 AUTHOR
#
#Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
#
#JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
#
#The release of this new version owes to the courtesy of Marc Lehmann.
#
#
#=head1 COPYRIGHT AND LICENSE
#
#Copyright 2005-2013 by Makamaka Hannyaharamitu
#
#This library is free software; you can redistribute it and/or modify
#it under the same terms as Perl itself. 
#
#=cut
#
### JSON/MaybeXS.pm ###
#package JSON::MaybeXS;
#
#use strict;
#use warnings FATAL => 'all';
#use base qw(Exporter);
#
#our $VERSION = '1.003009';
#$VERSION = eval $VERSION;
#
#sub _choose_json_module {
#    return 'Cpanel::JSON::XS' if $INC{'Cpanel/JSON/XS.pm'};
#    return 'JSON::XS'         if $INC{'JSON/XS.pm'};
#
#    my @err;
#
#    return 'Cpanel::JSON::XS' if eval { require Cpanel::JSON::XS; 1; };
#    push @err, "Error loading Cpanel::JSON::XS: $@";
#
#    return 'JSON::XS' if eval { require JSON::XS; 1; };
#    push @err, "Error loading JSON::XS: $@";
#
#    return 'JSON::PP' if eval { require JSON::PP; 1 };
#    push @err, "Error loading JSON::PP: $@";
#
#    die join( "\n", "Couldn't load a JSON module:", @err );
#
#}
#
#BEGIN {
#    our $JSON_Class = _choose_json_module();
#    $JSON_Class->import(qw(encode_json decode_json));
#}
#
#our @EXPORT = qw(encode_json decode_json JSON);
#my @EXPORT_ALL = qw(is_bool);
#our @EXPORT_OK = qw(is_bool to_json from_json);
#our %EXPORT_TAGS = ( all => [ @EXPORT, @EXPORT_ALL ],
#                     legacy => [ @EXPORT, @EXPORT_OK ],
#                   );
#
#sub JSON () { our $JSON_Class }
#
#sub new {
#  shift;
#  my %args = @_ == 1 ? %{$_[0]} : @_;
#  my $new = (our $JSON_Class)->new;
#  $new->$_($args{$_}) for keys %args;
#  return $new;
#}
#
#use Scalar::Util ();
#
#sub is_bool {
#  die 'is_bool is not a method' if $_[1];
#
#  Scalar::Util::blessed($_[0])
#    and ($_[0]->isa('JSON::XS::Boolean')
#      or $_[0]->isa('Cpanel::JSON::XS::Boolean')
#      or $_[0]->isa('JSON::PP::Boolean'));
#}
#
#use Carp ();
#
#sub from_json ($@) {
#    if ( ref($_[0]) =~ /^JSON/ or $_[0] =~ /^JSON/ ) {
#        Carp::croak "from_json should not be called as a method.";
#    }
#    my $json = JSON()->new;
#
#    if (@_ == 2 and ref $_[1] eq 'HASH') {
#        my $opt  = $_[1];
#        for my $method (keys %$opt) {
#            $json->$method( $opt->{$method} );
#        }
#    }
#
#    return $json->decode( $_[0] );
#}
#
#sub to_json ($@) {
#    if (
#        ref($_[0]) =~ /^JSON/
#        or (@_ > 2 and $_[0] =~ /^JSON/)
#          ) {
#               Carp::croak "to_json should not be called as a method.";
#    }
#    my $json = JSON()->new;
#
#    if (@_ == 2 and ref $_[1] eq 'HASH') {
#        my $opt  = $_[1];
#        for my $method (keys %$opt) {
#            $json->$method( $opt->{$method} );
#        }
#    }
#
#    $json->encode($_[0]);
#}
#
#1;
#
### JSON/PP.pm ###
#package JSON::PP;
#
#
#use 5.005;
#use strict;
#use base qw(Exporter);
#use overload ();
#
#use Carp ();
#use B ();
#
#$JSON::PP::VERSION = '2.27400_02';
#
#@JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);
#
#
#use constant P_ASCII                => 0;
#use constant P_LATIN1               => 1;
#use constant P_UTF8                 => 2;
#use constant P_INDENT               => 3;
#use constant P_CANONICAL            => 4;
#use constant P_SPACE_BEFORE         => 5;
#use constant P_SPACE_AFTER          => 6;
#use constant P_ALLOW_NONREF         => 7;
#use constant P_SHRINK               => 8;
#use constant P_ALLOW_BLESSED        => 9;
#use constant P_CONVERT_BLESSED      => 10;
#use constant P_RELAXED              => 11;
#
#use constant P_LOOSE                => 12;
#use constant P_ALLOW_BIGNUM         => 13;
#use constant P_ALLOW_BAREKEY        => 14;
#use constant P_ALLOW_SINGLEQUOTE    => 15;
#use constant P_ESCAPE_SLASH         => 16;
#use constant P_AS_NONBLESSED        => 17;
#
#use constant P_ALLOW_UNKNOWN        => 18;
#
#use constant OLD_PERL => $] < 5.008 ? 1 : 0;
#
#BEGIN {
#    my @xs_compati_bit_properties = qw(
#            latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
#            allow_blessed convert_blessed relaxed allow_unknown
#    );
#    my @pp_bit_properties = qw(
#            allow_singlequote allow_bignum loose
#            allow_barekey escape_slash as_nonblessed
#    );
#
#    if ($] < 5.008 ) {
#        my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
#        eval qq| require $helper |;
#        if ($@) { Carp::croak $@; }
#    }
#
#    for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
#        my $flag_name = 'P_' . uc($name);
#
#        eval qq/
#            sub $name {
#                my \$enable = defined \$_[1] ? \$_[1] : 1;
#
#                if (\$enable) {
#                    \$_[0]->{PROPS}->[$flag_name] = 1;
#                }
#                else {
#                    \$_[0]->{PROPS}->[$flag_name] = 0;
#                }
#
#                \$_[0];
#            }
#
#            sub get_$name {
#                \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
#            }
#        /;
#    }
#
#}
#
#
#
#
#my %encode_allow_method
#     = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
#                          allow_blessed convert_blessed indent indent_length allow_bignum
#                          as_nonblessed
#                        /;
#my %decode_allow_method
#     = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
#                          allow_barekey max_size relaxed/;
#
#
#my $JSON; 
#
#sub encode_json ($) { 
#    ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
#}
#
#
#sub decode_json { 
#    ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
#}
#
#
#sub to_json($) {
#   Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
#}
#
#
#sub from_json($) {
#   Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
#}
#
#
#
#sub new {
#    my $class = shift;
#    my $self  = {
#        max_depth   => 512,
#        max_size    => 0,
#        indent      => 0,
#        FLAGS       => 0,
#        fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
#        indent_length => 3,
#    };
#
#    bless $self, $class;
#}
#
#
#sub encode {
#    return $_[0]->PP_encode_json($_[1]);
#}
#
#
#sub decode {
#    return $_[0]->PP_decode_json($_[1], 0x00000000);
#}
#
#
#sub decode_prefix {
#    return $_[0]->PP_decode_json($_[1], 0x00000001);
#}
#
#
#
#
#
#sub pretty {
#    my ($self, $v) = @_;
#    my $enable = defined $v ? $v : 1;
#
#    if ($enable) { 
#        $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
#    }
#    else {
#        $self->indent(0)->space_before(0)->space_after(0);
#    }
#
#    $self;
#}
#
#
#sub max_depth {
#    my $max  = defined $_[1] ? $_[1] : 0x80000000;
#    $_[0]->{max_depth} = $max;
#    $_[0];
#}
#
#
#sub get_max_depth { $_[0]->{max_depth}; }
#
#
#sub max_size {
#    my $max  = defined $_[1] ? $_[1] : 0;
#    $_[0]->{max_size} = $max;
#    $_[0];
#}
#
#
#sub get_max_size { $_[0]->{max_size}; }
#
#
#sub filter_json_object {
#    $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
#    $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
#    $_[0];
#}
#
#sub filter_json_single_key_object {
#    if (@_ > 1) {
#        $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
#    }
#    $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
#    $_[0];
#}
#
#sub indent_length {
#    if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
#        Carp::carp "The acceptable range of indent_length() is 0 to 15.";
#    }
#    else {
#        $_[0]->{indent_length} = $_[1];
#    }
#    $_[0];
#}
#
#sub get_indent_length {
#    $_[0]->{indent_length};
#}
#
#sub sort_by {
#    $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
#    $_[0];
#}
#
#sub allow_bigint {
#    Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
#}
#
#
#
#
#{ 
#
#    my $max_depth;
#    my $indent;
#    my $ascii;
#    my $latin1;
#    my $utf8;
#    my $space_before;
#    my $space_after;
#    my $canonical;
#    my $allow_blessed;
#    my $convert_blessed;
#
#    my $indent_length;
#    my $escape_slash;
#    my $bignum;
#    my $as_nonblessed;
#
#    my $depth;
#    my $indent_count;
#    my $keysort;
#
#
#    sub PP_encode_json {
#        my $self = shift;
#        my $obj  = shift;
#
#        $indent_count = 0;
#        $depth        = 0;
#
#        my $idx = $self->{PROPS};
#
#        ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
#            $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
#         = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
#                    P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];
#
#        ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};
#
#        $keysort = $canonical ? sub { $a cmp $b } : undef;
#
#        if ($self->{sort_by}) {
#            $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
#                     : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
#                     : sub { $a cmp $b };
#        }
#
#        encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
#             if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);
#
#        my $str  = $self->object_to_json($obj);
#
#        $str .= "\n" if ( $indent ); 
#
#        unless ($ascii or $latin1 or $utf8) {
#            utf8::upgrade($str);
#        }
#
#        if ($idx->[ P_SHRINK ]) {
#            utf8::downgrade($str, 1);
#        }
#
#        return $str;
#    }
#
#
#    sub object_to_json {
#        my ($self, $obj) = @_;
#        my $type = ref($obj);
#
#        if($type eq 'HASH'){
#            return $self->hash_to_json($obj);
#        }
#        elsif($type eq 'ARRAY'){
#            return $self->array_to_json($obj);
#        }
#        elsif ($type) { 
#            if (blessed($obj)) {
#
#                return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );
#
#                if ( $convert_blessed and $obj->can('TO_JSON') ) {
#                    my $result = $obj->TO_JSON();
#                    if ( defined $result and ref( $result ) ) {
#                        if ( refaddr( $obj ) eq refaddr( $result ) ) {
#                            encode_error( sprintf(
#                                "%s::TO_JSON method returned same object as was passed instead of a new one",
#                                ref $obj
#                            ) );
#                        }
#                    }
#
#                    return $self->object_to_json( $result );
#                }
#
#                return "$obj" if ( $bignum and _is_bignum($obj) );
#                return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); 
#
#                encode_error( sprintf("encountered object '%s', but neither allow_blessed "
#                    . "nor convert_blessed settings are enabled", $obj)
#                ) unless ($allow_blessed);
#
#                return 'null';
#            }
#            else {
#                return $self->value_to_json($obj);
#            }
#        }
#        else{
#            return $self->value_to_json($obj);
#        }
#    }
#
#
#    sub hash_to_json {
#        my ($self, $obj) = @_;
#        my @res;
#
#        encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
#                                         if (++$depth > $max_depth);
#
#        my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
#        my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');
#
#        for my $k ( _sort( $obj ) ) {
#            if ( OLD_PERL ) { utf8::decode($k) } 
#            push @res, string_to_json( $self, $k )
#                          .  $del
#                          . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
#        }
#
#        --$depth;
#        $self->_down_indent() if ($indent);
#
#        return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
#    }
#
#
#    sub array_to_json {
#        my ($self, $obj) = @_;
#        my @res;
#
#        encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
#                                         if (++$depth > $max_depth);
#
#        my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
#
#        for my $v (@$obj){
#            push @res, $self->object_to_json($v) || $self->value_to_json($v);
#        }
#
#        --$depth;
#        $self->_down_indent() if ($indent);
#
#        return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
#    }
#
#
#    sub value_to_json {
#        my ($self, $value) = @_;
#
#        return 'null' if(!defined $value);
#
#        my $b_obj = B::svref_2object(\$value);  
#        my $flags = $b_obj->FLAGS;
#
#        return $value 
#            if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); 
#
#        my $type = ref($value);
#
#        if(!$type){
#            return string_to_json($self, $value);
#        }
#        elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
#            return $$value == 1 ? 'true' : 'false';
#        }
#        elsif ($type) {
#            if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
#                return $self->value_to_json("$value");
#            }
#
#            if ($type eq 'SCALAR' and defined $$value) {
#                return   $$value eq '1' ? 'true'
#                       : $$value eq '0' ? 'false'
#                       : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
#                       : encode_error("cannot encode reference to scalar");
#            }
#
#             if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
#                 return 'null';
#             }
#             else {
#                 if ( $type eq 'SCALAR' or $type eq 'REF' ) {
#                    encode_error("cannot encode reference to scalar");
#                 }
#                 else {
#                    encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
#                 }
#             }
#
#        }
#        else {
#            return $self->{fallback}->($value)
#                 if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
#            return 'null';
#        }
#
#    }
#
#
#    my %esc = (
#        "\n" => '\n',
#        "\r" => '\r',
#        "\t" => '\t',
#        "\f" => '\f',
#        "\b" => '\b',
#        "\"" => '\"',
#        "\\" => '\\\\',
#        "\'" => '\\\'',
#    );
#
#
#    sub string_to_json {
#        my ($self, $arg) = @_;
#
#        $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
#        $arg =~ s/\//\\\//g if ($escape_slash);
#        $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;
#
#        if ($ascii) {
#            $arg = JSON_PP_encode_ascii($arg);
#        }
#
#        if ($latin1) {
#            $arg = JSON_PP_encode_latin1($arg);
#        }
#
#        if ($utf8) {
#            utf8::encode($arg);
#        }
#
#        return '"' . $arg . '"';
#    }
#
#
#    sub blessed_to_json {
#        my $reftype = reftype($_[1]) || '';
#        if ($reftype eq 'HASH') {
#            return $_[0]->hash_to_json($_[1]);
#        }
#        elsif ($reftype eq 'ARRAY') {
#            return $_[0]->array_to_json($_[1]);
#        }
#        else {
#            return 'null';
#        }
#    }
#
#
#    sub encode_error {
#        my $error  = shift;
#        Carp::croak "$error";
#    }
#
#
#    sub _sort {
#        defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
#    }
#
#
#    sub _up_indent {
#        my $self  = shift;
#        my $space = ' ' x $indent_length;
#
#        my ($pre,$post) = ('','');
#
#        $post = "\n" . $space x $indent_count;
#
#        $indent_count++;
#
#        $pre = "\n" . $space x $indent_count;
#
#        return ($pre,$post);
#    }
#
#
#    sub _down_indent { $indent_count--; }
#
#
#    sub PP_encode_box {
#        {
#            depth        => $depth,
#            indent_count => $indent_count,
#        };
#    }
#
#} 
#
#
#sub _encode_ascii {
#    join('',
#        map {
#            $_ <= 127 ?
#                chr($_) :
#            $_ <= 65535 ?
#                sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
#        } unpack('U*', $_[0])
#    );
#}
#
#
#sub _encode_latin1 {
#    join('',
#        map {
#            $_ <= 255 ?
#                chr($_) :
#            $_ <= 65535 ?
#                sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
#        } unpack('U*', $_[0])
#    );
#}
#
#
#sub _encode_surrogates { 
#    my $uni = $_[0] - 0x10000;
#    return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
#}
#
#
#sub _is_bignum {
#    $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
#}
#
#
#
#
#my $max_intsize;
#
#BEGIN {
#    my $checkint = 1111;
#    for my $d (5..64) {
#        $checkint .= 1;
#        my $int   = eval qq| $checkint |;
#        if ($int =~ /[eE]/) {
#            $max_intsize = $d - 1;
#            last;
#        }
#    }
#}
#
#{ 
#
#    my %escapes = ( 
#        b    => "\x8",
#        t    => "\x9",
#        n    => "\xA",
#        f    => "\xC",
#        r    => "\xD",
#        '\\' => '\\',
#        '"'  => '"',
#        '/'  => '/',
#    );
#
#    my $text; 
#    my $at;   
#    my $ch;   
#    my $len;  
#    my $depth;          
#    my $encoding;       
#    my $is_valid_utf8;  
#    my $utf8_len;       
#    my $utf8;           
#    my $max_depth;      
#    my $max_size;
#    my $relaxed;
#    my $cb_object;
#    my $cb_sk_object;
#
#    my $F_HOOK;
#
#    my $allow_bigint;   
#    my $singlequote;    
#    my $loose;          
#    my $allow_barekey;  
#
#
#    sub PP_decode_json {
#        my ($self, $opt); 
#
#        ($self, $text, $opt) = @_;
#
#        ($at, $ch, $depth) = (0, '', 0);
#
#        if ( !defined $text or ref $text ) {
#            decode_error("malformed JSON string, neither array, object, number, string or atom");
#        }
#
#        my $idx = $self->{PROPS};
#
#        ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
#            = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];
#
#        if ( $utf8 ) {
#            utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
#        }
#        else {
#            utf8::upgrade( $text );
#            utf8::encode( $text );
#        }
#
#        $len = length $text;
#
#        ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
#             = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};
#
#        if ($max_size > 1) {
#            use bytes;
#            my $bytes = length $text;
#            decode_error(
#                sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
#                    , $bytes, $max_size), 1
#            ) if ($bytes > $max_size);
#        }
#
#        my @octets = unpack('C4', $text);
#        $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
#                    : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
#                    : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
#                    : ( $octets[2]                ) ? 'UTF-16LE'
#                    : (!$octets[2]                ) ? 'UTF-32LE'
#                    : 'unknown';
#
#        white(); 
#
#        my $valid_start = defined $ch; 
#
#        my $result = value();
#
#        return undef if ( !$result && ( $opt & 0x10000000 ) ); 
#
#        decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;
#
#        if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
#                decode_error(
#                'JSON text must be an object or array (but found number, string, true, false or null,'
#                       . ' use allow_nonref to allow this)', 1);
#        }
#
#        Carp::croak('something wrong.') if $len < $at; 
#
#        my $consumed = defined $ch ? $at - 1 : $at; 
#
#        white(); 
#
#        if ( $ch ) {
#            return ( $result, $consumed ) if ($opt & 0x00000001); 
#            decode_error("garbage after JSON object");
#        }
#
#        ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
#    }
#
#
#    sub next_chr {
#        return $ch = undef if($at >= $len);
#        $ch = substr($text, $at++, 1);
#    }
#
#
#    sub value {
#        white();
#        return          if(!defined $ch);
#        return object() if($ch eq '{');
#        return array()  if($ch eq '[');
#        return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
#        return number() if($ch =~ /[0-9]/ or $ch eq '-');
#        return word();
#    }
#
#    sub string {
#        my ($i, $s, $t, $u);
#        my $utf16;
#        my $is_utf8;
#
#        ($is_valid_utf8, $utf8_len) = ('', 0);
#
#        $s = ''; 
#
#        if($ch eq '"' or ($singlequote and $ch eq "'")){
#            my $boundChar = $ch;
#
#            OUTER: while( defined(next_chr()) ){
#
#                if($ch eq $boundChar){
#                    next_chr();
#
#                    if ($utf16) {
#                        decode_error("missing low surrogate character in surrogate pair");
#                    }
#
#                    utf8::decode($s) if($is_utf8);
#
#                    return $s;
#                }
#                elsif($ch eq '\\'){
#                    next_chr();
#                    if(exists $escapes{$ch}){
#                        $s .= $escapes{$ch};
#                    }
#                    elsif($ch eq 'u'){ 
#                        my $u = '';
#
#                        for(1..4){
#                            $ch = next_chr();
#                            last OUTER if($ch !~ /[0-9a-fA-F]/);
#                            $u .= $ch;
#                        }
#
#                        if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { 
#                            $utf16 = $u;
#                        }
#                        elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { 
#                            unless (defined $utf16) {
#                                decode_error("missing high surrogate character in surrogate pair");
#                            }
#                            $is_utf8 = 1;
#                            $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
#                            $utf16 = undef;
#                        }
#                        else {
#                            if (defined $utf16) {
#                                decode_error("surrogate pair expected");
#                            }
#
#                            if ( ( my $hex = hex( $u ) ) > 127 ) {
#                                $is_utf8 = 1;
#                                $s .= JSON_PP_decode_unicode($u) || next;
#                            }
#                            else {
#                                $s .= chr $hex;
#                            }
#                        }
#
#                    }
#                    else{
#                        unless ($loose) {
#                            $at -= 2;
#                            decode_error('illegal backslash escape sequence in string');
#                        }
#                        $s .= $ch;
#                    }
#                }
#                else{
#
#                    if ( ord $ch  > 127 ) {
#                        unless( $ch = is_valid_utf8($ch) ) {
#                            $at -= 1;
#                            decode_error("malformed UTF-8 character in JSON string");
#                        }
#                        else {
#                            $at += $utf8_len - 1;
#                        }
#
#                        $is_utf8 = 1;
#                    }
#
#                    if (!$loose) {
#                        if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { 
#                            $at--;
#                            decode_error('invalid character encountered while parsing JSON string');
#                        }
#                    }
#
#                    $s .= $ch;
#                }
#            }
#        }
#
#        decode_error("unexpected end of string while parsing JSON string");
#    }
#
#
#    sub white {
#        while( defined $ch  ){
#            if($ch le ' '){
#                next_chr();
#            }
#            elsif($ch eq '/'){
#                next_chr();
#                if(defined $ch and $ch eq '/'){
#                    1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
#                }
#                elsif(defined $ch and $ch eq '*'){
#                    next_chr();
#                    while(1){
#                        if(defined $ch){
#                            if($ch eq '*'){
#                                if(defined(next_chr()) and $ch eq '/'){
#                                    next_chr();
#                                    last;
#                                }
#                            }
#                            else{
#                                next_chr();
#                            }
#                        }
#                        else{
#                            decode_error("Unterminated comment");
#                        }
#                    }
#                    next;
#                }
#                else{
#                    $at--;
#                    decode_error("malformed JSON string, neither array, object, number, string or atom");
#                }
#            }
#            else{
#                if ($relaxed and $ch eq '#') { 
#                    pos($text) = $at;
#                    $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
#                    $at = pos($text);
#                    next_chr;
#                    next;
#                }
#
#                last;
#            }
#        }
#    }
#
#
#    sub array {
#        my $a  = $_[0] || []; 
#
#        decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
#                                                    if (++$depth > $max_depth);
#
#        next_chr();
#        white();
#
#        if(defined $ch and $ch eq ']'){
#            --$depth;
#            next_chr();
#            return $a;
#        }
#        else {
#            while(defined($ch)){
#                push @$a, value();
#
#                white();
#
#                if (!defined $ch) {
#                    last;
#                }
#
#                if($ch eq ']'){
#                    --$depth;
#                    next_chr();
#                    return $a;
#                }
#
#                if($ch ne ','){
#                    last;
#                }
#
#                next_chr();
#                white();
#
#                if ($relaxed and $ch eq ']') {
#                    --$depth;
#                    next_chr();
#                    return $a;
#                }
#
#            }
#        }
#
#        decode_error(", or ] expected while parsing array");
#    }
#
#
#    sub object {
#        my $o = $_[0] || {}; 
#        my $k;
#
#        decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
#                                                if (++$depth > $max_depth);
#        next_chr();
#        white();
#
#        if(defined $ch and $ch eq '}'){
#            --$depth;
#            next_chr();
#            if ($F_HOOK) {
#                return _json_object_hook($o);
#            }
#            return $o;
#        }
#        else {
#            while (defined $ch) {
#                $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
#                white();
#
#                if(!defined $ch or $ch ne ':'){
#                    $at--;
#                    decode_error("':' expected");
#                }
#
#                next_chr();
#                $o->{$k} = value();
#                white();
#
#                last if (!defined $ch);
#
#                if($ch eq '}'){
#                    --$depth;
#                    next_chr();
#                    if ($F_HOOK) {
#                        return _json_object_hook($o);
#                    }
#                    return $o;
#                }
#
#                if($ch ne ','){
#                    last;
#                }
#
#                next_chr();
#                white();
#
#                if ($relaxed and $ch eq '}') {
#                    --$depth;
#                    next_chr();
#                    if ($F_HOOK) {
#                        return _json_object_hook($o);
#                    }
#                    return $o;
#                }
#
#            }
#
#        }
#
#        $at--;
#        decode_error(", or } expected while parsing object/hash");
#    }
#
#
#    sub bareKey { 
#        my $key;
#        while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
#            $key .= $ch;
#            next_chr();
#        }
#        return $key;
#    }
#
#
#    sub word {
#        my $word =  substr($text,$at-1,4);
#
#        if($word eq 'true'){
#            $at += 3;
#            next_chr;
#            return $JSON::PP::true;
#        }
#        elsif($word eq 'null'){
#            $at += 3;
#            next_chr;
#            return undef;
#        }
#        elsif($word eq 'fals'){
#            $at += 3;
#            if(substr($text,$at,1) eq 'e'){
#                $at++;
#                next_chr;
#                return $JSON::PP::false;
#            }
#        }
#
#        $at--; 
#
#        decode_error("'null' expected")  if ($word =~ /^n/);
#        decode_error("'true' expected")  if ($word =~ /^t/);
#        decode_error("'false' expected") if ($word =~ /^f/);
#        decode_error("malformed JSON string, neither array, object, number, string or atom");
#    }
#
#
#    sub number {
#        my $n    = '';
#        my $v;
#        my $is_dec;
#
#        if($ch eq '0'){
#            my $peek = substr($text,$at,1);
#            my $hex  = $peek =~ /[xX]/; 
#
#            if($hex){
#                decode_error("malformed number (leading zero must not be followed by another digit)");
#                ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
#            }
#            else{ 
#                ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
#                if (defined $n and length $n > 1) {
#                    decode_error("malformed number (leading zero must not be followed by another digit)");
#                }
#            }
#
#            if(defined $n and length($n)){
#                if (!$hex and length($n) == 1) {
#                   decode_error("malformed number (leading zero must not be followed by another digit)");
#                }
#                $at += length($n) + $hex;
#                next_chr;
#                return $hex ? hex($n) : oct($n);
#            }
#        }
#
#        if($ch eq '-'){
#            $n = '-';
#            next_chr;
#            if (!defined $ch or $ch !~ /\d/) {
#                decode_error("malformed number (no digits after initial minus)");
#            }
#        }
#
#        while(defined $ch and $ch =~ /\d/){
#            $n .= $ch;
#            next_chr;
#        }
#
#        if(defined $ch and $ch eq '.'){
#            $n .= '.';
#            $is_dec = 1;
#
#            next_chr;
#            if (!defined $ch or $ch !~ /\d/) {
#                decode_error("malformed number (no digits after decimal point)");
#            }
#            else {
#                $n .= $ch;
#            }
#
#            while(defined(next_chr) and $ch =~ /\d/){
#                $n .= $ch;
#            }
#        }
#
#        if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
#            $n .= $ch;
#            next_chr;
#
#            if(defined($ch) and ($ch eq '+' or $ch eq '-')){
#                $n .= $ch;
#                next_chr;
#                if (!defined $ch or $ch =~ /\D/) {
#                    decode_error("malformed number (no digits after exp sign)");
#                }
#                $n .= $ch;
#            }
#            elsif(defined($ch) and $ch =~ /\d/){
#                $n .= $ch;
#            }
#            else {
#                decode_error("malformed number (no digits after exp sign)");
#            }
#
#            while(defined(next_chr) and $ch =~ /\d/){
#                $n .= $ch;
#            }
#
#        }
#
#        $v .= $n;
#
#        if ($v !~ /[.eE]/ and length $v > $max_intsize) {
#            if ($allow_bigint) { 
#                require Math::BigInt;
#                return Math::BigInt->new($v);
#            }
#            else {
#                return "$v";
#            }
#        }
#        elsif ($allow_bigint) {
#            require Math::BigFloat;
#            return Math::BigFloat->new($v);
#        }
#
#        return $is_dec ? $v/1.0 : 0+$v;
#    }
#
#
#    sub is_valid_utf8 {
#
#        $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
#                  : $_[0] =~ /[\xC2-\xDF]/  ? 2
#                  : $_[0] =~ /[\xE0-\xEF]/  ? 3
#                  : $_[0] =~ /[\xF0-\xF4]/  ? 4
#                  : 0
#                  ;
#
#        return unless $utf8_len;
#
#        my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);
#
#        return ( $is_valid_utf8 =~ /^(?:
#             [\x00-\x7F]
#            |[\xC2-\xDF][\x80-\xBF]
#            |[\xE0][\xA0-\xBF][\x80-\xBF]
#            |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
#            |[\xED][\x80-\x9F][\x80-\xBF]
#            |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
#            |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
#            |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
#            |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
#        )$/x )  ? $is_valid_utf8 : '';
#    }
#
#
#    sub decode_error {
#        my $error  = shift;
#        my $no_rep = shift;
#        my $str    = defined $text ? substr($text, $at) : '';
#        my $mess   = '';
#        my $type   = $] >= 5.008           ? 'U*'
#                   : $] <  5.006           ? 'C*'
#                   : utf8::is_utf8( $str ) ? 'U*' 
#                   : 'C*'
#                   ;
#
#        for my $c ( unpack( $type, $str ) ) { 
#            $mess .=  $c == 0x07 ? '\a'
#                    : $c == 0x09 ? '\t'
#                    : $c == 0x0a ? '\n'
#                    : $c == 0x0d ? '\r'
#                    : $c == 0x0c ? '\f'
#                    : $c <  0x20 ? sprintf('\x{%x}', $c)
#                    : $c == 0x5c ? '\\\\'
#                    : $c <  0x80 ? chr($c)
#                    : sprintf('\x{%x}', $c)
#                    ;
#            if ( length $mess >= 20 ) {
#                $mess .= '...';
#                last;
#            }
#        }
#
#        unless ( length $mess ) {
#            $mess = '(end of string)';
#        }
#
#        Carp::croak (
#            $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
#        );
#
#    }
#
#
#    sub _json_object_hook {
#        my $o    = $_[0];
#        my @ks = keys %{$o};
#
#        if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
#            my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
#            if (@val == 1) {
#                return $val[0];
#            }
#        }
#
#        my @val = $cb_object->($o) if ($cb_object);
#        if (@val == 0 or @val > 1) {
#            return $o;
#        }
#        else {
#            return $val[0];
#        }
#    }
#
#
#    sub PP_decode_box {
#        {
#            text    => $text,
#            at      => $at,
#            ch      => $ch,
#            len     => $len,
#            depth   => $depth,
#            encoding      => $encoding,
#            is_valid_utf8 => $is_valid_utf8,
#        };
#    }
#
#} 
#
#
#sub _decode_surrogates { 
#    my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
#    my $un  = pack('U*', $uni);
#    utf8::encode( $un );
#    return $un;
#}
#
#
#sub _decode_unicode {
#    my $un = pack('U', hex shift);
#    utf8::encode( $un );
#    return $un;
#}
#
#
#BEGIN {
#
#    unless ( defined &utf8::is_utf8 ) {
#       require Encode;
#       *utf8::is_utf8 = *Encode::is_utf8;
#    }
#
#    if ( $] >= 5.008 ) {
#        *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
#        *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
#        *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
#        *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
#    }
#
#    if ($] >= 5.008 and $] < 5.008003) { 
#        package JSON::PP;
#        require subs;
#        subs->import('join');
#        eval q|
#            sub join {
#                return '' if (@_ < 2);
#                my $j   = shift;
#                my $str = shift;
#                for (@_) { $str .= $j . $_; }
#                return $str;
#            }
#        |;
#    }
#
#
#    sub JSON::PP::incr_parse {
#        local $Carp::CarpLevel = 1;
#        ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
#    }
#
#
#    sub JSON::PP::incr_skip {
#        ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
#    }
#
#
#    sub JSON::PP::incr_reset {
#        ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
#    }
#
#    eval q{
#        sub JSON::PP::incr_text : lvalue {
#            $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
#
#            if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
#                Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
#            }
#            $_[0]->{_incr_parser}->{incr_text};
#        }
#    } if ( $] >= 5.006 );
#
#} 
#
#
#
#BEGIN {
#    eval 'require Scalar::Util';
#    unless($@){
#        *JSON::PP::blessed = \&Scalar::Util::blessed;
#        *JSON::PP::reftype = \&Scalar::Util::reftype;
#        *JSON::PP::refaddr = \&Scalar::Util::refaddr;
#    }
#    else{ 
#        eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
#        *JSON::PP::blessed = sub {
#            local($@, $SIG{__DIE__}, $SIG{__WARN__});
#            ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
#        };
#        my %tmap = qw(
#            B::NULL   SCALAR
#            B::HV     HASH
#            B::AV     ARRAY
#            B::CV     CODE
#            B::IO     IO
#            B::GV     GLOB
#            B::REGEXP REGEXP
#        );
#        *JSON::PP::reftype = sub {
#            my $r = shift;
#
#            return undef unless length(ref($r));
#
#            my $t = ref(B::svref_2object($r));
#
#            return
#                exists $tmap{$t} ? $tmap{$t}
#              : length(ref($$r)) ? 'REF'
#              :                    'SCALAR';
#        };
#        *JSON::PP::refaddr = sub {
#          return undef unless length(ref($_[0]));
#
#          my $addr;
#          if(defined(my $pkg = blessed($_[0]))) {
#            $addr .= bless $_[0], 'Scalar::Util::Fake';
#            bless $_[0], $pkg;
#          }
#          else {
#            $addr .= $_[0]
#          }
#
#          $addr =~ /0x(\w+)/;
#          local $^W;
#          hex($1);
#        }
#    }
#}
#
#
#
#$JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
#$JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };
#
#sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }
#
#sub true  { $JSON::PP::true  }
#sub false { $JSON::PP::false }
#sub null  { undef; }
#
#
#package JSON::PP::Boolean;
#
#use overload (
#   "0+"     => sub { ${$_[0]} },
#   "++"     => sub { $_[0] = ${$_[0]} + 1 },
#   "--"     => sub { $_[0] = ${$_[0]} - 1 },
#   fallback => 1,
#);
#
#
#
#package JSON::PP::IncrParser;
#
#use strict;
#
#use constant INCR_M_WS   => 0; 
#use constant INCR_M_STR  => 1; 
#use constant INCR_M_BS   => 2; 
#use constant INCR_M_JSON => 3; 
#use constant INCR_M_C0   => 4;
#use constant INCR_M_C1   => 5;
#
#$JSON::PP::IncrParser::VERSION = '1.01';
#
#my $unpack_format = $] < 5.006 ? 'C*' : 'U*';
#
#sub new {
#    my ( $class ) = @_;
#
#    bless {
#        incr_nest    => 0,
#        incr_text    => undef,
#        incr_parsing => 0,
#        incr_p       => 0,
#    }, $class;
#}
#
#
#sub incr_parse {
#    my ( $self, $coder, $text ) = @_;
#
#    $self->{incr_text} = '' unless ( defined $self->{incr_text} );
#
#    if ( defined $text ) {
#        if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
#            utf8::upgrade( $self->{incr_text} ) ;
#            utf8::decode( $self->{incr_text} ) ;
#        }
#        $self->{incr_text} .= $text;
#    }
#
#
#    my $max_size = $coder->get_max_size;
#
#    if ( defined wantarray ) {
#
#        $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};
#
#        if ( wantarray ) {
#            my @ret;
#
#            $self->{incr_parsing} = 1;
#
#            do {
#                push @ret, $self->_incr_parse( $coder, $self->{incr_text} );
#
#                unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
#                    $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
#                }
#
#            } until ( length $self->{incr_text} >= $self->{incr_p} );
#
#            $self->{incr_parsing} = 0;
#
#            return @ret;
#        }
#        else { 
#            $self->{incr_parsing} = 1;
#            my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
#            $self->{incr_parsing} = 0 if defined $obj; 
#            return $obj ? $obj : undef; 
#        }
#
#    }
#
#}
#
#
#sub _incr_parse {
#    my ( $self, $coder, $text, $skip ) = @_;
#    my $p = $self->{incr_p};
#    my $restore = $p;
#
#    my @obj;
#    my $len = length $text;
#
#    if ( $self->{incr_mode} == INCR_M_WS ) {
#        while ( $len > $p ) {
#            my $s = substr( $text, $p, 1 );
#            $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
#            $self->{incr_mode} = INCR_M_JSON;
#            last;
#       }
#    }
#
#    while ( $len > $p ) {
#        my $s = substr( $text, $p++, 1 );
#
#        if ( $s eq '"' ) {
#            if (substr( $text, $p - 2, 1 ) eq '\\' ) {
#                next;
#            }
#
#            if ( $self->{incr_mode} != INCR_M_STR  ) {
#                $self->{incr_mode} = INCR_M_STR;
#            }
#            else {
#                $self->{incr_mode} = INCR_M_JSON;
#                unless ( $self->{incr_nest} ) {
#                    last;
#                }
#            }
#        }
#
#        if ( $self->{incr_mode} == INCR_M_JSON ) {
#
#            if ( $s eq '[' or $s eq '{' ) {
#                if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
#                    Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
#                }
#            }
#            elsif ( $s eq ']' or $s eq '}' ) {
#                last if ( --$self->{incr_nest} <= 0 );
#            }
#            elsif ( $s eq '#' ) {
#                while ( $len > $p ) {
#                    last if substr( $text, $p++, 1 ) eq "\n";
#                }
#            }
#
#        }
#
#    }
#
#    $self->{incr_p} = $p;
#
#    return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
#    return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );
#
#    return '' unless ( length substr( $self->{incr_text}, 0, $p ) );
#
#    local $Carp::CarpLevel = 2;
#
#    $self->{incr_p} = $restore;
#    $self->{incr_c} = $p;
#
#    my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );
#
#    $self->{incr_text} = substr( $self->{incr_text}, $p );
#    $self->{incr_p} = 0;
#
#    return $obj || '';
#}
#
#
#sub incr_text {
#    if ( $_[0]->{incr_parsing} ) {
#        Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
#    }
#    $_[0]->{incr_text};
#}
#
#
#sub incr_skip {
#    my $self  = shift;
#    $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
#    $self->{incr_p} = 0;
#}
#
#
#sub incr_reset {
#    my $self = shift;
#    $self->{incr_text}    = undef;
#    $self->{incr_p}       = 0;
#    $self->{incr_mode}    = 0;
#    $self->{incr_nest}    = 0;
#    $self->{incr_parsing} = 0;
#}
#
#
#
#1;
#__END__
### JSON/PP/Boolean.pm ###
#
#use JSON::PP ();
#use strict;
#
#1;
#
#
### Lingua/EN/Numbers/Ordinate.pm ###
#package Lingua::EN::Numbers::Ordinate;
#$Lingua::EN::Numbers::Ordinate::VERSION = '1.04';
#
#use 5.006;
#use strict;
#use warnings;
#require Exporter;
#
#our @ISA        = qw/ Exporter  /;
#our @EXPORT     = qw/ ordinate  /;
#our @EXPORT_OK  = qw/ ordsuf th /;
#
#
#
#
#sub ordsuf ($) {
#  return 'th' if not(defined($_[0])) or not( 0 + $_[0] );
#  my $n = abs($_[0]);  
#  return 'th' unless $n == int($n); 
#  $n %= 100;
#  return 'th' if $n == 11 or $n == 12 or $n == 13;
#  $n %= 10;
#  return 'st' if $n == 1; 
#  return 'nd' if $n == 2;
#  return 'rd' if $n == 3;
#  return 'th';
#}
#
#sub ordinate ($) {
#  my $i = $_[0] || 0;
#  return $i . ordsuf($i);
#}
#
#no warnings 'all';
#*th = \&ordinate; 
#
#1;
#
#__END__
### Lingua/EN/PluralToSingular.pm ###
#package Lingua::EN::PluralToSingular;
#use warnings;
#use strict;
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw/to_singular is_plural/;
#our $VERSION = '0.19';
#
#
#
#
#my %irregular = (qw/
#    analyses analysis
#    brethren brother
#    children child
#    corpora corpus
#    craftsmen craftsman
#    crises crisis
#    criteria criterion
#    curricula curriculum
#    feet foot
#    fungi fungus
#    geese goose
#    genera genus
#    gentlemen gentleman
#    indices index
#    lice louse
#    matrices matrix
#    memoranda memorandum
#    men man
#    mice mouse
#    monies money
#    neuroses neurosis
#    nuclei nucleus
#    oases oasis
#    oxen ox
#    pence penny
#    people person
#    phenomena phenomenon
#    quanta quantum
#    strata stratum
#    teeth tooth
#    testes testis
#    these this
#    theses thesis
#    those that
#    women woman
#/);
#
#
#
#my %ves = (qw/
#    calves calf
#    dwarves dwarf
#    elves elf
#    halves half
#    knives knife
#    leaves leaf
#    lives life
#    loaves loaf
#    scarves scarf
#    sheaves sheaf
#    shelves shelf
#    wharves wharf 
#    wives wife
#    wolves wolf
#/);
#
#
#my %plural = (
#    'menus' => 'menu',
#    'buses' => 'bus',
#    %ves,
#    %irregular,
#);
#
#
#my @no_change = qw/
#                      deer
#                      ides
#                      fish
#                      means
#                      offspring
#                      series
#                      sheep
#                      species
#                  /;
#
#@plural{@no_change} = @no_change;
#
#
#
#
#my @not_plural = (qw/
#Aries
#Charles
#Gonzales 
#Hades 
#Hercules 
#Hermes 
#Holmes 
#Hughes 
#Ives 
#Jacques 
#James 
#Keyes 
#Mercedes 
#Naples 
#Oates 
#Raines 
#Texas
#athletics
#bogus
#bus
#cactus
#cannabis
#caries
#chaos
#citrus
#clothes
#corps
#corpus
#devious
#dias
#facies
#famous
#hippopotamus
#homunculus
#iris
#lens
#mathematics
#metaphysics
#metropolis
#mews
#minus
#miscellaneous
#molasses
#mrs
#narcissus
#news
#octopus
#ourselves
#papyrus
#perhaps
#physics
#platypus
#plus
#previous
#pus
#rabies
#scabies
#sometimes
#stylus
#themselves
#this
#thus
#various
#yes
#nucleus
#synchronous
#/);
#
#my %not_plural;
#
#@not_plural{@not_plural} = (1) x @not_plural;
#
#
#
#
#
#my @oes = (qw/
#canoes
#does
#foes
#gumshoes
#hoes
#horseshoes
#oboes
#shoes
#snowshoes
#throes
#toes
#/);
#
#my %oes;
#
#@oes{@oes} = (1) x @oes;
#
#
#
#
#
#
#
#my @ies = (qw/
#Aussies
#Valkryies
#aunties
#bogies
#brownies
#calories
#charlies
#coolies
#coteries
#curies
#cuties
#dies
#genies
#goalies
#kilocalories
#lies
#magpies
#menagerie
#movies
#neckties
#pies
#porkpies
#prairies
#quickies
#reveries
#rookies
#sorties
#stogies
#talkies
#ties
#zombies
#/);
#
#my %ies;
#
#@ies{@ies} = (1) x @ies;
#
#
#my @ses = (qw/
#automates
#bases
#cases
#causes
#ceases
#closes
#cornflakes
#creases
#databases
#deceases
#flakes
#horses
#increases
#mates
#parses
#purposes
#races
#releases
#tenses
#/);
#
#my %ses;
#@ses{@ses} = (1) x @ses;
#
#my $es_re = qr/([^aeiou]s|ch|sh)es$/;
#
#
#my @i_to_us = (qw/
#abaci
#abaculi
#acanthi
#acini
#alumni
#anthocauli
#bacilli
#baetuli
#cacti
#calculi
#calli
#catheti
#emboli
#emeriti
#esophagi
#foci
#foeti
#fumuli
#fungi
#gonococci
#hippopotami
#homunculi
#incubi
#loci
#macrofungi
#macronuclei
#naevi
#nuclei
#obeli
#octopi
#oeconomi
#oesophagi
#panni
#periœci
#phocomeli
#phoeti
#platypi
#polypi
#precunei
#radii
#rhombi
#sarcophagi
#solidi
#stimuli
#succubi
#syllabi
#thesauri
#thrombi
#tori
#trophi
#uteri
#viri
#virii
#xiphopagi
#zygomatici
#/);
#
#my %i_to_us;
#@i_to_us{@i_to_us} = (1) x @i_to_us;
#
#my @i_to_o = (qw/
#    alveoli
#    ghetti
#    manifesti
#    ostinati
#    pianissimi
#    scenarii
#    stiletti
#    torsi
#/);
#
#my %i_to_o;
#@i_to_o{@i_to_o} = (1) x @i_to_o;
#
#
#my %i_to_other = (
#    improvisatori => 'improvisatore',
#    rhinoceri => 'rhinoceros',
#    scaloppini => 'scaloppine'
#);
#
#
#sub to_singular
#{
#    my ($word) = @_;
#    my $singular = $word;
#    if (! $not_plural{$word}) {
#        if ($plural{$word}) {
#            $singular = $plural{$word};
#        }
#        elsif ($word =~ /s$/) {
#            if ($word =~ /'s$/) {
#            ;
#            }
#            elsif (length ($word) <= 2) {
#            ;
#            }
#            elsif ($word =~ /ss$/) {
#            ;
#            }
#            elsif ($word =~ /sis$/) {
#            ;
#            }
#            elsif ($word =~ /ies$/) {
#                if ($ies{$word}) {
#                    $singular =~ s/ies$/ie/;
#                }
#                else {
#                    $singular =~ s/ies$/y/;
#                }
#            }
#            elsif ($word =~ /oes$/) {
#                if ($oes{$word}) {
#                    $singular =~ s/oes$/oe/;
#                }
#                else {
#                    $singular =~ s/oes$/o/;
#                }
#            }
#            elsif ($word =~ /xes$/) {
#		        $singular =~ s/xes$/x/;
#            }
#            elsif ($word =~ /ses$/) {
#                if ($ses{$word}) {
#                    $singular =~ s/ses$/se/;
#                }
#                else {
#                    $singular =~ s/ses$/s/;
#                }
#	        }
#            elsif ($word =~ $es_re) {
#                $singular =~ s/$es_re/$1/;
#            }
#            else {
#                $singular =~ s/s$//;
#            }
#        }
#        elsif ($word =~ /i$/) {
#            if ($i_to_us{$word}) {
#                $singular =~ s/i$/us/;
#            }
#            elsif ($i_to_o{$word}) {
#                $singular =~ s/i$/o/;
#            }
#            if ($i_to_other{$word}) {
#                $singular = $i_to_other{$word};
#            }
#        }
#
#    }
#    return $singular;
#}
#
#sub is_plural
#{
#    my ($word) = @_;
#    my $singular = to_singular ($word);
#    my $is_plural;
#    if ($singular ne $word) {
#	$is_plural = 1;
#    }
#    elsif ($plural{$singular} && $plural{$singular} eq $singular) {
#	$is_plural = 1;
#    }
#    else {
#	$is_plural = 0;
#    }
#    return $is_plural;
#}
#
#1;
### Log/ger.pm ###
#package Log::ger;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#
#our $re_addr = qr/\(0x([0-9a-f]+)/o;
#
#our %Levels = (
#    fatal   => 10,
#    error   => 20,
#    warn    => 30,
#    info    => 40,
#    debug   => 50,
#    trace   => 60,
#);
#
#our %Level_Aliases = (
#    off     => 0,
#    warning => 30,
#);
#
#our $Current_Level = 30;
#
#our $Caller_Depth_Offset = 0;
#
#our $_logger_is_null;
#
#our $_dumper;
#
#our %Global_Hooks;
#
#
#our %Package_Targets; 
#our %Per_Package_Hooks; 
#
#our %Hash_Targets; 
#our %Per_Hash_Hooks; 
#
#our %Object_Targets; 
#our %Per_Object_Hooks; 
#
#my $sub0 = sub {0};
#my $sub1 = sub {1};
#my $default_null_routines;
#
#sub install_routines {
#    my ($target, $target_arg, $routines) = @_;
#
#    if ($target eq 'package') {
#        for my $r (@$routines) {
#            my ($code, $name, $lnum, $type) = @$r;
#            next unless $type =~ /_sub\z/;
#            *{"$target_arg\::$name"} = $code;
#        }
#    } elsif ($target eq 'object') {
#        my $pkg = ref $target_arg;
#        for my $r (@$routines) {
#            my ($code, $name, $lnum, $type) = @$r;
#            next unless $type =~ /_method\z/;
#            *{"$pkg\::$name"} = $code;
#        }
#    } elsif ($target eq 'hash') {
#        for my $r (@$routines) {
#            my ($code, $name, $lnum, $type) = @$r;
#            next unless $type =~ /_sub\z/;
#            $target_arg->{$name} = $code;
#        }
#    }
#}
#
#sub add_target {
#    my ($target, $target_arg, $args, $replace) = @_;
#    $replace = 1 unless defined $replace;
#
#    if ($target eq 'package') {
#        unless ($replace) { return if $Package_Targets{$target_arg} }
#        $Package_Targets{$target_arg} = $args;
#    } elsif ($target eq 'object') {
#        my ($addr) = "$target_arg" =~ $re_addr;
#        unless ($replace) { return if $Object_Targets{$addr} }
#        $Object_Targets{$addr} = [$target_arg, $args];
#    } elsif ($target eq 'hash') {
#        my ($addr) = "$target_arg" =~ $re_addr;
#        unless ($replace) { return if $Hash_Targets{$addr} }
#        $Hash_Targets{$addr} = [$target_arg, $args];
#    }
#}
#
#sub _set_default_null_routines {
#    $default_null_routines ||= [
#        (map {(
#            [$sub0, "log_$_", $Levels{$_}, 'log_sub'],
#            [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "log_is_$_", $Levels{$_}, 'is_sub'],
#            [$sub0, $_, $Levels{$_}, 'log_method'],
#            [$Levels{$_} > $Current_Level ? $sub0 : $sub1, "is_$_", $Levels{$_}, 'is_method'],
#        )} keys %Levels),
#    ];
#}
#
#sub get_logger {
#    my ($package, %args) = @_;
#
#    my $caller = caller(0);
#    $args{category} = $caller if !defined($args{category});
#    my $obj = []; $obj =~ $re_addr;
#    my $pkg = "Log::ger::Obj$1"; bless $obj, $pkg;
#    add_target(object => $obj, \%args);
#    if (keys %Global_Hooks) {
#        require Log::ger::Heavy;
#        init_target(object => $obj, \%args);
#    } else {
#        _set_default_null_routines();
#        install_routines(object => $obj, $default_null_routines);
#    }
#    $obj; 
#}
#
#sub import {
#    my ($package, %args) = @_;
#
#    my $caller = caller(0);
#    $args{category} = $caller if !defined($args{category});
#    add_target(package => $caller, \%args);
#    if (keys %Global_Hooks) {
#        require Log::ger::Heavy;
#        init_target(package => $caller, \%args);
#    } else {
#        _set_default_null_routines();
#        install_routines(package => $caller, $default_null_routines);
#    }
#}
#
#1;
#
#__END__
#
### Log/ger/App.pm ###
#package Log::ger::App;
#
#our $DATE = '2018-12-17'; 
#our $VERSION = '0.009'; 
#
#
#our $DEBUG = defined($ENV{LOG_GER_APP_DEBUG}) ? $ENV{LOG_GER_APP_DEBUG} : 0;
#
#sub _set_level {
#    my $name = shift;
#
#    while (my ($source, $param, $note) = splice @_, 0, 3) {
#        if ($source eq 'val') {
#            if (defined $param) {
#                warn "[lga] Setting $name to $param (from $note)\n" if $DEBUG;
#                return $param;
#            }
#        } elsif ($source eq 'envset') {
#            my $prefix = $param;
#            if (defined $ENV{"${prefix}LOG_LEVEL"}) {
#                my $val = $ENV{"${prefix}LOG_LEVEL"};
#                warn "[lga] Setting $name to $val (from environment ${prefix}LOG_LEVEL)\n" if $DEBUG;
#                return $val;
#            }
#            if ($ENV{"${prefix}TRACE"}) {
#                warn "[lga] Setting $name to trace (from environment ${prefix}TRACE)\n" if $DEBUG;
#                return 'trace';
#            }
#            if ($ENV{"${prefix}DEBUG"}) {
#                warn "[lga] Setting $name to debug (from environment ${prefix}DEBUG)\n" if $DEBUG;
#                return 'debug';
#            }
#            if ($ENV{"${prefix}VERBOSE"}) {
#                warn "[lga] Setting $name to info (from environment ${prefix}VERBOSE)\n" if $DEBUG;
#                return 'info';
#            }
#            if ($ENV{"${prefix}QUIET"}) {
#                warn "[lga] Setting $name to trace (from environment ${prefix}QUIET)\n" if $DEBUG;
#                return 'error';
#            }
#        } else {
#            die "BUG: Unknown level source '$source'";
#        }
#    }
#    'warn';
#}
#
#sub _is_daemon {
#    return $main::IS_DAEMON if defined $main::IS_DAEMON;
#    for (
#        "App/Daemon.pm",
#        "Daemon/Easy.pm",
#        "Daemon/Daemonize.pm",
#        "Daemon/Generic.pm",
#        "Daemonise.pm",
#        "Daemon/Simple.pm",
#        "HTTP/Daemon.pm",
#        "IO/Socket/INET/Daemon.pm",
#        "MooseX/Daemonize.pm",
#        "Net/Daemon.pm",
#        "Net/Server.pm",
#        "Proc/Daemon.pm",
#        "Proc/PID/File.pm",
#        "Win32/Daemon/Simple.pm") {
#        return 1 if $INC{$_};
#    }
#    0;
#}
#
#sub import {
#    no warnings 'once'; 
#
#    my ($pkg, %args) = @_;
#
#    require Log::ger;
#    require Log::ger::Util;
#
#    my $level = _set_level(
#        "general log level",
#        val => $args{level}, "import argument 'level'",
#        envset => "", "",
#        val => $args{default_level}, "import argument 'default_level'",
#        val => 'warn', "fallback value",
#    );
#    $Log::ger::Current_Level = Log::ger::Util::numeric_level($level);
#
#    my $is_daemon = $args{daemon};
#    $is_daemon = _is_daemon() if !defined($is_daemon);
#
#    my $is_oneliner = $0 eq '-e';
#
#    my $progname = $args{name};
#    unless (defined $progname) {
#        ($progname = $0) =~ s!.+/!!;
#        $progname =~ s/\.pl$//;
#    }
#    unless (length $progname) {
#        $progname = "prog";
#    }
#
#    my %conf = (
#        outputs => {},
#    );
#
#    {
#        last if $is_daemon;
#        my $olevel = _set_level(
#            "screen log level",
#            envset => "SCREEN_", "",
#            val => $level, "general log level",
#        );
#        last if $olevel eq 'off';
#        my $fmt = ($ENV{LOG_ADD_TIMESTAMP} ? '[%d] ': ''). '%m';
#        $conf{outputs}{Screen} = {
#            conf   => { formatter => sub { "$progname: $_[0]" } },
#            level  => $olevel,
#            layout => [Pattern => {format => $fmt}],
#        };
#    }
#
#    {
#        last if $0 eq '-';
#        require PERLANCAR::File::HomeDir;
#        my $path = $> ?
#            PERLANCAR::File::HomeDir::get_my_home_dir()."/$progname.log" :
#              "/var/log/$progname.log";
#        my $olevel = _set_level(
#            "file ($path) log level",
#            envset => "FILE_", "",
#            val => $level, "general log level",
#        );
#        last if $olevel eq 'off';
#        $conf{outputs}{File} = {
#            conf   => { path => $path },
#            level  => $olevel,
#            layout => [Pattern => {format => '[pid %P] [%d] %m'}],
#        };
#    }
#
#    {
#        last unless $is_daemon;
#        my $olevel = _set_level(
#            "syslog log level",
#            envset => "SYSLOG_", "",
#            val => $level, "general log level",
#        );
#        last if $olevel eq 'off';
#        $conf{outputs}{Syslog} = {
#            conf => { ident => $progname, facility => 'daemon' },
#            level => $olevel,
#        };
#    }
#
#    if ($args{outputs}) {
#        $conf{outputs}{$_} = $args{outputs}{$_}
#            for keys %{$args{outputs}{$_}};
#    }
#
#    require Log::ger::Output;
#    Log::ger::Output->set('Composite', %conf);
#}
#
#1;
#
#__END__
#
### Log/ger/Format.pm ###
#package Log::ger::Format;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use parent qw(Log::ger::Plugin);
#
#sub _import_sets_for_current_package { 1 }
#
#1;
#
#__END__
#
### Log/ger/Format/None.pm ###
#package Log::ger::Format::None;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#sub get_hooks {
#    return {
#        create_formatter => [
#            __PACKAGE__, 50,
#            sub {
#                [sub {shift}];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Heavy.pm ###
#package Log::ger::Heavy;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#
#package
#    Log::ger;
#
#
#our %Default_Hooks = (
#    create_formatter => [
#        [__PACKAGE__, 90,
#         sub {
#             my %args = @_;
#
#             my $formatter = sub {
#                 return $_[0] if @_ < 2;
#                 my $fmt = shift;
#                 my @args;
#                 for (@_) {
#                     if (!defined($_)) {
#                         push @args, '<undef>';
#                     } elsif (ref $_) {
#                         require Log::ger::Util unless $_dumper;
#                         push @args, Log::ger::Util::_dump($_);
#                     } else {
#                         push @args, $_;
#                     }
#                 }
#                 sprintf $fmt, @args;
#             };
#             [$formatter];
#         }],
#    ],
#
#    create_layouter => [],
#
#    create_routine_names => [
#        [__PACKAGE__, 90,
#         sub {
#             my %args = @_;
#
#             my $levels = [keys %Levels];
#
#             return [{
#                 log_subs    => [map { ["log_$_", $_]    } @$levels],
#                 is_subs     => [map { ["log_is_$_", $_] } @$levels],
#                 log_methods => [map { ["$_", $_]        } @$levels],
#                 is_methods  => [map { ["is_$_", $_]     } @$levels],
#             }, 1];
#         }],
#    ],
#
#    create_log_routine => [
#        [__PACKAGE__, 10,
#         sub {
#             my %args = @_;
#             my $level = $args{level};
#             if (defined($level) && (
#                 $Current_Level < $level ||
#                     @{ $Global_Hooks{create_log_routine} } == 1)
#             ) {
#                 $_logger_is_null = 1;
#                 return [sub {0}];
#             }
#             [undef]; 
#         }],
#    ],
#
#    create_logml_routine => [],
#
#    create_is_routine => [
#        [__PACKAGE__, 90,
#         sub {
#             my %args = @_;
#             my $level = $args{level};
#             [sub { $Current_Level >= $level }];
#         }],
#    ],
#
#    before_install_routines => [],
#
#    after_install_routines => [],
#);
#
#for my $phase (keys %Default_Hooks) {
#    $Global_Hooks{$phase} = [@{ $Default_Hooks{$phase} }];
#}
#
#sub run_hooks {
#    my ($phase, $hook_args, $flow_control,
#        $target, $target_arg) = @_;
#
#    $Global_Hooks{$phase} or die "Unknown phase '$phase'";
#    my @hooks = @{ $Global_Hooks{$phase} };
#
#    if ($target eq 'package') {
#        unshift @hooks, @{ $Per_Package_Hooks{$target_arg}{$phase} || [] };
#    } elsif ($target eq 'hash') {
#        my ($addr) = "$target_arg" =~ $re_addr;
#        unshift @hooks, @{ $Per_Hash_Hooks{$addr}{$phase} || [] };
#    } elsif ($target eq 'object') {
#        my ($addr) = "$target_arg" =~ $re_addr;
#        unshift @hooks, @{ $Per_Object_Hooks{$addr}{$phase} || [] };
#    }
#
#    my $res;
#    for my $hook (sort {$a->[1] <=> $b->[1]} @hooks)  {
#        my $hook_res = $hook->[2]->(%$hook_args);
#        if (defined $hook_res->[0]) {
#            $res = $hook_res->[0];
#            if (ref $flow_control eq 'CODE') {
#                last if $flow_control->($hook, $hook_res);
#            } else {
#                last if $flow_control;
#            }
#        }
#        last if $hook_res->[1];
#    }
#    return $res;
#}
#
#sub init_target {
#    my ($target, $target_arg, $init_args) = @_;
#
#    my %hook_args = (
#        target     => $target,
#        target_arg => $target_arg,
#        init_args  => $init_args,
#    );
#
#    my %formatters;
#    run_hooks(
#        'create_formatter', \%hook_args,
#        sub {
#            my ($hook, $hook_res) = @_;
#            my ($formatter, $flow_control, $fmtname) = @$hook_res;
#            $fmtname = 'default' if !defined($fmtname);
#            $formatters{$fmtname} ||= $formatter;
#            $flow_control;
#        },
#        $target, $target_arg);
#
#    my $layouter =
#        run_hooks('create_layouter', \%hook_args, 1, $target, $target_arg);
#
#    my $routine_names = {};
#    run_hooks(
#        'create_routine_names', \%hook_args,
#        sub {
#            my ($hook, $hook_res) = @_;
#            my ($rn, $flow_control) = @$hook_res;
#            $rn or return;
#            for (keys %$rn) {
#                push @{ $routine_names->{$_} }, @{ $rn->{$_} };
#            }
#            $flow_control;
#        },
#        $target, $target_arg);
#
#    my @routines;
#    my $object = $target eq 'object';
#
#  CREATE_LOG_ROUTINES:
#    {
#        my @rn;
#        if ($target eq 'package') {
#            push @rn, @{ $routine_names->{log_subs} || [] };
#            push @rn, @{ $routine_names->{logml_subs} || [] };
#        } else {
#            push @rn, @{ $routine_names->{log_methods} || [] };
#            push @rn, @{ $routine_names->{logml_methods} || [] };
#        }
#        my $mllogger0;
#        for my $rn (@rn) {
#            my ($rname, $lname, $fmtname) = @$rn;
#            my $lnum; $lnum = $Levels{$lname} if defined $lname;
#            my $routine_name_is_ml = !defined($lname);
#            $fmtname = 'default' if !defined($fmtname);
#
#            my $logger;
#            my ($logger0, $logger0_is_ml);
#            $_logger_is_null = 0;
#            for my $phase (qw/create_logml_routine create_log_routine/) {
#                local $hook_args{name} = $rname;
#                local $hook_args{level} = $lnum;
#                local $hook_args{str_level} = $lname;
#                $logger0_is_ml = $phase eq 'create_logml_routine';
#                if ($mllogger0) {
#                    $logger0 = $mllogger0;
#                    last;
#                }
#                $logger0 = run_hooks(
#                    $phase, \%hook_args, 1, $target, $target_arg)
#                    or next;
#                if ($logger0_is_ml) {
#                    $mllogger0 = $logger0;
#                }
#                last;
#            }
#            unless ($logger0) {
#                $_logger_is_null = 1;
#                $logger0 = sub {0};
#            }
#
#            require Log::ger::Util if !$logger0_is_ml && $routine_name_is_ml;
#
#            {
#                if ($_logger_is_null) {
#                    $logger = $logger0;
#                    last;
#                }
#
#                my $formatter = $formatters{$fmtname}
#                    or die "Formatter named '$fmtname' not available";
#                if ($formatter) {
#                    if ($layouter) {
#                        if ($logger0_is_ml) {
#                            if ($routine_name_is_ml) {
#                                if ($object) { $logger = sub { shift; my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
#                                                                                      $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
#                                } else {       $logger = sub {        my $lnum=shift; my $lname = Log::ger::Util::string_level($lnum);
#                                                                                      $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
#                            } else { 
#                                if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
#                                } else {       $logger = sub {                        $logger0->($init_args, $lnum, $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
#                            }
#                        } else { 
#                            if ($routine_name_is_ml) {
#                                if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
#                                                                                      $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
#                                } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
#                                                                                      $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
#                            } else { 
#                                if ($object) { $logger = sub { shift;                 $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) };
#                                } else {       $logger = sub {                        $logger0->($init_args,        $layouter->($formatter->(@_), $init_args, $lnum, $lname)) }; }
#                            }
#                        }
#                    } else { 
#                        if ($logger0_is_ml) {
#                            if ($routine_name_is_ml) {
#                                if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
#                                } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
#                            } else { 
#                                if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,             $formatter->(@_)                            ) };
#                                } else {       $logger = sub {                        $logger0->($init_args, $lnum,             $formatter->(@_)                            ) }; }
#                            }
#                        } else { 
#                            if ($routine_name_is_ml) {
#                                if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
#                                                                                      $logger0->($init_args,                    $formatter->(@_)                            ) };
#                                } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
#                                                                                      $logger0->($init_args,                    $formatter->(@_)                            ) }; }
#                            } else { 
#                                if ($object) { $logger = sub { shift;                 $logger0->($init_args,                    $formatter->(@_)                            ) };
#                                } else {       $logger = sub {                        $logger0->($init_args,                    $formatter->(@_)                            ) }; }
#                            }
#                        }
#                    }
#                } else { 
#                    { 
#                        if ($logger0_is_ml) {
#                            if ($routine_name_is_ml) {
#                                if ($object) { $logger = sub { shift; my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) };
#                                } else {       $logger = sub {        my $lnum=shift; $logger0->($init_args, $lnum,                          @_                             ) }; }
#                            } else { 
#                                if ($object) { $logger = sub { shift;                 $logger0->($init_args, $lnum,                          @_                             ) };
#                                } else {       $logger = sub {                        $logger0->($init_args, $lnum,                          @_                             ) }; }
#                            }
#                        } else { 
#                            if ($routine_name_is_ml) {
#                                if ($object) { $logger = sub { shift; return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
#                                                                                      $logger0->($init_args,                                 @_                             ) };
#                                } else {       $logger = sub {        return 0 if Log::ger::Util::numeric_level(shift) > $Current_Level;
#                                                                                      $logger0->($init_args,                                 @_                             ) }; }
#                            } else {
#                                if ($object) { $logger = sub { shift;                 $logger0->($init_args,                                 @_                             ) };
#                                } else {       $logger = sub {                        $logger0->($init_args,                                 @_                             ) }; }
#                            }
#                        }
#                    }
#                }
#            }
#          L1:
#            my $type = $routine_name_is_ml ?
#                ($object ? 'logml_method' : 'logml_sub') :
#                ($object ? 'log_method' : 'log_sub');
#            push @routines, [$logger, $rname, $lnum, $type];
#        }
#    }
#  CREATE_IS_ROUTINES:
#    {
#        my @rn;
#        my $type;
#        if ($target eq 'package') {
#            push @rn, @{ $routine_names->{is_subs} || [] };
#            $type = 'is_sub';
#        } else {
#            push @rn, @{ $routine_names->{is_methods} || [] };
#            $type = 'is_method';
#        }
#        for my $rn (@rn) {
#            my ($rname, $lname) = @$rn;
#            my $lnum = $Levels{$lname};
#
#            local $hook_args{name} = $rname;
#            local $hook_args{level} = $lnum;
#            local $hook_args{str_level} = $lname;
#
#            my $code_is =
#                run_hooks('create_is_routine', \%hook_args, 1,
#                          $target, $target_arg);
#            next unless $code_is;
#            push @routines, [$code_is, $rname, $lnum, $type];
#        }
#    }
#
#    {
#        local $hook_args{routines} = \@routines;
#        local $hook_args{formatters} = \%formatters;
#        local $hook_args{layouter} = $layouter;
#        run_hooks('before_install_routines', \%hook_args, 0,
#                  $target, $target_arg);
#    }
#
#    install_routines($target, $target_arg, \@routines);
#
#    {
#        local $hook_args{routines} = \@routines;
#        run_hooks('after_install_routines', \%hook_args, 0,
#                  $target, $target_arg);
#    }
#}
#
#1;
#
#__END__
#
### Log/ger/Layout.pm ###
#package Log::ger::Layout;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use parent qw(Log::ger::Plugin);
#
#sub _replace_package_regex { qr/\ALog::ger::Layout::/ }
#
#1;
#
#__END__
#
### Log/ger/Layout/Pattern.pm ###
#package Log::ger::Layout::Pattern;
#
#our $DATE = '2017-06-28'; 
#our $VERSION = '0.001'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Log::ger ();
#use Time::HiRes qw(time);
#
#our $caller_depth_offset = 4;
#
#our $time_start = time();
#our $time_now   = $time_start;
#our $time_last  = $time_start;
#
#my @per_message_data;
#
#our %format_for = (
#    'c' => sub { $_[1]{category} },
#    'C' => sub {
#        $per_message_data[0] //= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset)];
#        $per_message_data[1] //= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset-1)];
#        $per_message_data[0][0] // $per_message_data[1][0];
#    },
#    'd' => sub {
#        my @t = localtime($time_now);
#        sprintf(
#            "%04d-%02d-%02dT%02d:%02d:%02d",
#            $t[5]+1900, $t[4]+1, $t[3],
#            $t[2], $t[1], $t[0],
#        );
#    },
#    'D' => sub {
#        my @t = gmtime($time_now);
#        sprintf(
#            "%04d-%02d-%02dT%02d:%02d:%02d",
#            $t[5]+1900, $t[4]+1, $t[3],
#            $t[2], $t[1], $t[0],
#        );
#    },
#    'F' => sub {
#        $per_message_data[0] //= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset)];
#        $per_message_data[1] //= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset-1)];
#        $per_message_data[0][1] // $per_message_data[1][1];
#    },
#    'H' => sub {
#        require Sys::Hostname;
#        Sys::Hostname::hostname();
#    },
#    'l' => sub {
#        $per_message_data[0] ||= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset)];
#        $per_message_data[1] ||= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset-1)];
#        sprintf(
#            "%s (%s:%d)",
#            $per_message_data[0][3] // $per_message_data[1][3],
#            $per_message_data[1][1],
#            $per_message_data[1][2],
#        );
#    },
#    'L' => sub {
#        $per_message_data[1] ||= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset-1)];
#        $per_message_data[1][2];
#    },
#    'm' => sub { $_[0] },
#    'M' => sub {
#        $per_message_data[0] ||= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset)];
#        $per_message_data[1] ||= [caller($Log::ger::Caller_Depth_Offset+$caller_depth_offset-1)];
#        my $sub = $per_message_data[0][3] // $per_message_data[1][3];
#        $sub =~ s/.+:://;
#        $sub;
#    },
#    'n' => sub { "\n" },
#    'p' => sub { $_[3] },
#    'P' => sub { $$ },
#    'r' => sub { sprintf("%.3f", $time_now - $time_start) },
#    'R' => sub { sprintf("%.3f", $time_now - $time_last ) },
#    'T' => sub {
#        $per_message_data[2] //= do {
#            my @st;
#            my $i = $Log::ger::Caller_Depth_Offset+$caller_depth_offset-1;
#            while (my @c = caller($i++)) {
#                push @st, \@c;
#            }
#            \@st;
#        };
#        my $st = '';
#        for my $frame (@{ $per_message_data[2] }) {
#            $st .= "$frame->[3] ($frame->[1]:$frame->[2])\n";
#        }
#        $st;
#    },
#    '%' => sub { '%' },
#);
#
#sub _layout {
#    my $format = shift;
#
#    ($time_last, $time_now) = ($time_now, time());
#    @per_message_data = ();
#
#    $format =~ s/%(.)/
#        exists $format_for{$1} ? $format_for{$1}->(@_) :
#        die("Unknown format '%$1'")/eg;
#    $format;
#}
#
#sub get_hooks {
#    my %conf = @_;
#
#    $conf{format} or die "Please specify format";
#
#    return {
#        create_layouter => [
#            __PACKAGE__, 50,
#            sub {
#                [sub { _layout($conf{format}, @_) }];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output.pm ###
#package Log::ger::Output;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use parent 'Log::ger::Plugin';
#
#sub _replace_package_regex { qr/\ALog::ger::Output::/ }
#
#1;
#
#__END__
#
### Log/ger/Output/Array.pm ###
#package Log::ger::Output::Array;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use strict;
#use warnings;
#
#sub get_hooks {
#    my %conf = @_;
#
#    $conf{array} or die "Please specify array";
#
#    return {
#        create_log_routine => [
#            __PACKAGE__, 50,
#            sub {
#                my %args = @_;
#
#                my $logger = sub {
#                    my ($ctx, $msg) = @_;
#                    push @{$conf{array}}, $msg;
#                };
#                [$logger];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output/ArrayML.pm ###
#package Log::ger::Output::ArrayML;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use strict;
#use warnings;
#
#use Log::ger::Util;
#
#sub get_hooks {
#    my %conf = @_;
#
#    $conf{array} or die "Please specify array";
#
#    return {
#        create_logml_routine => [
#            __PACKAGE__, 50,
#            sub {
#                my %args = @_;
#                my $logger = sub {
#                    my $level = Log::ger::Util::numeric_level($_[1]);
#                    return if $level > $Log::ger::Current_Level;
#                    push @{$conf{array}}, $_[2];
#                };
#                [$logger];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output/Composite.pm ###
#package Log::ger::Output::Composite;
#
#our $DATE = '2019-01-31'; 
#our $VERSION = '0.008'; 
#
#use strict;
#use warnings;
#
#sub _get_min_max_level {
#    my $level = shift;
#    my ($min, $max);
#    if (defined $level) {
#        if (ref $level eq 'ARRAY') {
#            $min = Log::ger::Util::numeric_level($level->[0]);
#            $max = Log::ger::Util::numeric_level($level->[1]);
#            ($min, $max) = ($max, $min) if $min > $max;
#        } else {
#            $min = 0;
#            $max = Log::ger::Util::numeric_level($level);
#        }
#    }
#    ($min, $max);
#}
#
#sub get_hooks {
#    my %conf = @_;
#
#    for my $k (keys %conf) {
#        my $conf = $conf{$k};
#        if ($k eq 'outputs') {
#            for my $o (keys %$conf) {
#                for my $oconf (ref $conf->{$o} eq 'ARRAY' ?
#                                   @{ $conf->{$o} } : $conf->{$o}) {
#                    for my $k2 (keys %$oconf) {
#                        unless ($k2 =~
#                                    /\A(conf|level|category_level|layout)\z/) {
#                            die "Unknown configuration for output '$o': '$k2'";
#                        }
#                    }
#                }
#            }
#        } elsif ($k =~ /\A(category_level)\z/) {
#        } else {
#            die "Unknown configuration: '$k'";
#        }
#    }
#
#    my @ospecs;
#    {
#        my $outputs = $conf{outputs};
#        for my $oname (sort keys %$outputs) {
#            my $ospec0 = $outputs->{$oname};
#            my @ospecs0;
#            if (ref $ospec0 eq 'ARRAY') {
#                @ospecs0 = map { +{ %{$_} } } @$ospec0;
#            } else {
#                @ospecs0 = (+{ %{ $ospec0 } });
#            }
#
#            die "Invalid output name '$oname'"
#                unless $oname =~ /\A\w+(::\w+)*\z/;
#            my $mod = "Log::ger::Output::$oname";
#            (my $mod_pm = "$mod.pm") =~ s!::!/!g;
#            require $mod_pm;
#            for my $ospec (@ospecs0) {
#                $ospec->{_name} = $oname;
#                $ospec->{_mod} = $mod;
#                push @ospecs, $ospec;
#            }
#        }
#    }
#
#    return {
#        'create_logml_routine' => [
#            __PACKAGE__, 50,
#            sub {
#                no strict 'refs';
#                require Data::Dmp;
#
#                my %args = @_;
#
#                my $target = $args{target};
#                my $target_arg = $args{target_arg};
#
#                my $loggers = [];
#                my $logger_is_ml = [];
#                my $layouters = [];
#                for my $ospec (@ospecs) {
#                    my $oname = $ospec->{_name};
#                    my $mod = "Log::ger::Output::$oname";
#                    my $hooks = &{"$mod\::get_hooks"}(%{ $ospec->{conf} || {} })
#                        or die "Output module $mod does not return any hooks";
#                    my @hook_args = (
#                        target => $args{target},
#                        target_arg => $args{target_arg},
#                        init_args => $args{init_args},
#                    );
#                    my $res;
#                    {
#                        if ($hooks->{create_logml_routine}) {
#                            $res = $hooks->{create_logml_routine}->[2]->(
#                                @hook_args);
#                            if ($res->[0]) {
#                                push @$loggers, $res->[0];
#                                push @$logger_is_ml, 1;
#                                last;
#                            }
#                        }
#                        push @hook_args, (level => 6, str_level => 'trace');
#                        if ($hooks->{create_log_routine}) {
#                            $res = $hooks->{create_log_routine}->[2]->(
#                                @hook_args);
#                            if ($res->[0]) {
#                                push @$loggers, $res->[0];
#                                push @$logger_is_ml, 0;
#                                last;
#                            }
#                        }
#                        die "Output module $mod does not produce logger in ".
#                            "its create_logml_routine nor create_log_routine ".
#                                "hook";
#                    }
#                    if ($ospec->{layout}) {
#                        my $lname = $ospec->{layout}[0];
#                        my $lconf = $ospec->{layout}[1] || {};
#                        my $lmod  = "Log::ger::Layout::$lname";
#                        (my $lmod_pm = "$lmod.pm") =~ s!::!/!g;
#                        require $lmod_pm;
#                        my $lhooks = &{"$lmod\::get_hooks"}(%$lconf)
#                            or die "Layout module $lmod does not return ".
#                            "any hooks";
#                        $lhooks->{create_layouter}
#                            or die "Layout module $mod does not declare ".
#                            "layouter";
#                        my @lhook_args = (
#                            target => $args{target},
#                            target_arg => $args{target_arg},
#                            init_args => $args{init_args},
#                        );
#                        my $lres = $lhooks->{create_layouter}->[2]->(
#                            @lhook_args) or die "Hook from layout module ".
#                                "$lmod does not produce layout routine";
#                        ref $lres->[0] eq 'CODE'
#                            or die "Layouter from layout module $lmod ".
#                            "is not a coderef";
#                        push @$layouters, $lres->[0];
#                    } else {
#                        push @$layouters, undef;
#                    }
#                }
#                unless (@$loggers) {
#                    $Log::err::_logger_is_null = 1;
#                    return [sub {0}];
#                }
#
#                my $varname = do {
#                    my $suffix;
#                    if ($args{target} eq 'package') {
#                        $suffix = $args{target_arg};
#                    } else {
#                        ($suffix) = "$args{target_arg}" =~ /\(0x(\w+)/;
#                    }
#                    "Log::ger::Stash::OComposite_$suffix";
#                };
#                {
#                    no strict 'refs';
#                    ${$varname} = [];
#                    ${$varname}->[0] = $loggers;
#                    ${$varname}->[1] = $layouters;
#                    ${$varname}->[2] = $args{init_args};
#                }
#
#                my $logger;
#                {
#                    my @src;
#                    push @src, "sub {\n";
#                    push @src, "  my (\$ctx, \$lvl, \$msg) = \@_;\n";
#
#                    for my $i (0..$#ospecs) {
#                        my $ospec = $ospecs[$i];
#                        push @src, "  # output #$i: $ospec->{_name}\n";
#                        push @src, "  {\n";
#
#                        if ($ospec->{category_level} || $conf{category_level}) {
#                            push @src, "    my \$cat = \$ctx->{category} || ".
#                                "'';\n";
#
#                            my @cats;
#                            if ($ospec->{category_level}) {
#                                for my $cat (keys %{$ospec->{category_level}}) {
#                                    my $clevel = $ospec->{category_level}{$cat};
#                                    push @cats, [$cat, 1, $clevel];
#                                }
#                            }
#                            if ($conf{category_level}) {
#                                for my $cat (keys %{$conf{category_level}}) {
#                                    my $clevel = $conf{category_level}{$cat};
#                                    push @cats, [$cat, 2, $clevel];
#                                }
#                            }
#
#                            for my $cat (sort {
#                                length($b->[0]) <=> length($a->[0]) ||
#                                    $a->[0] cmp $b->[0] ||
#                                        $a->[1] <=> $b->[1]} @cats) {
#                                push @src, "    if (\$cat eq ".Data::Dmp::dmp($cat->[0])." || index(\$cat, ".Data::Dmp::dmp("$cat->[0]\::").") == 0) { ";
#                                my ($min_level, $max_level) =
#                                    _get_min_max_level($cat->[2]);
#                                push @src, "if (\$lvl >= $min_level && ".
#                                    "\$lvl <= $max_level) { goto L } else { last }";
#                                push @src, " }\n";
#                            }
#                            push @src, "\n";
#                        }
#
#                        my ($min_level, $max_level) = _get_min_max_level(
#                            $ospec->{level});
#                        if (defined $min_level) {
#                            push @src, "    if (\$lvl >= $min_level && ".
#                                "\$lvl <= $max_level) { goto L } else { last }\n";
#                        }
#
#                        push @src, "    if (\$Log::ger::Current_Level >= \$lvl) { goto L } else { last }\n";
#
#                        if ($logger_is_ml->[$i]) {
#                            push @src, "    L: if (\$$varname\->[1][$i]) { \$$varname\->[0][$i]->(\$ctx, \$lvl, \$$varname\->[1][$i]->(\$msg, \$$varname\->[2], \$lvl, Log::ger::Util::string_level(\$lvl))) } else { \$$varname\->[0][$i]->(\$ctx, \$lvl, \$msg) }\n";
#                        } else {
#                            push @src, "    L: if (\$$varname\->[1][$i]) { \$$varname\->[0][$i]->(\$ctx,        \$$varname\->[1][$i]->(\$msg, \$$varname\->[2], \$lvl, Log::ger::Util::string_level(\$lvl))) } else { \$$varname\->[0][$i]->(\$ctx,        \$msg) }\n";
#                        }
#                        push @src, "  }\n";
#                        push @src, "  # end output #$i\n\n";
#                    } 
#
#                    push @src, "};\n";
#                    my $src = join("", @src);
#
#                    $logger = eval $src;
#                }
#                [$logger];
#            }]
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output/File.pm ###
#package Log::ger::Output::File;
#
#our $DATE = '2017-08-02'; 
#our $VERSION = '0.006'; 
#
#
#use strict;
#use warnings;
#
#our %lock_handles;
#
#sub get_hooks {
#    my %conf = @_;
#
#    my $lazy      = $conf{lazy};
#    my $autoflush = $conf{autoflush}; $autoflush = 1 unless defined $autoflush;
#    my $lock_mode = $conf{lock_mode} || 'none';
#
#    (defined($conf{path}) || $conf{handle}) or
#        die "Please specify 'path' or 'handle'";
#    $lock_mode =~ /\A(none|write|exclusive)\z/ or
#        die "Invalid lock_mode, please choose none|write|exclusive";
#    $lock_mode ne 'none' && $conf{handle} and
#        die "Locking using handle not supported for now";
#
#    my $code_lock = sub {
#        require File::Flock::Retry;
#        my $key = defined($conf{path}) ? ":$conf{path}" : $conf{handle};
#        if ($lock_handles{$key}) {
#            return $lock_handles{$key};
#        }
#        $lock_handles{$key} = File::Flock::Retry->lock("$conf{path}.lck");
#        return $lock_handles{$key};
#    };
#
#    my $fh;
#    my $code_open = sub {
#        return if $fh;
#        if (defined(my $path = $conf{path})) {
#            open $fh, ">>", $path or die "Can't open log file '$path': $!";
#        } else {
#            $fh = $conf{handle};
#        }
#        $fh;
#    };
#
#    if ($lock_mode eq 'exclusive') {
#        $code_lock->();
#    }
#
#    $code_open->() unless $lazy;
#
#    return {
#        create_log_routine => [
#            __PACKAGE__, 50,
#            sub {
#                my %args = @_;
#
#                my $logger = sub {
#                    my $lock_handle;
#                    $code_open->() if $lazy && !$fh;
#                    $lock_handle = $code_lock->() if $lock_mode eq 'write';
#                    print $fh $_[1];
#                    print $fh "\n" unless $_[1] =~ /\R\z/;
#                    $fh->flush if $autoflush || $lock_handle;
#                    undef $lock_handle;
#                };
#                [$logger];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output/Null.pm ###
#package Log::ger::Output::Null;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#sub get_hooks {
#    return {
#        create_log_routine => [
#            __PACKAGE__, 50,
#            sub {
#                $Log::ger::_logger_is_null = 1;
#                [sub {0}];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output/Screen.pm ###
#package Log::ger::Output::Screen;
#
#our $DATE = '2018-12-22'; 
#our $VERSION = '0.008'; 
#
#use strict;
#use warnings;
#
#use Log::ger::Util;
#
#our %colors = (
#    10 => "\e[31m"  , 
#    20 => "\e[35m"  , 
#    30 => "\e[1;34m", 
#    40 => "\e[32m"  , 
#    50 => "",         
#    60 => "\e[33m"  , 
#);
#
#our %level_map;
#
#sub _pick_color {
#    my $level = shift;
#    if (defined(my $c = $colors{$level})) {
#        return $c;
#    }
#    if (defined(my $clevel = $level_map{$level})) {
#        return $colors{$clevel};
#    }
#
#    my ($dist, $clevel);
#    for my $k (keys %colors) {
#        my $d = abs($k - $level);
#        if (!defined($dist) || $dist > $d) {
#            $dist = $d;
#            $clevel = $k;
#        }
#    }
#    $level_map{$level} = $clevel;
#    return $colors{$clevel};
#}
#
#sub hook_before_log {
#    my ($ctx, $msg) = @_;
#}
#
#sub hook_after_log {
#    my ($ctx, $msg) = @_;
#    print { $ctx->{_fh} } "\n" unless $msg =~ /\R\z/;
#}
#
#sub get_hooks {
#    my %conf = @_;
#
#    my $stderr = $conf{stderr};
#    $stderr = 1 unless defined $stderr;
#    my $handle = $stderr ? \*STDERR : \*STDOUT;
#    my $use_color = do {
#        if (defined $conf{use_color}) {
#            $conf{use_color};
#        } elsif (exists $ENV{NO_COLOR}) {
#            0;
#        } elsif (defined $ENV{COLOR}) {
#            $ENV{COLOR};
#        } else {
#            (-t STDOUT);
#        }
#    };
#    my $formatter = $conf{formatter};
#
#    return {
#
#        create_log_routine => [
#            __PACKAGE__, 50,
#            sub {
#                my %args = @_;
#                my $logger = sub {
#                    my $level = $args{level};
#                    my $msg = $_[1];
#                    if ($formatter) {
#                        $msg = $formatter->($msg);
#                    }
#                    hook_before_log({ _fh=>$handle }, $msg);
#                    if ($use_color) {
#                        print $handle _pick_color($level), $msg, "\e[0m";
#                    } else {
#                        print $handle $msg;
#                    }
#                    hook_after_log({ _fh=>$handle }, $msg);
#                };
#                [$logger];
#            }],
#        create_logml_routine => [
#            __PACKAGE__, 50,
#            sub {
#                my %args = @_;
#                my $logger = sub {
#                    my $level = Log::ger::Util::numeric_level($_[1]);
#                    return if $level > $Log::ger::Current_Level;
#                    my $msg = $_[2];
#                    if ($formatter) {
#                        $msg = $formatter->($msg);
#                    }
#                    hook_before_log({ _fh=>$handle }, $msg);
#                    if ($use_color) {
#                        print $handle _pick_color($level), $msg, "\e[0m";
#                    } else {
#                        print $handle $msg;
#                    }
#                    hook_after_log({ _fh=>$handle }, $msg);
#                };
#                [$logger];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output/String.pm ###
#package Log::ger::Output::String;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use strict;
#use warnings;
#
#sub get_hooks {
#    my %conf = @_;
#
#    $conf{string} or die "Please specify string";
#
#    my $formatter = $conf{formatter};
#    my $append_newline = $conf{append_newline};
#    $append_newline = 1 unless defined $append_newline;
#
#    return {
#        create_log_routine => [
#            __PACKAGE__, 50,
#            sub {
#                my %args = @_;
#                my $level = $args{level};
#                my $logger = sub {
#                    my $msg = $_[1];
#                    if ($formatter) {
#                        $msg = $formatter->($msg);
#                    }
#                    ${ $conf{string} } .= $msg;
#                    ${ $conf{string} } .= "\n"
#                        unless !$append_newline || $msg =~ /\R\z/;
#                };
#                [$logger];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Output/Syslog.pm ###
#package Log::ger::Output::Syslog;
#
#our $DATE = '2017-07-12'; 
#our $VERSION = '0.001'; 
#
#use strict 'subs', 'vars';
#use warnings;
#
#our %level_map = (
#    fatal => 'crit',
#    error => 'err',
#    warn  => 'warning',
#    info  => 'info',
#    debug => 'debug',
#    trace => 'debug',
#);
#
#sub get_hooks {
#    my %conf = @_;
#
#    my $ident = delete($conf{ident});
#    defined($ident) or die "Please specify ident";
#
#    my $facility = $conf{facility} || 'user';
#    $facility =~ /\A(auth|daemon|ftp|mail|user)\z/
#        or die "Invalid value for facility, please choose ".
#        "auth|daemon|ftp|mail|user";
#
#    my $logopt = delete($conf{logopt});
#    $logopt = "pid" unless defined $logopt;
#
#    require Sys::Syslog;
#    Sys::Syslog::openlog($ident, $logopt, $facility) or die;
#
#    return {
#        create_log_routine => [
#            __PACKAGE__, 50,
#            sub {
#                my %args = @_;
#
#                my $str_level = $args{str_level};
#                $level_map{$str_level} or die "Don't know how to map ".
#                    "Log::ger level '$str_level' to syslog level";
#
#                my $logger = sub {
#                    Sys::Syslog::syslog(
#                        &{"Sys::Syslog::LOG_".uc($level_map{$str_level})},
#                        $_[1],
#                    );
#                };
#                [$logger];
#            }],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Plugin.pm ###
#package Log::ger::Plugin;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use strict;
#use warnings;
#
#use Log::ger::Util;
#
#sub set {
#    my $pkg = shift;
#
#    my %args;
#    if (ref $_[0] eq 'HASH') {
#        %args = %{shift()};
#    } else {
#        %args = (name => shift, conf => {@_});
#    }
#
#    $args{prefix} ||= $pkg . '::';
#    $args{replace_package_regex} = $pkg->_replace_package_regex;
#    Log::ger::Util::set_plugin(%args);
#}
#
#sub set_for_current_package {
#    my $pkg = shift;
#
#    my %args;
#    if (ref $_[0] eq 'HASH') {
#        %args = %{shift()};
#    } else {
#        %args = (name => shift, conf => {@_});
#    }
#
#    my $caller = caller(0);
#    $args{target} = 'package';
#    $args{target_arg} = $caller;
#
#    set($pkg, \%args);
#}
#
#sub _import_sets_for_current_package { 0 }
#
#sub _replace_package_regex { undef }
#
#sub import {
#    if (@_ > 1) {
#        if ($_[0]->_import_sets_for_current_package) {
#            goto &set_for_current_package;
#        } else {
#            goto &set;
#        }
#    }
#}
#
#1;
#
#__END__
#
### Log/ger/Plugin/MultilevelLog.pm ###
#package Log::ger::Plugin::MultilevelLog;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use strict;
#use warnings;
#
#use Log::ger::Util;
#
#sub get_hooks {
#    my %conf = @_;
#
#    return {
#        create_routine_names => [
#            __PACKAGE__, 50,
#            sub {
#                return [{
#                    logml_subs    => [[$conf{sub_name}    || 'log', undef]],
#                    logml_methods => [[$conf{method_name} || 'log', undef]],
#                }];
#            },
#        ],
#    };
#}
#
#1;
#
#__END__
#
### Log/ger/Util.pm ###
#package Log::ger::Util;
#
#our $DATE = '2018-12-20'; 
#our $VERSION = '0.025'; 
#
#use strict;
#use warnings;
#
#require Log::ger;
#require Log::ger::Heavy;
#
#sub _dump {
#    unless ($Log::ger::_dumper) {
#        eval {
#            no warnings 'once';
#            require Data::Dmp;
#            $Data::Dmp::OPT_REMOVE_PRAGMAS = 1;
#            1;
#        };
#        if ($@) {
#            no warnings 'once';
#            require Data::Dumper;
#            $Log::ger::_dumper = sub {
#                local $Data::Dumper::Terse = 1;
#                local $Data::Dumper::Indent = 0;
#                local $Data::Dumper::Useqq = 1;
#                local $Data::Dumper::Deparse = 1;
#                local $Data::Dumper::Quotekeys = 0;
#                local $Data::Dumper::Sortkeys = 1;
#                local $Data::Dumper::Trailingcomma = 1;
#                Data::Dumper::Dumper($_[0]);
#            };
#        } else {
#            $Log::ger::_dumper = sub { Data::Dmp::dmp($_[0]) };
#        }
#    }
#    $Log::ger::_dumper->($_[0]);
#}
#
#sub numeric_level {
#    my $level = shift;
#    return $level if $level =~ /\A\d+\z/;
#    return $Log::ger::Levels{$level}
#        if defined $Log::ger::Levels{$level};
#    return $Log::ger::Level_Aliases{$level}
#        if defined $Log::ger::Level_Aliases{$level};
#    die "Unknown level '$level'";
#}
#
#sub string_level {
#    my $level = shift;
#    return $level if defined $Log::ger::Levels{$level};
#    $level = $Log::ger::Level_Aliases{$level}
#        if defined $Log::ger::Level_Aliases{$level};
#    for (keys %Log::ger::Levels) {
#        my $v = $Log::ger::Levels{$_};
#        return $_ if $v == $level;
#    }
#    die "Unknown level '$level'";
#}
#
#sub set_level {
#    no warnings 'once';
#    $Log::ger::Current_Level = numeric_level(shift);
#    reinit_all_targets();
#}
#
#sub _action_on_hooks {
#    no warnings 'once';
#
#    my ($action, $target, $target_arg, $phase) = splice @_, 0, 4;
#
#    my $hooks = $Log::ger::Global_Hooks{$phase} or die "Unknown phase '$phase'";
#    if ($target eq 'package') {
#        $hooks = ($Log::ger::Per_Package_Hooks{$target_arg}{$phase} ||= []);
#    } elsif ($target eq 'object') {
#        my ($addr) = $target_arg =~ $Log::ger::re_addr;
#        $hooks = ($Log::ger::Per_Object_Hooks{$addr}{$phase} ||= []);
#    } elsif ($target eq 'hash') {
#        my ($addr) = $target_arg =~ $Log::ger::re_addr;
#        $hooks = ($Log::ger::Per_Hash_Hooks{$addr}{$phase} ||= []);
#    }
#
#    if ($action eq 'add') {
#        my $hook = shift;
#        unshift @$hooks, $hook;
#    } elsif ($action eq 'remove') {
#        my $code = shift;
#        for my $i (reverse 0..$#{$hooks}) {
#            splice @$hooks, $i, 1 if $code->($hooks->[$i]);
#        }
#    } elsif ($action eq 'reset') {
#        my $saved = [@$hooks];
#        splice @$hooks, 0, scalar(@$hooks),
#            @{ $Log::ger::Default_Hooks{$phase} };
#        return $saved;
#    } elsif ($action eq 'empty') {
#        my $saved = [@$hooks];
#        splice @$hooks, 0;
#        return $saved;
#    } elsif ($action eq 'save') {
#        return [@$hooks];
#    } elsif ($action eq 'restore') {
#        my $saved = shift;
#        splice @$hooks, 0, scalar(@$hooks), @$saved;
#        return $saved;
#    }
#}
#
#sub add_hook {
#    my ($phase, $hook) = @_;
#    _action_on_hooks('add', '', undef, $phase, $hook);
#}
#
#sub add_per_target_hook {
#    my ($target, $target_arg, $phase, $hook) = @_;
#    _action_on_hooks('add', $target, $target_arg, $phase, $hook);
#}
#
#sub remove_hook {
#    my ($phase, $code) = @_;
#    _action_on_hooks('remove', '', undef, $phase, $code);
#}
#
#sub remove_per_target_hook {
#    my ($target, $target_arg, $phase, $code) = @_;
#    _action_on_hooks('remove', $target, $target_arg, $phase, $code);
#}
#
#sub reset_hooks {
#    my ($phase) = @_;
#    _action_on_hooks('reset', '', undef, $phase);
#}
#
#sub reset_per_target_hooks {
#    my ($target, $target_arg, $phase) = @_;
#    _action_on_hooks('reset', $target, $target_arg, $phase);
#}
#
#sub empty_hooks {
#    my ($phase) = @_;
#    _action_on_hooks('empty', '', undef, $phase);
#}
#
#sub empty_per_target_hooks {
#    my ($target, $target_arg, $phase) = @_;
#    _action_on_hooks('empty', $target, $target_arg, $phase);
#}
#
#sub save_hooks {
#    my ($phase) = @_;
#    _action_on_hooks('save', '', undef, $phase);
#}
#
#sub save_per_target_hooks {
#    my ($target, $target_arg, $phase) = @_;
#    _action_on_hooks('save', $target, $target_arg, $phase);
#}
#
#sub restore_hooks {
#    my ($phase, $saved) = @_;
#    _action_on_hooks('restore', '', undef, $phase, $saved);
#}
#
#sub restore_per_target_hooks {
#    my ($target, $target_arg, $phase, $saved) = @_;
#    _action_on_hooks('restore', $target, $target_arg, $phase, $saved);
#}
#
#sub reinit_target {
#    my ($target, $target_arg) = @_;
#
#    Log::ger::add_target($target, $target_arg, {}, 0);
#
#    if ($target eq 'package') {
#        my $init_args = $Log::ger::Package_Targets{$target_arg};
#        Log::ger::init_target(package => $target_arg, $init_args);
#    } elsif ($target eq 'object') {
#        my ($obj_addr) = $target_arg =~ $Log::ger::re_addr
#            or die "Invalid object '$target_arg': not a reference";
#        my $v = $Log::ger::Object_Targets{$obj_addr}
#            or die "Unknown object target '$target_arg'";
#        Log::ger::init_target(object => $v->[0], $v->[1]);
#    } elsif ($target eq 'hash') {
#        my ($hash_addr) = $target_arg =~ $Log::ger::re_addr
#            or die "Invalid hashref '$target_arg': not a reference";
#        my $v = $Log::ger::Hash_Targets{$hash_addr}
#            or die "Unknown hash target '$target_arg'";
#        Log::ger::init_target(hash => $v->[0], $v->[1]);
#    } else {
#        die "Unknown target '$target'";
#    }
#}
#
#sub reinit_all_targets {
#    for my $pkg (keys %Log::ger::Package_Targets) {
#        Log::ger::init_target(
#            package => $pkg, $Log::ger::Package_Targets{$pkg});
#    }
#    for my $k (keys %Log::ger::Object_Targets) {
#        my ($obj, $init_args) = @{ $Log::ger::Object_Targets{$k} };
#        Log::ger::init_target(object => $obj, $init_args);
#    }
#    for my $k (keys %Log::ger::Hash_Targets) {
#        my ($hash, $init_args) = @{ $Log::ger::Hash_Targets{$k} };
#        Log::ger::init_target(hash => $hash, $init_args);
#    }
#}
#
#sub set_plugin {
#    my %args = @_;
#
#    my $hooks;
#    if ($args{hooks}) {
#        $hooks = $args{hooks};
#    } else {
#        no strict 'refs';
#        my $prefix = $args{prefix} || 'Log::ger::Plugin::';
#        my $mod = $args{name};
#        $mod = $prefix . $mod unless index($mod, $prefix) == 0;
#        (my $mod_pm = "$mod.pm") =~ s!::!/!g;
#        require $mod_pm;
#        $hooks = &{"$mod\::get_hooks"}(%{ $args{conf} || {} });
#    }
#
#    {
#        last unless $args{replace_package_regex};
#        my $all_hooks;
#        if (!$args{target}) {
#            $all_hooks = \%Log::ger::Global_Hooks;
#        } elsif ($args{target} eq 'package') {
#            $all_hooks = $Log::ger::Per_Package_Hooks{ $args{target_arg} };
#        } elsif ($args{target} eq 'object') {
#            my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
#            $all_hooks = $Log::ger::Per_Object_Hooks{$addr};
#        } elsif ($args{target} eq 'hash') {
#            my ($addr) = $args{target_arg} =~ $Log::ger::re_addr;
#            $all_hooks = $Log::ger::Per_Hash_Hooks{$addr};
#        }
#        last unless $all_hooks;
#        for my $phase (keys %$all_hooks) {
#            my $hooks = $all_hooks->{$phase};
#            for my $i (reverse 0..$#{$hooks}) {
#                splice @$hooks, $i, 1
#                    if $hooks->[$i][0] =~ $args{replace_package_regex};
#            }
#        }
#    }
#
#    for my $phase (keys %$hooks) {
#        my $hook = $hooks->{$phase};
#        if (defined $args{target}) {
#            add_per_target_hook(
#                $args{target}, $args{target_arg}, $phase, $hook);
#        } else {
#            add_hook($phase, $hook);
#        }
#    }
#
#    my $reinit = $args{reinit};
#    $reinit = 1 unless defined $reinit;
#    if ($reinit) {
#        if (defined $args{target}) {
#            reinit_target($args{target}, $args{target_arg});
#        } else {
#            reinit_all_targets();
#        }
#    }
#}
#
#1;
#
#__END__
#
### Mo.pm ###
#package Mo;
#$Mo::VERSION = '0.40';
#$VERSION='0.40';
#no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{my$c=shift;my$s=bless{@_},$c;my%n=%{$c.'::'.':E'};map{$s->{$_}=$n{$_}->()if!exists$s->{$_}}keys%n;$s};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};@_=(default,@_)if!($#_%2);$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};
### Mo/Golf.pm ###
#
#use strict;
#use warnings;
#package Mo::Golf;
#
#our $VERSION='0.40';
#
#use PPI;
#
#my %short_names = (
#    (
#        map {($_, substr($_, 0, 1))}
#        qw(
#            args builder class default exports features
#            generator import is_lazy method MoPKG name
#            nonlazy_defaults options reftype self
#        )
#    ),
#    build_subs => 'B',
#    old_constructor => 'C',
#    caller_pkg => 'P',
#);
#
#my %short_barewords = ( EAGERINIT => q{':E'}, NONLAZY => q{':N'} );
#
#my %hands_off = map {($_,1)} qw'&import *import';
#
#sub import {
#    return unless @_ == 2 and $_[1] eq 'golf';
#    binmode STDOUT;
#    my $text = do { local $/; <> };
#    print STDOUT golf( $text );
#};
#
#sub golf {
#    my ( $text ) = @_;
#
#    my $tree = PPI::Document->new( \$text );
#
#    my %finder_subs = _finder_subs();
#
#    my @order = qw( comments duplicate_whitespace whitespace trailing_whitespace );
#
#    for my $name ( @order ) {
#        my $elements = $tree->find( $finder_subs{$name} );
#        die $@ if !defined $elements;
#        $_->delete for @{ $elements || [] };
#    }
#
#    $tree->find( $finder_subs{$_} )
#      for qw( del_superfluous_concat del_last_semicolon_in_block separate_version shorten_var_names shorten_barewords );
#    die $@ if $@;
#
#    for my $name ( 'double_semicolon' ) {
#        my $elements = $tree->find( $finder_subs{$name} );
#        die $@ if !defined $elements;
#        $_->delete for @{ $elements || [] };
#    }
#
#    return $tree->serialize . "\n";
#}
#
#sub tok { "PPI::Token::$_[0]" }
#
#sub _finder_subs {
#    return (
#        comments => sub { $_[1]->isa( tok 'Comment' ) },
#
#        duplicate_whitespace => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( tok 'Whitespace' );
#
#            $current->set_content(' ') if 1 < length $current->content;
#
#            return 0 if !$current->next_token;
#            return 0 if !$current->next_token->isa( tok 'Whitespace' );
#            return 1;
#        },
#
#        whitespace => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( tok 'Whitespace' );
#            my $prev = $current->previous_token;
#            my $next = $current->next_token;
#
#            return 1 if $prev->isa( tok 'Number' ) and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; 
#            return 1 if $prev->isa( tok 'Word' )   and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; 
#            return 1 if $prev->isa( tok 'Symbol' ) and $next->isa( tok 'Operator' ) and $next->content =~ /^\W/; 
#
#            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Single' ) and $next->content =~ /^\W/; 
#            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Quote::Double' ) and $next->content =~ /^\W/; 
#            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Symbol' )        and $next->content =~ /^\W/; 
#            return 1 if $prev->isa( tok 'Operator' ) and $next->isa( tok 'Structure' )     and $next->content =~ /^\W/; 
#
#            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Symbol' );           
#            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Structure' );        
#            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Quote::Double' );    
#            return 1 if $prev->isa( tok 'Symbol' )     and $next->isa( tok 'Structure' );        
#            return 1 if $prev->isa( tok 'ArrayIndex' ) and $next->isa( tok 'Operator' );         
#            return 1 if $prev->isa( tok 'Word' )       and $next->isa( tok 'Cast' );             
#            return 0;
#        },
#
#        trailing_whitespace => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( tok 'Whitespace' );
#            my $prev = $current->previous_token;
#
#            return 1 if $prev->isa( tok 'Structure' );                                           
#            return 1 if $prev->isa( tok 'Operator' ) and $prev->content =~ /\W$/;                
#            return 1 if $prev->isa( tok 'Quote::Double' );                                       
#            return 1 if $prev->isa( tok 'Quote::Single' );                                       
#
#            return 0;
#        },
#
#        double_semicolon => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( tok 'Structure' );
#            return 0 if $current->content ne ';';
#
#            my $prev = $current->previous_token;
#
#            return 0 if !$prev->isa( tok 'Structure' );
#            return 0 if $prev->content ne ';';
#
#            return 1;
#        },
#
#        del_last_semicolon_in_block => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( 'PPI::Structure::Block' );
#
#            my $last = $current->last_token;
#
#            return 0 if !$last->isa( tok 'Structure' );
#            return 0 if $last->content ne '}';
#
#            my $maybe_semi = $last->previous_token;
#
#            return 0 if !$maybe_semi->isa( tok 'Structure' );
#            return 0 if $maybe_semi->content ne ';';
#
#            $maybe_semi->delete;
#
#            return 1;
#        },
#
#        del_superfluous_concat => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( tok 'Operator' );
#
#            my $prev = $current->previous_token;
#            my $next = $current->next_token;
#
#            return 0 if $current->content ne '.';
#            return 0 if !$prev->isa( tok 'Quote::Double' );
#            return 0 if !$next->isa( tok 'Quote::Double' );
#
#            $current->delete;
#            $prev->set_content( $prev->{separator} . $prev->string . $next->string . $prev->{separator} );
#            $next->delete;
#
#            return 1;
#        },
#
#        separate_version => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( 'PPI::Statement' );
#
#            my $first = $current->first_token;
#            return 0 if $first->content ne '$VERSION';
#
#            $current->$_( PPI::Token::Whitespace->new( "\n" ) ) for qw( insert_before insert_after );
#
#            return 1;
#        },
#
#        shorten_var_names => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( tok 'Symbol' );
#
#            my $long_name = $current->canonical;
#
#            return 1 if $hands_off{$long_name};
#            (my $name = $long_name) =~ s/^([\$\@\%])// or die $long_name;
#            my $sigil = $1;
#            die "variable $long_name conflicts with shortened var name"
#                if grep {
#                    $name eq $_
#                } values %short_names;
#
#            my $short_name = $short_names{$name};
#            $current->set_content( "$sigil$short_name" ) if $short_name;
#
#            return 1;
#        },
#
#        shorten_barewords => sub {
#            my ( $top, $current ) = @_;
#            return 0 if !$current->isa( tok 'Word' );
#
#            my $name = $current->content;
#
#            die "bareword $name conflicts with shortened bareword"
#                if grep {
#                    $name eq $_
#                } values %short_barewords;
#
#            my $short_name = $short_barewords{$name};
#            $current->set_content( $short_name ) if $short_name;
#
#            return 1;
#        },
#    );
#}
#
### Mo/Inline.pm ###
#
#package Mo::Inline;
#use Mo;
#
#our $VERSION='0.40';
#
#use IO::All;
#
#my $matcher = qr/((?m:^#\s*use Mo(\s.*)?;.*\n))(?:#.*\n)*(?:.{400,}\n)?/;
#
#sub run {
#    my $self = shift;
#    my @files;
#    if (not @_ and -d 'lib') {
#        print "Searching the 'lib' directory for a Mo to inline:\n";
#        @_ = 'lib';
#    }
#    if (not @_ or @_ == 1 and $_[0] =~ /^(?:-\?|-h|--help)$/) {
#        print usage();
#        return 0;
#    }
#    for my $name (@_) {
#        die "No file or directory called '$name'"
#            unless -e $name;
#        die "'$name' is not a Perl module"
#            if -f $name and $name !~ /\.pm$/;
#        if (-f $name) {
#            push @files, $name;
#        }
#        elsif (-d $name) {
#            push @_, grep /\.pm$/, map { "$_" } io($name)->All_Files;
#        }
#    }
#
#    die "No .pm files specified"
#        unless @files;
#
#    for my $file (@files) {
#        my $text = io($file)->all;
#        if ($text !~ $matcher) {
#            print "Ignoring $file - No Mo to Inline!\n";
#            next;
#        }
#        $self->inline($file, 1);
#    }
#}
#
#sub inline {
#    my ($self, $file, $noisy) = @_;
#    my $text = io($file)->all;
#    $text =~ s/$matcher/"$1" . &inliner($2)/eg;
#    io($file)->print($text);
#    print "Mo Inlined $file\n"
#        if $noisy;
#}
#
#sub inliner {
#    my $mo = shift;
#    require Mo;
#    my @features = grep {$_ ne 'qw'} ($mo =~ /(\w+)/g);
#    for (@features) {
#        eval "require Mo::$_; 1" or die $@;
#    }
#    my $inline = '';
#    $inline .= $_ for map {
#        my $module = $_;
#        $module .= '.pm';
#        my @lines = io($INC{$module})->chomp->getlines;
#        $lines[-1];
#    } ('Mo', map { s!::!/!g; "Mo/$_" } @features);
#    return <<"...";
##   The following line of code was produced from the previous line by
##   Mo::Inline version $VERSION
#$inline\@f=qw[@features];use strict;use warnings;
#...
#}
#
#sub usage {
#    <<'...';
#Usage: mo-linline <perl module files or directories>
#
#...
#}
#
#1;
#
### Mo/Moose.pm ###
#package Mo::Moose;
#$Mo::Moose::VERSION = '0.40';$M="Mo::";
#$VERSION='0.40';
#*{$M.'Moose::e'}=sub{my($P,$e)=@_;$P=~s/::$//;%$e=(M=>1);require Moose;Moose->import({into=>$P});Moose::Util::MetaRole::apply_metaroles(for=>$P,class_metaroles=>{attribute=>['Attr::Trait']},)};BEGIN{package Attr::Trait;
#$Attr::Trait::VERSION = '0.40';use Moose::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}
### Mo/Mouse.pm ###
#package Mo::Mouse;
#$Mo::Mouse::VERSION = '0.40';$M="Mo::";
#$VERSION='0.40';
#*{$M.'Mouse::e'}=sub{my($P,$e)=@_;$P=~s/::$//;%$e=(M=>1);require Mouse;require Mouse::Util::MetaRole;Mouse->import({into=>$P});Mouse::Util::MetaRole::apply_metaroles(for=>$P,class_metaroles=>{attribute=>['Attr::Trait']},)};BEGIN{package Attr::Trait;
#$Attr::Trait::VERSION = '0.40';use Mouse::Role;around _process_options=>sub{my$orig=shift;my$c=shift;my($n,$o)=@_;$o->{is}||='rw';$o->{lazy}||=1 if defined$o->{default}or defined$o->{builder};$c->$orig(@_)};$INC{'Attr/Trait.pm'}=1}
### Mo/build.pm ###
#package Mo::build;
#$Mo::build::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'build::e'}=sub{my($P,$e)=@_;$e->{new}=sub{$c=shift;my$s=&{$M.Object::new}($c,@_);my@B;do{@B=($c.::BUILD,@B)}while($c)=@{$c.::ISA};exists&$_&&&$_($s)for@B;$s}};
### Mo/builder.pm ###
#package Mo::builder;
#$Mo::builder::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=\&{$P.$b}and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};
### Mo/chain.pm ###
#package Mo::chain;
#$Mo::chain::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'chain::e'}=sub{my($P,$e,$o)=@_;$o->{chain}=sub{my($m,$n,%a)=@_;$a{chain}or return$m;sub{$#_?($m->(@_),return$_[0]):$m->(@_)}}};
### Mo/coerce.pm ###
#package Mo::coerce;
#$Mo::coerce::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'coerce::e'}=sub{my($P,$e,$o)=@_;$o->{coerce}=sub{my($m,$n,%a)=@_;$a{coerce}or return$m;sub{$#_?$m->($_[0],$a{coerce}->($_[1])):$m->(@_)}};my$C=$e->{new}||*{$M.Object::new}{CODE};$e->{new}=sub{my$s=$C->(@_);$s->$_($s->{$_})for keys%$s;$s}};
### Mo/default.pm ###
#package Mo::default;
#$Mo::default::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;exists$a{default}or return$m;my($d,$r)=$a{default};my$g='HASH'eq($r=ref$d)?sub{+{%$d}}:'ARRAY'eq$r?sub{[@$d]}:'CODE'eq$r?$d:sub{$d};my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=$g and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$g->(@_):$m->(@_)}}};
### Mo/exporter.pm ###
#package Mo::exporter;
#$Mo::exporter::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'exporter::e'}=sub{my($P)=@_;if(@{$M.EXPORT}){*{$P.$_}=\&{$M.$_}for@{$M.EXPORT}}};
### Mo/import.pm ###
#package Mo::import;
#$Mo::import::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#my$i=\&import;*{$M.import}=sub{(@_==2 and not$_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};
### Mo/importer.pm ###
#package Mo::importer;
#$Mo::importer::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'importer::e'}=sub{my($P,$e,$o,$f)=@_;(my$pkg=$P)=~s/::$//;&{$P.'importer'}($pkg,@$f)if defined&{$P.'importer'}};
### Mo/is.pm ###
#package Mo::is;
#$Mo::is::VERSION = '0.40';$M="Mo::";
#$VERSION='0.40';
#*{$M.'is::e'}=sub{my($P,$e,$o)=@_;$o->{is}=sub{my($m,$n,%a)=@_;$a{is}or return$m;sub{$#_&&$a{is}eq'ro'&&caller ne'Mo::coerce'?die$n.' is ro':$m->(@_)}}};
### Mo/nonlazy.pm ###
#package Mo::nonlazy;
#$Mo::nonlazy::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'nonlazy::e'}=sub{${shift().':N'}=1};
### Mo/option.pm ###
#package Mo::option;
#$Mo::option::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'option::e'}=sub{my($P,$e,$o)=@_;$o->{option}=sub{my($m,$n,%a)=@_;$a{option}or return$m;my$n2=$n;*{$P."read_$n2"}=sub{$_[0]->{$n2}};sub{$#_?$m->(@_):$m->(@_,1);$_[0]}}};
### Mo/required.pm ###
#package Mo::required;
#$Mo::required::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#*{$M.'required::e'}=sub{my($P,$e,$o)=@_;$o->{required}=sub{my($m,$n,%a)=@_;if($a{required}){my$C=*{$P."new"}{CODE}||*{$M.Object::new}{CODE};no warnings 'redefine';*{$P."new"}=sub{my$s=$C->(@_);my%a=@_[1..$#_];die$n." required"if!exists$a{$n};$s}}$m}};
### Mo/xs.pm ###
#package Mo::xs;
#$Mo::xs::VERSION = '0.40';my$M="Mo::";
#$VERSION='0.40';
#require Class::XSAccessor;*{$M.'xs::e'}=sub{my($P,$e,$o,$f)=@_;$P=~s/::$//;$e->{has}=sub{my($n,%a)=@_;Class::XSAccessor->import(class=>$P,accessors=>{$n=>$n})}if!grep!/^xs$/,@$f};
### Module/Installed/Tiny.pm ###
#package Module::Installed::Tiny;
#
#our $DATE = '2016-08-04'; 
#our $VERSION = '0.003'; 
#
#use strict;
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(module_installed module_source);
#
#our $SEPARATOR;
#BEGIN {
#    if ($^O =~ /^(dos|os2)/i) {
#        $SEPARATOR = '\\';
#    } elsif ($^O =~ /^MacOS/i) {
#        $SEPARATOR = ':';
#    } else {
#        $SEPARATOR = '/';
#    }
#}
#
#sub _module_source {
#    my $name_pm = shift;
#
#    for my $entry (@INC) {
#        next unless defined $entry;
#        my $ref = ref($entry);
#        my ($is_hook, @hook_res);
#        if ($ref eq 'ARRAY') {
#            $is_hook++;
#            @hook_res = $entry->[0]->($entry, $name_pm);
#        } elsif (UNIVERSAL::can($entry, 'INC')) {
#            $is_hook++;
#            @hook_res = $entry->INC($name_pm);
#        } elsif ($ref eq 'CODE') {
#            $is_hook++;
#            @hook_res = $entry->($entry, $name_pm);
#        } else {
#            my $path = "$entry$SEPARATOR$name_pm";
#            if (-f $path) {
#                open my($fh), "<", $path
#                    or die "Can't locate $name_pm: $path: $!";
#                local $/;
#                return scalar <$fh>;
#            }
#        }
#
#        if ($is_hook) {
#            next unless @hook_res;
#            my $prepend_ref = shift @hook_res if ref($hook_res[0]) eq 'SCALAR';
#            my $fh          = shift @hook_res if ref($hook_res[0]) eq 'GLOB';
#            my $code        = shift @hook_res if ref($hook_res[0]) eq 'CODE';
#            my $code_state  = shift @hook_res if @hook_res;
#            if ($fh) {
#                my $src = "";
#                local $_;
#                while (!eof($fh)) {
#                    $_ = <$fh>;
#                    if ($code) {
#                        $code->($code, $code_state);
#                    }
#                    $src .= $_;
#                }
#                $src = $$prepend_ref . $src if $prepend_ref;
#                return $src;
#            } elsif ($code) {
#                my $src = "";
#                local $_;
#                while ($code->($code, $code_state)) {
#                    $src .= $_;
#                }
#                $src = $$prepend_ref . $src if $prepend_ref;
#                return $src;
#            }
#        }
#    }
#
#    die "Can't locate $name_pm in \@INC (\@INC contains: ".join(" ", @INC).")";
#}
#
#sub module_source {
#    my $name = shift;
#
#    my $name_pm;
#    if ($name =~ /\A\w+(?:::\w+)*\z/) {
#        ($name_pm = "$name.pm") =~ s!::!$SEPARATOR!g;
#    } else {
#        $name_pm = $name;
#    }
#
#    _module_source $name_pm;
#}
#
#sub module_installed {
#    my $name = shift;
#
#    my $name_pm;
#    if ($name =~ /\A\w+(?:::\w+)*\z/) {
#        ($name_pm = "$name.pm") =~ s!::!$SEPARATOR!g;
#    } else {
#        $name_pm = $name;
#    }
#
#    return 1 if exists $INC{$name_pm};
#
#    if (eval { _module_source $name_pm; 1 }) {
#        1;
#    } else {
#        0;
#    }
#}
#
#1;
#
#__END__
#
### Monkey/Patch/Action.pm ###
#package Monkey::Patch::Action;
#
#our $DATE = '2018-04-02'; 
#our $VERSION = '0.061'; 
#
#use 5.010001;
#use warnings;
#use strict;
#
#use Monkey::Patch::Action::Handle;
#use Scalar::Util qw(blessed);
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(patch_package patch_object);
#our %EXPORT_TAGS = (all => \@EXPORT_OK);
#
#sub patch_package {
#    my ($package, $subname, $action, $code, @extra) = @_;
#
#    die "Please specify action" unless $action;
#    if ($action eq 'delete') {
#        die "code not needed for 'delete' action" if $code;
#    } else {
#        die "Please specify code" unless $code;
#    }
#
#    my $name = "$package\::$subname";
#    my $type;
#    if ($action eq 'add') {
#        die "Adding $name: must not already exist" if defined(&$name);
#        $type = 'sub';
#    } elsif ($action eq 'replace') {
#        die "Replacing $name: must already exist" unless defined(&$name);
#        $type = 'sub';
#    } elsif ($action eq 'add_or_replace') {
#        $type = 'sub';
#    } elsif ($action eq 'wrap') {
#        die "Wrapping $name: must already exist" unless defined(&$name);
#        $type = 'wrap';
#    } elsif ($action eq 'delete') {
#        $type = 'delete';
#    } else {
#        die "Unknown action '$action', please use either ".
#            "wrap/add/replace/add_or_replace/delete";
#    }
#
#    my @caller = caller(0);
#
#    Monkey::Patch::Action::Handle->new(
#        package => $package,
#        subname => $subname,
#        extra   => \@extra,
#        patcher => \@caller,
#        code    => $code,
#
#        -type   => $type,
#    );
#}
#
#sub patch_object {
#    my ($obj, $methname, $action0, $code0, @extra) = @_;
#
#    die "'$obj' not an object" unless blessed($obj);
#    die "Please specify action" unless $action0;
#    die "Invalid action '$action0', please choose add|replace|add_or_replace|wrap|delete"
#        unless $action0 =~ /\A(add|replace|add_or_replace|wrap|delete)\z/;
#    if ($action0 eq 'delete') {
#        die "code not needed for 'delete' action" if $code0;
#    } else {
#        die "Please specify code" unless $code0;
#    }
#
#    my $package = ref($obj);
#    my $name = "$package\::$methname";
#    my $action = defined(&$name) ? 'wrap' : 'add';
#
#    my $code = sub {
#        my $ctx  = $action eq 'wrap' ? shift : undef;
#        my $self = $_[0];
#        no warnings 'numeric';
#        if ($obj == $self) {
#            if ($action0 eq 'add') {
#                $code0->(@_);
#            } elsif ($action0 eq 'replace') {
#                $code0->(@_);
#            } elsif ($action0 eq 'add_or_replace') {
#                $code0->(@_);
#            } elsif ($action0 eq 'wrap') {
#                my $octx = {%$ctx};
#                $code0->($octx, @_);
#            } elsif ($action0 eq 'delete') {
#                die "Undefined method '$methname' for object '$obj'";
#            } else {
#                die "BUG: Unknown action '$action0'";
#            }
#        } else {
#            if ($action eq 'wrap') {
#                return $ctx->{orig}->(@_);
#            } else {
#                die "Undefined method '$methname' for object '$obj'";
#            }
#        }
#    };
#
#    patch_package($package, $methname, $action, $code, @extra);
#}
#
#1;
#
#__END__
#
### Monkey/Patch/Action/Handle.pm ###
#package Monkey::Patch::Action::Handle;
#
#our $DATE = '2018-04-02'; 
#our $VERSION = '0.061'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Scalar::Util qw(weaken);
#use Sub::Delete;
#
#my %stacks;
#
#sub __find_previous {
#    my ($stack, $code) = @_;
#    state $empty = sub {};
#
#    for my $i (1..$#$stack) {
#        if ($stack->[$i][1] == $code) {
#            return $stack->[$i-1][2] // $stack->[$i-1][1];
#        }
#    }
#    $empty;
#}
#
#sub new {
#    my ($class, %args) = @_;
#
#    my $type = $args{-type};
#    delete $args{-type};
#
#    my $code = $args{code};
#
#    my $name = "$args{package}::$args{subname}";
#    my $stack;
#    if (!$stacks{$name}) {
#        $stacks{$name} = [];
#        push @{$stacks{$name}}, [sub => \&$name] if defined(&$name);
#    }
#    $stack = $stacks{$name};
#
#    my $self = bless \%args, $class;
#
#    no strict 'refs';
#    no warnings 'redefine';
#    if ($type eq 'sub') {
#        push @$stack, [$type => $code];
#        *$name = $code;
#    } elsif ($type eq 'delete') {
#        $code = sub {};
#        $args{code} = $code;
#        push @$stack, [$type, $code];
#        delete_sub $name;
#    } elsif ($type eq 'wrap') {
#        weaken($self);
#        my $wrapper = sub {
#            my $ctx = {
#                package => $self->{package},
#                subname => $self->{subname},
#                extra   => $self->{extra},
#                orig    => __find_previous($stack, $self->{code}),
#            };
#            unshift @_, $ctx;
#            goto &{$self->{code}};
#        };
#        push @$stack, [$type => $code => $wrapper];
#        *$name = $wrapper;
#    }
#
#    $self;
#}
#
#sub DESTROY {
#    my $self = shift;
#
#    my $name  = "$self->{package}::$self->{subname}";
#    my $stack = $stacks{$name};
#    my $code  = $self->{code};
#
#    for my $i (0..$#$stack) {
#        if($stack->[$i][1] == $code) {
#            if ($stack->[$i+1]) {
#                if ($stack->[$i+1][0] eq 'wrap' &&
#                        ($i == 0 || $stack->[$i-1][0] eq 'delete')) {
#                    my $p = $self->{patcher};
#                    warn "Warning: unapplying patch to $name ".
#                        "(applied in $p->[1]:$p->[2]) before a wrapping patch";
#                }
#            }
#
#            no strict 'refs';
#            if ($i == @$stack-1) {
#                if ($i) {
#                    no warnings 'redefine';
#                    if ($stack->[$i-1][0] eq 'delete') {
#                        delete_sub $name;
#                    } else {
#                        *$name = $stack->[$i-1][2] // $stack->[$i-1][1];
#                    }
#                } else {
#                    delete_sub $name;
#                }
#            }
#            splice @$stack, $i, 1;
#            last;
#        }
#    }
#}
#
#1;
#
#__END__
#
### Nodejs/Util.pm ###
#package Nodejs::Util;
#
#our $DATE = '2018-03-21'; 
#our $VERSION = '0.012'; 
#
#use 5.010001;
#use strict 'subs', 'vars';
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       get_nodejs_path
#                       nodejs_path
#                       nodejs_available
#                       system_nodejs
#                       nodejs_module_path
#               );
#
#our %SPEC;
#
#my %arg_all = (
#    all => {
#        schema => 'bool',
#        summary => 'Find all node.js instead of the first found',
#        description => <<'_',
#
#If this option is set to true, will return an array of paths intead of path.
#
#_
#    },
#);
#
#$SPEC{nodejs_path} = {
#    v => 1.1,
#    summary => 'Check the availability of Node.js executable in PATH',
#    description => <<'_',
#
#Return the path to executable or undef if none is available. Node.js is usually
#installed as 'node' or 'nodejs'.
#
#_
#    args => {
#        %arg_all,
#    },
#    result_naked => 1,
#};
#sub nodejs_path {
#    require File::Which;
#    require IPC::System::Options;
#
#    my %args = @_;
#
#    my @paths;
#    for my $name (qw/nodejs node/) {
#        my $path = File::Which::which($name);
#        next unless $path;
#
#        my $out = IPC::System::Options::readpipe(
#            $path, '-e', 'console.log(1+1)');
#        if ($out =~ /\A2\n?\z/) {
#            return $path unless $args{all};
#            push @paths, $path;
#        } else {
#        }
#    }
#    return undef unless @paths;
#    \@paths;
#}
#
#*get_nodejs_path = \&nodejs_path;
#
#$SPEC{nodejs_available} = {
#    v => 1.1,
#    summary => 'Check the availability of Node.js',
#    description => <<'_',
#
#This is a more advanced alternative to `nodejs_path()`. Will check for `node` or
#`nodejs` in the PATH, like `nodejs_path()`. But you can also specify minimum
#version (and other options in the future). And it will return more details.
#
#Will return status 200 if everything is okay. Actual result will return the path
#to executable, and result metadata will contain extra result like detected
#version in `func.version`.
#
#Will return satus 412 if something is wrong. The return message will tell the
#reason.
#
#_
#    args => {
#        min_version => {
#            schema => 'str*',
#        },
#        path => {
#            summary => 'Search this instead of PATH environment variable',
#            schema => ['str*'],
#        },
#        %arg_all,
#    },
#};
#sub nodejs_available {
#    require IPC::System::Options;
#
#    my %args = @_;
#    my $all = $args{all};
#
#    my $paths = do {
#        local $ENV{PATH} = $args{path} if defined $args{path};
#        nodejs_path(all => 1);
#    };
#    defined $paths or return [412, "node.js not detected in PATH"];
#
#    my $res = [200, "OK"];
#    my @filtered_paths;
#    my @versions;
#    my @errors;
#
#    for my $path (@$paths) {
#        my $v;
#        if ($args{min_version}) {
#            my $out = IPC::System::Options::readpipe(
#                $path, '-v');
#            $out =~ /^(v\d+\.\d+\.\d+)$/ or do {
#                push @errors, "Can't recognize output of $path -v: $out";
#                next;
#            };
#            $v = version->parse($1);
#            $v >= version->parse($args{min_version}) or do {
#                push @errors, "Version of $path less than $args{min_version}";
#                next;
#            };
#        }
#        push @filtered_paths, $path;
#        push @versions, defined($v) ? "$v" : undef;
#    }
#
#    $res->[2]                 = $all ? \@filtered_paths : $filtered_paths[0];
#    $res->[3]{'func.path'}    = $all ? \@filtered_paths : $filtered_paths[0];
#    $res->[3]{'func.version'} = $all ? \@versions       : $versions[0];
#    $res->[3]{'func.errors'}  = \@errors;
#
#    unless (@filtered_paths) {
#        $res->[0] = 412;
#        $res->[1] = @errors == 1 ? $errors[0] :
#            "No eligible node.js found in PATH";
#    }
#
#    $res;
#}
#
#sub system_nodejs {
#    require IPC::System::Options;
#    my $opts = ref($_[0]) eq 'HASH' ? shift : {};
#
#    my $harmony_scoping = delete $opts->{harmony_scoping};
#    my $path = delete $opts->{path};
#
#    my %detect_nodejs_args;
#    if ($harmony_scoping) {
#        $detect_nodejs_args{min_version} = '0.5.10';
#    }
#    if ($path) {
#        $detect_nodejs_args{path} = $path;
#    }
#    my $detect_res = nodejs_available(%detect_nodejs_args);
#    die "No eligible node.js binary available: ".
#        "$detect_res->[0] - $detect_res->[1]" unless $detect_res->[0] == 200;
#
#    my @extra_args;
#    if ($harmony_scoping) {
#        my $node_v = $detect_res->[3]{'func.version'};
#        if (version->parse($node_v) < version->parse("2.0.0")) {
#            push @extra_args, "--use_strict", "--harmony_scoping";
#        } else {
#            push @extra_args, "--use_strict";
#        }
#    }
#
#    IPC::System::Options::system(
#        $opts,
#        $detect_res->[2],
#        @extra_args,
#        @_,
#    );
#}
#
#sub nodejs_module_path {
#    my $opts = ref $_[0] eq 'HASH' ? shift : {};
#    my $module = shift;
#
#    my ($dir, $name, $ext) = $module =~ m!\A(?:(.*)/)?(.+?)(\.\w+)?\z!;
#
#    my  @dirs;
#    if (defined $dir) {
#        @dirs = ($dir);
#    } else {
#        my $cwd = do {
#            if (defined $opts->{cwd}) {
#                $opts->{cwd};
#            } else {
#                require Cwd;
#                Cwd::getcwd();
#            }
#        };
#        $cwd =~ s!/node_modules\z!!;
#        while (1) {
#            push @dirs, "$cwd/node_modules";
#            $cwd =~ s!(.*)/.+!$1!
#                or last;
#        }
#    }
#
#    if (defined $ENV{NODE_PATH}) {
#        my $sep = $^O =~ /win32/i ? qr/;/ : qr/:/;
#        push @dirs, split($sep, $ENV{NODE_PATH});
#    }
#
#    if (defined $ENV{HOME}) {
#        push @dirs, "$ENV{HOME}/.node_modules";
#        push @dirs, "$ENV{HOME}/.node_libraries";
#    }
#
#    if (defined $ENV{PREFIX}) {
#        push @dirs, "$ENV{PREFIX}/lib/node";
#    }
#
#
#    my @res;
#    for my $d (@dirs) {
#        next unless -d $d;
#        if (defined $ext) {
#            my $p = "$d/$name$ext";
#            if (-f $p) {
#                push @res, $p;
#                last unless $opts->{all};
#            }
#        } else {
#            my $p;
#            for my $e (".js", ".json", ".node") {
#                $p = "$d/$name$e";
#                if (-f $p) {
#                    push @res, $p;
#                    last unless $opts->{all};
#                }
#            }
#            $p = "$d/$name";
#            if (-d $p) {
#                if (-f "$p/index.js") {
#                    push @res, "$p/index.js";
#                    last unless $opts->{all};
#                } elsif (-f "$p/package.json") {
#                    push @res, "$p/package.json";
#                    last unless $opts->{all};
#                }
#            }
#        }
#    }
#
#    if ($opts->{all}) {
#        return \@res;
#    } else {
#        return $res[0];
#    }
#}
#
#1;
#
#__END__
#
### Number/Format/BigFloat.pm ###
#package Number::Format::BigFloat;
#
#our $DATE = '2017-12-09'; 
#our $VERSION = '0.001'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Math::BigFloat;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       format_number
#               );
#
#sub format_number {
#    my ($num, $opts) = @_;
#    $opts //= {};
#
#    $opts->{thousands_sep}  //= ',';
#    $opts->{decimal_point}  //= '.';
#    $opts->{decimal_digits} //= 2;
#
#    my $str = Math::BigFloat->new($num)->round(0, -$opts->{decimal_digits});
#    my ($sign, $int, $decpoint, $frac) =
#        $str =~ /\A(-?)([0-9]+)(\.?)([0-9]*)\z/
#        or return $num;
#
#    $int =~ s/(?<=[0-9])(?=([0-9]{3})+(?![0-9]))/$opts->{thousands_sep}/g
#        if length $opts->{thousands_sep};
#
#    $decpoint = $opts->{decimal_point}
#        if length $decpoint;
#
#    "$sign$int$decpoint$frac";
#}
#
#1;
#
#__END__
#
### PERLANCAR/File/HomeDir.pm ###
#package PERLANCAR::File::HomeDir;
#
#our $DATE = '2018-09-20'; 
#our $VERSION = '0.060'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       get_my_home_dir
#                       get_user_home_dir
#               );
#
#our $DIE_ON_FAILURE = 0;
#
#sub get_my_home_dir {
#    if ($^O eq 'MSWin32') {
#        return $ENV{HOME} if $ENV{HOME};
#        return $ENV{USERPROFILE} if $ENV{USERPROFILE};
#        return join($ENV{HOMEDRIVE}, "\\", $ENV{HOMEPATH})
#            if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};
#    } else {
#        return $ENV{HOME} if $ENV{HOME};
#        my @pw;
#        eval { @pw = getpwuid($>) };
#        return $pw[7] if @pw;
#    }
#
#    if ($DIE_ON_FAILURE) {
#        die "Can't get home directory";
#    } else {
#        return undef;
#    }
#}
#
#sub get_user_home_dir {
#    my ($name) = @_;
#
#    if ($^O eq 'MSWin32') {
#        return undef;
#    } else {
#        if ($name eq getpwuid($<)) {
#            return get_my_home_dir();
#        }
#
#      SCOPE: {
#            my $home = (getpwnam($name))[7];
#            return $home if $home and -d $home;
#        }
#
#        return undef;
#    }
#
#}
#
#1;
#
#__END__
#
### Perinci/Access/Lite.pm ###
#package Perinci::Access::Lite;
#
#our $DATE = '2016-09-25'; 
#our $VERSION = '0.14'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Perinci::AccessUtil qw(strip_riap_stuffs_from_res);
#
#sub new {
#    my ($class, %args) = @_;
#    $args{riap_version} //= 1.1;
#    bless \%args, $class;
#}
#
#sub __package_exists {
#    no strict 'refs';
#
#    my $pkg = shift;
#
#    return unless $pkg =~ /\A\w+(::\w+)*\z/;
#    if ($pkg =~ s/::(\w+)\z//) {
#        return !!${$pkg . "::"}{$1 . "::"};
#    } else {
#        return !!$::{$pkg . "::"};
#    }
#}
#
#sub request {
#    no strict 'refs';
#
#    my ($self, $action, $url, $extra) = @_;
#
#
#    $extra //= {};
#
#    my $v = $extra->{v} // 1.1;
#    if ($v ne '1.1' && $v ne '1.2') {
#        return [501, "Riap protocol not supported, must be 1.1 or 1.2"];
#    }
#
#    my $res;
#    if ($url =~ m!\A(?:pl:)?/(\w+(?:/\w+)*)/(\w*)\z!) {
#        my ($mod_uripath, $func) = ($1, $2);
#        (my $pkg = $mod_uripath) =~ s!/!::!g;
#        my $mod_pm = "$mod_uripath.pm";
#
#        my $pkg_exists;
#
#      LOAD:
#        {
#            last if exists $INC{$mod_pm};
#            $pkg_exists = __package_exists($pkg);
#            last LOAD if $pkg =~ /\A(main)\z/;
#            last if $pkg_exists && defined(${"$pkg\::VERSION"});
#            eval { require $mod_pm };
#            return [500, "Can't load module $pkg: $@"] if $@;
#        }
#
#        if ($action eq 'list') {
#            return [501, "Action 'list' not implemented for ".
#                        "non-package entities"]
#                if length($func);
#            no strict 'refs';
#            my $spec = \%{"$pkg\::SPEC"};
#            return [200, "OK (list)", [grep {/\A\w+\z/} sort keys %$spec]];
#        } elsif ($action eq 'info') {
#            my $data = {
#                uri => "$mod_uripath/$func",
#                type => (!length($func) ? "package" :
#                             $func =~ /\A\w+\z/ ? "function" :
#                                 $func =~ /\A[\@\$\%]/ ? "variable" :
#                                     "?"),
#            };
#            return [200, "OK (info)", $data];
#        } elsif ($action eq 'meta' || $action eq 'call') {
#            return [501, "Action 'call' not implemented for package entity"]
#                if !length($func) && $action eq 'call';
#            my $meta;
#            {
#                no strict 'refs';
#                if (length $func) {
#                    $meta = ${"$pkg\::SPEC"}{$func}
#                        or return [
#                            500, "No metadata for '$url' (".
#                                ($pkg_exists ? "package '$pkg' exists, perhaps you mentioned '$pkg' somewhere without actually loading the module, or perhaps '$func' is a typo?" :
#                                     "package '$pkg' doesn't exist, perhaps '$mod_uripath' or '$func' is a typo?") .
#                                ")"];
#                } else {
#                    $meta = ${"$pkg\::SPEC"}{':package'} // {v=>1.1};
#                }
#                $meta->{entity_v}    //= ${"$pkg\::VERSION"};
#                $meta->{entity_date} //= ${"$pkg\::DATE"};
#            }
#
#            require Perinci::Sub::Normalize;
#            $meta = Perinci::Sub::Normalize::normalize_function_metadata($meta);
#            if ($action eq 'meta') {
#                $meta->{_orig_args_as} = $meta->{args_as};
#                $meta->{args_as} = 'hash';
#                $meta->{_orig_result_naked} = $meta->{result_naked};
#                $meta->{result_naked} = 0;
#                return [200, "OK ($action)", $meta];
#            }
#
#            my $args = { %{$extra->{args} // {}} }; 
#            if ($meta->{features} && $meta->{features}{progress}) {
#                require Progress::Any;
#                $args->{-progress} = Progress::Any->get_indicator;
#            }
#
#            my $aa = $meta->{args_as} // 'hash';
#            my @args;
#            if ($aa =~ /array/) {
#                require Perinci::Sub::ConvertArgs::Array;
#                my $convres = Perinci::Sub::ConvertArgs::Array::convert_args_to_array(
#                    args => $args, meta => $meta,
#                );
#                return $convres unless $convres->[0] == 200;
#                if ($aa =~ /ref/) {
#                    @args = ($convres->[2]);
#                } else {
#                    @args = @{ $convres->[2] };
#                }
#            } elsif ($aa eq 'hashref') {
#                @args = ({ %$args });
#            } else {
#                @args = %$args;
#            }
#
#            {
#                no strict 'refs';
#                $res = &{"$pkg\::$func"}(@args);
#            }
#
#            if ($meta->{result_naked}) {
#                $res = [200, "OK (envelope added by ".__PACKAGE__.")", $res];
#            }
#
#            if (defined $res->[2]) {
#                if ($meta->{result} && $meta->{result}{schema} &&
#                        $meta->{result}{schema}[0] eq 'buf') {
#                    $res->[3]{'x.hint.result_binary'} = 1;
#                }
#            }
#
#        } else {
#            return [501, "Unknown/unsupported action '$action'"];
#        }
#    } elsif ($url =~ m!\Ahttps?:/(/?)!i) {
#        my $is_unix = !$1;
#        my $ht;
#        require JSON;
#        state $json = JSON->new->allow_nonref;
#        if ($is_unix) {
#            require HTTP::Tiny::UNIX;
#            $ht = HTTP::Tiny::UNIX->new;
#        } else {
#            require HTTP::Tiny;
#            $ht = HTTP::Tiny->new;
#        }
#        my %headers = (
#            "x-riap-v" => $self->{riap_version},
#            "x-riap-action" => $action,
#            "x-riap-fmt" => "json",
#            "content-type" => "application/json",
#        );
#        my $args = $extra->{args} // {};
#        for (keys %$extra) {
#            next if /\Aargs\z/;
#            $headers{"x-riap-$_"} = $extra->{$_};
#        }
#        my $htres = $ht->post(
#            $url, {
#                headers => \%headers,
#                content => $json->encode($args),
#            });
#        return [500, "Network error: $htres->{status} - $htres->{reason}"]
#            if $htres->{status} != 200;
#        return [500, "Server error: didn't return JSON (".$htres->{headers}{'content-type'}.")"]
#            unless $htres->{headers}{'content-type'} eq 'application/json';
#        return [500, "Server error: didn't return Riap 1.1 response (".$htres->{headers}{'x-riap-v'}.")"]
#            unless $htres->{headers}{'x-riap-v'} =~ /\A1\.1(\.\d+)?\z/;
#        $res = $json->decode($htres->{content});
#    } else {
#        return [501, "Unsupported scheme or bad URL '$url'"];
#    }
#
#    strip_riap_stuffs_from_res($res);
#}
#
#1;
#
#__END__
#
### Perinci/AccessUtil.pm ###
#package Perinci::AccessUtil;
#
#our $DATE = '2015-09-06'; 
#our $VERSION = '0.06'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use MIME::Base64;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(insert_riap_stuffs_to_res
#                    strip_riap_stuffs_from_res
#                    decode_args_in_riap_req);
#
#sub insert_riap_stuffs_to_res {
#    my ($res, $def_ver, $nmeta, $encode) = @_;
#
#    $res->[3]{'riap.v'} //= $def_ver // 1.1;
#    if ($res->[3]{'riap.v'} >= 1.2) {
#        {
#            last unless $encode // 1;
#            last if $res->[3]{'riap.result_encoding'};
#            if ($nmeta) {
#                last unless $nmeta->{result}{schema} &&
#                    $nmeta->{result}{schema}[0] eq 'buf';
#            }
#            last unless defined($res->[2]) && !ref($res->[2]) &&
#                $res->[2] =~ /[^\x20-\x7f]/;
#            $res->[2] = encode_base64($res->[2], "");
#            $res->[3]{'riap.result_encoding'} = 'base64';
#        }
#    }
#    $res;
#}
#
#sub strip_riap_stuffs_from_res {
#    my $res = shift;
#
#    my $ver = $res->[3]{'riap.v'} // 1.1;
#    return [501, "Riap version returned by server ($ver) is not supported, ".
#                "only recognize v1.1 and v1.2"]
#        unless $ver == 1.1 || $ver == 1.2;
#
#    if ($ver >= 1.2) {
#        for my $k (keys %{$res->[3]}) {
#            next unless $k =~ /\Ariap\./;
#            my $val = $res->[3]{$k};
#            if ($k eq 'riap.v') {
#            } elsif ($k eq 'riap.result_encoding') {
#                return [501, "Unknown result_encoding returned by server ".
#                            "($val), only base64 is supported"]
#                    unless $val eq 'base64';
#                $res->[2] = decode_base64($res->[2]//'');
#            } else {
#                return [501, "Unknown Riap attribute in result metadata ".
#                            "returned by server ($k)"];
#            }
#            delete $res->[3]{$k};
#        }
#    }
#
#    $res;
#}
#
#sub decode_args_in_riap_req {
#    my $req = shift;
#
#    my $v = $req->{v} // 1.1;
#    if ($v >= 1.2) {
#        if ($req->{args}) {
#            my $args = $req->{args};
#            for (keys %$args) {
#                next unless /\A(.+):base64\z/;
#                $args->{$1} = decode_base64($args->{$_});
#                delete $args->{$_};
#            }
#        }
#    }
#    $req;
#}
#
#1;
#
#__END__
#
### Perinci/CmdLine/Base.pm ###
#package Perinci::CmdLine::Base;
#
#our $DATE = '2019-01-14'; 
#our $VERSION = '1.817'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#
#BEGIN {
#    if ($INC{'Perinci/CmdLine/Classic.pm'}) {
#        require Moo; Moo->import;
#    } else {
#        require Mo; Mo->import(qw(build default));
#    }
#}
#
#sub __array_iter {
#    my $ary = shift;
#    my $i = 0;
#    sub {
#        if ($i < @$ary) {
#            return $ary->[$i++];
#        } else {
#            return undef;
#        }
#    };
#}
#
#sub __list_iter {
#    __array_iter([@_]);
#}
#
#has actions => (is=>'rw');
#has common_opts => (is=>'rw');
#has completion => (is=>'rw');
#has default_subcommand => (is=>'rw');
#has get_subcommand_from_arg => (is=>'rw', default=>1);
#has auto_abbrev_subcommand => (is=>'rw', default=>1);
#has description => (is=>'rw');
#has exit => (is=>'rw', default=>1);
#has formats => (is=>'rw');
#has default_format => (is=>'rw');
#has pass_cmdline_object => (is=>'rw', default=>0);
#has per_arg_json => (is=>'rw');
#has per_arg_yaml => (is=>'rw');
#has program_name => (
#    is=>'rw',
#    default => sub {
#        my $pn = $ENV{PERINCI_CMDLINE_PROGRAM_NAME};
#        if (!defined($pn)) {
#            $pn = $0; $pn =~ s!.+/!!;
#        }
#        $pn;
#    });
#has riap_version => (is=>'rw', default=>1.1);
#has riap_client => (is=>'rw');
#has riap_client_args => (is=>'rw');
#has subcommands => (is=>'rw');
#has summary => (is=>'rw');
#has tags => (is=>'rw');
#has url => (is=>'rw');
#has log => (is=>'rw', default => 0);
#has log_level => (is=>'rw');
#
#has read_env => (is=>'rw', default=>1);
#has env_name => (
#    is => 'rw',
#    lazy => 1,
#    default => sub {
#        my $self = shift;
#        __default_env_name($self->program_name);
#    },
#);
#
#has read_config => (is=>'rw', default=>1);
#has config_filename => (is=>'rw');
#has config_dirs => (
#    is=>'rw',
#    default => sub {
#        require Perinci::CmdLine::Util::Config;
#        Perinci::CmdLine::Util::Config::get_default_config_dirs();
#    },
#);
#
#has cleanser => (
#    is => 'rw',
#    lazy => 1,
#    default => sub {
#        require Data::Clean::JSON;
#        Data::Clean::JSON->get_cleanser;
#    },
#);
#has use_cleanser => (is=>'rw', default=>1);
#
#has extra_urls_for_version => (is=>'rw');
#
#has skip_format => (is=>'rw');
#
#has use_utf8 => (
#    is=>'rw',
#    default => sub {
#        $ENV{UTF8} // 0;
#    },
#);
#
#has default_dry_run => (
#    is=>'rw',
#    default => 0,
#);
#
#
#
#our %copts = (
#
#    version => {
#        getopt  => "version|v",
#        summary => "Display program's version and exit",
#        usage   => "--version (or -v)",
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{action} = 'version';
#            $r->{skip_parse_subcommand_argv} = 1;
#        },
#    },
#
#    help => {
#        getopt  => 'help|h|?',
#        summary => 'Display help message and exit',
#        usage   => "--help (or -h, -?)",
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{action} = 'help';
#            $r->{skip_parse_subcommand_argv} = 1;
#        },
#        order => 0, 
#    },
#
#    format => {
#        getopt  => 'format=s',
#        summary => 'Choose output format, e.g. json, text',
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{format} = $val;
#        },
#        default => undef,
#        tags => ['category:output'],
#        is_settable_via_config => 1,
#    },
#    json => {
#        getopt  => 'json',
#        summary => 'Set output format to json',
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{format} = (-t STDOUT) ? 'json-pretty' : 'json';
#        },
#        tags => ['category:output'],
#    },
#
#    naked_res => {
#        getopt  => 'naked-res!',
#        summary => 'When outputing as JSON, strip result envelope',
#        'summary.alt.bool.not' => 'When outputing as JSON, add result envelope',
#        description => <<'_',
#
#By default, when outputing as JSON, the full enveloped result is returned, e.g.:
#
#    [200,"OK",[1,2,3],{"func.extra"=>4}]
#
#The reason is so you can get the status (1st element), status message (2nd
#element) as well as result metadata/extra result (4th element) instead of just
#the result (3rd element). However, sometimes you want just the result, e.g. when
#you want to pipe the result for more post-processing. In this case you can use
#`--naked-res` so you just get:
#
#    [1,2,3]
#
#_
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{naked_res} = $val ? 1:0;
#        },
#        default => 0,
#        tags => ['category:output'],
#        is_settable_via_config => 1,
#    },
#
#    subcommands => {
#        getopt  => 'subcommands',
#        summary => 'List available subcommands',
#        usage   => "--subcommands",
#        show_in_usage => sub {
#            my ($self, $r) = @_;
#            !$r->{subcommand_name};
#        },
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{action} = 'subcommands';
#            $r->{skip_parse_subcommand_argv} = 1;
#        },
#    },
#
#    cmd => {
#        getopt  => "cmd=s",
#        summary => 'Select subcommand',
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{subcommand_name} = $val;
#            $r->{subcommand_name_from} = '--cmd';
#        },
#        completion => sub {
#            require Complete::Util;
#            my %args = @_;
#            my $cmdline = $args{cmdline};
#            Complete::Util::complete_array_elem(
#                array => [keys %{ $cmdline->list_subcommands }],
#                word  => $args{word},
#                ci    => 1,
#            );
#        },
#    },
#
#    config_path => {
#        getopt  => 'config-path=s@',
#        schema  => ['array*', of => 'str*'],
#        'x.schema.element_entity' => 'filename',
#        summary => 'Set path to configuration file',
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{config_paths} //= [];
#            push @{ $r->{config_paths} }, $val;
#        },
#        tags => ['category:configuration'],
#    },
#    no_config => {
#        getopt  => 'no-config',
#        summary => 'Do not use any configuration file',
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{read_config} = 0;
#        },
#        tags => ['category:configuration'],
#    },
#    no_env => {
#        getopt  => 'no-env',
#        summary => 'Do not read environment for default options',
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{read_env} = 0;
#        },
#        tags => ['category:environment'],
#    },
#    config_profile => {
#        getopt  => 'config-profile=s',
#        summary => 'Set configuration profile to use',
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{config_profile} = $val;
#        },
#        completion => sub {
#
#            my %args = @_;
#            my $word    = $args{word} // '';
#            my $cmdline = $args{cmdline};
#            my $r       = $args{r};
#
#            return undef unless $cmdline;
#
#            {
#                $r->{read_config} = 1;
#
#                my $res = $cmdline->parse_argv($r);
#
#                $cmdline->_read_config($r) unless $r->{config};
#            }
#
#            return [] unless $r->{config};
#
#            my @profiles;
#            for my $section (keys %{$r->{config}}) {
#                my %keyvals;
#                for my $word (split /\s+/, ($section eq 'GLOBAL' ? '' : $section)) {
#                    if ($word =~ /(.+)=(.*)/) {
#                        $keyvals{$1} = $2;
#                    } else {
#                        $keyvals{subcommand} = $word;
#                    }
#                }
#                if (defined(my $p = $keyvals{profile})) {
#                    push @profiles, $p unless grep {$_ eq $p} @profiles;
#                }
#            }
#
#            require Complete::Util;
#            Complete::Util::complete_array_elem(
#                array=>\@profiles, word=>$word, ci=>1);
#        },
#        tags => ['category:configuration'],
#    },
#
#    log_level => {
#        getopt  => 'log-level=s',
#        summary => 'Set log level',
#        schema  => ['str*' => in => [
#            qw/trace debug info warn warning error fatal/]],
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{log_level} = $val;
#        },
#        is_settable_via_config => 1,
#        tags => ['category:logging'],
#    },
#    trace => {
#        getopt  => "trace",
#        summary => "Shortcut for --log-level=trace",
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{log_level} = 'trace';
#        },
#        tags => ['category:logging'],
#    },
#    debug => {
#        getopt  => "debug",
#        summary => "Shortcut for --log-level=debug",
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{log_level} = 'debug';
#        },
#        tags => ['category:logging'],
#    },
#    verbose => {
#        getopt  => "verbose",
#        summary => "Shortcut for --log-level=info",
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{log_level} = 'info';
#            $r->{_help_verbose} = 1;
#        },
#        tags => ['category:logging'],
#    },
#    quiet => {
#        getopt  => "quiet",
#        summary => "Shortcut for --log-level=error",
#        handler => sub {
#            my ($go, $val, $r) = @_;
#            $r->{log_level} = 'error';
#        },
#        tags => ['category:logging'],
#    },
#
#);
#
#sub __default_env_name {
#    my ($prog) = @_;
#
#    for ($prog) {
#        $_ //= "PROG"; 
#        $_ = uc($_);
#        s/[^A-Z0-9]+/_/g;
#        $_ = "_$_" if /\A\d/;
#    }
#    "${prog}_OPT";
#}
#
#sub hook_before_run {}
#
#sub hook_before_read_config_file {}
#
#sub hook_after_read_config_file {}
#
#sub hook_before_action {}
#
#sub hook_after_action {}
#
#sub get_meta {
#    my ($self, $r, $url) = @_;
#
#    my $res = $self->riap_client->request(meta => $url);
#    die $res unless $res->[0] == 200;
#    my $meta = $res->[2];
#    $r->{meta} = $meta;
#    log_trace("[pericmd] Running hook_after_get_meta ...");
#    $self->hook_after_get_meta($r);
#    $meta;
#}
#
#sub get_program_and_subcommand_name {
#    my ($self, $r) = @_;
#    my $res = ($self->program_name // "") . " " .
#        ($r->{subcommand_name} // "");
#    $res =~ s/\s+$//;
#    $res;
#}
#
#sub get_subcommand_data {
#    my ($self, $name) = @_;
#
#    my $scs = $self->subcommands;
#    return undef unless $scs;
#
#    if (ref($scs) eq 'CODE') {
#        return $scs->($self, name=>$name);
#    } else {
#        return $scs->{$name};
#    }
#}
#
#sub list_subcommands {
#    my ($self) = @_;
#    return $self->{_cache_subcommands} if $self->{_cache_subcommands};
#
#    my $scs = $self->subcommands;
#    my $res;
#    if ($scs) {
#        if (ref($scs) eq 'CODE') {
#            $scs = $scs->($self);
#            die [500, "BUG: Subcommands code didn't return a hashref"]
#                unless ref($scs) eq 'HASH';
#        }
#        $res = $scs;
#    } else {
#        $res = {};
#    }
#    $self->{_cache_subcommands} = $res;
#    $res;
#}
#
#sub status2exitcode {
#    my ($self, $status) = @_;
#    return 0 if $status =~ /^2..|304/;
#    $status - 300;
#}
#
#sub _detect_completion {
#    my ($self, $r) = @_;
#
#    if ($ENV{COMP_SHELL}) {
#        $r->{shell} = $ENV{COMP_SHELL};
#        return 1;
#    } elsif ($ENV{COMP_LINE}) {
#        $r->{shell} = 'bash';
#        return 1;
#    } elsif ($ENV{COMMAND_LINE}) {
#        $r->{shell} = 'tcsh';
#        return 1;
#    }
#
#    $r->{shell} //= 'bash';
#    0;
#}
#
#sub _read_env {
#    my ($self, $r) = @_;
#
#    return [] unless $self->read_env;
#    my $env_name = $self->env_name;
#    my $env = $ENV{$env_name};
#    log_trace("[pericmd] Checking env %s: %s", $env_name, $env);
#    return [] unless defined $env;
#
#
#    my $words;
#    if ($r->{shell} eq 'bash') {
#        require Complete::Bash;
#        ($words, undef) = @{ Complete::Bash::parse_cmdline($env, 0) };
#    } elsif ($r->{shell} eq 'fish') {
#        ($words, undef) = @{ Complete::Base::parse_cmdline($env) };
#    } elsif ($r->{shell} eq 'tcsh') {
#        require Complete::Tcsh;
#        ($words, undef) = @{ Complete::Tcsh::parse_cmdline($env) };
#    } elsif ($r->{shell} eq 'zsh') {
#        require Complete::Bash;
#        ($words, undef) = @{ Complete::Bash::parse_cmdline($env) };
#    } else {
#        die "Unsupported shell '$r->{shell}'";
#    }
#    log_trace("[pericmd] Words from env: %s", $words);
#    $words;
#}
#
#sub do_dump {
#    require Data::Dump;
#
#    my ($self, $r) = @_;
#
#    local $r->{in_dump} = 1;
#
#    $self->hook_before_parse_argv($r);
#    $self->_parse_argv1($r);
#
#    if ($r->{read_env}) {
#        my $env_words = $self->_read_env($r);
#        unshift @ARGV, @$env_words;
#    }
#
#    my $scd = $r->{subcommand_data};
#    my $meta = $self->get_meta($r, $scd->{url} // $self->{url});
#
#    $self->{'x.main.spec'} = \%main::SPEC;
#
#    my $dump = join(
#        "",
#        "# BEGIN DUMP $ENV{PERINCI_CMDLINE_DUMP}\n",
#        Data::Dump::dump($self), "\n",
#        "# END DUMP $ENV{PERINCI_CMDLINE_DUMP}\n",
#    );
#
#    [200, "OK", $dump,
#     {
#         stream => 0,
#         "cmdline.skip_format" => 1,
#     }];
#}
#
#sub do_completion {
#    my ($self, $r) = @_;
#
#    local $r->{in_completion} = 1;
#
#    my ($words, $cword);
#    if ($r->{shell} eq 'bash') {
#        require Complete::Bash;
#        require Encode;
#        ($words, $cword) = @{ Complete::Bash::parse_cmdline(undef, undef, {truncate_current_word=>1}) };
#        ($words, $cword) = @{ Complete::Bash::join_wordbreak_words($words, $cword) };
#        $words = [map {Encode::decode('UTF-8', $_)} @$words];
#    } elsif ($r->{shell} eq 'fish') {
#        require Complete::Bash;
#        ($words, $cword) = @{ Complete::Bash::parse_cmdline() };
#    } elsif ($r->{shell} eq 'tcsh') {
#        require Complete::Tcsh;
#        ($words, $cword) = @{ Complete::Tcsh::parse_cmdline() };
#    } elsif ($r->{shell} eq 'zsh') {
#        require Complete::Bash;
#        ($words, $cword) = @{ Complete::Bash::parse_cmdline() };
#    } else {
#        die "Unsupported shell '$r->{shell}'";
#    }
#
#    shift @$words; $cword--; 
#
#    @ARGV = @$words;
#
#    $self->hook_before_parse_argv($r);
#    $self->_parse_argv1($r);
#
#    if ($r->{read_env}) {
#        my $env_words = $self->_read_env($r);
#        unshift @ARGV, @$env_words;
#        $cword += @$env_words;
#    }
#
#
#    $r->{format} = 'text';
#
#    my $scd = $r->{subcommand_data};
#    my $meta = $self->get_meta($r, $scd->{url} // $self->{url});
#
#    my $subcommand_name_from = $r->{subcommand_name_from} // '';
#
#    require Perinci::Sub::Complete;
#    my $compres = Perinci::Sub::Complete::complete_cli_arg(
#        meta            => $meta, 
#        words           => $words,
#        cword           => $cword,
#        common_opts     => $self->common_opts,
#        riap_server_url => $scd->{url},
#        riap_uri        => undef,
#        riap_client     => $self->riap_client,
#        extras          => {r=>$r, cmdline=>$self},
#        func_arg_starts_at => ($subcommand_name_from eq 'arg' ? 1:0),
#        completion      => sub {
#            my %args = @_;
#            my $type = $args{type};
#
#            if ($self->completion) {
#                my $res = $self->completion(%args);
#                return $res if $res;
#            }
#            if ($self->subcommands &&
#                    $subcommand_name_from ne '--cmd' &&
#                         $type eq 'arg' && $args{argpos}==0) {
#                require Complete::Util;
#                return Complete::Util::complete_array_elem(
#                    array => [keys %{ $self->list_subcommands }],
#                    word  => $words->[$cword]);
#            }
#
#            return undef;
#        },
#    );
#
#    my $formatted;
#    if ($r->{shell} eq 'bash') {
#        require Complete::Bash;
#        $formatted = Complete::Bash::format_completion(
#            $compres, {word=>$words->[$cword]});
#    } elsif ($r->{shell} eq 'fish') {
#        require Complete::Fish;
#        $formatted = Complete::Fish::format_completion($compres);
#    } elsif ($r->{shell} eq 'tcsh') {
#        require Complete::Tcsh;
#        $formatted = Complete::Tcsh::format_completion($compres);
#    } elsif ($r->{shell} eq 'zsh') {
#        require Complete::Zsh;
#        $formatted = Complete::Zsh::format_completion($compres);
#    }
#
#    $self->use_utf8(1);
#
#    [200, "OK", $formatted,
#     {
#         "func.words" => $words,
#         "func.cword" => $cword,
#         "cmdline.skip_format" => 1,
#     }];
#}
#
#sub _read_config {
#    require Perinci::CmdLine::Util::Config;
#
#    my ($self, $r) = @_;
#
#    my $hook_section;
#    if ($self->can("hook_config_file_section")) {
#        $hook_section = sub {
#            my ($section_name, $section_content) = @_;
#            $self->hook_config_file_section(
#                $r, $section_name, $section_content);
#        };
#    }
#
#    my $res = Perinci::CmdLine::Util::Config::read_config(
#        config_paths     => $r->{config_paths},
#        config_filename  => $self->config_filename,
#        config_dirs      => $self->config_dirs,
#        program_name     => $self->program_name,
#        hook_section     => $hook_section,
#    );
#    die $res unless $res->[0] == 200;
#    $r->{config} = $res->[2];
#    $r->{read_config_files} = $res->[3]{'func.read_files'};
#    $r->{_config_section_read_order} = $res->[3]{'func.section_read_order'}; 
#
#    if ($ENV{LOG_DUMP_CONFIG}) {
#        log_trace "config: %s", $r->{config};
#        log_trace "read_config_files: %s", $r->{read_config_files};
#    }
#}
#
#sub __min(@) {
#    my $m = $_[0];
#    for (@_) {
#        $m = $_ if $_ < $m;
#    }
#    $m;
#}
#
#sub __editdist {
#    my @a = split //, shift;
#    my @b = split //, shift;
#
#    my @d;
#    $d[$_][0] = $_ for 0 .. @a;
#    $d[0][$_] = $_ for 0 .. @b;
#
#    for my $i (1 .. @a) {
#        for my $j (1 .. @b) {
#            $d[$i][$j] = (
#                $a[$i-1] eq $b[$j-1]
#                    ? $d[$i-1][$j-1]
#                    : 1 + __min(
#                        $d[$i-1][$j],
#                        $d[$i][$j-1],
#                        $d[$i-1][$j-1]
#                    )
#                );
#        }
#    }
#
#    $d[@a][@b];
#}
#
#sub __uniq {
#    my %seen = ();
#    my $k;
#    my $seen_undef;
#    grep { defined $_ ? not $seen{ $k = $_ }++ : not $seen_undef++ } @_;
#}
#
#sub __find_similar_strings {
#    my ($needle, $haystack, $cut) = @_;
#
#    my $factor   = 1.5;
#    my $max_dist = 4;
#
#    my @res =
#        map { $_->[0] }
#        sort { $a->[1] <=> $b->[1] }
#        grep { defined }
#        map {
#            my $el = $_;
#            if ($cut && length($_) > length($needle)) {
#                $el = substr($el, 0, length($needle));
#            }
#            my $d = __editdist($el, $needle);
#            my $max_distance = __min(
#                __min(length($el), length($needle))/$factor,
#                $max_dist,
#            );
#            ($d <= $max_distance) ? [$_, $d] : undef
#        } @$haystack;
#
#    $cut ? __uniq(@res) : @res;
#}
#
#sub __find_similar_go_opts {
#    my ($opt, $go_spec) = @_;
#
#    $opt =~ s/^--?//;
#
#    my @ospecs0 = ref($go_spec) eq 'ARRAY' ?
#        keys(%{ { @$go_spec } }) : keys(%$go_spec);
#    my @ospecs;
#    for my $o (@ospecs0) {
#        $o =~ s/^--?//;
#        my $is_neg = $o =~ /\!$/;
#        $o =~ s/[=:].+|[?+!]$//;
#        for (split /\|/, $o) {
#            if ($is_neg && length($_) > 1) {
#                push @ospecs, $_, "no$_", "no-$_";
#            } else {
#                push @ospecs, $_;
#            }
#        }
#    }
#
#    map { length($_) > 1 ? "--$_" : "-$_" }
#        __find_similar_strings($opt, \@ospecs, "cut");
#}
#
#sub _parse_argv1 {
#    my ($self, $r) = @_;
#
#    my @go_spec;
#    {
#
#        require Getopt::Long;
#        my $old_go_conf = Getopt::Long::Configure(
#            'pass_through', 'no_ignore_case', 'no_auto_abbrev',
#            'no_getopt_compat', 'gnu_compat', 'bundling');
#        my $co = $self->common_opts // {};
#        for my $k (keys %$co) {
#            push @go_spec, $co->{$k}{getopt} => sub {
#                my ($go, $val) = @_;
#                $co->{$k}{handler}->($go, $val, $r);
#            };
#        }
#        Getopt::Long::GetOptions(@go_spec);
#        Getopt::Long::Configure($old_go_conf);
#    }
#
#    {
#        my $scn = $r->{subcommand_name};
#        my $scn_from = $r->{subcommand_name_from};
#        if (!defined($scn) && defined($self->{default_subcommand})) {
#            if ($self->get_subcommand_from_arg == 1) {
#                $scn = $self->{default_subcommand};
#                $scn_from = 'default_subcommand';
#            } elsif ($self->get_subcommand_from_arg == 2 && !@ARGV) {
#                $scn = $self->{default_subcommand};
#                $scn_from = 'default_subcommand';
#            }
#        }
#        if (!defined($scn) && $self->{subcommands} && @ARGV) {
#            if ($ARGV[0] =~ /\A-/) {
#                if ($r->{in_completion}) {
#                    $scn = shift @ARGV;
#                    $scn_from = 'arg';
#                } else {
#                    my $suggestion = '';
#                    my @similar = __find_similar_go_opts($ARGV[0], \@go_spec);
#                    $suggestion = " (perhaps you meant ".
#                        join("/", @similar)."?)" if @similar;
#                    die [400, "Unknown option: $ARGV[0]".$suggestion];
#                }
#            } else {
#                $scn = shift @ARGV;
#                $scn_from = 'arg';
#            }
#        }
#
#        my $scd;
#        if (defined $scn) {
#            $scd = $self->get_subcommand_data($scn);
#            unless ($r->{in_completion}) {
#                unless ($scd) {
#                    my $scs = $self->list_subcommands;
#                    if ($self->auto_abbrev_subcommand) {
#                        my $num_matches = 0;
#                        my $complete_scn;
#                        for (keys %$scs) {
#                            if (index($_, $scn) == 0) {
#                                $num_matches++;
#                                $complete_scn = $_;
#                                last if $num_matches > 1;
#                            }
#                        }
#                        if ($num_matches == 1) {
#                            $scn = $complete_scn;
#                            $scd = $self->get_subcommand_data($scn);
#                            goto L1;
#                        }
#                    }
#                    my @similar =
#                        __find_similar_strings($scn, [keys %$scs]);
#                    my $suggestion = '';
#                    $suggestion = " (perhaps you meant ".
#                        join("/", @similar)."?)" if @similar;
#                    die [500, "Unknown subcommand: $scn".$suggestion];
#                }
#            }
#        } elsif (!$r->{action} && $self->{subcommands}) {
#            $r->{action} = 'help';
#            $r->{skip_parse_subcommand_argv} = 1;
#        } else {
#            $scn = '';
#            $scd = {
#                url => $self->url,
#                summary => $self->summary,
#                description => $self->description,
#                pass_cmdline_object => $self->pass_cmdline_object,
#                tags => $self->tags,
#            };
#        }
#      L1:
#        $r->{subcommand_name} = $scn;
#        $r->{subcommand_name_from} = $scn_from;
#        $r->{subcommand_data} = $scd;
#    }
#
#    $r->{_parse_argv1_done} = 1;
#}
#
#sub _parse_argv2 {
#    require Perinci::CmdLine::Util::Config;
#
#    my ($self, $r) = @_;
#
#    my %args;
#
#    if ($r->{read_env}) {
#        my $env_words = $self->_read_env($r);
#        unshift @ARGV, @$env_words;
#    }
#
#    if ($r->{skip_parse_subcommand_argv}) {
#        return [200, "OK (subcommand options parsing skipped)"];
#    } else {
#        my $scd = $r->{subcommand_data};
#        if ($r->{meta} && !$self->{subcommands}) {
#        } else {
#            $self->get_meta($r, $scd->{url});
#        }
#
#        if ($scd->{args}) {
#            $args{$_} = $scd->{args}{$_} for keys %{ $scd->{args} };
#        }
#
#        if ($r->{read_config}) {
#
#            log_trace("[pericmd] Running hook_before_read_config_file ...");
#            $self->hook_before_read_config_file($r);
#
#            $self->_read_config($r) unless $r->{config};
#
#            log_trace("[pericmd] Running hook_after_read_config_file ...");
#            $self->hook_after_read_config_file($r);
#
#            my $res = Perinci::CmdLine::Util::Config::get_args_from_config(
#                r                  => $r,
#                config             => $r->{config},
#                args               => \%args,
#                program_name       => $self->program_name,
#                subcommand_name    => $r->{subcommand_name},
#                config_profile     => $r->{config_profile},
#                common_opts        => $self->common_opts,
#                meta               => $r->{meta},
#                meta_is_normalized => 1,
#            );
#            die $res unless $res->[0] == 200;
#            log_trace("[pericmd] args after reading config files: %s",
#                         \%args);
#            my $found = $res->[3]{'func.found'};
#            if (defined($r->{config_profile}) && !$found &&
#                    defined($r->{read_config_files}) &&
#                        @{$r->{read_config_files}} &&
#                            !$r->{ignore_missing_config_profile_section}) {
#                return [412, "Profile '$r->{config_profile}' not found ".
#                            "in configuration file"];
#            }
#
#        }
#
#
#        my $copts = $self->common_opts;
#        my %old_handlers;
#        for (keys %$copts) {
#            my $h = $copts->{$_}{handler};
#            $copts->{$_}{handler} = sub {
#                my ($go, $val) = @_;
#                $h->($go, $val, $r);
#            };
#            $old_handlers{$_} = $h;
#        }
#
#        my $has_cmdline_src;
#        for my $ak (keys %{$r->{meta}{args} // {}}) {
#            my $av = $r->{meta}{args}{$ak};
#            if ($av->{cmdline_src}) {
#                $has_cmdline_src = 1;
#                last;
#            }
#        }
#
#        require Perinci::Sub::GetArgs::Argv;
#        my $ga_res = Perinci::Sub::GetArgs::Argv::get_args_from_argv(
#            argv                => \@ARGV,
#            args                => \%args,
#            meta                => $r->{meta},
#            meta_is_normalized  => 1,
#            allow_extra_elems   => $has_cmdline_src ? 1:0,
#            per_arg_json        => $self->{per_arg_json},
#            per_arg_yaml        => $self->{per_arg_yaml},
#            common_opts         => $copts,
#            strict              => $r->{in_completion} ? 0:1,
#            (ggls_res            => $r->{_ggls_res}) x defined($r->{_ggls_res}),
#            on_missing_required_args => sub {
#                my %a = @_;
#
#                my ($an, $aa, $as) = ($a{arg}, $a{args}, $a{spec});
#                my $src = $as->{cmdline_src} // '';
#
#                $src = '' if $src eq 'stdin_or_args' && -t STDIN;
#
#                if ($src && $as->{req}) {
#                    return 1;
#                } else {
#                    return 0;
#                }
#            },
#        );
#
#        return $ga_res unless $ga_res->[0] == 200;
#
#        my $args_p = $r->{meta}{args} // {};
#        for my $arg (keys %{$ga_res->[2]}) {
#            next unless $args_p->{$arg};
#            next unless $args_p->{$arg}{stream};
#            for ($ga_res->[2]{$arg}) {
#                $_ = ref $_ eq 'ARRAY' ? __array_iter($_) : __list_iter($_);
#            }
#        }
#
#        for (keys %$copts) {
#            $copts->{$_}{handler} = $old_handlers{$_};
#        }
#
#        return $ga_res;
#    }
#}
#
#sub parse_argv {
#    my ($self, $r) = @_;
#
#    log_trace("[pericmd] Parsing \@ARGV: %s", \@ARGV);
#
#
#    $self->_parse_argv1($r) unless $r->{_parse_argv1_done};
#    $self->_parse_argv2($r);
#}
#
#sub __gen_iter {
#    require Data::Sah::Util::Type;
#
#    my ($fh, $argspec, $argname) = @_;
#    my $schema = $argspec->{schema};
#    $schema = $schema->[1]{of} if $schema->[0] eq 'array';
#    my $type = Data::Sah::Util::Type::get_type($schema);
#
#    if (Data::Sah::Util::Type::is_simple($schema)) {
#        my $chomp = $type eq 'buf' ? 0 :
#            $argspec->{'cmdline.chomp'} // 1;
#        return sub {
#            local $/ = \(64*1024) if $type eq 'buf';
#
#            state $eof;
#            return undef if $eof;
#            my $l = <$fh>;
#            unless (defined $l) {
#                $eof++; return undef;
#            }
#            chomp($l) if $chomp;
#            $l;
#        };
#    } else {
#        require JSON::MaybeXS;
#        state $json = JSON::MaybeXS->new->allow_nonref;
#        my $i = -1;
#        return sub {
#            state $eof;
#            return undef if $eof;
#            $i++;
#            my $l = <$fh>;
#            unless (defined $l) {
#                $eof++; return undef;
#            }
#            eval { $l = $json->decode($l) };
#            if ($@) {
#                die "Invalid JSON in stream argument '$argname' record #$i: $@";
#            }
#            $l;
#        };
#    }
#}
#
#sub parse_cmdline_src {
#    my ($self, $r) = @_;
#
#    my $action = $r->{action};
#    my $meta   = $r->{meta};
#
#    my $url = $r->{subcommand_data}{url} // $self->{url} // '';
#    my $is_network = $url =~ m!^(https?|riap[^:]+):!;
#
#    if ($action eq 'call') {
#        my $args_p = $meta->{args} // {};
#        my $stdin_seen;
#        for my $an (sort {
#            my $csa  = $args_p->{$a}{cmdline_src};
#            my $csb  = $args_p->{$b}{cmdline_src};
#            my $posa = $args_p->{$a}{pos} // 9999;
#            my $posb = $args_p->{$b}{pos} // 9999;
#
#            (
#                !$csa || !$csb ? 0 :
#                    $csa eq 'stdin_line' && $csb eq 'stdin_line' ? 0 :
#                    $csa eq 'stdin_line' && $csb =~ /^(stdin|stdin_or_files?|stdin_or_args)/ ? -1 :
#                    $csb eq 'stdin_line' && $csa =~ /^(stdin|stdin_or_files?|stdin_or_args)/ ? 1 : 0
#            )
#            ||
#
#            ($posa <=> $posb)
#
#            ||
#            ($a cmp $b)
#        } keys %$args_p) {
#            my $as = $args_p->{$an};
#            my $src = $as->{cmdline_src};
#            my $type = $as->{schema}[0]
#                or die "BUG: No schema is defined for arg '$an'";
#            my $do_stream = $as->{stream} && $url !~ /^https?:/;
#            if ($src) {
#                die [531,
#                     "Invalid 'cmdline_src' value for argument '$an': $src"]
#                    unless $src =~ /\A(stdin|file|stdin_or_files?|stdin_or_args|stdin_line)\z/;
#                die [531,
#                     "Sorry, argument '$an' is set cmdline_src=$src, but type ".
#                         "is not str/buf/array, only those are supported now"]
#                    unless $do_stream || $type =~ /\A(str|buf|array)\z/; 
#
#                if ($src =~ /\A(stdin|stdin_or_files?|stdin_or_args)\z/) {
#                    die [531, "Only one argument can be specified ".
#                             "cmdline_src stdin/stdin_or_file/stdin_or_files/stdin_or_args"]
#                        if $stdin_seen++;
#                }
#                my $is_ary = $type eq 'array';
#                if ($src eq 'stdin_line' && !exists($r->{args}{$an})) {
#                    require Perinci::Object;
#                    my $term_readkey_available = eval { require Term::ReadKey; 1 };
#                    my $prompt = Perinci::Object::rimeta($as)->langprop('cmdline_prompt') //
#                        sprintf($self->default_prompt_template, $an);
#                    print $prompt;
#                    my $iactive = (-t STDOUT);
#                    Term::ReadKey::ReadMode('noecho')
#                          if $term_readkey_available && $iactive && $as->{is_password};
#                    chomp($r->{args}{$an} = <STDIN>);
#                    do { print "\n"; Term::ReadKey::ReadMode(0) if $term_readkey_available }
#                        if $iactive && $as->{is_password};
#                    $r->{args}{"-cmdline_src_$an"} = 'stdin_line';
#                } elsif ($src eq 'stdin' || $src eq 'file' &&
#                        ($r->{args}{$an}//"") eq '-') {
#                    die [400, "Argument $an must be set to '-' which means ".
#                             "from stdin"]
#                        if defined($r->{args}{$an}) &&
#                            $r->{args}{$an} ne '-';
#                    $r->{args}{$an} = $do_stream ?
#                        __gen_iter(\*STDIN, $as, $an) :
#                            $is_ary ? [<STDIN>] :
#                                do {local $/; ~~<STDIN>};
#                    $r->{args}{"-cmdline_src_$an"} = 'stdin';
#                } elsif ($src eq 'stdin_or_file' || $src eq 'stdin_or_files') {
#                    local @ARGV = @ARGV;
#                    unshift @ARGV, $r->{args}{$an}
#                        if defined $r->{args}{$an};
#
#                    splice @ARGV, 1
#                        if @ARGV > 1 && $src eq 'stdin_or_file';
#
#
#                    for (@ARGV) {
#                        next if $_ eq '-';
#                        die [500, "Can't read file '$_': $!"] if !(-r $_);
#                    }
#
#                    $r->{args}{"-cmdline_srcfilenames_$an"} = [@ARGV];
#                    $r->{args}{$an} = $do_stream ?
#                        __gen_iter(\*ARGV, $as, $an) :
#                            $is_ary ? [<>] :
#                                do {local $/; ~~<>};
#                    $r->{args}{"-cmdline_src_$an"} = $src;
#                } elsif ($src eq 'stdin_or_args' && !(-t STDIN)) {
#                    unless (defined($r->{args}{$an})) {
#                        $r->{args}{$an} = $do_stream ?
#                            __gen_iter(\*STDIN, $as, $an) :
#                            $is_ary ? [map {chomp;$_} <STDIN>] :
#                                do {local $/; ~~<STDIN>};
#                    }
#                } elsif ($src eq 'file') {
#                    unless (exists $r->{args}{$an}) {
#                        if ($as->{req}) {
#                            die [400,
#                                 "Please specify filename for argument '$an'"];
#                        } else {
#                            next;
#                        }
#                    }
#                    die [400, "Please specify filename for argument '$an'"]
#                        unless defined $r->{args}{$an};
#                    my $fh;
#                    my $fname = $r->{args}{$an};
#                    unless (open $fh, "<", $fname) {
#                        die [500, "Can't open file '$fname' for argument '$an'".
#                                 ": $!"];
#                    }
#                    $r->{args}{$an} = $do_stream ?
#                        __gen_iter($fh, $as, $an) :
#                            $is_ary ? [<$fh>] :
#                                do { local $/; ~~<$fh> };
#                    close $fh;
#                    $r->{args}{"-cmdline_src_$an"} = 'file';
#                    $r->{args}{"-cmdline_srcfilenames_$an"} = [$fname];
#                }
#            }
#
#            if ($self->riap_version == 1.2 && $is_network &&
#                    defined($r->{args}{$an}) && $args_p->{$an}{schema} &&
#                        $args_p->{$an}{schema}[0] eq 'buf' &&
#                            !$r->{args}{"$an:base64"}) {
#                require MIME::Base64;
#                $r->{args}{"$an:base64"} =
#                    MIME::Base64::encode_base64($r->{args}{$an}, "");
#                delete $r->{args}{$an};
#            }
#        } 
#    }
#}
#
#sub select_output_handle {
#    my ($self, $r) = @_;
#
#    my $resmeta = $r->{res}[3] // {};
#
#    my $handle;
#  SELECT_HANDLE:
#    {
#        if ($ENV{VIEW_RESULT} // $resmeta->{"cmdline.view_result"}) {
#            my $viewer = $resmeta->{"cmdline.viewer"} // $ENV{VIEWER} //
#                $ENV{BROWSER};
#            last if defined $viewer && !$viewer; 
#            die [500, "No VIEWER program set"] unless defined $viewer;
#            $r->{viewer} = $viewer;
#            require File::Temp;
#            my $filename;
#            ($handle, $filename) = File::Temp::tempfile();
#            $r->{viewer_temp_path} = $filename;
#        }
#
#        if ($ENV{PAGE_RESULT} // $resmeta->{"cmdline.page_result"}) {
#            require File::Which;
#            my $pager = $resmeta->{"cmdline.pager"} //
#                $ENV{PAGER};
#            unless (defined $pager) {
#                $pager = "less -FRSX" if File::Which::which("less");
#            }
#            unless (defined $pager) {
#                $pager = "more" if File::Which::which("more");
#            }
#            unless (defined $pager) {
#                die [500, "Can't determine PAGER"];
#            }
#            last unless $pager; 
#            open $handle, "| $pager";
#        }
#        $handle //= \*STDOUT;
#    }
#    $r->{output_handle} = $handle;
#}
#
#sub save_output {
#    my ($self, $r, $dir) = @_;
#    $dir //= $ENV{PERINCI_CMDLINE_OUTPUT_DIR};
#
#    unless (-d $dir) {
#        warn "Can't save output to $dir: doesn't exist or not a directory,skipped saving program output";
#        return;
#    }
#
#    my $time = do {
#        if (eval { require Time::HiRes; 1 }) {
#            Time::HiRes::time();
#        } else {
#            time();
#        }
#    };
#
#    my $fmttime = do {
#        my @time = gmtime($time);
#        sprintf(
#            "%04d-%02d-%02dT%02d%02d%02d.%09dZ",
#            $time[5]+1900,
#            $time[4]+1,
#            $time[3],
#            $time[2],
#            $time[1],
#            $time[0],
#            ($time - int($time))*1_000_000_000,
#        );
#    };
#
#    my ($fpath_out, $fpath_meta);
#    my ($fh_out, $fh_meta);
#    {
#        require Fcntl;
#        my $counter = -1;
#        while (1) {
#            if ($counter++ >= 10_000) {
#                warn "Can't create file to save program output, skipped saving program output";
#                return;
#            }
#            my $fpath_out  = "$dir/" . ($counter ? "$fmttime.out.$counter"  : "$fmttime.out");
#            my $fpath_meta = "$dir/" . ($counter ? "$fmttime.meta.$counter" : "$fmttime.meta");
#            if ((-e $fpath_out) || (-e $fpath_meta)) {
#                next;
#            }
#            unless (sysopen $fh_out , $fpath_out , Fcntl::O_WRONLY() | Fcntl::O_CREAT() | Fcntl::O_EXCL()) {
#                warn "Can't create file '$fpath_out' to save program output: $!, skipped saving program output";
#                return;
#            }
#            unless (sysopen $fh_meta, $fpath_meta, Fcntl::O_WRONLY() | Fcntl::O_CREAT() | Fcntl::O_EXCL()) {
#                warn "Can't create file '$fpath_meta' to save program output meta information: $!, skipped saving program output";
#                unlink $fpath_out;
#                return;
#            }
#            last;
#        }
#    }
#
#    require JSON::MaybeXS;
#    state $json = JSON::MaybeXS->new->allow_nonref;
#
#    my $out = $self->cleanser->clone_and_clean($r->{res});
#    my $meta = {
#        time        => $time,
#        pid         => $$,
#        argv        => $r->{orig_argv},
#        read_env    => $r->{read_env},
#        read_config => $r->{read_config},
#        read_config_files => $r->{read_config_files},
#    };
#    log_trace "Saving program output to %s ...", $fpath_out;
#    print $fh_out $json->encode($out);
#    log_trace "Saving program output's meta information to %s ...", $fpath_meta;
#    print $fh_meta $json->encode($meta);
#}
#
#sub display_result {
#    require Data::Sah::Util::Type;
#
#    my ($self, $r) = @_;
#
#    my $meta = $r->{meta};
#    my $res = $r->{res};
#    my $fres = $r->{fres};
#    my $resmeta = $res->[3] // {};
#
#    my $handle = $r->{output_handle};
#
#    my $sch = $meta->{result}{schema};
#    my $type = Data::Sah::Util::Type::get_type($sch) // '';
#
#    if ($resmeta->{stream} // $meta->{result}{stream}) {
#        my $x = $res->[2];
#        if (ref($x) eq 'CODE') {
#            if (Data::Sah::Util::Type::is_simple($sch)) {
#                while (defined(my $l = $x->())) {
#                    print $l;
#                    print "\n" unless $type eq 'buf';
#                }
#            } else {
#                require JSON::MaybeXS;
#                state $json = JSON::MaybeXS->new->allow_nonref;
#                if ($self->use_cleanser) {
#                    while (defined(my $rec = $x->())) {
#                        print $json->encode(
#                            $self->cleanser->clone_and_clean($rec)), "\n";
#                    }
#                } else {
#                    while (defined(my $rec = $x->())) {
#                        print $json->encode($rec), "\n";
#                    }
#                }
#            }
#        } else {
#            die "Result is a stream but no coderef provided";
#        }
#    } else {
#        print $handle $fres;
#        if ($r->{viewer}) {
#            require ShellQuote::Any::Tiny;
#            my $cmd = $r->{viewer} ." ". ShellQuote::Any::Tiny::shell_quote($r->{viewer_temp_path});
#            system $cmd;
#        }
#    }
#}
#
#sub run {
#    my ($self) = @_;
#    log_trace("[pericmd] -> run(), \@ARGV=%s", \@ARGV);
#
#    my $co = $self->common_opts;
#
#    my $r = {
#        orig_argv   => [@ARGV],
#        common_opts => $co,
#    };
#
#    if ($ENV{PERINCI_CMDLINE_DUMP}) {
#        $r->{res} = $self->do_dump($r);
#        goto FORMAT;
#    }
#
#    if ($self->_detect_completion($r)) {
#        $r->{res} = $self->do_completion($r);
#        goto FORMAT;
#    }
#
#    $r->{naked_res} = $co->{naked_res}{default} if $co->{naked_res};
#    $r->{format}    = $co->{format}{default} if $co->{format};
#
#    {
#        last if (-t STDOUT) || $r->{format};
#        last unless eval { require Pipe::Find; 1 };
#        my $pipeinfo = Pipe::Find::get_stdout_pipe_process();
#        last unless $pipeinfo;
#        last unless $pipeinfo->{exe} =~ m![/\\]td\z! ||
#            $pipeinfo->{cmdline} =~ m!\A([^\0]*[/\\])?perl\0([^\0]*[/\\])?td\0!;
#        $r->{format} = 'json';
#    }
#
#    $r->{format} //= $self->default_format;
#
#    if ($self->read_config) {
#        $r->{read_config} = 1;
#    }
#
#    if ($self->read_env) {
#        $r->{read_env} = 1;
#    }
#
#    eval {
#        log_trace("[pericmd] Running hook_before_run ...");
#        $self->hook_before_run($r);
#
#        log_trace("[pericmd] Running hook_before_parse_argv ...");
#        $self->hook_before_parse_argv($r);
#
#        my $parse_res = $self->parse_argv($r);
#        if ($parse_res->[0] == 501) {
#            $r->{send_argv} = 1;
#        } elsif ($parse_res->[0] != 200) {
#            die $parse_res;
#        }
#        $r->{parse_argv_res} = $parse_res;
#        $r->{args} = $parse_res->[2] // {};
#
#        $r->{action} //= 'call';
#
#        if ($self->log) {
#            require Log::ger::App;
#            my $default_level = do {
#                my $dry_run = $r->{dry_run} // $self->default_dry_run;
#                $dry_run ? 'info' : 'warn';
#            };
#            Log::ger::App->import(
#                level => $r->{log_level} // $self->log_level // $default_level,
#                name  => $self->program_name,
#            );
#        }
#
#        log_trace("[pericmd] Running hook_after_parse_argv ...");
#        $self->hook_after_parse_argv($r);
#
#        $self->parse_cmdline_src($r);
#
#
#        my $missing = $parse_res->[3]{"func.missing_args"};
#        die [400, "Missing required argument(s): ".join(", ", @$missing)]
#            if $missing && @$missing;
#
#        my $scd = $r->{subcommand_data};
#        if ($scd->{pass_cmdline_object} // $self->pass_cmdline_object) {
#            $r->{args}{-cmdline} = $self;
#            $r->{args}{-cmdline_r} = $r;
#        }
#
#        log_trace("[pericmd] Running hook_before_action ...");
#        $self->hook_before_action($r);
#
#        my $meth = "action_$r->{action}";
#        die [500, "Unknown action $r->{action}"] unless $self->can($meth);
#        log_trace("[pericmd] Running %s() ...", $meth);
#        $r->{res} = $self->$meth($r);
#
#        log_trace("[pericmd] Running hook_after_action ...");
#        $self->hook_after_action($r);
#    };
#    my $err = $@;
#    if ($err || !$r->{res}) {
#        if ($err) {
#            $err = [500, "Died: $err"] unless ref($err) eq 'ARRAY';
#            if (%Devel::Confess::) {
#                no warnings 'once';
#                require Scalar::Util;
#                my $id = Scalar::Util::refaddr($err);
#                my $stack_trace = $Devel::Confess::MESSAGES{$id};
#                $err->[1] .= "\n$stack_trace" if $stack_trace;
#            }
#            $err->[1] =~ s/\n+$//;
#            $r->{res} = $err;
#        } else {
#            $r->{res} = [500, "Bug: no response produced"];
#        }
#    } elsif (ref($r->{res}) ne 'ARRAY') {
#        log_trace("[pericmd] res=%s", $r->{res}); 
#        $r->{res} = [500, "Bug in program: result not an array"];
#    }
#
#    if (!$r->{res}[0] || $r->{res}[0] < 200 || $r->{res}[0] > 555) {
#        $r->{res}[3]{'x.orig_status'} = $r->{res}[0];
#        $r->{res}[0] = 555;
#    }
#
#    $r->{format} //= $r->{res}[3]{'cmdline.default_format'};
#    $r->{format} //= $r->{meta}{'cmdline.default_format'};
#    my $restore_orig_result;
#    my $orig_result;
#    if (exists $r->{res}[3]{'cmdline.result'}) {
#        $restore_orig_result = 1;
#        $orig_result = $r->{res}[2];
#        $r->{res}[2] = $r->{res}[3]{'cmdline.result'};
#    }
#  FORMAT:
#    my $is_success = $r->{res}[0] =~ /\A2/ || $r->{res}[0] == 304;
#
#    if (defined $ENV{PERINCI_CMDLINE_OUTPUT_DIR}) {
#        $self->save_output($r);
#    }
#
#    if ($is_success &&
#            ($self->skip_format ||
#             $r->{meta}{'cmdline.skip_format'} ||
#             $r->{res}[3]{'cmdline.skip_format'})) {
#        $r->{fres} = $r->{res}[2] // '';
#    } elsif ($is_success &&
#                 ($r->{res}[3]{stream} // $r->{meta}{result}{stream})) {
#    }else {
#        log_trace("[pericmd] Running hook_format_result ...");
#        $r->{res}[3]{stream} = 0;
#        $r->{fres} = $self->hook_format_result($r) // '';
#    }
#    $self->select_output_handle($r);
#    log_trace("[pericmd] Running hook_display_result ...");
#    $self->hook_display_result($r);
#    log_trace("[pericmd] Running hook_after_run ...");
#    $self->hook_after_run($r);
#
#    if ($restore_orig_result) {
#        $r->{res}[2] = $orig_result;
#    }
#
#    my $exitcode;
#    if ($r->{res}[3] && defined($r->{res}[3]{'cmdline.exit_code'})) {
#        $exitcode = $r->{res}[3]{'cmdline.exit_code'};
#    } else {
#        $exitcode = $self->status2exitcode($r->{res}[0]);
#    }
#    if ($self->exit) {
#        log_trace("[pericmd] exit(%s)", $exitcode);
#        exit $exitcode;
#    } else {
#        log_trace("[pericmd] <- run(), exitcode=%s", $exitcode);
#        $r->{res}[3]{'x.perinci.cmdline.base.exit_code'} = $exitcode;
#        return $r->{res};
#    }
#}
#
#1;
#
#__END__
#
### Perinci/CmdLine/Help.pm ###
#package Perinci::CmdLine::Help;
#
#our $DATE = '2017-08-12'; 
#our $VERSION = '0.170'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(gen_help);
#
#our %SPEC;
#
#$SPEC{gen_help} = {
#    v => 1.1,
#    summary => 'Generate help message for Perinci::CmdLine-based app',
#    args => {
#        program_name => {
#            schema => 'str*',
#            req => 1,
#        },
#        program_summary => {
#            schema => 'str*',
#        },
#        subcommands => {
#            schema => 'hash',
#        },
#        meta => {
#            summary => 'Function metadata, must be normalized',
#            schema => 'hash*',
#            req => 1,
#        },
#        common_opts => {
#            schema => 'hash*',
#            default => {},
#        },
#        per_arg_json => {
#            schema => 'bool*',
#        },
#        per_arg_yaml => {
#            schema => 'bool*',
#        },
#        ggls_res => {
#            summary => 'Full result from gen_getopt_long_spec_from_meta()',
#            schema  => 'array*', 
#            description => <<'_',
#
#If you already call <pm:Perinci::Sub::GetArgs::Argv>'s
#`gen_getopt_long_spec_from_meta()`, you can pass the _full_ enveloped result
#here, to avoid calculating twice.
#
#_
#        },
#    },
#};
#sub gen_help {
#    no warnings 'once';
#    require Text::Wrap;
#
#    my %args = @_;
#
#    local $Text::Wrap::columns = $ENV{COLUMNS} // 80;
#
#    my $meta = $args{meta};
#    my $common_opts = $args{common_opts} // {};
#
#    my @help;
#
#    my $progname = $args{program_name};
#    {
#        my $sum = $args{program_summary} // $meta->{summary};
#        last unless $sum;
#        push @help, $progname, " - ", $sum, "\n\n";
#    }
#
#    my $clidocdata;
#
#    push @help, "Usage:\n";
#    {
#        for (sort {
#            ($common_opts->{$a}{order} // 99) <=>
#                ($common_opts->{$b}{order} // 99) ||
#                    $a cmp $b
#            } keys %$common_opts) {
#            my $co = $common_opts->{$_};
#            next unless $co->{usage};
#            push @help, "  $progname $co->{usage}\n";
#        }
#
#        require Perinci::Sub::To::CLIDocData;
#        my $res = Perinci::Sub::To::CLIDocData::gen_cli_doc_data_from_meta(
#            meta => $meta, meta_is_normalized => 1,
#            common_opts  => $common_opts,
#            per_arg_json => $args{per_arg_json},
#            per_arg_yaml => $args{per_arg_yaml},
#            (ggls_res => $args{ggls_res}) x defined($args{ggls_res}),
#        );
#        die [500, "gen_cli_doc_data_from_meta failed: ".
#                 "$res->[0] - $res->[1]"] unless $res->[0] == 200;
#        $clidocdata = $res->[2];
#        my $usage = $clidocdata->{usage_line};
#        $usage =~ s/\[\[prog\]\]/$progname/;
#        push @help, "  $usage\n";
#    }
#
#    {
#        my $subcommands = $args{subcommands} or last;
#        push @help, "\nSubcommands:\n";
#        if (keys(%$subcommands) >= 12) {
#            push @help, Text::Wrap::wrap(
#                "  ", "  ", join(", ", sort keys %$subcommands)), "\n";
#        } else {
#            for my $sc_name (sort keys %$subcommands) {
#                my $sc_spec = $subcommands->{$sc_name};
#                next unless $sc_spec->{show_in_help} //1;
#                push @help, "  $sc_name\n";
#            }
#        }
#    }
#
#    {
#        last unless @{ $clidocdata->{examples} };
#        push @help, "\nExamples:\n";
#        my $i = 0;
#        my $egs = $clidocdata->{examples};
#        for my $eg (@$egs) {
#            $i++;
#            my $cmdline = $eg->{cmdline};
#            $cmdline =~ s/\[\[prog\]\]/$progname/;
#            push @help, "\n" if $eg->{summary} && $i > 1;
#            if ($eg->{summary}) {
#                push @help, "  $eg->{summary}:\n";
#            } else {
#                push @help, "\n";
#            }
#            push @help, "  % $cmdline\n";
#        }
#    }
#
#    {
#        my $desc = $args{program_description} //
#            $meta->{'description.alt.env.cmdline'} // $meta->{description};
#        last unless $desc;
#        $desc =~ s/\A\n+//;
#        $desc =~ s/\n+\z//;
#        push @help, "\n", $desc, "\n" if $desc =~ /\S/;
#    }
#
#    {
#        require Data::Dmp;
#
#        my $opts = $clidocdata->{opts};
#        last unless keys %$opts;
#
#        my %options_by_cat; 
#        for my $optkey (keys %$opts) {
#            for my $cat (@{ $opts->{$optkey}{categories} }) {
#                push @{ $options_by_cat{$cat} }, $optkey;
#            }
#        }
#
#        my $cats_spec = $clidocdata->{option_categories};
#        for my $cat (sort {
#            ($cats_spec->{$a}{order} // 50) <=> ($cats_spec->{$b}{order} // 50)
#                || $a cmp $b }
#                         keys %options_by_cat) {
#            my @opts = sort {length($b)<=>length($a)}
#                @{ $options_by_cat{$cat} };
#            my $len = length($opts[0]);
#            @opts = sort {
#                (my $a_without_dash = $a) =~ s/^-+//;
#                (my $b_without_dash = $b) =~ s/^-+//;
#                lc($a) cmp lc($b);
#            } @opts;
#            push @help, "\n$cat:\n";
#            for my $opt (@opts) {
#                my $ospec = $opts->{$opt};
#                my $arg_spec = $ospec->{arg_spec};
#                next if grep {$_ eq 'hidden'} @{$arg_spec->{tags} // []};
#                my $is_bool = $arg_spec->{schema} &&
#                    $arg_spec->{schema}[0] eq 'bool';
#                my $show_default = exists($ospec->{default}) &&
#                    !$is_bool && !$ospec->{is_base64} &&
#                        !$ospec->{is_json} && !$ospec->{is_yaml} &&
#                            !$ospec->{is_alias};
#
#                my $add_sum = '';
#                if ($ospec->{is_base64}) {
#                    $add_sum = " (as base64-encoded str)";
#                } elsif ($ospec->{is_json}) {
#                    $add_sum = " (as JSON-encoded str)";
#                } elsif ($ospec->{is_yaml}) {
#                    $add_sum = " (as YAML-encoded str)";
#                }
#
#                my $argv = '';
#                if (!$ospec->{main_opt} && defined($ospec->{pos})) {
#                    if ($ospec->{greedy}) {
#                        $argv = " (=arg[$ospec->{pos}-])";
#                    } else {
#                        $argv = " (=arg[$ospec->{pos}])";
#                    }
#                }
#
#                my $cmdline_src = '';
#                if (!$ospec->{main_opt} && defined($arg_spec->{cmdline_src})) {
#                    $cmdline_src = " (or from $arg_spec->{cmdline_src})";
#                    $cmdline_src =~ s!_or_!/!g;
#                }
#
#                push @help, sprintf(
#                    "  %-${len}s  %s%s%s%s%s\n",
#                    $opt,
#                    Text::Wrap::wrap("", " " x (2+$len+2 +2),
#                                     $ospec->{summary}//''),
#                    $add_sum,
#                    $argv,
#                    $cmdline_src,
#                    ($show_default && defined($ospec->{default}) ?
#                         " [".Data::Dmp::dmp($ospec->{default})."]":""),
#
#                );
#            }
#        }
#    }
#
#    [200, "OK", join("", @help)];
#}
#
#1;
#
#__END__
#
### Perinci/CmdLine/Lite.pm ###
#package Perinci::CmdLine::Lite;
#
#our $DATE = '2019-01-14'; 
#our $VERSION = '1.817'; 
#
#use 5.010001;
#use Log::ger;
#
#use List::Util qw(first);
#use Mo qw(build default);
#extends 'Perinci::CmdLine::Base';
#
#
#has default_prompt_template => (
#    is=>'rw',
#    default => 'Enter %s: ',
#);
#has validate_args => (
#    is=>'rw',
#    default => 1,
#);
#
#my $formats = [qw/text text-simple text-pretty json json-pretty csv html html+datatables perl/];
#
#sub BUILD {
#    my ($self, $args) = @_;
#
#    if (!$self->{riap_client}) {
#        require Perinci::Access::Lite;
#        my %rcargs = (
#            riap_version => $self->{riap_version} // 1.1,
#            %{ $self->{riap_client_args} // {} },
#        );
#        $self->{riap_client} = Perinci::Access::Lite->new(%rcargs);
#    }
#
#    if (!$self->{actions}) {
#        $self->{actions} = {
#            call => {},
#            version => {},
#            subcommands => {},
#            help => {},
#        };
#    }
#
#    my $_t = sub {
#        no warnings;
#        my $co_name = shift;
#        my $href = $Perinci::CmdLine::Base::copts{$co_name};
#        %$href;
#    };
#
#    if (!$self->{common_opts}) {
#        my $copts = {};
#
#        $copts->{version}   = { $_t->('version'), };
#        $copts->{help}      = { $_t->('help'), };
#
#        unless ($self->skip_format) {
#            $copts->{format}    = {
#                $_t->('format'),
#                schema => ['str*' => in => $formats],
#            };
#            $copts->{json}      = { $_t->('json'), };
#            $copts->{naked_res} = { $_t->('naked_res'), };
#        }
#        if ($self->subcommands) {
#            $copts->{subcommands} = { $_t->('subcommands'), };
#        }
#        if ($self->default_subcommand) {
#            $copts->{cmd} = { $_t->('cmd') };
#        }
#        if ($self->read_config) {
#            $copts->{config_path}    = { $_t->('config_path') };
#            $copts->{no_config}      = { $_t->('no_config') };
#            $copts->{config_profile} = { $_t->('config_profile') };
#        }
#        if ($self->read_env) {
#            $copts->{no_env} = { $_t->('no_env') };
#        }
#        if ($self->log) {
#            $copts->{log_level} = { $_t->('log_level'), };
#            $copts->{trace}     = { $_t->('trace'), };
#            $copts->{debug}     = { $_t->('debug'), };
#            $copts->{verbose}   = { $_t->('verbose'), };
#            $copts->{quiet}     = { $_t->('quiet'), };
#        }
#        $self->{common_opts} = $copts;
#    }
#
#    $self->{formats} //= $formats;
#
#    $self->{per_arg_json} //= 1;
#}
#
#my $setup_progress;
#sub _setup_progress_output {
#    my $self = shift;
#
#    return unless $ENV{PROGRESS} // (-t STDOUT);
#
#    require Progress::Any::Output;
#    Progress::Any::Output->set("TermProgressBarColor");
#    $setup_progress = 1;
#}
#
#sub _unsetup_progress_output {
#    my $self = shift;
#
#    return unless $setup_progress;
#    no warnings 'once';
#    my $out = $Progress::Any::outputs{''}[0];
#    $out->cleanup if $out->can("cleanup");
#    $setup_progress = 0;
#}
#
#sub hook_after_parse_argv {
#    my ($self, $r) = @_;
#
#    my $ass  = $r->{meta}{args} // {};
#    my $args = $r->{args};
#    for (keys %$ass) {
#        next if exists $args->{$_};
#        my $as = $ass->{$_};
#        if (exists $as->{default}) {
#            $args->{$_} = $as->{default};
#        } elsif ($as->{schema} && exists $as->{schema}[1]{default}) {
#            $args->{$_} = $as->{schema}[1]{default};
#        }
#    }
#}
#
#sub equal2 {
#    state $require = do { require Scalar::Util };
#
#    my ($val1, $val2) = @_;
#
#
#    if (defined $val1) {
#        return 0 unless defined $val2;
#        if (ref $val1) {
#            return 0 unless ref $val2;
#            return Scalar::Util::refaddr($val1) eq Scalar::Util::refaddr($val2);
#        } else {
#            return 0 if ref $val2;
#            return $val1 eq $val2;
#        }
#    } else {
#        return 0 if defined $val2;
#        return 1;
#    }
#}
#
#sub hook_before_parse_argv {
#    my ($self, $r) = @_;
#
#    return if $r->{subcommands};
#    $self->get_meta($r, $self->{url});
#
#    my $copts = $self->common_opts;
#
#    require Perinci::Sub::GetArgs::Argv;
#    my $ggls_res = Perinci::Sub::GetArgs::Argv::gen_getopt_long_spec_from_meta(
#        meta               => $r->{meta},
#        meta_is_normalized => 1,
#        args               => $r->{args},
#        common_opts        => $copts,
#        per_arg_json       => $self->{per_arg_json},
#        per_arg_yaml       => $self->{per_arg_yaml},
#    );
#
#    my $meta_uses_opt_P = 0;
#    my $meta_uses_opt_c = 0;
#    my $meta_uses_opt_C = 0;
#    {
#        last unless $ggls_res->[0] == 200;
#        my $opts = $ggls_res->[3]{'func.opts'};
#        if (grep { $_ eq '-P' } @$opts) { $meta_uses_opt_P = 1 }
#        if (grep { $_ eq '-c' } @$opts) { $meta_uses_opt_c = 1 }
#        if (grep { $_ eq '-C' } @$opts) { $meta_uses_opt_C = 1 }
#    }
#
#
#    if ($copts->{config_profile} && !$meta_uses_opt_P) {
#        $copts->{config_profile}{getopt} = 'config-profile|P=s';
#    }
#
#    if ($copts->{config_path} && !$meta_uses_opt_c) {
#        $copts->{config_path}{getopt} = 'config-path|c=s';
#    }
#
#    if ($copts->{no_config} && !$meta_uses_opt_C) {
#        $copts->{no_config}{getopt} = 'no-config|C';
#    }
#}
#
#sub hook_before_action {
#    my ($self, $r) = @_;
#
#  VALIDATE_ARGS:
#    {
#        last unless $self->validate_args;
#
#        last unless $r->{action} eq 'call';
#
#        my $meta = $r->{meta};
#
#        last if $meta->{'x.perinci.sub.wrapper.logs'} &&
#            (grep { $_->{validate_args} }
#             @{ $meta->{'x.perinci.sub.wrapper.logs'} });
#
#        require Data::Sah;
#
#        my %validators; 
#
#        for my $arg (sort keys %{ $meta->{args} // {} }) {
#            next unless exists($r->{args}{$arg});
#
#            next if $meta->{args}{$arg}{stream};
#
#            my $schema = $meta->{args}{$arg}{schema};
#            next unless $schema;
#            unless ($validators{"$schema"}) {
#                my $v = Data::Sah::gen_validator($schema, {
#                    return_type => 'str+val',
#                    schema_is_normalized => 1,
#                });
#                $validators{"$schema"} = $v;
#            }
#            my $res = $validators{"$schema"}->($r->{args}{$arg});
#            if ($res->[0]) {
#                die [400, "Argument '$arg' fails validation: $res->[0]"];
#            }
#            my $val0 = $r->{args}{$arg};
#            my $coerced_val = $res->[1];
#            $r->{args}{$arg} = $coerced_val;
#            $r->{args}{"-orig_$arg"} = $val0 unless equal2($val0, $coerced_val);
#        }
#
#        if ($meta->{args_rels}) {
#            my $schema = [hash => $meta->{args_rels}];
#            my $sah = Data::Sah->new;
#            my $hc  = $sah->get_compiler("human");
#            my $cd  = $hc->init_cd;
#            $cd->{args}{lang} //= $cd->{default_lang};
#            my $v = Data::Sah::gen_validator($schema, {
#                return_type => 'str',
#                human_hash_values => {
#                    field  => $hc->_xlt($cd, "argument"),
#                    fields => $hc->_xlt($cd, "arguments"),
#                },
#            });
#            my $res = $v->($r->{args});
#            if ($res) {
#                die [400, $res];
#            }
#        }
#
#    }
#}
#
#sub hook_format_result {
#    require Perinci::Result::Format::Lite;
#    my ($self, $r) = @_;
#
#    my $fmt = $r->{format} // 'text';
#
#    if ($fmt eq 'html+datatables') {
#        $fmt = 'text-pretty';
#        $ENV{VIEW_RESULT} //= 1;
#        $ENV{FORMAT_PRETTY_TABLE_BACKEND} //= 'Text::Table::HTML::DataTables';
#    }
#
#    my $fres = Perinci::Result::Format::Lite::format(
#        $r->{res}, $fmt, $r->{naked_res}, $self->{use_cleanser});
#
#    if ($fmt =~ /text/ && $r->{res}[0] =~ /\A[45]/ && defined($r->{res}[1])) {
#        $fres = $self->program_name . ": $fres";
#    }
#
#    $fres;
#}
#
#sub hook_format_row {
#    my ($self, $r, $row) = @_;
#
#    if (ref($row) eq 'ARRAY') {
#        return join("\t", @$row) . "\n";
#    } else {
#        return ($row // "") . "\n";
#    }
#}
#
#sub hook_display_result {
#    my ($self, $r) = @_;
#
#    my $res  = $r->{res};
#    my $resmeta = $res->[3] // {};
#
#    my $handle = $r->{output_handle};
#
#    my $utf8;
#    {
#        last if defined($utf8 = $ENV{UTF8});
#        if ($resmeta->{'x.hint.result_binary'}) {
#            $utf8 = 0; last;
#        }
#        if ($r->{subcommand_data}) {
#            last if defined($utf8 = $r->{subcommand_data}{use_utf8});
#        }
#        $utf8 = $self->use_utf8;
#    }
#    binmode($handle, ":encoding(utf8)") if $utf8;
#
#    $self->display_result($r);
#}
#
#sub hook_after_run {
#    my ($self, $r) = @_;
#    $self->_unsetup_progress_output;
#}
#
#sub hook_after_get_meta {
#    my ($self, $r) = @_;
#
#    my $copts = $self->common_opts;
#
#    require Perinci::Sub::GetArgs::Argv;
#    my $ggls_res = Perinci::Sub::GetArgs::Argv::gen_getopt_long_spec_from_meta(
#        meta               => $r->{meta},
#        meta_is_normalized => 1,
#        args               => $r->{args},
#        common_opts        => $copts,
#        per_arg_json       => $self->{per_arg_json},
#        per_arg_yaml       => $self->{per_arg_yaml},
#    );
#
#    my $meta_uses_opt_n = 0;
#    {
#        last unless $ggls_res->[0] == 200;
#        my $opts = $ggls_res->[3]{'func.opts'};
#        if (grep { $_ eq '-n' } @$opts) { $meta_uses_opt_n = 1 }
#    }
#
#    require Perinci::Object;
#    my $metao = Perinci::Object::risub($r->{meta});
#
#    {
#        last if $self->skip_format; 
#        last unless $r->{meta}{'cmdline.skip_format'};
#        delete $copts->{format};
#        delete $copts->{json};
#        delete $copts->{naked_res};
#    }
#
#    {
#        last unless $metao->can_dry_run;
#        my $default_dry_run = $metao->default_dry_run // $self->default_dry_run;
#        $r->{dry_run} = 1 if $default_dry_run;
#        $r->{dry_run} = ($ENV{DRY_RUN} ? 1:0) if defined $ENV{DRY_RUN};
#
#        my $optname = 'dry-run' . ($meta_uses_opt_n ? '' : '|n');
#        $copts->{dry_run} = {
#            getopt  => $default_dry_run ? "$optname!" : $optname,
#            summary => $default_dry_run ?
#                "Disable simulation mode (also via DRY_RUN=0)" :
#                "Run in simulation mode (also via DRY_RUN=1)",
#            handler => sub {
#                my ($go, $val, $r) = @_;
#                if ($val) {
#                    log_debug("[pericmd] Dry-run mode is activated");
#                    $r->{dry_run} = 1;
#                } else {
#                    log_debug("[pericmd] Dry-run mode is deactivated");
#                    $r->{dry_run} = 0;
#                }
#            },
#        };
#    }
#
#    if ($r->{meta}{deps} && !$r->{in_dump} && !$r->{in_completion}) {
#        require Perinci::Sub::DepChecker;
#        my $res = Perinci::Sub::DepChecker::check_deps($r->{meta}{deps});
#        if ($res) {
#            die [412, "Dependency failed: $res"];
#        }
#    }
#}
#
#sub action_subcommands {
#    my ($self, $r) = @_;
#
#    if (!$self->subcommands) {
#        say "There are no subcommands.";
#        return 0;
#    }
#
#    say "Available subcommands:";
#    my $scs = $self->list_subcommands;
#    my $longest = 6;
#    for (keys %$scs) { my $l = length; $longest = $l if $l > $longest }
#    [200, "OK",
#     join("",
#          (map { sprintf("  %-${longest}s  %s\n",$_,$scs->{$_}{summary}//"") }
#               sort keys %$scs),
#      )];
#}
#
#sub action_version {
#    no strict 'refs';
#
#    my ($self, $r) = @_;
#
#    my @text;
#
#    {
#        my $meta = $r->{meta} = $self->get_meta($r, $self->url);
#        push @text, $self->get_program_and_subcommand_name($r),
#            " version ", ($meta->{entity_v} // "?"),
#            ($meta->{entity_date} ? " ($meta->{entity_date})" : ''),
#            "\n";
#        for my $mod (@{ $meta->{'x.dynamic_generator_modules'} // [] }) {
#            push @text, "  $mod version ", ${"$mod\::VERSION"},
#                (${"$mod\::DATE"} ? " (".${"$mod\::DATE"}.")" : ""),
#                    "\n";
#        }
#    }
#
#    for my $url (@{ $self->extra_urls_for_version // [] }) {
#        my $meta = $self->get_meta($r, $url);
#        push @text, "  $url version ", ($meta->{entity_v} // "?"),
#            ($meta->{entity_date} ? " ($meta->{entity_date})" : ''),
#            "\n";
#    }
#
#    push @text, "  ", __PACKAGE__,
#        " version ", ($Perinci::CmdLine::Lite::VERSION // "?"),
#        ($Perinci::CmdLine::Lite::DATE ?
#         " ($Perinci::CmdLine::Lite::DATE)":''),
#        "\n";
#
#    [200, "OK", join("", @text)];
#}
#
#sub action_help {
#    require Perinci::CmdLine::Help;
#
#    my ($self, $r) = @_;
#
#    my @help;
#    my $scn    = $r->{subcommand_name};
#    my $scd    = $r->{subcommand_data};
#
#    my $meta = $self->get_meta($r, $scd->{url} // $self->{url});
#
#    my $common_opts = { %{$self->common_opts} };
#
#    my $has_sc_no_sc = $self->subcommands &&
#        !length($r->{subcommand_name} // '');
#    delete $common_opts->{subcommands} if $self->subcommands && !$has_sc_no_sc;
#
#    my $res = Perinci::CmdLine::Help::gen_help(
#        program_name => $self->get_program_and_subcommand_name($r),
#        program_summary => ($scd ? $scd->{summary}:undef ) // $meta->{summary},
#        program_description => $scd ? $scd->{description} : undef,
#        meta => $meta,
#        subcommands => $has_sc_no_sc ? $self->list_subcommands : undef,
#        common_opts => $common_opts,
#        per_arg_json => $self->per_arg_json,
#        per_arg_yaml => $self->per_arg_yaml,
#    );
#
#    $res->[3]{"cmdline.skip_format"} = 1;
#    $res;
#}
#
#sub action_call {
#    my ($self, $r) = @_;
#
#    my %extra;
#    if ($r->{send_argv}) {
#        log_trace("[pericmd] Sending argv to server: %s", $extra{argv});
#        $extra{argv} = $r->{orig_argv};
#    } else {
#        my %extra_args;
#        $extra_args{-dry_run} = 1 if $r->{dry_run};
#        $extra{args} = {%extra_args, %{$r->{args}}};
#    }
#
#    $extra{stream_arg} = 1 if $r->{stream_arg};
#
#    my $url = $r->{subcommand_data}{url};
#
#    log_trace("[pericmd] Riap request: action=call, url=%s", $url);
#
#
#    if ($r->{meta}{features}{progress}) {
#        $self->_setup_progress_output;
#    }
#
#    $self->riap_client->request(
#        call => $url, \%extra);
#}
#
#1;
#
#__END__
#
### Perinci/CmdLine/Util/Config.pm ###
#package Perinci::CmdLine::Util::Config;
#
#our $DATE = '2018-03-05'; 
#our $VERSION = '1.721'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#our %SPEC;
#
#sub _get_my_home_dir {
#    if ($^O eq 'MSWin32') {
#        return $ENV{HOME} if $ENV{HOME};
#        return $ENV{USERPROFILE} if $ENV{USERPROFILE};
#        return join($ENV{HOMEDRIVE}, "\\", $ENV{HOMEPATH})
#            if $ENV{HOMEDRIVE} && $ENV{HOMEPATH};
#    } else {
#        return $ENV{HOME} if $ENV{HOME};
#        my @pw;
#        eval { @pw = getpwuid($>) };
#        return $pw[7] if @pw;
#    }
#    die "Can't get home directory";
#}
#
#$SPEC{get_default_config_dirs} = {
#    v => 1.1,
#    args => {},
#};
#sub get_default_config_dirs {
#    my @dirs;
#    my $home = _get_my_home_dir();
#    if ($^O eq 'MSWin32') {
#        push @dirs, $home;
#    } else {
#        push @dirs, "$home/.config", $home, "/etc";
#    }
#    \@dirs;
#}
#
#$SPEC{read_config} = {
#    v => 1.1,
#    args => {
#        config_paths    => {},
#        config_filename => {},
#        config_dirs     => {},
#        program_name    => {},
#        hook_section    => {},
#    },
#};
#sub read_config {
#    require Config::IOD::Reader;
#
#    my %args = @_;
#
#    my $config_dirs = $args{config_dirs} // get_default_config_dirs();
#
#    my $paths;
#
#    my @filenames;
#    my %section_config_filename_map;
#    if (my $names = $args{config_filename}) {
#        for my $name (ref($names) eq 'ARRAY' ? @$names : ($names)) {
#            if (ref($name) eq 'HASH') {
#                $section_config_filename_map{$name->{filename}} = $name->{section};
#                push @filenames, $name->{filename};
#            } else {
#                $section_config_filename_map{$name} = 'GLOBAL';
#                push @filenames, $name;
#            }
#        }
#    }
#    unless (@filenames) {
#        @filenames = (($args{program_name} // "prog") . ".conf");
#    }
#
#    if ($args{config_paths}) {
#        $paths = $args{config_paths};
#    } else {
#        for my $dir (@$config_dirs) {
#            for my $name (@filenames) {
#                my $path = "$dir/" . $name;
#                push @$paths, $path if -e $path;
#            }
#        }
#    }
#
#    my $reader = Config::IOD::Reader->new;
#    my %res;
#    my @read;
#    my %section_read_order;
#  FILE:
#    for my $i (0..$#{$paths}) {
#        my $path           = $paths->[$i];
#        my $filename = $path; $filename =~ s!.*[/\\]!!;
#        my $wanted_section = $section_config_filename_map{$filename};
#        log_trace "[pericmd] Reading config file '%s' ...", $path;
#        my $j = 0;
#        $section_read_order{GLOBAL} = [$i, $j++];
#        my @file_sections = ("GLOBAL");
#        my $hoh = $reader->read_file(
#            $path,
#            sub {
#                my %args = @_;
#                return unless $args{event} eq 'section';
#                my $section = $args{section};
#                push @file_sections, $section
#                    unless grep {$section eq $_} @file_sections;
#                $section_read_order{$section} = [$i, $j++];
#            },
#        );
#        push @read, $path;
#      SECTION:
#        for my $section (@file_sections) {
#            my $hash = $hoh->{$section};
#
#            my $s = $section; $s =~ s/\s*\S*=.*\z//; 
#            $s = 'GLOBAL' if $s eq '';
#
#            if ($args{hook_section}) {
#                my $res = $args{hook_section}->($section, $hash);
#                if ($res->[0] == 204) {
#                    log_trace "[pericmd] Skipped config section '$section' ".
#                        "in file '$path': hook_section returns 204";
#                    next SECTION;
#                } elsif ($res->[0] >= 400 && $res->[0] <= 599) {
#                    return [$res->[0], "Error when reading config file '$path'".
#                                ": $res->[1]"];
#                }
#            }
#
#            next unless !defined($wanted_section) || $s eq $wanted_section;
#
#            for (keys %$hash) {
#                $res{$section}{$_} = $hash->{$_};
#            }
#        }
#    }
#    [200, "OK", \%res, {
#        'func.read_files' => \@read,
#        'func.section_read_order' => \%section_read_order,
#    }];
#}
#
#$SPEC{get_args_from_config} = {
#    v => 1.1,
#    args => {
#        r => {},
#        config => {},
#        args => {},
#        subcommand_name => {},
#        config_profile => {},
#        common_opts => {},
#        meta => {},
#        meta_is_normalized => {},
#    },
#};
#sub get_args_from_config {
#    my %fargs = @_;
#
#    my $r       = $fargs{r};
#    my $conf    = $fargs{config};
#    my $progn   = $fargs{program_name};
#    my $scn     = $fargs{subcommand_name} // '';
#    my $profile = $fargs{config_profile};
#    my $args    = $fargs{args} // {};
#    my $copts   = $fargs{common_opts};
#    my $meta    = $fargs{meta};
#    my $found;
#
#    unless ($fargs{meta_is_normalized}) {
#        require Perinci::Sub::Normalize;
#        $meta = Perinci::Sub::Normalize::normalize_function_metadata($meta);
#    }
#
#    my $csro = $r->{_config_section_read_order} // {};
#    my @sections = sort {
#        my $csro_a = $csro->{$a} // [0,0];
#        my $csro_b = $csro->{$b} // [0,0];
#        $csro_a->[0] <=> $csro_b->[0] ||
#            $csro_a->[1] <=> $csro_b->[1] ||
#            $a cmp $b
#        } keys %$conf;
#
#    my %seen_profiles; 
#    for my $section0 (@sections) {
#        my %keyvals;
#        my $sect_name;
#        for my $word (split /\s+/, $section0) {
#            if ($word =~ /(.*?)=(.*)/) {
#                $keyvals{$1} = $2;
#            } else {
#                $sect_name //= $word;
#            }
#        }
#        $seen_profiles{$keyvals{profile}}++ if defined $keyvals{profile};
#
#        my $sect_scn     = $keyvals{subcommand} // '';
#        my $sect_profile = $keyvals{profile};
#
#        if (length $scn) {
#            if (length($sect_scn) && $sect_scn ne $scn) {
#                log_trace(
#                    "[pericmd] Skipped config section '%s' (%s)",
#                    $section0, "subcommand does not match '$scn'",
#                );
#                next;
#            }
#        } else {
#            if (length $sect_scn) {
#                log_trace(
#                    "[pericmd] Skipped config section '%s' (%s)",
#                    $section0, "only for a certain subcommand",
#                );
#                next;
#            }
#        }
#
#        if (defined $profile) {
#            if (defined($sect_profile) && $sect_profile ne $profile) {
#                log_trace(
#                    "[pericmd] Skipped config section '%s' (%s)",
#                    $section0, "profile does not match '$profile'",
#                );
#                next;
#            }
#            $found = 1 if defined($sect_profile) && $sect_profile eq $profile;
#        } else {
#            if (defined($sect_profile)) {
#                log_trace(
#                    "[pericmd] Skipped config section '%s' (%s)",
#                    $section0, "only for a certain profile",
#                );
#                next;
#            }
#        }
#
#        if (defined($progn) && defined($keyvals{program})) {
#            if ($progn ne $keyvals{program}) {
#                log_trace(
#                    "[pericmd] Skipped config section '%s' (%s)",
#                    $section0, "program does not match '$progn'",
#                );
#                next;
#            }
#        }
#
#        if (defined(my $env = $keyvals{env})) {
#            my ($var, $val);
#            if (($var, $val) = $env =~ /\A(\w+)=(.*)\z/) {
#                if (($ENV{$var} // '') ne $val) {
#                    log_trace(
#                        "[pericmd] Skipped config section '%s' (%s)",
#                        $section0, "env $var has non-matching value '".
#                            ($ENV{$var} // '')."'",
#                    );
#                    next;
#                }
#            } elsif (($var, $val) = $env =~ /\A(\w+)!=(.*)\z/) {
#                if (($ENV{$var} // '') eq $val) {
#                    log_trace(
#                        "[pericmd] Skipped config section '%s' (%s)",
#                        $section0, "env $var has that value",
#                    );
#                    next;
#                }
#            } elsif (($var, $val) = $env =~ /\A(\w+)\*=(.*)\z/) {
#                if (index(($ENV{$var} // ''), $val) < 0) {
#                    log_trace(
#                        "[pericmd] Skipped config section '%s' (%s)",
#                        $section0, "env $var has value '".
#                            ($ENV{$var} // '')."' which does not contain the ".
#                                "requested string"
#                    );
#                    next;
#                }
#            } else {
#                if (!$ENV{$env}) {
#                    log_trace(
#                        "[pericmd] Skipped config section '%s' (%s)",
#                        $section0, "env $env is not set/true",
#                    );
#                    next;
#                }
#            }
#        }
#
#        log_trace("[pericmd] Reading config section '%s'", $section0);
#
#        my $as = $meta->{args} // {};
#        for my $k (keys %{ $conf->{$section0} }) {
#            my $v = $conf->{$section0}{$k};
#            if ($copts->{$k} && $copts->{$k}{is_settable_via_config}) {
#                my $sch = $copts->{$k}{schema};
#                if ($sch) {
#                    require Data::Sah::Normalize;
#                    $sch = Data::Sah::Normalize::normalize_schema($sch);
#                    if (ref($v) ne 'ARRAY' && $sch->[0] eq 'array') {
#                        $v = [$v];
#                    }
#                }
#                $copts->{$k}{handler}->(undef, $v, $r);
#            } else {
#                $k =~ s/\.arg\z//;
#
#                if (ref($v) ne 'ARRAY' && $as->{$k} && $as->{$k}{schema} &&
#                        $as->{$k}{schema}[0] eq 'array') {
#                    $v = [$v];
#                }
#                $args->{$k} = $v;
#            }
#        }
#    }
#    log_trace("[pericmd] Seen config profiles: %s",
#              [sort keys %seen_profiles]);
#
#    [200, "OK", $args, {'func.found'=>$found}];
#}
#
#1;
#
#__END__
#
### Perinci/Object.pm ###
#
#package Perinci::Object;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA    = qw(Exporter);
#our @EXPORT = qw(rimeta risub rivar ripkg envres envresmulti envrestable
#                 riresmeta);
#
#sub rimeta {
#    require Perinci::Object::Metadata;
#    Perinci::Object::Metadata->new(@_);
#}
#
#sub risub {
#    require Perinci::Object::Function;
#    Perinci::Object::Function->new(@_);
#}
#
#sub rivar {
#    require Perinci::Object::Variable;
#    Perinci::Object::Variable->new(@_);
#}
#
#sub ripkg {
#    require Perinci::Object::Package;
#    Perinci::Object::Package->new(@_);
#}
#
#sub envres {
#    require Perinci::Object::EnvResult;
#    Perinci::Object::EnvResult->new(@_);
#}
#
#sub envresmulti {
#    require Perinci::Object::EnvResultMulti;
#    Perinci::Object::EnvResultMulti->new(@_);
#}
#
#sub envrestable {
#    require Perinci::Object::EnvResultTable;
#    Perinci::Object::EnvResultTable->new(@_);
#}
#
#sub riresmeta {
#    require Perinci::Object::ResMeta;
#    Perinci::Object::ResMeta->new(@_);
#}
#
#1;
#
#__END__
#
### Perinci/Object/EnvResult.pm ###
#package Perinci::Object::EnvResult;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#sub new {
#    my ($class, $res) = @_;
#    $res //= [0, "", undef];
#    my $obj = \$res;
#    bless $obj, $class;
#}
#
#sub new_ok {
#    my $class = shift;
#    my $res = [200, "OK"];
#    if (@_) {
#        push @$res, $_[0];
#    }
#    $class->new($res);
#}
#
#sub status {
#    my ($self, $new) = @_;
#    if (defined $new) {
#        die "Status must be an integer between 100 and 555" unless
#            int($new) eq $new && $new >= 100 && $new <= 555;
#        my $old = ${$self}->[0];
#        ${$self}->[0] = $new;
#        return $old;
#    }
#    ${$self}->[0];
#}
#
#sub message {
#    my ($self, $new) = @_;
#    if (defined $new) {
#        die "Extra must be a string" if ref($new);
#        my $old = ${$self}->[1];
#        ${$self}->[1] = $new;
#        return $old;
#    }
#    ${$self}->[1];
#}
#
#
#sub payload {
#    my ($self, $new) = @_;
#    if (defined $new) {
#        my $old = ${$self}->[2];
#        ${$self}->[2] = $new;
#        return $old;
#    }
#    ${$self}->[2];
#}
#
#sub meta {
#    my ($self, $new) = @_;
#    if (defined $new) {
#        die "Extra must be a hashref" unless ref($new) eq 'HASH';
#        my $old = ${$self}->[3];
#        ${$self}->[3] = $new;
#        return $old;
#    }
#    ${$self}->[3];
#}
#
#sub is_success {
#    my ($self) = @_;
#    my $status = ${$self}->[0];
#    $status >= 200 && $status <= 299;
#}
#
#sub as_struct {
#    my ($self) = @_;
#    ${$self};
#}
#
#1;
#
#__END__
#
### Perinci/Object/EnvResultMulti.pm ###
#package Perinci::Object::EnvResultMulti;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use parent qw(Perinci::Object::EnvResult);
#
#sub new {
#    my ($class, $res) = @_;
#    $res //= [200, "Success/no items"];
#    my $obj = \$res;
#    bless $obj, $class;
#}
#
#sub add_result {
#    my ($self, $status, $message, $extra) = @_;
#    my $num_ok  = 0;
#    my $num_nok = 0;
#
#    push @{ ${$self}->[3]{results} },
#        {status=>$status, message=>$message, %{ $extra // {} }};
#    for (@{ ${$self}->[3]{results} // [] }) {
#        if ($_->{status} =~ /\A(2|304)/) {
#            $num_ok++;
#        } else {
#            $num_nok++;
#        }
#    }
#    if ($num_ok) {
#        if ($num_nok) {
#            ${$self}->[0] = 207;
#            ${$self}->[1] = "Partial success";
#        } else {
#            my $overall_status = 200;
#            my %statuses;
#            for (@{ ${$self}->[3]{results} // []}) {
#                $statuses{ $_->{status} }++;
#            }
#            if (keys %statuses == 1) {
#                my @tmp = keys %statuses;
#                $overall_status = $tmp[0];
#            }
#            ${$self}->[0] = $overall_status;
#            ${$self}->[1] = "All success";
#        }
#    } else {
#        ${$self}->[0] = $status;
#        ${$self}->[1] = $message;
#    }
#}
#
#1;
#
#__END__
#
### Perinci/Object/EnvResultTable.pm ###
#package Perinci::Object::EnvResultTable;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use parent qw(Perinci::Object::EnvResult);
#
#sub add_field {
#    my ($self, $name, %attrs) = @_;
#    ${$self}->[3]{'table.fields'} //= [];
#    push @{ ${$self}->[3]{'table.fields'} }, $name;
#}
#
#1;
#
#__END__
#
### Perinci/Object/Function.pm ###
#package Perinci::Object::Function;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use parent qw(Perinci::Object::Metadata);
#
#sub type { "function" }
#
#sub feature {
#    my $self = shift;
#    my $name = shift;
#    if (@_) {
#        die "1.0 can't set feature" if $self->v eq 1.0;
#        my $value = shift;
#        ${$self}->{features} //= {};
#        my $old = ${$self}->{features}{$name};
#        ${$self}->{features}{$name} = $value;
#        return $old;
#    } else {
#        ${$self}->{features}{$name};
#    }
#}
#
#sub features {
#    my $self = shift;
#    ${$self}->{features} // {};
#}
#
#sub can_dry_run {
#    my $self = shift;
#    my $ff = ${$self}->{features} // {};
#    $ff->{dry_run} // $ff->{tx} && $ff->{tx}{v} == 2;
#}
#
#sub default_dry_run {
#    my $self = shift;
#    my $ff = ${$self}->{features} // {};
#    ref($ff->{dry_run}) eq 'HASH' && $ff->{dry_run}{default};
#}
#
#sub arg {
#    my $self = shift;
#    my $name = shift;
#    if (@_) {
#        die "1.0 can't set arg" if $self->v eq 1.0;
#        my $value = shift;
#        ${$self}->{args} //= {};
#        my $old = ${$self}->{args}{$name};
#        ${$self}->{args}{$name} = $value;
#        return $old;
#    } else {
#        ${$self}->{args}{$name};
#    }
#}
#
#1;
#
#__END__
#
### Perinci/Object/Metadata.pm ###
#package Perinci::Object::Metadata;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#sub __trim_blank_lines {
#    local $_ = shift;
#    return $_ unless defined;
#    s/\A(?:\n\s*)+//;
#    s/(?:\n\s*){2,}\z/\n/;
#    $_;
#}
#
#sub new {
#    my ($class, $meta) = @_;
#    $meta //= {};
#    my $obj = \$meta;
#    bless $obj, $class;
#}
#
#sub v {
#    my $self = shift;
#    ${$self}->{v} // 1.0;
#}
#
#sub type {
#    die "BUG: type() must be subclassed";
#}
#
#sub as_struct {
#    my $self = shift;
#    ${$self};
#}
#
#sub langprop {
#    my $self = shift;
#    my $opts;
#    if (ref($_[0]) eq 'HASH') {
#        $opts = shift;
#    } else {
#        $opts = {};
#    }
#    my $prop = shift;
#
#    my $deflang = ${$self}->{default_lang} // "en_US";
#    my $olang   = $opts->{lang} || $ENV{LANGUAGE} || $ENV{LANG} || $deflang;
#    $olang =~ s/\W.+//; 
#    $olang = "en_US" if $olang eq 'C';
#    (my $olang2 = $olang) =~ s/\A([a-z]{2})_[A-Z]{2}\z/$1/; 
#    my $mark    = $opts->{mark_different_lang} // 1;
#
#    my @k;
#    if ($olang eq $deflang) {
#        @k = ([$olang, $prop, 0]);
#    } else {
#        @k = (
#            [$olang, "$prop.alt.lang.$olang", 0],
#            ([$olang2, "$prop.alt.lang.$olang2", 0]) x !!($olang2 ne $olang),
#            [$deflang, $prop, $mark],
#        );
#    }
#
#    my $v;
#  GET:
#    for my $k (@k) {
#        $v = ${$self}->{$k->[1]};
#        if (defined $v) {
#            if ($k->[2]) {
#                my $has_nl = $v =~ s/\n\z//;
#                $v = "{$olang|$k->[0] $v}" . ($has_nl ? "\n" : "");
#            }
#            $v = __trim_blank_lines($v);
#            last GET;
#        }
#    }
#
#    if (@_) {
#        ${$self}->{$k[0][1]} = $_[0];
#    }
#
#    $v;
#}
#
#sub name {
#    my $self = shift;
#    my $opts;
#    if (@_ && ref($_[0]) eq 'HASH') {
#        $opts = shift;
#    } else {
#        $opts = {};
#    }
#    $self->langprop($opts, "name", @_);
#}
#
#sub caption {
#    my $self = shift;
#    my $opts;
#    if (@_ && ref($_[0]) eq 'HASH') {
#        $opts = shift;
#    } else {
#        $opts = {};
#    }
#    $self->langprop($opts, "caption", @_);
#}
#
#sub summary {
#    my $self = shift;
#    my $opts;
#    if (@_ && ref($_[0]) eq 'HASH') {
#        $opts = shift;
#    } else {
#        $opts = {};
#    }
#    $self->langprop($opts, "summary", @_);
#}
#
#sub description {
#    my $self = shift;
#    my $opts;
#    if (@_ && ref($_[0]) eq 'HASH') {
#        $opts = shift;
#    } else {
#        $opts = {};
#    }
#    $self->langprop($opts, "description", @_);
#}
#
#1;
#
#__END__
#
### Perinci/Object/Package.pm ###
#package Perinci::Object::Package;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use parent qw(Perinci::Object::Metadata);
#
#sub type { "package" }
#
#1;
#
#__END__
#
### Perinci/Object/ResMeta.pm ###
#package Perinci::Object::ResMeta;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use parent qw(Perinci::Object::Metadata);
#
#sub type { "resmeta" }
#
#1;
#
#__END__
#
### Perinci/Object/Variable.pm ###
#package Perinci::Object::Variable;
#
#our $DATE = '2018-10-18'; 
#our $VERSION = '0.310'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use parent qw(Perinci::Object::Metadata);
#
#sub type { "variable" }
#
#1;
#
#__END__
#
### Perinci/Result/Format/Lite.pm ###
#package Perinci::Result::Format::Lite;
#
#our $DATE = '2018-07-04'; 
#our $VERSION = '0.274'; 
#
#use 5.010001;
#
#use List::Util qw(first max);
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(format);
#
#sub firstidx (&@) {
#    my $f = shift;
#    foreach my $i ( 0 .. $#_ )
#        {
#            local *_ = \$_[$i];
#            return $i if $f->();
#        }
#    return -1;
#}
#
#sub _json {
#    state $json = do {
#        if    (eval { require Cpanel::JSON::XS; 1 })   { Cpanel::JSON::XS->new->canonical(1)->convert_blessed->allow_nonref }
#        elsif (eval { require JSON::Tiny::Subclassable; 1 }) { JSON::Tiny::Subclassable->new }
#        elsif (eval { require JSON::PP; 1 })   { JSON::PP->new->canonical(1)->convert_blessed->allow_nonref }
#        else { die "Can't find any JSON module" }
#    };
#    $json;
#};
#
#sub __cleanse {
#    state $cleanser = do {
#        eval { require Data::Clean::JSON; 1 };
#        if ($@) {
#            undef;
#        } else {
#            Data::Clean::JSON->get_cleanser;
#        }
#    };
#    if ($cleanser) {
#        $cleanser->clean_in_place($_[0]);
#    } else {
#        $_[0];
#    }
#}
#
#sub __gen_table {
#    my ($data, $header_row, $resmeta, $format) = @_;
#
#    $resmeta //= {};
#
#    my @columns;
#    if ($header_row) {
#        @columns = @{$data->[0]};
#    } else {
#        @columns = map {"col$_"} 0..@{$data->[0]}-1;
#    }
#
#    my $column_orders; 
#  SET_COLUMN_ORDERS: {
#
#        my $tcos;
#        if ($ENV{FORMAT_PRETTY_TABLE_COLUMN_ORDERS}) {
#            $tcos = _json->encode($ENV{FORMAT_PRETTY_TABLE_COLUMN_ORDERS});
#        } elsif (my $rfos = ($resmeta->{'cmdline.format_options'} //
#                                 $resmeta->{format_options})) {
#            my $rfo = $rfos->{'text-pretty'} // $rfos->{text} // $rfos->{any};
#            if ($rfo) {
#                $tcos = $rfo->{table_column_orders};
#            }
#        }
#        if ($tcos) {
#          COLS:
#            for my $cols (@$tcos) {
#                for my $col (@$cols) {
#                    next COLS unless first {$_ eq $col} @columns;
#                }
#                $column_orders = $cols;
#                last SET_COLUMN_ORDERS;
#            }
#        }
#
#        if ($resmeta->{'table.field_orders'}) {
#            $column_orders = $resmeta->{'table.field_orders'};
#            last SET_COLUMN_ORDERS;
#        }
#
#        $column_orders = $resmeta->{'table.fields'};
#    }
#
#    if ($column_orders) {
#        require Sort::BySpec;
#        my $cmp = Sort::BySpec::cmp_by_spec(spec => $column_orders);
#        my @map0 = sort { $cmp->($a->[1], $b->[1]) }
#            map {[$_, $columns[$_]]} 0..$#columns;
#        my @map;
#        for (0..$#map0) {
#            $map[$_] = $map0[$_][0];
#        }
#        my $newdata = [];
#        for my $row (@$data) {
#            my @newrow;
#            for (0..$#map) { $newrow[$_] = $row->[$map[$_]] }
#            push @$newdata, \@newrow;
#        }
#        $data = $newdata;
#        my @newcolumns;
#        for (@map) { push @newcolumns, $columns[$_] }
#        @columns = @newcolumns;
#    }
#
#    my @field_idxs; 
#    {
#        my $tff = $resmeta->{'table.fields'} or last;
#        for my $i (0..$#columns) {
#            $field_idxs[$i] = firstidx { $_ eq $columns[$i] } @$tff;
#        }
#    }
#
#    {
#        last unless $header_row && @$data;
#        my $tff = $resmeta->{'table.fields'} or last;
#        my $tfl = $resmeta->{'table.field_labels'};
#        my $tfu = $resmeta->{'table.field_units'};
#        for my $i (0..$#columns) {
#            my $field_idx = $field_idxs[$i];
#            next unless $field_idx >= 0;
#            if ($tfl && defined $tfl->[$field_idx]) {
#                $data->[0][$i] = $tfl->[$field_idx];
#            } elsif ($tfu && defined $tfu->[$field_idx]) {
#                $data->[0][$i] .= " ($tfu->[$field_idx])";
#            }
#        }
#    }
#
#  FORMAT_CELLS:
#    {
#        my $tffmt         = $resmeta->{'table.field_formats'};
#        my $tffmt_code    = $resmeta->{'table.field_format_code'};
#        my $tffmt_default = $resmeta->{'table.default_field_format'};
#        last unless $tffmt || $tffmt_code || $tffmt_default;
#
#        my (@fmt_names, @fmt_opts); 
#        for my $i (0..$#columns) {
#            my $field_idx = $field_idxs[$i];
#            my $fmt = $tffmt_code ? $tffmt_code->($columns[$i]) : undef;
#            $fmt //= $tffmt->[$field_idx] if $field_idx >= 0;
#            $fmt //= $tffmt_default;
#            if (ref $fmt eq 'ARRAY') {
#                $fmt_names[$i] = $fmt->[0];
#                $fmt_opts [$i] = $fmt->[1] // {};
#            } else {
#                $fmt_names[$i] = $fmt;
#                $fmt_opts [$i] = {};
#            }
#        }
#
#        my $nf;
#
#        for my $i (0..$#{$data}) {
#            next if $i==0 && $header_row;
#            my $row = $data->[$i];
#            for my $j (0..$#columns) {
#                next unless defined $row->[$j];
#                my $fmt_name = $fmt_names[$j];
#                next unless $fmt_name;
#                my $fmt_opts = $fmt_opts [$j];
#                if ($fmt_name eq 'iso8601_datetime' || $fmt_name eq 'iso8601_date') {
#                    if ($row->[$j] =~ /\A[0-9]+(\.[0-9]*)?\z/) {
#                        my $frac = $1 ? "0$1"+0 : 0;
#                        my @t = gmtime($row->[$j]);
#                        if ($fmt_name eq 'iso8601_datetime') {
#                            $row->[$j] = sprintf(
#                                "%04d-%02d-%02dT%02d:%02d:".($frac ? "%06.3f" : "%02d")."Z",
#                                $t[5]+1900, $t[4]+1, $t[3], $t[2], $t[1], $t[0]+$frac);
#                        } else {
#                            $row->[$j] = sprintf(
#                                "%04d-%02d-%02d",
#                                $t[5]+1900, $t[4]+1, $t[3]);
#                        }
#                    }
#                } elsif ($fmt_name eq 'boolstr') {
#                    $row->[$j] = $row->[$j] ? "yes" : "no";
#                } elsif ($fmt_name eq 'sci2dec') {
#                    if ($row->[$j] =~ /\A(?:[+-]?)(?:\d+\.|\d*\.(\d+))[eE]([+-]?\d+)\z/) {
#                        my $n = length($1 || "") - $2; $n = 0 if $n < 0;
#                        $row->[$j] = sprintf("%.${n}f", $row->[$j]);
#                    }
#                } elsif ($fmt_name eq 'percent') {
#                    my $fmt = $fmt_opts->{sprintf} // '%.2f%%';
#                    $row->[$j] = sprintf($fmt, $row->[$j] * 100);
#                } elsif ($fmt_name eq 'number') {
#                    require Number::Format::BigFloat;
#                    $row->[$j] = Number::Format::BigFloat::format_number(
#                        $row->[$j], {
#                            thousands_sep  => $fmt_opts->{thousands_sep} // ',',
#                            decimal_point  => $fmt_opts->{decimal_point} // '.',
#                            decimal_digits => $fmt_opts->{precision} // 0,
#                        });
#                }
#            }
#        }
#    }
#
#    if ($format eq 'text-pretty') {
#      ALIGN_COLUMNS:
#        {
#            no warnings;
#
#            my $tfa         = $resmeta->{'table.field_aligns'};
#            my $tfa_code    = $resmeta->{'table.field_align_code'};
#            my $tfa_default = $resmeta->{'table.default_field_align'};
#            last unless $tfa || $tfa_code || $tfa_default;
#            last unless @$data;
#
#            for my $colidx (0..$#columns) {
#                my $field_idx = $field_idxs[$colidx];
#                my $align = $tfa_code ? $tfa_code->($columns[$colidx]) : undef;
#                $align //= $tfa->[$field_idx] if $field_idx >= 0;
#                $align //= $tfa_default;
#                next unless $align;
#
#                my $maxw;
#                my ($maxw_bd, $maxw_d, $maxw_ad); 
#                if ($align eq 'number') {
#                    my (@w_bd, @w_d, @w_ad);
#                    for my $i (0..$#{$data}) {
#                        my $row = $data->[$i];
#                        if (@$row > $colidx) {
#                            my $cell = $row->[$colidx];
#                            if ($header_row && $i == 0) {
#                                my $w = length($cell);
#                                push @w_bd, 0;
#                                push @w_bd, 0;
#                                push @w_ad, 0;
#                            } elsif ($cell =~ /\A([+-]?\d+)(\.?)(\d*)\z/) {
#                                push @w_bd, length($1);
#                                push @w_d , length($2);
#                                push @w_ad, length($3);
#                            } elsif ($cell =~ /\A([+-]?\d+\.?\d*)([eE])([+-]?\d+)\z/) {
#                                push @w_bd, length($1);
#                                push @w_d , length($2);
#                                push @w_ad, length($3);
#                            } else {
#                                push @w_bd, length($cell);
#                                push @w_bd, 0;
#                                push @w_ad, 0;
#                            }
#                        } else {
#                            push @w_bd, 0;
#                            push @w_d , 0;
#                            push @w_ad, 0;
#                        }
#                    }
#                    $maxw_bd = max(@w_bd);
#                    $maxw_d  = max(@w_d);
#                    $maxw_ad = max(@w_ad);
#                    if ($header_row) {
#                        my $w = length($data->[0][$colidx]);
#                        if ($maxw_d == 0 && $maxw_ad == 0) {
#                            $maxw_bd = $w;
#                        }
#                    }
#                }
#
#                $maxw = max(map {
#                    @$_ > $colidx ? length($_->[$colidx]) : 0
#                } @$data);
#
#                for my $i (0..$#{$data}) {
#                    my $row = $data->[$i];
#                    for my $i (0..$#{$data}) {
#                        my $row = $data->[$i];
#                        next unless @$row > $colidx;
#                        my $cell = $row->[$colidx];
#                        next unless defined($cell);
#                        if ($align eq 'number') {
#                            my ($bd, $d, $ad);
#                            if ($header_row && $i == 0) {
#                            } elsif (($bd, $d, $ad) = $cell =~ /\A([+-]?\d+)(\.?)(\d*)\z/) {
#                                $cell = join(
#                                    '',
#                                    (' ' x ($maxw_bd - length($bd))), $bd,
#                                    $d , (' ' x ($maxw_d  - length($d ))),
#                                    $ad, (' ' x ($maxw_ad - length($ad))),
#                                );
#                            } elsif (($bd, $d, $ad) = $cell =~ /\A([+-]?\d+\.?\d*)([eE])([+-]?\d+)\z/) {
#                                $cell = join(
#                                    '',
#                                    (' ' x ($maxw_bd - length($bd))), $bd,
#                                    $d , (' ' x ($maxw_d  - length($d ))),
#                                    $ad, (' ' x ($maxw_ad - length($ad))),
#                                );
#                            }
#                            my $w = length($cell);
#                            $cell = (' ' x ($maxw - $w)) . $cell
#                                if $maxw > $w;
#                        } elsif ($align eq 'right') {
#                            $cell = (' ' x ($maxw - length($cell))) . $cell;
#                        } elsif ($align eq 'middle' || $align eq 'center') {
#                            my $w = length($cell);
#                            my $n = int(($maxw-$w)/2);
#                            $cell = (' ' x $n) . $cell . (' ' x ($maxw-$w-$n));
#                        } else {
#                            $cell .= (' ' x ($maxw - length($cell)));
#
#                        }
#                        $row->[$colidx] = $cell;
#                    }
#                }
#            } 
#        } 
#
#        my $fres;
#        if (my $backend = $ENV{FORMAT_PRETTY_TABLE_BACKEND}) {
#            require Text::Table::Any;
#            $fres = Text::Table::Any::table(rows=>$data, header_row=>$header_row, backend=>$backend);
#        } else {
#            require Text::Table::Tiny;
#            $fres = Text::Table::Tiny::table(rows=>$data, header_row=>$header_row);
#        }
#        $fres .= "\n" unless $fres =~ /\R\z/ || !length($fres);
#        $fres;
#    } elsif ($format eq 'csv') {
#        no warnings 'uninitialized';
#        join(
#            "",
#            map {
#                my $row = $_;
#                join(
#                    ",",
#                    map {
#                        my $cell = $_;
#                        $cell =~ s/(["\\])/\\$1/g;
#                        qq("$cell");
#                    } @$row)."\n";
#            } @$data
#        );
#    } elsif ($format eq 'html') {
#        no warnings 'uninitialized';
#        require HTML::Entities;
#
#        my $tfa = $resmeta->{'table.field_aligns'};
#
#        my @res;
#        push @res, "<table".($resmeta->{'table.html_class'} ?
#                                 " class=\"".HTML::Entities::encode_entities(
#                                     $resmeta->{'table.html_class'})."\"" : "").
#                                         ">\n";
#        for my $i (0..$#{$data}) {
#            my $data_elem = $i == 0 ? "th" : "td";
#            push @res, "<thead>\n" if $i == 0;
#            push @res, "<tbody>\n" if $i == 1;
#            push @res, " <tr>\n";
#            my $row = $data->[$i];
#            for my $j (0..$#{$row}) {
#                my $field_idx = $field_idxs[$j];
#                my $align;
#                if ($field_idx >= 0 && $tfa->[$field_idx]) {
#                    $align = $tfa->[$field_idx];
#                    $align = "right" if $align eq 'number';
#                    $align = "middle" if $align eq 'center';
#                }
#                push @res, "  <$data_elem",
#                    ($align ? " align=\"$align\"" : ""),
#                    ">", HTML::Entities::encode_entities($row->[$j]),
#                    "</$data_elem>\n";
#            }
#            push @res, " </tr>\n";
#            push @res, "</thead>\n" if $i == 0;
#        }
#        push @res, "</tbody>\n";
#        push @res, "</table>\n";
#        join '', @res;
#    } else {
#        no warnings 'uninitialized';
#        shift @$data if $header_row;
#        join("", map {join("\t", @$_)."\n"} @$data);
#    }
#}
#
#sub format {
#    my ($res, $format, $is_naked, $cleanse) = @_;
#
#    if ($format =~ /\A(text|text-simple|text-pretty|csv|html)\z/) {
#        $format = $format eq 'text' ?
#            ((-t STDOUT) ? 'text-pretty' : 'text-simple') : $format;
#        no warnings 'uninitialized';
#        if ($res->[0] !~ /^(2|304)/) {
#            my $fres = "ERROR $res->[0]: $res->[1]";
#            if (my $prev = $res->[3]{prev}) {
#                $fres .= " ($prev->[0]: $prev->[1])";
#            }
#            return "$fres\n";
#        } elsif ($res->[3] && $res->[3]{"x.hint.result_binary"}) {
#            return $res->[2];
#        } else {
#            require Data::Check::Structure;
#            my $data = $res->[2];
#            my $max = 5;
#            if (!ref($data)) {
#                $data //= "";
#                $data .= "\n" unless !length($data) || $data =~ /\n\z/;
#                return $data;
#            } elsif (ref($data) eq 'ARRAY' && !@$data) {
#                return "";
#            } elsif (Data::Check::Structure::is_aos($data, {max=>$max})) {
#                return join("", map {"$_\n"} @$data);
#            } elsif (Data::Check::Structure::is_aoaos($data, {max=>$max})) {
#                my $header_row = 0;
#                my $data = $data;
#                if ($res->[3]{'table.fields'}) {
#                    $data = [$res->[3]{'table.fields'}, @$data];
#                    $header_row = 1;
#                }
#                return __gen_table($data, $header_row, $res->[3], $format);
#            } elsif (Data::Check::Structure::is_hos($data, {max=>$max})) {
#                $data = [map {[$_, $data->{$_}]} sort keys %$data];
#                unshift @$data, ["key", "value"];
#                return __gen_table($data, 1, $res->[3], $format);
#            } elsif (Data::Check::Structure::is_aohos($data, {max=>$max})) {
#                my @fieldnames;
#                if ($res->[3] && $res->[3]{'table.fields'} &&
#                        $res->[3]{'table.hide_unknown_fields'}) {
#                    @fieldnames = @{ $res->[3]{'table.fields'} };
#                } else {
#                    my %fieldnames;
#                    for my $row (@$data) {
#                        $fieldnames{$_}++ for keys %$row;
#                    }
#                    @fieldnames = sort keys %fieldnames;
#                }
#                my $newdata = [];
#                for my $row (@$data) {
#                    push @$newdata, [map {$row->{$_}} @fieldnames];
#                }
#                unshift @$newdata, \@fieldnames;
#                return __gen_table($newdata, 1, $res->[3], $format);
#            } else {
#                $format = 'json-pretty';
#            }
#        }
#    }
#
#    my $tff = $res->[3]{'table.fields'};
#    $res = $res->[2] if $is_naked;
#
#    if ($format eq 'perl') {
#        my $use_color = $ENV{COLOR} // (-t STDOUT);
#        if ($use_color && eval { require Data::Dump::Color; 1 }) {
#            return Data::Dump::Color::dump($res);
#        } elsif (eval { require Data::Dump; 1 }) {
#            return Data::Dump::dump($res);
#        } else {
#            no warnings 'once';
#            require Data::Dumper;
#            local $Data::Dumper::Terse = 1;
#            local $Data::Dumper::Indent = 1;
#            local $Data::Dumper::Useqq = 1;
#            local $Data::Dumper::Deparse = 1;
#            local $Data::Dumper::Quotekeys = 0;
#            local $Data::Dumper::Sortkeys = 1;
#            local $Data::Dumper::Trailingcomma = 1;
#            return Data::Dumper::Dumper($res);
#        }
#    }
#
#    unless ($format =~ /\Ajson(-pretty)?\z/) {
#        warn "Unknown format '$format', fallback to json-pretty";
#        $format = 'json-pretty';
#    }
#    __cleanse($res) if ($cleanse//1);
#    if ($format =~ /json/) {
#        if ($tff && _json->can("sort_by") &&
#                eval { require Sort::ByExample; 1}) {
#            my $cmp = Sort::ByExample->cmp($tff);
#            _json->sort_by(sub { $cmp->($JSON::PP::a, $JSON::PP::b) });
#        }
#
#        if ($format eq 'json') {
#            return _json->encode($res) . "\n";
#        } else {
#            _json->pretty(1);
#            return _json->encode($res);
#        }
#    }
#}
#
#1;
#
#__END__
#
### Perinci/Sub/Complete.pm ###
#package Perinci::Sub::Complete;
#
#our $DATE = '2019-02-14'; 
#our $VERSION = '0.932'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Log::ger;
#
#use Complete::Util qw(hashify_answer complete_array_elem complete_hash_key combine_answers modify_answer);
#use Complete::Common qw(:all);
#use Perinci::Sub::Util qw(gen_modified_sub);
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       complete_from_schema
#                       complete_arg_val
#                       complete_arg_index
#                       complete_arg_elem
#                       complete_cli_arg
#               );
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Complete command-line argument using Rinci metadata',
#};
#
#my %common_args_riap = (
#    riap_client => {
#        summary => 'Optional, to perform complete_arg_val to the server',
#        schema  => 'obj*',
#        description => <<'_',
#
#When the argument spec in the Rinci metadata contains `completion` key, this
#means there is custom completion code for that argument. However, if retrieved
#from a remote server, sometimes the `completion` key no longer contains the code
#(it has been cleansed into a string). Moreover, the completion code needs to run
#on the server.
#
#If supplied this argument and te `riap_server_url` argument, the function will
#try to request to the server (via Riap request `complete_arg_val`). Otherwise,
#the function will just give up/decline completing.
#
#_
#        },
#    riap_server_url => {
#        summary => 'Optional, to perform complete_arg_val to the server',
#        schema  => 'str*',
#        description => <<'_',
#
#See the `riap_client` argument.
#
#_
#    },
#    riap_uri => {
#        summary => 'Optional, to perform complete_arg_val to the server',
#        schema  => 'str*',
#        description => <<'_',
#
#See the `riap_client` argument.
#
#_
#    },
#);
#
#$SPEC{complete_from_schema} = {
#    v => 1.1,
#    summary => 'Complete a value from schema',
#    description => <<'_',
#
#Employ some heuristics to complete a value from Sah schema. For example, if
#schema is `[str => in => [qw/new open resolved rejected/]]`, then we can
#complete from the `in` clause. Or for something like `[int => between => [1,
#20]]` we can complete using values from 1 to 20.
#
#_
#    args => {
#        schema => {
#            summary => 'Must be normalized',
#            req => 1,
#        },
#        word => {
#            schema => [str => default => ''],
#            req => 1,
#        },
#    },
#};
#sub complete_from_schema {
#    my %args = @_;
#    my $sch  = $args{schema}; 
#    my $word = $args{word} // "";
#
#    my $fres;
#    log_trace("[comp][periscomp] entering complete_from_schema, word=<%s>, schema=%s", $word, $sch);
#
#    my ($type, $cs) = @{$sch};
#
#    unless ($type =~ /\A(all|any|array|bool|buf|cistr|code|date|duration|float|hash|int|num|obj|re|str|undef)\z/) {
#        no strict 'refs';
#        my $pkg = "Sah::SchemaR::$type";
#        (my $pkg_pm = "$pkg.pm") =~ s!::!/!g;
#        eval { require $pkg_pm; 1 };
#        if ($@) {
#            log_trace("[comp][periscomp] couldn't load schema module %s: %s, skipped", $pkg, $@);
#            goto RETURN_RES;
#        }
#        my $rsch = ${"$pkg\::rschema"};
#        $type = $rsch->[0];
#        $cs = {};
#        for my $cs0 (@{ $rsch->[1] // [] }) {
#            for (keys %$cs0) {
#                $cs->{$_} = $cs0->{$_};
#            }
#        }
#        log_trace("[comp][periscomp] retrieving schema from module %s, base type=%s", $pkg, $type);
#    }
#
#    my $static;
#    my $words;
#    eval {
#        if (my $xcomp = $cs->{'x.completion'}) {
#            require Module::Installed::Tiny;
#            my $comp;
#            if (ref($xcomp) eq 'CODE') {
#                $comp = $xcomp;
#            } else {
#                my ($submod, $xcargs);
#                if (ref($xcomp) eq 'ARRAY') {
#                    $submod = $xcomp->[0];
#                    $xcargs = $xcomp->[1];
#                } else {
#                    $submod = $xcomp;
#                    $xcargs = {};
#                }
#                my $mod = "Perinci::Sub::XCompletion::$submod";
#                if (Module::Installed::Tiny::module_installed($mod)) {
#                    log_trace("[comp][periscomp] loading module %s ...", $mod);
#                    my $mod_pm = $mod; $mod_pm =~ s!::!/!g; $mod_pm .= ".pm";
#                    require $mod_pm;
#                    my $fref = \&{"$mod\::gen_completion"};
#                    log_trace("[comp][periscomp] invoking %s's gen_completion(%s) ...", $mod, $xcargs);
#                    $comp = $fref->(%$xcargs);
#                } else {
#                    log_trace("[comp][periscomp] module %s is not installed, skipped", $mod);
#                }
#            }
#            if ($comp) {
#                log_trace("[comp][periscomp] using arg completion routine from schema's 'x.completion' attribute");
#                $fres = $comp->(
#                    %{$args{extras} // {}},
#                    word=>$word, arg=>$args{arg}, args=>$args{args});
#                return; 
#                }
#            }
#
#        if ($cs->{is} && !ref($cs->{is})) {
#            log_trace("[comp][periscomp] adding completion from schema's 'is' clause");
#            push @$words, $cs->{is};
#            $static++;
#            return; 
#        }
#        if ($cs->{in}) {
#            log_trace("[comp][periscomp] adding completion from schema's 'in' clause");
#            push @$words, grep {!ref($_)} @{ $cs->{in} };
#            $static++;
#            return; 
#        }
#        if ($type eq 'any') {
#            require Data::Sah::Normalize;
#            if ($cs->{of} && @{ $cs->{of} }) {
#                $fres = combine_answers(
#                    grep { defined } map {
#                        complete_from_schema(
#                            schema=>Data::Sah::Normalize::normalize_schema($_),
#                            word => $word,
#                        )
#                    } @{ $cs->{of} }
#                );
#                goto RETURN_RES; 
#            }
#        }
#        if ($type eq 'bool') {
#            log_trace("[comp][periscomp] adding completion from possible values of bool");
#            push @$words, 0, 1;
#            $static++;
#            return; 
#        }
#        if ($type eq 'int') {
#            my $limit = 100;
#            if ($cs->{between} &&
#                    $cs->{between}[0] - $cs->{between}[0] <= $limit) {
#                log_trace("[comp][periscomp] adding completion from schema's 'between' clause");
#                push @$words, $cs->{between}[0] .. $cs->{between}[1];
#                $static++;
#            } elsif ($cs->{xbetween} &&
#                         $cs->{xbetween}[0] - $cs->{xbetween}[0] <= $limit) {
#                log_trace("[comp][periscomp] adding completion from schema's 'xbetween' clause");
#                push @$words, $cs->{xbetween}[0]+1 .. $cs->{xbetween}[1]-1;
#                $static++;
#            } elsif (defined($cs->{min}) && defined($cs->{max}) &&
#                         $cs->{max}-$cs->{min} <= $limit) {
#                log_trace("[comp][periscomp] adding completion from schema's 'min' & 'max' clauses");
#                push @$words, $cs->{min} .. $cs->{max};
#                $static++;
#            } elsif (defined($cs->{min}) && defined($cs->{xmax}) &&
#                         $cs->{xmax}-$cs->{min} <= $limit) {
#                log_trace("[comp][periscomp] adding completion from schema's 'min' & 'xmax' clauses");
#                push @$words, $cs->{min} .. $cs->{xmax}-1;
#                $static++;
#            } elsif (defined($cs->{xmin}) && defined($cs->{max}) &&
#                         $cs->{max}-$cs->{xmin} <= $limit) {
#                log_trace("[comp][periscomp] adding completion from schema's 'xmin' & 'max' clauses");
#                push @$words, $cs->{xmin}+1 .. $cs->{max};
#                $static++;
#            } elsif (defined($cs->{xmin}) && defined($cs->{xmax}) &&
#                         $cs->{xmax}-$cs->{xmin} <= $limit) {
#                log_trace("[comp][periscomp] adding completion from schema's 'xmin' & 'xmax' clauses");
#                push @$words, $cs->{xmin}+1 .. $cs->{xmax}-1;
#                $static++;
#            } elsif (length($word) && $word !~ /\A-?\d*\z/) {
#                log_trace("[comp][periscomp] word not an int");
#                $words = [];
#            } else {
#                $words = [];
#                for my $sign ("", "-") {
#                    for ("", 0..9) {
#                        my $i = $sign . $word . $_;
#                        next unless length $i;
#                        next unless $i =~ /\A-?\d+\z/;
#                        next if $i eq '-0';
#                        next if $i =~ /\A-?0\d/;
#                        next if $cs->{between} &&
#                            ($i < $cs->{between}[0] ||
#                                 $i > $cs->{between}[1]);
#                        next if $cs->{xbetween} &&
#                            ($i <= $cs->{xbetween}[0] ||
#                                 $i >= $cs->{xbetween}[1]);
#                        next if defined($cs->{min} ) && $i <  $cs->{min};
#                        next if defined($cs->{xmin}) && $i <= $cs->{xmin};
#                        next if defined($cs->{max} ) && $i >  $cs->{max};
#                        next if defined($cs->{xmin}) && $i >= $cs->{xmax};
#                        push @$words, $i;
#                    }
#                }
#                $words = [sort @$words];
#            }
#            return; 
#        }
#        if ($type eq 'float') {
#            if (length($word) && $word !~ /\A-?\d*(\.\d*)?\z/) {
#                log_trace("[comp][periscomp] word not a float");
#                $words = [];
#            } else {
#                $words = [];
#                for my $sig ("", "-") {
#                    for ("", 0..9,
#                         ".0",".1",".2",".3",".4",".5",".6",".7",".8",".9") {
#                        my $f = $sig . $word . $_;
#                        next unless length $f;
#                        next unless $f =~ /\A-?\d+(\.\d+)?\z/;
#                        next if $f eq '-0';
#                        next if $f =~ /\A-?0\d\z/;
#                        next if $cs->{between} &&
#                            ($f < $cs->{between}[0] ||
#                                 $f > $cs->{between}[1]);
#                        next if $cs->{xbetween} &&
#                            ($f <= $cs->{xbetween}[0] ||
#                                 $f >= $cs->{xbetween}[1]);
#                        next if defined($cs->{min} ) && $f <  $cs->{min};
#                        next if defined($cs->{xmin}) && $f <= $cs->{xmin};
#                        next if defined($cs->{max} ) && $f >  $cs->{max};
#                        next if defined($cs->{xmin}) && $f >= $cs->{xmax};
#                        push @$words, $f;
#                    }
#                }
#            }
#            return; 
#        }
#    }; 
#
#    log_trace("[periscomp] complete_from_schema died: %s", $@) if $@;
#
#    goto RETURN_RES unless $words;
#    $fres = hashify_answer(
#        complete_array_elem(array=>$words, word=>$word),
#        {static=>$static && $word eq '' ? 1:0},
#    );
#
#  RETURN_RES:
#    log_trace("[comp][periscomp] leaving complete_from_schema, result=%s", $fres);
#    $fres;
#}
#
#$SPEC{complete_arg_val} = {
#    v => 1.1,
#    summary => 'Given argument name and function metadata, complete value',
#    description => <<'_',
#
#Will attempt to complete using the completion routine specified in the argument
#specification (the `completion` property, or in the case of `complete_arg_elem`
#function, the `element_completion` property), or if that is not specified, from
#argument's schema using `complete_from_schema`.
#
#Completion routine will get `%args`, with the following keys:
#
#* `word` (str, the word to be completed)
#* `arg` (str, the argument name which value is currently being completed)
#* `index (int, only for the `complete_arg_elem` function, the index in the
#   argument array that is currently being completed, starts from 0)
#* `args` (hash, the argument hash to the function, so far)
#
#as well as extra keys from `extras` (but these won't overwrite the above
#standard keys).
#
#Completion routine should return a completion answer structure (described in
#<pm:Complete>) which is either a hash or an array. The simplest form of answer
#is just to return an array of strings. Completion routine can also return undef
#to express declination.
#
#_
#    args => {
#        meta => {
#            summary => 'Rinci function metadata, must be normalized',
#            schema => 'hash*',
#            req => 1,
#        },
#        arg => {
#            summary => 'Argument name',
#            schema => 'str*',
#            req => 1,
#        },
#        word => {
#            summary => 'Word to be completed',
#            schema => ['str*', default => ''],
#        },
#        args => {
#            summary => 'Collected arguments so far, '.
#                'will be passed to completion routines',
#            schema  => 'hash',
#        },
#        extras => {
#            summary => 'Add extra arguments to completion routine',
#            schema  => 'hash',
#            description => <<'_',
#
#The keys from this `extras` hash will be merged into the final `%args` passed to
#completion routines. Note that standard keys like `word`, `cword`, and so on as
#described in the function description will not be overwritten by this.
#
#_
#        },
#
#        %common_args_riap,
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array', 
#    },
#};
#sub complete_arg_val {
#    my %args = @_;
#
#    log_trace("[comp][periscomp] entering complete_arg_val, arg=<%s>", $args{arg});
#    my $fres;
#
#    my $extras = $args{extras} // {};
#
#    my $meta = $args{meta} or do {
#        log_trace("[comp][periscomp] meta is not supplied, declining");
#        goto RETURN_RES;
#    };
#    my $arg  = $args{arg} or do {
#        log_trace("[comp][periscomp] arg is not supplied, declining");
#        goto RETURN_RES;
#    };
#    my $word = $args{word} // '';
#
#
#    my $args_prop = $meta->{args} // {};
#    my $arg_spec = $args_prop->{$arg} or do {
#        log_trace("[comp][periscomp] arg '$arg' is not specified in meta, declining");
#        goto RETURN_RES;
#    };
#
#    my $static;
#    eval { 
#
#        my $comp;
#      GET_COMP_ROUTINE:
#        {
#            $comp = $arg_spec->{completion};
#            if ($comp) {
#                log_trace("[comp][periscomp] using arg completion routine from arg spec's 'completion' property");
#                last GET_COMP_ROUTINE;
#            }
#            my $xcomp = $arg_spec->{'x.completion'};
#            if ($xcomp) {
#                if (ref($xcomp) eq 'CODE') {
#                    $comp = $xcomp;
#                } else {
#                    my ($submod, $xcargs);
#                    if (ref($xcomp) eq 'ARRAY') {
#                        $submod = $xcomp->[0];
#                        $xcargs = $xcomp->[1];
#                    } else {
#                        $submod = $xcomp;
#                        $xcargs = {};
#                    }
#                    my $mod = "Perinci::Sub::XCompletion::$submod";
#                    require Module::Installed::Tiny;
#                    if (Module::Installed::Tiny::module_installed($mod)) {
#                        log_trace("[comp][periscomp] loading module %s ...", $mod);
#                        my $mod_pm = $mod; $mod_pm =~ s!::!/!g; $mod_pm .= ".pm";
#                        require $mod_pm;
#                        my $fref = \&{"$mod\::gen_completion"};
#                        log_trace("[comp][periscomp] invoking gen_completion() from %s ...", $mod);
#                        $comp = $fref->(%$xcargs);
#                    } else {
#                        log_trace("[comp][periscomp] module %s is not installed, skipped", $mod);
#                    }
#                }
#                if ($comp) {
#                    log_trace("[comp][periscomp] using arg completion routine from arg spec's 'x.completion' attribute");
#                    last GET_COMP_ROUTINE;
#                }
#            }
#            my $ent = $arg_spec->{'x.schema.entity'};
#            if ($ent) {
#                require Module::Installed::Tiny;
#                my $mod = "Perinci::Sub::ArgEntity::$ent";
#                if (Module::Installed::Tiny::module_installed($mod)) {
#                    log_trace("[comp][periscomp] loading module %s ...", $mod);
#                    my $mod_pm = $mod; $mod_pm =~ s!::!/!g; $mod_pm .= ".pm";
#                    require $mod_pm;
#                    if (defined &{"$mod\::complete_arg_val"}) {
#                        log_trace("[comp][periscomp] invoking complete_arg_val() from %s ...", $mod);
#                        $comp = \&{"$mod\::complete_arg_val"};
#                        last GET_COMP_ROUTINE;
#                    } else {
#                        log_trace("[comp][periscomp] module %s doesn't define complete_arg_val(), skipped", $mod);
#                    }
#                } else {
#                    log_trace("[comp][periscomp] module %s not installed, skipped", $mod);
#                }
#            }
#        } 
#
#        if ($comp) {
#            if (ref($comp) eq 'CODE') {
#                log_trace("[comp][periscomp] invoking arg completion routine");
#                $fres = $comp->(
#                    %$extras,
#                    word=>$word, arg=>$arg, args=>$args{args});
#                return; 
#            } elsif (ref($comp) eq 'ARRAY') {
#                log_trace("[comp][periscomp] using array specified in arg completion routine: %s", $comp);
#                $fres = complete_array_elem(array=>$comp, word=>$word);
#                $static++;
#                return; 
#            }
#
#            log_trace("[comp][periscomp] arg spec's 'completion' property is not a coderef or arrayref");
#            if ($args{riap_client} && $args{riap_server_url}) {
#                log_trace("[comp][periscomp] trying to perform complete_arg_val request to Riap server");
#                my $res = $args{riap_client}->request(
#                    complete_arg_val => $args{riap_server_url},
#                    {(uri=>$args{riap_uri}) x !!defined($args{riap_uri}),
#                     arg=>$arg, word=>$word},
#                );
#                if ($res->[0] != 200) {
#                    log_trace("[comp][periscomp] Riap request failed (%s), declining", $res);
#                    return; 
#                }
#                $fres = $res->[2];
#                return; 
#            }
#
#            log_trace("[comp][periscomp] declining");
#            return; 
#        }
#
#        my $fres_from_arg_examples;
#      COMPLETE_FROM_ARG_EXAMPLES:
#        {
#            my $eg = $arg_spec->{examples};
#            unless ($eg) {
#                log_trace("[comp][periscomp] arg spec does not specify examples");
#                last COMPLETE_FROM_ARG_EXAMPLES;
#            }
#            $fres_from_arg_examples = complete_array_elem(
#                word=>$word, array=>[map {ref $_ eq 'HASH' ? $_->{value} : $_} @$eg]);
#        } 
#
#        my $fres_from_schema;
#      COMPLETE_FROM_SCHEMA:
#        {
#            my $sch = $arg_spec->{schema};
#            unless ($sch) {
#                log_trace("[comp][periscomp] arg spec does not specify schema");
#                last COMPLETE_FROM_SCHEMA;
#            }
#            $fres_from_schema = complete_from_schema(arg=>$arg, extras=>$extras, schema=>$sch, word=>$word);
#        } 
#
#        $fres = combine_answers(grep {defined} (
#            $fres_from_arg_examples,
#            $fres_from_schema,
#        ));
#    };
#    log_debug("[comp][periscomp] completion died: $@") if $@;
#    unless ($fres) {
#        log_trace("[comp][periscomp] no completion from metadata possible, declining");
#        goto RETURN_RES;
#    }
#
#    $fres = hashify_answer($fres);
#    $fres->{static} //= $static && $word eq '' ? 1:0;
#  RETURN_RES:
#    log_trace("[comp][periscomp] leaving complete_arg_val, result=%s", $fres);
#    $fres;
#}
#
#gen_modified_sub(
#    output_name  => 'complete_arg_elem',
#    install_sub  => 0,
#    base_name    => 'complete_arg_val',
#    summary      => 'Given argument name and function metadata, '.
#        'complete array element',
#    add_args     => {
#        index => {
#            summary => 'Index of element to complete',
#            schema  => ['str*'],
#        },
#    },
#);
#sub complete_arg_elem {
#    require Data::Sah::Normalize;
#
#    my %args = @_;
#
#    my $fres;
#
#    log_trace("[comp][periscomp] entering complete_arg_elem, arg=<%s>, index=<%d>",
#                 $args{arg}, $args{index});
#
#    my $extras = $args{extras} // {};
#
#    my $ourextras = {arg=>$args{arg}, args=>$args{args}};
#
#    my $meta = $args{meta} or do {
#        log_trace("[comp][periscomp] meta is not supplied, declining");
#        goto RETURN_RES;
#    };
#    my $arg  = $args{arg} or do {
#        log_trace("[comp][periscomp] arg is not supplied, declining");
#        goto RETURN_RES;
#    };
#    defined(my $index = $args{index}) or do {
#        log_trace("[comp][periscomp] index is not supplied, declining");
#        goto RETURN_RES;
#    };
#    my $word = $args{word} // '';
#
#
#    my $args_prop = $meta->{args} // {};
#    my $arg_spec = $args_prop->{$arg} or do {
#        log_trace("[comp][periscomp] arg '$arg' is not specified in meta, declining");
#        goto RETURN_RES;
#    };
#
#    my $static;
#    eval { 
#
#        my $elcomp;
#      GET_ELCOMP_ROUTINE:
#        {
#            $elcomp = $arg_spec->{element_completion};
#            if ($elcomp) {
#                log_trace("[comp][periscomp] using arg element completion routine from 'element_completion' property");
#                last GET_ELCOMP_ROUTINE;
#            }
#            my $xelcomp = $arg_spec->{'x.element_completion'};
#            if ($xelcomp) {
#                if (ref($xelcomp) eq 'CODE') {
#                    $elcomp = $xelcomp;
#                } else {
#                    my ($submod, $xcargs);
#                    if (ref($xelcomp) eq 'ARRAY') {
#                        $submod = $xelcomp->[0];
#                        $xcargs = $xelcomp->[1];
#                    } else {
#                        $submod = $xelcomp;
#                        $xcargs = {};
#                    }
#                    my $mod = "Perinci::Sub::XCompletion::$submod";
#                    require Module::Installed::Tiny;
#                    if (Module::Installed::Tiny::module_installed($mod)) {
#                        log_trace("[comp][periscomp] loading module %s ...", $mod);
#                        my $mod_pm = $mod; $mod_pm =~ s!::!/!g; $mod_pm .= ".pm";
#                        require $mod_pm;
#                        my $fref = \&{"$mod\::gen_completion"};
#                        log_trace("[comp][periscomp] invoking gen_completion() from %s ...", $mod);
#                        $elcomp = $fref->(%$xcargs);
#                    } else {
#                        log_trace("[comp][periscomp] module %s is not installed, skipped", $mod);
#                    }
#                }
#                if ($elcomp) {
#                    log_trace("[comp][periscomp] using arg element completion routine from 'x.element_completion' attribute");
#                    last GET_ELCOMP_ROUTINE;
#                }
#            }
#            my $ent = $arg_spec->{'x.schema.element_entity'};
#            if ($ent) {
#                require Module::Installed::Tiny;
#                my $mod = "Perinci::Sub::ArgEntity::$ent";
#                if (Module::Installed::Tiny::module_installed($mod)) {
#                    log_trace("[comp][periscomp] loading module %s ...", $mod);
#                    my $mod_pm = $mod; $mod_pm =~ s!::!/!g; $mod_pm .= ".pm";
#                    require $mod_pm;
#                    if (defined &{"$mod\::complete_arg_val"}) {
#                        log_trace("[comp][periscomp] invoking complete_arg_val() from %s ...", $mod);
#                        $elcomp = \&{"$mod\::complete_arg_val"};
#                        last GET_ELCOMP_ROUTINE;
#                    } else {
#                        log_trace("[comp][periscomp] module %s doesn't defined complete_arg_val(), skipped", $mod);
#                    }
#                } else {
#                    log_trace("[comp][periscomp] module %s is not installed, skipped", $mod);
#                }
#            }
#        } 
#
#        $ourextras->{index} = $index;
#        if ($elcomp) {
#            if (ref($elcomp) eq 'CODE') {
#                log_trace("[comp][periscomp] invoking arg element completion routine");
#                $fres = $elcomp->(
#                    %$extras,
#                    %$ourextras,
#                    word=>$word);
#                return; 
#            } elsif (ref($elcomp) eq 'ARRAY') {
#                log_trace("[comp][periscomp] using array specified in arg element completion routine: %s", $elcomp);
#                $fres = complete_array_elem(array=>$elcomp, word=>$word);
#                $static = $word eq '';
#            }
#
#            log_trace("[comp][periscomp] arg spec's 'element_completion' property is not a coderef or ".
#                             "arrayref");
#            if ($args{riap_client} && $args{riap_server_url}) {
#                log_trace("[comp][periscomp] trying to perform complete_arg_elem request to Riap server");
#                my $res = $args{riap_client}->request(
#                    complete_arg_elem => $args{riap_server_url},
#                    {(uri=>$args{riap_uri}) x !!defined($args{riap_uri}),
#                     arg=>$arg, args=>$args{args}, word=>$word,
#                     index=>$index},
#                );
#                if ($res->[0] != 200) {
#                    log_trace("[comp][periscomp] Riap request failed (%s), declining", $res);
#                    return; 
#                }
#                $fres = $res->[2];
#                return; 
#            }
#
#            log_trace("[comp][periscomp] declining");
#            return; 
#        } 
#
#        my $sch = $arg_spec->{schema};
#        unless ($sch) {
#            log_trace("[comp][periscomp] arg spec does not specify schema, declining");
#            return; 
#        };
#
#        my $nsch = Data::Sah::Normalize::normalize_schema($sch);
#
#        my ($type, $cs) = @$nsch;
#        if ($type ne 'array') {
#            log_trace("[comp][periscomp] can't complete element for non-array");
#            return; 
#        }
#
#        unless ($cs->{of}) {
#            log_trace("[comp][periscomp] schema does not specify 'of' clause, declining");
#            return; 
#        }
#
#        my $elsch = Data::Sah::Normalize::normalize_schema($cs->{of});
#
#        $fres = complete_from_schema(schema=>$elsch, word=>$word);
#    };
#    log_debug("[comp][periscomp] completion died: $@") if $@;
#    unless ($fres) {
#        log_trace("[comp][periscomp] no completion from metadata possible, declining");
#        goto RETURN_RES;
#    }
#
#    $fres = hashify_answer($fres);
#    $fres->{static} //= $static && $word eq '' ? 1:0;
#  RETURN_RES:
#    log_trace("[comp][periscomp] leaving complete_arg_elem, result=%s", $fres);
#    $fres;
#}
#
#$SPEC{complete_arg_index} = {
#    v => 1.1,
#    summary => 'Given argument name and function metadata, complete arg element index',
#    description => <<'_',
#
#This is only relevant for arguments which have `index_completion` property set
#(currently only `hash` type arguments). When that property is not set, will
#simply return undef.
#
#Completion routine will get `%args`, with the following keys:
#
#* `word` (str, the word to be completed)
#* `arg` (str, the argument name which value is currently being completed)
#* `args` (hash, the argument hash to the function, so far)
#
#as well as extra keys from `extras` (but these won't overwrite the above
#standard keys).
#
#Completion routine should return a completion answer structure (described in
#<pm:Complete>) which is either a hash or an array. The simplest form of answer
#is just to return an array of strings. Completion routine can also return undef
#to express declination.
#
#_
#    args => {
#        meta => {
#            summary => 'Rinci function metadata, must be normalized',
#            schema => 'hash*',
#            req => 1,
#        },
#        arg => {
#            summary => 'Argument name',
#            schema => 'str*',
#            req => 1,
#        },
#        word => {
#            summary => 'Word to be completed',
#            schema => ['str*', default => ''],
#        },
#        args => {
#            summary => 'Collected arguments so far, '.
#                'will be passed to completion routines',
#            schema  => 'hash',
#        },
#        extras => {
#            summary => 'Add extra arguments to completion routine',
#            schema  => 'hash',
#            description => <<'_',
#
#The keys from this `extras` hash will be merged into the final `%args` passed to
#completion routines. Note that standard keys like `word`, `cword`, and so on as
#described in the function description will not be overwritten by this.
#
#_
#        },
#
#        %common_args_riap,
#    },
#    result_naked => 1,
#    result => {
#        schema => 'array', 
#    },
#};
#sub complete_arg_index {
#    require Data::Sah::Normalize;
#
#    my %args = @_;
#
#    my $fres;
#
#    log_trace("[comp][periscomp] entering complete_arg_index, arg=<%s>",
#                 $args{arg});
#
#    my $extras = $args{extras} // {};
#
#    my $ourextras = {arg=>$args{arg}, args=>$args{args}};
#
#    my $meta = $args{meta} or do {
#        log_trace("[comp][periscomp] meta is not supplied, declining");
#        goto RETURN_RES;
#    };
#    my $arg  = $args{arg} or do {
#        log_trace("[comp][periscomp] arg is not supplied, declining");
#        goto RETURN_RES;
#    };
#    my $word = $args{word} // '';
#
#
#    my $args_prop = $meta->{args} // {};
#    my $arg_spec = $args_prop->{$arg} or do {
#        log_trace("[comp][periscomp] arg '$arg' is not specified in meta, declining");
#        goto RETURN_RES;
#    };
#
#    my $static;
#    eval { 
#
#        my $idxcomp;
#      GET_IDXCOMP_ROUTINE:
#        {
#            $idxcomp = $arg_spec->{index_completion};
#            if ($idxcomp) {
#                log_trace("[comp][periscomp] using arg element index completion routine from 'index_completion' property");
#                last GET_IDXCOMP_ROUTINE;
#            }
#        } 
#
#        if ($idxcomp) {
#            if (ref($idxcomp) eq 'CODE') {
#                log_trace("[comp][periscomp] invoking arg element index completion routine");
#                $fres = $idxcomp->(
#                    %$extras,
#                    %$ourextras,
#                    word=>$word);
#                return; 
#            } elsif (ref($idxcomp) eq 'ARRAY') {
#                log_trace("[comp][periscomp] using array specified in arg element index completion routine: %s", $idxcomp);
#                $fres = complete_array_elem(array=>$idxcomp, word=>$word);
#                $static = $word eq '';
#            }
#
#            log_trace("[comp][periscomp] arg spec's 'index_completion' property is not a coderef or ".
#                             "arrayref");
#            if ($args{riap_client} && $args{riap_server_url}) {
#                log_trace("[comp][periscomp] trying to perform complete_arg_index request to Riap server");
#                my $res = $args{riap_client}->request(
#                    complete_arg_index => $args{riap_server_url},
#                    {(uri=>$args{riap_uri}) x !!defined($args{riap_uri}),
#                     arg=>$arg, args=>$args{args}, word=>$word},
#                );
#                if ($res->[0] != 200) {
#                    log_trace("[comp][periscomp] Riap request failed (%s), declining", $res);
#                    return; 
#                }
#                $fres = $res->[2];
#                return; 
#            }
#
#            log_trace("[comp][periscomp] declining");
#            return; 
#        } 
#
#        my $sch = $arg_spec->{schema};
#        unless ($sch) {
#            log_trace("[comp][periscomp] arg spec does not specify schema, declining");
#            return; 
#        };
#
#        my $nsch = Data::Sah::Normalize::normalize_schema($sch);
#
#        my ($type, $cs) = @$nsch;
#        if ($type ne 'hash') {
#            log_trace("[comp][periscomp] can't complete element index for non-hash");
#            return; 
#        }
#
#        my %keys;
#        if ($cs->{keys}) {
#            $keys{$_}++ for keys %{ $cs->{keys} };
#        }
#        if ($cs->{indices}) {
#            $keys{$_}++ for keys %{ $cs->{indices} };
#        }
#        if ($cs->{req_keys}) {
#            $keys{$_}++ for @{ $cs->{req_keys} };
#        }
#        if ($cs->{allowed_keys}) {
#            $keys{$_}++ for @{ $cs->{allowed_keys} };
#        }
#
#        for (keys %{$args{args}{$arg} // {}}) {
#            delete $keys{$_};
#        }
#
#        $fres = complete_hash_key(word => $word, hash => \%keys);
#
#    }; 
#    log_debug("[comp][periscomp] completion died: $@") if $@;
#    unless ($fres) {
#        log_trace("[comp][periscomp] no index completion from metadata possible, declining");
#        goto RETURN_RES;
#    }
#
#    $fres = hashify_answer($fres);
#    $fres->{static} //= $static && $word eq '' ? 1:0;
#  RETURN_RES:
#    log_trace("[comp][periscomp] leaving complete_arg_index, result=%s", $fres);
#    $fres;
#}
#
#$SPEC{complete_cli_arg} = {
#    v => 1.1,
#    summary => 'Complete command-line argument using Rinci function metadata',
#    description => <<'_',
#
#This routine uses <pm:Perinci::Sub::GetArgs::Argv> to generate <pm:Getopt::Long>
#specification from arguments list in Rinci function metadata and common options.
#Then, it will use <pm:Complete::Getopt::Long> to complete option names, option
#values, as well as arguments.
#
#_
#    args => {
#        meta => {
#            summary => 'Rinci function metadata',
#            schema => 'hash*',
#            req => 1,
#        },
#        words => {
#            summary => 'Command-line arguments',
#            schema => ['array*' => {of=>'str*'}],
#            req => 1,
#        },
#        cword => {
#            summary => 'On which argument cursor is located (zero-based)',
#            schema => 'int*',
#            req => 1,
#        },
#        completion => {
#            summary => 'Supply custom completion routine',
#            description => <<'_',
#
#If supplied, instead of the default completion routine, this code will be called
#instead. Will receive all arguments that <pm:Complete::Getopt::Long> will pass,
#and additionally:
#
#* `arg` (str, the name of function argument)
#* `args` (hash, the function arguments formed so far)
#* `index` (int, if completing argument element value)
#
#_
#            schema => 'code*',
#        },
#        per_arg_json => {
#            summary => 'Will be passed to Perinci::Sub::GetArgs::Argv',
#            schema  => 'bool',
#        },
#        per_arg_yaml => {
#            summary => 'Will be passed to Perinci::Sub::GetArgs::Argv',
#            schema  => 'bool',
#        },
#        common_opts => {
#            summary => 'Common options',
#            description => <<'_',
#
#A hash where the values are hashes containing these keys: `getopt` (Getopt::Long
#option specification), `handler` (Getopt::Long handler). Will be passed to
#`get_args_from_argv()`. Example:
#
#    {
#        help => {
#            getopt  => 'help|h|?',
#            handler => sub { ... },
#            summary => 'Display help and exit',
#        },
#        version => {
#            getopt  => 'version|v',
#            handler => sub { ... },
#            summary => 'Display version and exit',
#        },
#    }
#
#_
#            schema => ['hash*'],
#        },
#        extras => {
#            summary => 'Add extra arguments to completion routine',
#            schema  => 'hash',
#            description => <<'_',
#
#The keys from this `extras` hash will be merged into the final `%args` passed to
#completion routines. Note that standard keys like `word`, `cword`, and so on as
#described in the function description will not be overwritten by this.
#
#_
#        },
#        func_arg_starts_at => {
#            schema  => 'int*',
#            default => 0,
#            description => <<'_',
#
#This is a (temporary?) workaround for <pm:Perinci::CmdLine>. In an application
#with subcommands (e.g. `cmd --verbose subcmd arg0 arg1 ...`), then `words` will
#still contain the subcommand name. Positional function arguments then start at 1
#not 0. This option allows offsetting function arguments.
#
#_
#        },
#        %common_args_riap,
#    },
#    result_naked => 1,
#    result => {
#        schema => 'hash*',
#        description => <<'_',
#
#You can use `format_completion` function in <pm:Complete::Bash> module to format
#the result of this function for bash.
#
#_
#    },
#};
#sub complete_cli_arg {
#    require Complete::Getopt::Long;
#    require Perinci::Sub::GetArgs::Argv;
#
#    my %args   = @_;
#    my $meta   = $args{meta} or die "Please specify meta";
#    my $words  = $args{words} or die "Please specify words";
#    my $cword  = $args{cword}; defined($cword) or die "Please specify cword";
#    my $copts  = $args{common_opts} // {};
#    my $comp   = $args{completion};
#    my $extras = {
#        %{ $args{extras} // {} },
#        words => $args{words},
#        cword => $args{cword},
#    };
#
#    my $fname = __PACKAGE__ . "::complete_cli_arg"; 
#    my $fres;
#
#    my $word   = $words->[$cword];
#    my $args_prop = $meta->{args} // {};
#
#    log_trace('[comp][periscomp] entering %s(), words=%s, cword=%d, word=<%s>',
#                 $fname, $words, $cword, $word);
#
#    my $genres = Perinci::Sub::GetArgs::Argv::gen_getopt_long_spec_from_meta(
#        meta         => $meta,
#        common_opts  => $copts,
#        per_arg_json => $args{per_arg_json},
#        per_arg_yaml => $args{per_arg_yaml},
#        ignore_converted_code => 1,
#    );
#    die "Can't generate getopt spec from meta: $genres->[0] - $genres->[1]"
#        unless $genres->[0] == 200;
#    my $gospec = $genres->[2];
#    my $specmeta = $genres->[3]{'func.specmeta'};
#
#    my $gares = Perinci::Sub::GetArgs::Argv::get_args_from_argv(
#        argv   => [@$words],
#        meta   => $meta,
#        strict => 0,
#    );
#
#    my $copts_by_ospec = {};
#    for (keys %$copts) { $copts_by_ospec->{$copts->{$_}{getopt}}=$copts->{$_} }
#
#    my $compgl_comp = sub {
#        log_trace("[comp][periscomp] entering completion routine (that we supply to Complete::Getopt::Long)");
#        my %cargs = @_;
#        my $type  = $cargs{type};
#        my $ospec = $cargs{ospec} // '';
#        my $word  = $cargs{word};
#
#        my $fres;
#
#        my %rargs = (
#            riap_server_url => $args{riap_server_url},
#            riap_uri        => $args{riap_uri},
#            riap_client     => $args{riap_client},
#        );
#
#        $extras->{parsed_opts} = $cargs{parsed_opts};
#
#        if (my $sm = $specmeta->{$ospec}) {
#            $cargs{type} = 'optval';
#            if ($sm->{arg}) {
#                log_trace("[comp][periscomp] completing option value for a known function argument, arg=<%s>, ospec=<%s>", $sm->{arg}, $ospec);
#                $cargs{arg} = $sm->{arg};
#                my $arg_spec = $args_prop->{$sm->{arg}} or goto RETURN_RES;
#                if ($comp) {
#                    log_trace("[comp][periscomp] invoking routine supplied from 'completion' argument");
#                    my $compres;
#                    eval { $compres = $comp->(%cargs) };
#                    log_debug("[comp][periscomp] completion died: $@") if $@;
#                    log_trace("[comp][periscomp] result from 'completion' routine: %s", $compres);
#                    if ($compres) {
#                        $fres = $compres;
#                        goto RETURN_RES;
#                    }
#                }
#                if ($ospec =~ /\@$/) {
#                    $fres = complete_arg_elem(
#                        meta=>$meta, arg=>$sm->{arg}, args=>$gares->[2],
#                        word=>$word, index=>$cargs{nth}, 
#                        extras=>$extras, %rargs);
#                    goto RETURN_RES;
#                } elsif ($ospec =~ /\%$/) {
#                    if ($word =~ /(.*?)=(.*)/s) {
#                        my $key = $1;
#                        my $val = $2;
#                        $fres = complete_arg_elem(
#                            meta=>$meta, arg=>$sm->{arg}, args=>$gares->[2],
#                            word=>$val, index=>$key,
#                            extras=>$extras, %rargs);
#                        modify_answer(answer=>$fres, prefix=>"$key=");
#                        goto RETURN_RES;
#                    } else {
#                        $fres = complete_arg_index(
#                            meta=>$meta, arg=>$sm->{arg}, args=>$gares->[2],
#                            word=>$word, extras=>$extras, %rargs);
#                        modify_answer(answer=>$fres, suffix=>"=");
#                        $fres->{path_sep} = "=";
#                        $fres->{esc_mode} = "none";
#                        goto RETURN_RES;
#                    }
#                } else {
#                    $fres = complete_arg_val(
#                        meta=>$meta, arg=>$sm->{arg}, args=>$gares->[2],
#                        word=>$word, extras=>$extras, %rargs);
#                    goto RETURN_RES;
#                }
#            } else {
#                log_trace("[comp][periscomp] completing option value for a common option, ospec=<%s>", $ospec);
#                $cargs{arg}  = undef;
#                my $codata = $copts_by_ospec->{$ospec};
#                if ($comp) {
#                    log_trace("[comp][periscomp] invoking routine supplied from 'completion' argument");
#                    my $res;
#                    eval { $res = $comp->(%cargs) };
#                    log_debug("[comp][periscomp] completion died: $@") if $@;
#                    if ($res) {
#                        $fres = $res;
#                        goto RETURN_RES;
#                    }
#                }
#                if ($codata->{completion}) {
#                    $cargs{arg}  = undef;
#                    log_trace("[comp][periscomp] completing with common option's 'completion' property");
#                    my $res;
#                    eval { $res = $codata->{completion}->(%cargs) };
#                    log_debug("[comp][periscomp] completion died: $@") if $@;
#                    if ($res) {
#                        $fres = $res;
#                        goto RETURN_RES;
#                    }
#                }
#                if ($codata->{schema}) {
#                    require Data::Sah::Normalize;
#                    my $nsch = Data::Sah::Normalize::normalize_schema(
#                        $codata->{schema});
#                    log_trace("[comp][periscomp] completing with common option's schema");
#                    $fres = complete_from_schema(
#                        schema => $nsch, word=>$word);
#                    goto RETURN_RES;
#                }
#                goto RETURN_RES;
#            }
#        } elsif ($type eq 'arg') {
#            log_trace("[comp][periscomp] completing argument #%d", $cargs{argpos});
#            $cargs{type} = 'arg';
#
#            my $pos = $cargs{argpos};
#            my $fasa = $args{func_arg_starts_at} // 0;
#
#            for my $an (keys %$args_prop) {
#                my $arg_spec = $args_prop->{$an};
#                next unless !$arg_spec->{greedy} &&
#                    defined($arg_spec->{pos}) && $arg_spec->{pos} == $pos - $fasa;
#                log_trace("[comp][periscomp] this argument position is for non-greedy function argument <%s>", $an);
#                $cargs{arg} = $an;
#                if ($comp) {
#                    log_trace("[comp][periscomp] invoking routine supplied from 'completion' argument");
#                    my $res;
#                    eval { $res = $comp->(%cargs) };
#                    log_debug("[comp][periscomp] completion died: $@") if $@;
#                    if ($res) {
#                        $fres = $res;
#                        goto RETURN_RES;
#                    }
#                }
#                $fres = complete_arg_val(
#                    meta=>$meta, arg=>$an, args=>$gares->[2],
#                    word=>$word, extras=>$extras, %rargs);
#                goto RETURN_RES;
#            }
#
#            for my $an (sort {
#                ($args_prop->{$b}{pos} // 9999) <=> ($args_prop->{$a}{pos} // 9999)
#            } keys %$args_prop) {
#                my $arg_spec = $args_prop->{$an};
#                next unless $arg_spec->{greedy} &&
#                    defined($arg_spec->{pos}) && $arg_spec->{pos} <= $pos - $fasa;
#                my $index = $pos - $fasa - $arg_spec->{pos};
#                $cargs{arg} = $an;
#                $cargs{index} = $index;
#                log_trace("[comp][periscomp] this position is for greedy function argument <%s>'s element[%d]", $an, $index);
#                if ($comp) {
#                    log_trace("[comp][periscomp] invoking routine supplied from 'completion' argument");
#                    my $res;
#                    eval { $res = $comp->(%cargs) };
#                    log_debug("[comp][periscomp] completion died: $@") if $@;
#                    if ($res) {
#                        $fres = $res;
#                        goto RETURN_RES;
#                    }
#                }
#                $fres = complete_arg_elem(
#                    meta=>$meta, arg=>$an, args=>$gares->[2],
#                    word=>$word, index=>$index, extras=>$extras, %rargs);
#                goto RETURN_RES;
#            }
#
#            log_trace("[comp][periscomp] there is no matching function argument at this position");
#            if ($comp) {
#                log_trace("[comp][periscomp] invoking routine supplied from 'completion' argument");
#                my $res;
#                eval { $res = $comp->(%cargs) };
#                log_debug("[comp][periscomp] completion died: $@") if $@;
#                if ($res) {
#                    $fres = $res;
#                    goto RETURN_RES;
#                }
#            }
#            goto RETURN_RES;
#        } else {
#            log_trace("[comp][periscomp] completing option value for an unknown/ambiguous option, declining ...");
#            goto RETURN_RES;
#        }
#      RETURN_RES:
#        log_trace("[comp][periscomp] leaving completion routine (that we supply to Complete::Getopt::Long)");
#        $fres;
#    }; 
#
#    $fres = Complete::Getopt::Long::complete_cli_arg(
#        getopt_spec => $gospec,
#        words       => $words,
#        cword       => $cword,
#        completion  => $compgl_comp,
#        extras      => $extras,
#    );
#
#  RETURN_RES:
#    log_trace('[comp][periscomp] leaving %s(), result=%s',
#                 $fname, $fres);
#    $fres;
#}
#
#1;
#
#__END__
#
### Perinci/Sub/ConvertArgs/Argv.pm ###
#package Perinci::Sub::ConvertArgs::Argv;
#
#our $DATE = '2016-12-12'; 
#our $VERSION = '0.10'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Data::Sah::Util::Type qw(is_simple);
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(convert_args_to_argv);
#
#our %SPEC;
#
#sub _json {
#    require JSON;
#    state $json = JSON->new->allow_nonref;
#    $json->encode($_[0]);
#}
#
#sub _encode {
#    ref($_[0]) ? _json($_[0]) : $_[0];
#}
#
#$SPEC{convert_args_to_argv} = {
#    v => 1.1,
#    summary => 'Convert hash arguments to command-line options (and arguments)',
#    description => <<'_',
#
#Convert hash arguments to command-line arguments. This is the reverse of
#`Perinci::Sub::GetArgs::Argv::get_args_from_argv`.
#
#Note: currently the function expects schemas in metadata to be normalized
#already.
#
#_
#    args => {
#        args => {req=>1, schema=>'hash*', pos=>0},
#        meta => {req=>0, schema=>'hash*', pos=>1},
#        use_pos => {
#            summary => 'Whether to use positional arguments',
#            schema  => 'bool',
#            description => <<'_',
#
#For example, given this metadata:
#
#    {
#        v => 1.1,
#        args => {
#          arg1 => {pos=>0, req=>1},
#          arg2 => {pos=>1},
#          arg3 => {},
#        },
#    }
#
#then under `use_pos=0` the hash `{arg1=>1, arg2=>2, arg3=>'a b'}` will be
#converted to `['--arg1', 1, '--arg2', 2, '--arg3', 'a b']`. Meanwhile if
#`use_pos=1` the same hash will be converted to `[1, 2, '--arg3', 'a b']`.
#
#_
#        },
#    },
#};
#sub convert_args_to_argv {
#    my %fargs = @_;
#
#    my $iargs = $fargs{args} or return [400, "Please specify args"];
#    my $meta  = $fargs{meta} // {v=>1.1};
#    my $args_prop = $meta->{args} // {};
#
#    my $v = $meta->{v} // 1.0;
#    return [412, "Sorry, only metadata version 1.1 is supported (yours: $v)"]
#        unless $v == 1.1;
#
#    my @argv;
#    my %iargs = %$iargs; 
#
#    if ($fargs{use_pos}) {
#        for my $arg (sort {$args_prop->{$a}{pos} <=> $args_prop->{$b}{pos}}
#                         grep {defined $args_prop->{$_}{pos}} keys %iargs) {
#            my $pos = $args_prop->{$arg}{pos};
#            if ($args_prop->{$arg}{greedy}) {
#                my $sch = $args_prop->{$arg}{schema};
#                my $is_array_of_simple = $sch && $sch->[0] eq 'array' &&
#                    is_simple($sch->[1]{of} // $sch->[1]{each_elem});
#                for my $el (@{ $iargs{$arg} }) {
#                    $argv[$pos] = $is_array_of_simple ? $el : _encode($el);
#                    $pos++;
#                }
#            } else {
#                $argv[$pos] = _encode($iargs{$arg});
#            }
#            delete $iargs{$arg};
#        }
#    }
#
#    for (sort keys %iargs) {
#        my $sch = $args_prop->{$_}{schema};
#        my $is_bool = $sch && $sch->[0] eq 'bool';
#        my $is_array_of_simple = $sch && $sch->[0] eq 'array' &&
#            $sch->[1]{of} && is_simple($sch->[1]{of});
#        my $is_hash_of_simple = $sch && $sch->[0] eq 'hash' &&
#            is_simple($sch->[1]{of} // $sch->[1]{each_value} // $sch->[1]{each_elem});
#        my $can_be_comma_separated = $is_array_of_simple &&
#            $sch->[1]{of}[0] =~ /\A(int|float)\z/; 
#        my $opt = $_; $opt =~ s/_/-/g;
#        my $dashopt = length($opt) > 1 ? "--$opt" : "-$opt";
#        if ($is_bool) {
#            if ($iargs{$_}) {
#                push @argv, $dashopt;
#            } else {
#                push @argv, "--no$opt";
#            }
#        } elsif ($can_be_comma_separated) {
#            push @argv, "$dashopt", join(",", @{ $iargs{$_} });
#        } elsif ($is_array_of_simple) {
#            for (@{ $iargs{$_} }) {
#                push @argv, "$dashopt", $_;
#            }
#        } elsif ($is_hash_of_simple) {
#            my $arg = $iargs{$_};
#            for (sort keys %$arg) {
#                push @argv, "$dashopt", "$_=$arg->{$_}";
#            }
#        } else {
#            if (ref $iargs{$_}) {
#                push @argv, "$dashopt-json", _encode($iargs{$_});
#            } else {
#                push @argv, $dashopt, "$iargs{$_}";
#            }
#        }
#    }
#    [200, "OK", \@argv];
#}
#
#1;
#
#__END__
#
### Perinci/Sub/ConvertArgs/Array.pm ###
#package Perinci::Sub::ConvertArgs::Array;
#
#our $DATE = '2015-12-29'; 
#our $VERSION = '0.08'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(convert_args_to_array);
#
#our %SPEC;
#
#$SPEC{convert_args_to_array} = {
#    v => 1.1,
#    summary => 'Convert hash arguments to array',
#    description => <<'_',
#
#Using information in 'args' property (particularly the 'pos' and 'greedy' of
#each argument spec), convert hash arguments to array.
#
#Example:
#
#    my $meta = {
#        v => 1.1,
#        summary => 'Multiply 2 numbers (a & b)',
#        args => {
#            a => ['num*' => {arg_pos=>0}],
#            b => ['num*' => {arg_pos=>1}],
#        }
#    }
#
#then 'convert_args_to_array(args=>{a=>2, b=>3}, meta=>$meta)' will produce:
#
#    [200, "OK", [2, 3]]
#
#_
#    args => {
#        args => {req=>1, schema=>'hash*', pos=>0},
#        meta => {req=>1, schema=>'hash*', pos=>1},
#    },
#};
#sub convert_args_to_array {
#    my %input_args   = @_;
#    my $args         = $input_args{args} or return [400, "Please specify args"];
#    my $meta         = $input_args{meta} or return [400, "Please specify meta"];
#    my $args_prop    = $meta->{args} // {};
#
#    my $v = $meta->{v} // 1.0;
#    return [412, "Sorry, only metadata version 1.1 is supported (yours: $v)"]
#        unless $v == 1.1;
#
#
#    my @array;
#
#    while (my ($k, $v) = each %$args) {
#        next if $k =~ /\A-/; 
#        my $as = $args_prop->{$k};
#        return [412, "Argument $k: Not specified in args property"] unless $as;
#        my $pos = $as->{pos};
#        return [412, "Argument $k: No pos specified in arg spec"]
#            unless defined $pos;
#        if ($as->{greedy}) {
#            $v = [$v] if ref($v) ne 'ARRAY';
#            for (@array .. $pos-1) {
#                $array[$_] = undef;
#            }
#            splice @array, $pos, 0, @$v;
#        } else {
#            $array[$pos] = $v;
#        }
#    }
#    [200, "OK", \@array];
#}
#
#1;
#
#__END__
#
### Perinci/Sub/DepChecker.pm ###
#package Perinci::Sub::DepChecker;
#
#use 5.010001;
#use strict;
#use warnings;
#use experimental 'smartmatch';
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       check_deps
#                       dep_satisfy_rel
#                       list_mentioned_dep_clauses
#               );
#
#our $VERSION = '0.11'; 
#our $DATE = '2015-09-03'; 
#
#my $pa;
#
#sub check_deps {
#    my ($val) = @_;
#    for my $dname (keys %$val) {
#        my $dval = $val->{$dname};
#        unless (defined &{"checkdep_$dname"}) {
#            eval { require "Perinci/Sub/Dep/$dname.pm" };
#            return "Unknown dependency type: $dname"
#                unless defined &{"checkdep_$dname"};
#        }
#        my $check = \&{"checkdep_$dname"};
#        my $res = $check->($dval);
#        if ($res) {
#            $res = "$dname: $res";
#            return $res;
#        }
#    }
#    "";
#}
#
#sub checkdep_all {
#    my ($val) = @_;
#    for (@$val) {
#        my $res = check_deps($_);
#        return "Some dependencies not met: $res" if $res;
#    }
#    "";
#}
#
#sub checkdep_any {
#    my ($val) = @_;
#    my $nfail = 0;
#    for (@$val) {
#        return "" unless check_deps($_);
#        $nfail++;
#    }
#    $nfail ? "None of the dependencies are met" : "";
#}
#
#sub checkdep_none {
#    my ($val) = @_;
#    for (@$val) {
#        my $res = check_deps($_);
#        return "A dependency is met when it shouldn't: $res" unless $res;
#    }
#    "";
#}
#
#sub checkdep_env {
#    my ($cval) = @_;
#    $ENV{$cval} ? "" : "Environment variable $cval not set/true";
#}
#
#sub checkdep_code {
#    my ($cval) = @_;
#    $cval->() ? "" : "code doesn't return true value";
#}
#
#sub checkdep_prog {
#    my ($cval) = @_;
#
#    if ($cval =~ m!/!) {
#        return "Program $cval not executable" unless (-x $cval);
#    } else {
#        require File::Which;
#        return "Program $cval not found in PATH (".
#            join(":", File::Spec->path).")"
#                unless File::Which::which($cval);
#    }
#    "";
#}
#
#sub riap_client {
#    return $pa if $pa;
#    require Perinci::Access;
#    $pa = Perinci::Access->new;
#    $pa;
#}
#
#sub checkdep_pkg {
#    my ($cval) = @_;
#    my $res = riap_client->request(info => $cval);
#    $res->[0] == 200 or return "Can't perform 'info' Riap request on '$cval': ".
#        "$res->[0] $res->[1]";
#    $res->[2]{type} eq 'package' or return "$cval is not a Riap package";
#    "";
#}
#
#sub checkdep_func {
#    my ($cval) = @_;
#    my $res = riap_client->request(info => $cval);
#    $res->[0] == 200 or return "Can't perform 'info' Riap request on '$cval': ".
#        "$res->[0] $res->[1]";
#    $res->[2]{type} eq 'function' or return "$cval is not a Riap function";
#    "";
#}
#
#sub checkdep_exec { checkdep_prog(@_) }
#
#sub checkdep_tmp_dir { "" }
#
#sub checkdep_trash_dir { "" }
#
#sub checkdep_undo_trash_dir { "" }
#
#sub _all_elems_is {
#    my ($ary, $el) = @_;
#    (grep {$_ eq $el} @$ary) && !(grep {$_ ne $el} @$ary);
#}
#
#sub _all_nonblank_elems_is {
#    my ($ary, $el) = @_;
#    (grep {$_ eq $el} @$ary) && !(grep {$_ && $_ ne $el} @$ary);
#}
#
#sub dep_satisfy_rel {
#    my ($wanted, $deps) = @_;
#
#    my $res;
#    for my $dname (keys %$deps) {
#        my $dval = $deps->{$dname};
#
#        if ($dname eq 'all') {
#            my @r = map { dep_satisfy_rel($wanted, $_) } @$dval;
#            next unless @r;
#            return "impossible" if "impossible" ~~ @r;
#            return "impossible" if "must" ~~ @r && "must not" ~~ @r;
#            return "must"       if "must" ~~ @r;
#            return "must not"   if "must not" ~~ @r;
#            return "might"      if _all_nonblank_elems_is(\@r, "might");
#        } elsif ($dname eq 'any') {
#            my @r = map { dep_satisfy_rel($wanted, $_) } @$dval;
#            next unless @r;
#            return "impossible" if "impossible" ~~ @r;
#            return "must"       if _all_elems_is(\@r, "must");
#            return "must not"   if _all_elems_is(\@r, "must not");
#            next                if _all_elems_is(\@r, "");
#            return "might";
#        } elsif ($dname eq 'none') {
#            my @r = map { dep_satisfy_rel($wanted, $_) } @$dval;
#            next unless @r;
#            return "impossible" if "impossible" ~~ @r;
#            return "impossible" if "must" ~~ @r && "must not" ~~ @r;
#            return "must not"   if "must" ~~ @r;
#            return "must"       if "must not" ~~ @r;
#            return "might"      if _all_nonblank_elems_is(\@r, "might");
#        } else {
#            return "must" if $dname eq $wanted;
#        }
#    }
#    "";
#}
#
#sub list_mentioned_dep_clauses {
#    my ($deps, $res) = @_;
#    $res //= [];
#    for my $dname (keys %$deps) {
#        my $dval = $deps->{$dname};
#        push @$res, $dname unless $dname ~~ @$res;
#        if ($dname =~ /\A(?:all|any|none)\z/) {
#            list_mentioned_dep_clauses($_, $res) for @$dval;
#        }
#    }
#    $res;
#}
#
#1;
#
#__END__
#
### Perinci/Sub/GetArgs/Argv.pm ###
#package Perinci::Sub::GetArgs::Argv;
#
#our $DATE = '2017-08-27'; 
#our $VERSION = '0.840'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Data::Sah::Normalize qw(normalize_schema);
#use Data::Sah::Util::Type qw(is_type is_simple);
#use Getopt::Long::Negate::EN qw(negations_for_option);
#use Getopt::Long::Util qw(parse_getopt_long_opt_spec);
#use List::Util qw(first);
#use Perinci::Sub::GetArgs::Array qw(get_args_from_array);
#use Perinci::Sub::Util qw(err);
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       gen_getopt_long_spec_from_meta
#                       get_args_from_argv
#               );
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Get subroutine arguments from command line arguments (@ARGV)',
#};
#
#sub _parse_json {
#    my $str = shift;
#
#    state $json = do {
#        require JSON::PP;
#        JSON::PP->new->allow_nonref;
#    };
#
#    state $cleanser = do {
#        if (eval { require Data::Clean::FromJSON; 1 }) {
#            Data::Clean::FromJSON->get_cleanser;
#        } else {
#            undef;
#        }
#    };
#
#    my $res;
#    eval { $res = $json->decode($str); $cleanser->clean_in_place($res) if $cleanser };
#    my $e = $@;
#    return (!$e, $e, $res);
#}
#
#sub _parse_yaml {
#    no warnings 'once';
#
#    state $yaml_xs_available = do {
#        if (eval { require YAML::XS; 1 }) {
#            1;
#        } else {
#            require YAML::Old;
#            0;
#        }
#    };
#
#    my $str = shift;
#
#    my $res;
#    eval {
#        if ($yaml_xs_available) {
#            $res = YAML::XS::Load($str);
#        } else {
#            $str = "--- $str" unless $str =~ /\A--- /;
#            $str .= "\n" unless $str =~ /\n\z/;
#            $res = YAML::Old::Load($str);
#        }
#    };
#    my $e = $@;
#    return (!$e, $e, $res);
#}
#
#sub _arg2opt {
#    my $opt = shift;
#    $opt =~ s/[^A-Za-z0-9-]+/-/g; 
#    $opt;
#}
#
#sub _is_coercible_from_simple {
#    my $nsch = shift;
#    my $cset = $nsch->[1] or return 0;
#    my $rules = $cset->{'x.perl.coerce_rules'} // $cset->{'x.coerce_rules'}
#        or return 0;
#    for my $rule (@$rules) {
#        next unless $rule =~ /\A([^_]+)_/;
#        return 1 if is_simple($1);
#    }
#    0;
#}
#
#sub _is_simple_or_coercible_from_simple {
#    my $nsch = shift;
#    is_simple($nsch) || _is_coercible_from_simple($nsch);
#}
#
#sub _is_simple_or_array_of_simple_or_hash_of_simple {
#    my $nsch = shift;
#
#    my $is_simple = 0;
#    my $is_array_of_simple = 0;
#    my $is_hash_of_simple = 0;
#    my $eltype;
#
#    my $type = $nsch->[0];
#    my $cset = $nsch->[1];
#
#    {
#        unless (is_type($nsch)) {
#            require Data::Sah::Resolve;
#            my $res = Data::Sah::Resolve::resolve_schema(
#                {merge_clause_sets => 0}, $nsch);
#            $type = $res->[0];
#            $cset = $res->[1][0] // {};
#        }
#
#        $is_simple = _is_simple_or_coercible_from_simple([$type, $cset]);
#        last if $is_simple;
#
#        if ($type eq 'array') {
#            my $elnsch = $cset->{of} // $cset->{each_elem};
#            last unless $elnsch;
#            $elnsch = normalize_schema($elnsch);
#            $eltype = $elnsch->[0];
#
#            unless (is_type($elnsch)) {
#                require Data::Sah::Resolve;
#                my $res = Data::Sah::Resolve::resolve_schema(
#                    {merge_clause_sets => 0}, $elnsch);
#                $elnsch = [$res->[0], $res->[1][0] // {}]; 
#                $eltype = $res->[0];
#            }
#
#            $is_array_of_simple = _is_simple_or_coercible_from_simple($elnsch);
#            last;
#        }
#
#        if ($type eq 'hash') {
#            my $elnsch = $cset->{of} // $cset->{each_value} // $cset->{each_elem};
#            last unless $elnsch;
#            $elnsch = normalize_schema($elnsch);
#            $eltype = $elnsch->[0];
#
#            unless (is_type($elnsch)) {
#                require Data::Sah::Resolve;
#                my $res = Data::Sah::Resolve::resolve_schema(
#                    {merge_clause_sets => 0}, $elnsch);
#                $elnsch = [$res->[0], $res->[1][0] // {}]; 
#                $eltype = $res->[0];
#            }
#
#            $is_hash_of_simple = _is_simple_or_coercible_from_simple($elnsch);
#            last;
#        }
#    }
#
#    ($is_simple, $is_array_of_simple, $is_hash_of_simple, $type, $cset, $eltype);
#}
#
#sub _opt2ospec {
#    my ($opt, $schema, $arg_spec) = @_;
#    my ($is_simple, $is_array_of_simple, $is_hash_of_simple, $type, $cset, $eltype) =
#        _is_simple_or_array_of_simple_or_hash_of_simple($schema);
#
#    my (@opts, @types, @isaos, @ishos);
#
#    if ($is_array_of_simple || $is_hash_of_simple) {
#        my $singular_opt;
#        if ($arg_spec && $arg_spec->{'x.name.is_plural'}) {
#            if ($arg_spec->{'x.name.singular'}) {
#                $singular_opt = _arg2opt($arg_spec->{'x.name.singular'});
#            } else {
#                require Lingua::EN::PluralToSingular;
#                $singular_opt = Lingua::EN::PluralToSingular::to_singular($opt);
#            }
#        } else {
#            $singular_opt = $opt;
#        }
#        push @opts , $singular_opt;
#        push @types, $eltype;
#        push @isaos, $is_array_of_simple ? 1:0;
#        push @ishos, $is_hash_of_simple  ? 1:0;
#    }
#
#    if ($is_simple || !@opts) {
#        push @opts , $opt;
#        push @types, $type;
#        push @isaos, 0;
#        push @ishos, 0;
#    }
#
#    my @res;
#
#    for my $i (0..$#opts) {
#        my $opt   = $opts[$i];
#        my $type  = $types[$i];
#        my $isaos = $isaos[$i];
#        my $ishos = $ishos[$i];
#
#        if ($type eq 'bool') {
#            if (length($opt) == 1 || $cset->{is}) {
#                push @res, ($opt, {opts=>[$opt]}), undef;
#            } else {
#                my @negs = negations_for_option($opt);
#                push @res, $opt, {opts=>[$opt]}, {is_neg=>0, neg_opts=>\@negs};
#                for (@negs) {
#                    push @res, $_, {opts=>[$_]}, {is_neg=>1, pos_opts=>[$opt]};
#                }
#            }
#        } elsif ($type eq 'buf') {
#            push @res, (
#                "$opt=s", {opts=>[$opt], desttype=>"", type=>"s"}, undef,
#                "$opt-base64=s", {opts=>["$opt-base64"], desttype=>"", type=>"s"}, {is_base64=>1},
#            );
#        } else {
#            my $t = ($type eq 'int' ? 's' : $type eq 'float' ? 's' : 's') .
#                ($isaos ? '@' : $ishos ? '%' : '');
#            push @res, ("$opt=$t", {opts=>[$opt], desttype=>"", type=>$t}, undef);
#        }
#    }
#
#    @res;
#}
#
#sub _args2opts {
#    my %args = @_;
#
#    my $argprefix        = $args{argprefix};
#    my $parent_args      = $args{parent_args};
#    my $meta             = $args{meta};
#    my $seen_opts        = $args{seen_opts};
#    my $seen_common_opts = $args{seen_common_opts};
#    my $seen_func_opts   = $args{seen_func_opts};
#    my $rargs            = $args{rargs};
#    my $go_spec          = $args{go_spec};
#    my $specmeta         = $args{specmeta};
#
#    my $args_prop = $meta->{args} // {};
#
#    for my $arg (keys %$args_prop) {
#        my $fqarg    = "$argprefix$arg";
#        my $arg_spec = $args_prop->{$arg};
#        next if grep { $_ eq 'hidden' || $_ eq 'hidden-cli' }
#            @{ $arg_spec->{tags} // [] };
#        my $sch      = $arg_spec->{schema} // ['any', {}];
#        my ($is_simple, $is_array_of_simple, $is_hash_of_simple, $type, $cset, $eltype) =
#            _is_simple_or_array_of_simple_or_hash_of_simple($sch);
#
#        if ($type eq 'array' && $cset->{of}) {
#            $cset->{of} = normalize_schema($cset->{of});
#        }
#        my $opt = _arg2opt($fqarg);
#        if ($seen_opts->{$opt}) {
#            my $i = 1;
#            my $opt2;
#            while (1) {
#                $opt2 = "$opt-arg" . ($i > 1 ? $i : '');
#                last unless $seen_opts->{$opt2};
#                $i++;
#            }
#            $opt = $opt2;
#        }
#
#        my $stash = {};
#
#
#        my $handler = sub {
#            my ($val, $val_set);
#
#            my $num_called = ++$stash->{called}{$arg};
#
#            my $rargs = do {
#                if (ref($rargs) eq 'ARRAY') {
#                    $rargs->[$num_called-1] //= {};
#                    $rargs->[$num_called-1];
#                } else {
#                    $rargs;
#                }
#            };
#
#            if ($is_simple) {
#                $val_set = 1; $val = $_[1];
#                $rargs->{$arg} = $val;
#            } elsif ($is_array_of_simple) {
#                $rargs->{$arg} //= [];
#                $val_set = 1; $val = $_[1];
#                push @{ $rargs->{$arg} }, $val;
#            } elsif ($is_hash_of_simple) {
#                $rargs->{$arg} //= {};
#                $val_set = 1; $val = $_[2];
#                $rargs->{$arg}{$_[1]} = $val;
#            } else {
#                {
#                    my ($success, $e, $decoded);
#                    ($success, $e, $decoded) = _parse_json($_[1]);
#                    if ($success) {
#                        $val_set = 1; $val = $decoded;
#                        $rargs->{$arg} = $val;
#                        last;
#                    }
#                    ($success, $e, $decoded) = _parse_yaml($_[1]);
#                    if ($success) {
#                        $val_set = 1; $val = $decoded;
#                        $rargs->{$arg} = $val;
#                        last;
#                    }
#                    die "Invalid YAML/JSON in arg '$fqarg'";
#                }
#            }
#            if ($val_set && $arg_spec->{cmdline_on_getopt}) {
#                $arg_spec->{cmdline_on_getopt}->(
#                    arg=>$arg, fqarg=>$fqarg, value=>$val, args=>$rargs,
#                    opt=>$opt,
#                );
#            }
#        }; 
#
#        my @triplets = _opt2ospec($opt, $sch, $arg_spec);
#        my $aliases_processed;
#        while (my ($ospec, $parsed, $extra) = splice @triplets, 0, 3) {
#            $extra //= {};
#            if ($extra->{is_neg}) {
#                $go_spec->{$ospec} = sub { $handler->($_[0], 0) };
#            } elsif (defined $extra->{is_neg}) {
#                $go_spec->{$ospec} = sub { $handler->($_[0], 1) };
#            } elsif ($extra->{is_base64}) {
#                $go_spec->{$ospec} = sub {
#                    require MIME::Base64;
#                    my $decoded = MIME::Base64::decode($_[1]);
#                    $handler->($_[0], $decoded);
#                };
#            } else {
#                $go_spec->{$ospec} = $handler;
#            }
#
#            $specmeta->{$ospec} = {arg=>$arg, fqarg=>$fqarg, parsed=>$parsed, %$extra};
#            for (@{ $parsed->{opts} }) {
#                $seen_opts->{$_}++; $seen_func_opts->{$_} = $fqarg;
#            }
#
#            if ($parent_args->{per_arg_json} && !$is_simple) {
#                my $jopt = "$opt-json";
#                if ($seen_opts->{$jopt}) {
#                    warn "Clash of option: $jopt, not added";
#                } else {
#                    my $jospec = "$jopt=s";
#                    my $parsed = {type=>"s", opts=>[$jopt]};
#                    $go_spec->{$jospec} = sub {
#                        my ($success, $e, $decoded);
#                        ($success, $e, $decoded) = _parse_json($_[1]);
#                        if ($success) {
#                            $rargs->{$arg} = $decoded;
#                        } else {
#                            die "Invalid JSON in option --$jopt: $_[1]: $e";
#                        }
#                    };
#                    $specmeta->{$jospec} = {arg=>$arg, fqarg=>$fqarg, is_json=>1, parsed=>$parsed, %$extra};
#                    $seen_opts->{$jopt}++; $seen_func_opts->{$jopt} = $fqarg;
#                }
#            }
#            if ($parent_args->{per_arg_yaml} && !$is_simple) {
#                my $yopt = "$opt-yaml";
#                if ($seen_opts->{$yopt}) {
#                    warn "Clash of option: $yopt, not added";
#                } else {
#                    my $yospec = "$yopt=s";
#                    my $parsed = {type=>"s", opts=>[$yopt]};
#                    $go_spec->{$yospec} = sub {
#                        my ($success, $e, $decoded);
#                        ($success, $e, $decoded) = _parse_yaml($_[1]);
#                        if ($success) {
#                            $rargs->{$arg} = $decoded;
#                        } else {
#                            die "Invalid YAML in option --$yopt: $_[1]: $e";
#                        }
#                    };
#                    $specmeta->{$yospec} = {arg=>$arg, fqarg=>$fqarg, is_yaml=>1, parsed=>$parsed, %$extra};
#                    $seen_opts->{$yopt}++; $seen_func_opts->{$yopt} = $fqarg;
#                }
#            }
#
#            if ($arg_spec->{cmdline_aliases} && !$aliases_processed++) {
#                for my $al (keys %{$arg_spec->{cmdline_aliases}}) {
#                    my $alspec = $arg_spec->{cmdline_aliases}{$al};
#                    my $alsch = $alspec->{schema} //
#                        $alspec->{is_flag} ? [bool=>{req=>1,is=>1}] : $sch;
#                    my $altype = $alsch->[0];
#                    my $alopt = _arg2opt("$argprefix$al");
#                    if ($seen_opts->{$alopt}) {
#                        warn "Clash of cmdline_alias option $al";
#                        next;
#                    }
#                    my $alcode = $alspec->{code};
#                    my $alospec;
#                    my $parsed;
#                    if ($alcode && $alsch->[0] eq 'bool') {
#                        $alospec = $alopt; 
#                        $parsed = {opts=>[$alopt]};
#                    } else {
#                        ($alospec, $parsed) = _opt2ospec($alopt, $alsch);
#                    }
#
#                    if ($alcode) {
#                        if ($alcode eq 'CODE') {
#                            if ($parent_args->{ignore_converted_code}) {
#                                $alcode = sub {};
#                            } else {
#                                return [
#                                    501,
#                                    join("",
#                                         "Code in cmdline_aliases for arg $fqarg ",
#                                         "got converted into string, probably ",
#                                         "because of JSON/YAML transport"),
#                                ];
#                            }
#                        }
#                        $go_spec->{$alospec} = sub {
#
#                            my $num_called = ++$stash->{called}{$arg};
#                            my $rargs = do {
#                                if (ref($rargs) eq 'ARRAY') {
#                                    $rargs->[$num_called-1] //= {};
#                                    $rargs->[$num_called-1];
#                                } else {
#                                    $rargs;
#                                }
#                            };
#
#                            $alcode->($rargs, $_[1]);
#                        };
#                    } else {
#                        $go_spec->{$alospec} = $handler;
#                    }
#                    $specmeta->{$alospec} = {
#                        alias     => $al,
#                        is_alias  => 1,
#                        alias_for => $ospec,
#                        arg       => $arg,
#                        fqarg     => $fqarg,
#                        is_code   => $alcode ? 1:0,
#                        parsed    => $parsed,
#                        %$extra,
#                    };
#                    push @{$specmeta->{$ospec}{($alcode ? '':'non').'code_aliases'}},
#                        $alospec;
#                    $seen_opts->{$alopt}++; $seen_func_opts->{$alopt} = $fqarg;
#                }
#            } 
#
#            if ($arg_spec->{meta}) {
#                $rargs->{$arg} = {};
#                my $res = _args2opts(
#                    %args,
#                    argprefix => "$argprefix$arg\::",
#                    meta      => $arg_spec->{meta},
#                    rargs     => $rargs->{$arg},
#                );
#                return $res if $res;
#            }
#
#            if ($arg_spec->{element_meta}) {
#                $rargs->{$arg} = [];
#                my $res = _args2opts(
#                    %args,
#                    argprefix => "$argprefix$arg\::",
#                    meta      => $arg_spec->{element_meta},
#                    rargs     => $rargs->{$arg},
#                );
#                return $res if $res;
#            }
#        } 
#
#    } 
#
#    undef;
#}
#
#$SPEC{gen_getopt_long_spec_from_meta} = {
#    v           => 1.1,
#    summary     => 'Generate Getopt::Long spec from Rinci function metadata',
#    description => <<'_',
#
#This routine will produce a <pm:Getopt::Long> specification from Rinci function
#metadata, as well as some more data structure in the result metadata to help
#producing a command-line help/usage message.
#
#Function arguments will be mapped to command-line options with the same name,
#with non-alphanumeric characters changed to `-` (`-` is preferred over `_`
#because it lets user avoid pressing Shift on popular keyboards). For example:
#`file_size` becomes `file-size`, `file_size.max` becomes `file-size-max`. If
#function argument option name clashes with command-line option or another
#existing option, it will be renamed to `NAME-arg` (or `NAME-arg2` and so on).
#For example: `help` will become `help-arg` (if `common_opts` contains `help`,
#that is).
#
#Each command-line alias (`cmdline_aliases` property) in the argument
#specification will also be added as command-line option, except if it clashes
#with an existing option, in which case this function will warn and skip adding
#the alias. For more information about `cmdline_aliases`, see `Rinci::function`.
#
#For arguments with type of `bool`, Getopt::Long will by default also
#automatically recognize `--noNAME` or `--no-NAME` in addition to `--name`. So
#this function will also check those names for clashes.
#
#For arguments with type array of simple scalar, `--NAME` can be specified more
#than once to append to the array.
#
#If `per_arg_json` setting is active, and argument's schema is not a "required
#simple scalar" (e.g. an array, or a nullable string), then `--NAME-json` will
#also be added to let users input undef (through `--NAME-json null`) or a
#non-scalar value (e.g. `--NAME-json '[1,2,3]'`). If this name conflicts with
#another existing option, a warning will be displayed and the option will not be
#added.
#
#If `per_arg_yaml` setting is active, and argument's schema is not a "required
#simple scalar" (e.g. an array, or a nullable string), then `--NAME-yaml` will
#also be added to let users input undef (through `--NAME-yaml '~'`) or a
#non-scalar value (e.g. `--NAME-yaml '[foo, bar]'`). If this name conflicts with
#another existing option, a warning will be displayed and the option will not be
#added. YAML can express a larger set of values, e.g. binary data, circular
#references, etc.
#
#Will produce a hash (Getopt::Long spec), with `func.specmeta`, `func.opts`,
#`func.common_opts`, `func.func_opts` that contain extra information
#(`func.specmeta` is a hash of getopt spec name and a hash of extra information
#while `func.*opts` lists all used option names).
#
#_
#    args => {
#        meta => {
#            summary => 'Rinci function metadata',
#            schema  => 'hash*',
#            req     => 1,
#        },
#        meta_is_normalized => {
#            schema => 'bool*',
#        },
#        args => {
#            summary => 'Reference to hash which will store the result',
#            schema  => 'hash*',
#        },
#        common_opts => {
#            summary => 'Common options',
#            description => <<'_',
#
#A hash where the values are hashes containing these keys: `getopt` (Getopt::Long
#option specification), `handler` (Getopt::Long handler). Will be passed to
#`get_args_from_argv()`. Example:
#
#    {
#        help => {
#            getopt  => 'help|h|?',
#            handler => sub { ... },
#            summary => 'Display help and exit',
#        },
#        version => {
#            getopt  => 'version|v',
#            handler => sub { ... },
#            summary => 'Display version and exit',
#        },
#    }
#
#_
#            schema => ['hash*'],
#        },
#        per_arg_json => {
#            summary => 'Whether to add --NAME-json for non-simple arguments',
#            schema  => 'bool',
#            default => 0,
#            description => <<'_',
#
#Will also interpret command-line arguments as JSON if assigned to function
#arguments, if arguments' schema is not simple scalar.
#
#_
#        },
#        per_arg_yaml => {
#            summary => 'Whether to add --NAME-yaml for non-simple arguments',
#            schema  => 'bool',
#            default => 0,
#            description => <<'_',
#
#Will also interpret command-line arguments as YAML if assigned to function
#arguments, if arguments' schema is not simple scalar.
#
#_
#        },
#        ignore_converted_code => {
#            summary => 'Whether to ignore coderefs converted to string',
#            schema => 'bool',
#            default => 0,
#            description => <<'_',
#
#Across network through JSON encoding, coderef in metadata (e.g. in
#`cmdline_aliases` property) usually gets converted to string `CODE`. In some
#cases, like for tab completion, this is pretty harmless so you can turn this
#option on. For example, in the case of `cmdline_aliases`, the effect is just
#that command-line aliases code are not getting executed, but this is usually
#okay.
#
#_
#        },
#    },
#};
#sub gen_getopt_long_spec_from_meta {
#    my %fargs = @_;
#
#    my $meta       = $fargs{meta} or return [400, "Please specify meta"];
#    unless ($fargs{meta_is_normalized}) {
#        require Perinci::Sub::Normalize;
#        $meta = Perinci::Sub::Normalize::normalize_function_metadata($meta);
#    }
#    my $co           = $fargs{common_opts} // {};
#    my $per_arg_yaml = $fargs{per_arg_yaml} // 0;
#    my $per_arg_json = $fargs{per_arg_json} // 0;
#    my $ignore_converted_code = $fargs{ignore_converted_code};
#    my $rargs        = $fargs{args} // {};
#
#    my %go_spec;
#    my %specmeta; 
#    my %seen_opts;
#    my %seen_common_opts;
#    my %seen_func_opts;
#
#    for my $k (keys %$co) {
#        my $v = $co->{$k};
#        my $ospec   = $v->{getopt};
#        my $handler = $v->{handler};
#        my $res = parse_getopt_long_opt_spec($ospec)
#            or return [400, "Can't parse common opt spec '$ospec'"];
#        $go_spec{$ospec} = $handler;
#        $specmeta{$ospec} = {common_opt=>$k, arg=>undef, parsed=>$res};
#        for (@{ $res->{opts} }) {
#            return [412, "Clash of common opt '$_'"] if $seen_opts{$_};
#            $seen_opts{$_}++; $seen_common_opts{$_} = $ospec;
#            if ($res->{is_neg}) {
#                $seen_opts{"no$_"}++ ; $seen_common_opts{"no$_"}  = $ospec;
#                $seen_opts{"no-$_"}++; $seen_common_opts{"no-$_"} = $ospec;
#            }
#        }
#    }
#
#    my $res = _args2opts(
#        argprefix        => "",
#        parent_args      => \%fargs,
#        meta             => $meta,
#        seen_opts        => \%seen_opts,
#        seen_common_opts => \%seen_common_opts,
#        seen_func_opts   => \%seen_func_opts,
#        rargs            => $rargs,
#        go_spec          => \%go_spec,
#        specmeta         => \%specmeta,
#    );
#    return $res if $res;
#
#    my $opts        = [sort(map {length($_)>1 ? "--$_":"-$_"} keys %seen_opts)];
#    my $common_opts = [sort(map {length($_)>1 ? "--$_":"-$_"} keys %seen_common_opts)];
#    my $func_opts   = [sort(map {length($_)>1 ? "--$_":"-$_"} keys %seen_func_opts)];
#    my $opts_by_common = {};
#    for my $k (keys %$co) {
#        my $v = $co->{$k};
#        my $ospec = $v->{getopt};
#        my @opts;
#        for (keys %seen_common_opts) {
#            next unless $seen_common_opts{$_} eq $ospec;
#            push @opts, (length($_)>1 ? "--$_":"-$_");
#        }
#        $opts_by_common->{$ospec} = [sort @opts];
#    }
#
#    my $opts_by_arg = {};
#    for (keys %seen_func_opts) {
#        my $fqarg = $seen_func_opts{$_};
#        push @{ $opts_by_arg->{$fqarg} }, length($_)>1 ? "--$_":"-$_";
#    }
#    for (keys %$opts_by_arg) {
#        $opts_by_arg->{$_} = [sort @{ $opts_by_arg->{$_} }];
#    }
#
#    [200, "OK", \%go_spec,
#     {
#         "func.specmeta"       => \%specmeta,
#         "func.opts"           => $opts,
#         "func.common_opts"    => $common_opts,
#         "func.func_opts"      => $func_opts,
#         "func.opts_by_arg"    => $opts_by_arg,
#         "func.opts_by_common" => $opts_by_common,
#     }];
#}
#
#$SPEC{get_args_from_argv} = {
#    v => 1.1,
#    summary => 'Get subroutine arguments (%args) from command-line arguments '.
#        '(@ARGV)',
#    description => <<'_',
#
#Using information in Rinci function metadata's `args` property, parse command
#line arguments `@argv` into hash `%args`, suitable for passing into subroutines.
#
#Currently uses <pm:Getopt::Long>'s `GetOptions` to do the parsing.
#
#As with GetOptions, this function modifies its `argv` argument, so you might
#want to copy the original `argv` first (or pass a copy instead) if you want to
#preserve the original.
#
#See also: gen_getopt_long_spec_from_meta() which is the routine that generates
#the specification.
#
#_
#    args => {
#        argv => {
#            schema => ['array*' => {
#                of => 'str*',
#            }],
#            description => 'If not specified, defaults to @ARGV',
#        },
#        args => {
#            summary => 'Specify input args, with some arguments preset',
#            schema  => ['hash'],
#        },
#        meta => {
#            schema => ['hash*' => {}],
#            req => 1,
#        },
#        meta_is_normalized => {
#            summary => 'Can be set to 1 if your metadata is normalized, '.
#                'to avoid duplicate effort',
#            schema => 'bool',
#            default => 0,
#        },
#        strict => {
#            schema => ['bool' => {default=>1}],
#            summary => 'Strict mode',
#            description => <<'_',
#
#If set to 0, will still return parsed argv even if there are parsing errors
#(reported by Getopt::Long). If set to 1 (the default), will die upon error.
#
#Normally you would want to use strict mode, for more error checking. Setting off
#strict is used by, for example, Perinci::Sub::Complete during completion where
#the command-line might still be incomplete.
#
#Should probably be named `ignore_errors`. :-)
#
#_
#        },
#        per_arg_yaml => {
#            schema => ['bool' => {default=>0}],
#            summary => 'Whether to recognize --ARGNAME-yaml',
#            description => <<'_',
#
#This is useful for example if you want to specify a value which is not
#expressible from the command-line, like 'undef'.
#
#    % script.pl --name-yaml '~'
#
#See also: per_arg_json. You should enable just one instead of turning on both.
#
#_
#        },
#        per_arg_json => {
#            schema => ['bool' => {default=>0}],
#            summary => 'Whether to recognize --ARGNAME-json',
#            description => <<'_',
#
#This is useful for example if you want to specify a value which is not
#expressible from the command-line, like 'undef'.
#
#    % script.pl --name-json 'null'
#
#But every other string will need to be quoted:
#
#    % script.pl --name-json '"foo"'
#
#See also: per_arg_yaml. You should enable just one instead of turning on both.
#
#_
#        },
#        common_opts => {
#            summary => 'Common options',
#            description => <<'_',
#
#A hash where the values are hashes containing these keys: `getopt` (Getopt::Long
#option specification), `handler` (Getopt::Long handler). Will be passed to
#`get_args_from_argv()`. Example:
#
#    {
#        help => {
#            getopt  => 'help|h|?',
#            handler => sub { ... },
#            summary => 'Display help and exit',
#        },
#        version => {
#            getopt  => 'version|v',
#            handler => sub { ... },
#            summary => 'Display version and exit',
#        },
#    }
#
#_
#            schema => ['hash*'],
#        },
#        allow_extra_elems => {
#            schema => ['bool' => {default=>0}],
#            summary => 'Allow extra/unassigned elements in argv',
#            description => <<'_',
#
#If set to 1, then if there are array elements unassigned to one of the
#arguments, instead of generating an error, this function will just ignore them.
#
#This option will be passed to Perinci::Sub::GetArgs::Array's allow_extra_elems.
#
#_
#        },
#        on_missing_required_args => {
#            schema => 'code',
#            summary => 'Execute code when there is missing required args',
#            description => <<'_',
#
#This can be used to give a chance to supply argument value from other sources if
#not specified by command-line options. Perinci::CmdLine, for example, uses this
#hook to supply value from STDIN or file contents (if argument has `cmdline_src`
#specification key set).
#
#This hook will be called for each missing argument. It will be supplied hash
#arguments: (arg => $the_missing_argument_name, args =>
#$the_resulting_args_so_far, spec => $the_arg_spec).
#
#The hook can return true if it succeeds in making the missing situation
#resolved. In this case, this function will not report the argument as missing.
#
#_
#        },
#        ignore_converted_code => {
#            summary => 'Whether to ignore coderefs converted to string',
#            schema => 'bool',
#            default => 0,
#            description => <<'_',
#
#Across network through JSON encoding, coderef in metadata (e.g. in
#`cmdline_aliases` property) usually gets converted to string `CODE`. In some
#cases, like for tab completion, this is harmless so you can turn this option on.
#
#_
#        },
#        ggls_res => {
#            summary => 'Full result from gen_getopt_long_spec_from_meta()',
#            schema  => 'array*', 
#            description => <<'_',
#
#If you already call `gen_getopt_long_spec_from_meta()`, you can pass the _full_ enveloped result
#here, to avoid calculating twice.
#
#_
#            tags => ['category:optimization'],
#        },
#    },
#    result => {
#        description => <<'_',
#
#Error codes:
#
#* 400 - Error in Getopt::Long option specification, e.g. in common_opts.
#
#* 500 - failure in GetOptions, meaning argv is not valid according to metadata
#  specification (only if 'strict' mode is enabled).
#
#* 501 - coderef in cmdline_aliases got converted into a string, probably because
#  the metadata was transported (e.g. through Riap::HTTP/Riap::Simple).
#
#_
#    },
#};
#sub get_args_from_argv {
#    require Getopt::Long;
#
#    my %fargs = @_;
#    my $argv       = $fargs{argv} // \@ARGV;
#    my $meta       = $fargs{meta} or return [400, "Please specify meta"];
#    unless ($fargs{meta_is_normalized}) {
#        require Perinci::Sub::Normalize;
#        $meta = Perinci::Sub::Normalize::normalize_function_metadata($meta);
#    }
#    my $strict            = $fargs{strict} // 1;
#    my $common_opts       = $fargs{common_opts} // {};
#    my $per_arg_yaml      = $fargs{per_arg_yaml} // 0;
#    my $per_arg_json      = $fargs{per_arg_json} // 0;
#    my $allow_extra_elems = $fargs{allow_extra_elems} // 0;
#    my $on_missing        = $fargs{on_missing_required_args};
#    my $ignore_converted_code = $fargs{ignore_converted_code};
#
#    my $rargs = $fargs{args} // {};
#
#    my $genres = $fargs{ggls_res} // gen_getopt_long_spec_from_meta(
#        meta => $meta, meta_is_normalized => 1,
#        args => $rargs,
#        common_opts  => $common_opts,
#        per_arg_json => $per_arg_json,
#        per_arg_yaml => $per_arg_yaml,
#        ignore_converted_code => $ignore_converted_code,
#    );
#    return err($genres->[0], "Can't generate Getopt::Long spec", $genres)
#        if $genres->[0] != 200;
#    my $go_spec = $genres->[2];
#
#    {
#        local $SIG{__WARN__} = sub{} if !$strict;
#        my $old_go_conf = Getopt::Long::Configure(
#            $strict ? "no_pass_through" : "pass_through",
#            "no_ignore_case", "permute", "no_getopt_compat", "gnu_compat", "bundling");
#        my $res = Getopt::Long::GetOptionsFromArray($argv, %$go_spec);
#        Getopt::Long::Configure($old_go_conf);
#        unless ($res) {
#            return [500, "GetOptions failed"] if $strict;
#        }
#    }
#
#
#    my $args_prop = $meta->{args};
#
#    if (@$argv) {
#        my $res = get_args_from_array(
#            array=>$argv, meta => $meta,
#            meta_is_normalized => 1,
#            allow_extra_elems => $allow_extra_elems,
#        );
#        if ($res->[0] != 200 && $strict) {
#            return err(500, "Get args from array failed", $res);
#        } elsif ($strict && $res->[0] != 200) {
#            return err("Can't get args from argv", $res);
#        } elsif ($res->[0] == 200) {
#            my $pos_args = $res->[2];
#            for my $name (keys %$pos_args) {
#                my $arg_spec = $args_prop->{$name};
#                my $val      = $pos_args->{$name};
#                if (exists $rargs->{$name}) {
#                    return [400, "You specified option --$name but also ".
#                                "argument #".$arg_spec->{pos}] if $strict;
#                }
#                my ($is_simple, $is_array_of_simple, $is_hash_of_simple, $type, $cset, $eltype) =
#                    _is_simple_or_array_of_simple_or_hash_of_simple($arg_spec->{schema});
#
#                if ($arg_spec->{greedy} && ref($val) eq 'ARRAY' &&
#                        !$is_array_of_simple && !$is_hash_of_simple) {
#                    my $i = 0;
#                    for (@$val) {
#                      TRY_PARSING_AS_JSON_YAML:
#                        {
#                            my ($success, $e, $decoded);
#                            if ($per_arg_json) {
#                                ($success, $e, $decoded) = _parse_json($_);
#                                if ($success) {
#                                    $_ = $decoded;
#                                    last TRY_PARSING_AS_JSON_YAML;
#                                } else {
#                                    warn "Failed trying to parse argv #$i as JSON: $e";
#                                }
#                            }
#                            if ($per_arg_yaml) {
#                                ($success, $e, $decoded) = _parse_yaml($_);
#                                if ($success) {
#                                    $_ = $decoded;
#                                    last TRY_PARSING_AS_JSON_YAML;
#                                } else {
#                                    warn "Failed trying to parse argv #$i as YAML: $e";
#                                }
#                            }
#                        }
#                        $i++;
#                    }
#                }
#                if (!$arg_spec->{greedy} && !$is_simple) {
#                  TRY_PARSING_AS_JSON_YAML:
#                    {
#                        my ($success, $e, $decoded);
#                        if ($per_arg_json) {
#                            ($success, $e, $decoded) = _parse_json($val);
#                            if ($success) {
#                                $val = $decoded;
#                                last TRY_PARSING_AS_JSON_YAML;
#                            } else {
#                                warn "Failed trying to parse argv #$arg_spec->{pos} as JSON: $e";
#                            }
#                        }
#                        if ($per_arg_yaml) {
#                            ($success, $e, $decoded) = _parse_yaml($val);
#                            if ($success) {
#                                $val = $decoded;
#                                last TRY_PARSING_AS_JSON_YAML;
#                            } else {
#                                warn "Failed trying to parse argv #$arg_spec->{pos} as YAML: $e";
#                            }
#                        }
#                    }
#                }
#                $rargs->{$name} = $val;
#                if ($arg_spec->{cmdline_on_getopt}) {
#                    if ($arg_spec->{greedy}) {
#                        $arg_spec->{cmdline_on_getopt}->(
#                            arg=>$name, fqarg=>$name, value=>$_, args=>$rargs,
#                            opt=>undef, 
#                        ) for @$val;
#                    } else {
#                        $arg_spec->{cmdline_on_getopt}->(
#                            arg=>$name, fqarg=>$name, value=>$val, args=>$rargs,
#                            opt=>undef, 
#                        );
#                    }
#                }
#            }
#        }
#    }
#
#
#    my %missing_args;
#    for my $arg (keys %$args_prop) {
#        my $arg_spec = $args_prop->{$arg};
#        if (!exists($rargs->{$arg})) {
#            next unless $arg_spec->{req};
#            if ($on_missing) {
#                next if $on_missing->(arg=>$arg, args=>$rargs, spec=>$arg_spec);
#            }
#            next if exists $rargs->{$arg};
#            $missing_args{$arg} = 1;
#        }
#    }
#
#    {
#        last unless $strict;
#
#        for my $arg (keys %$args_prop) {
#            my $arg_spec = $args_prop->{$arg};
#            next unless exists $rargs->{$arg};
#            next unless $arg_spec->{deps};
#            my $dep_arg = $arg_spec->{deps}{arg};
#            next unless $dep_arg;
#            return [400, "You specify '$arg', but don't specify '$dep_arg' ".
#                        "(upon which '$arg' depends)"]
#                unless exists $rargs->{$dep_arg};
#        }
#    }
#
#    [200, "OK", $rargs, {
#        "func.missing_args" => [sort keys %missing_args],
#        "func.gen_getopt_long_spec_result" => $genres,
#    }];
#}
#
#1;
#
#__END__
#
### Perinci/Sub/GetArgs/Array.pm ###
#package Perinci::Sub::GetArgs::Array;
#
#our $DATE = '2016-12-10'; 
#our $VERSION = '0.16'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(get_args_from_array);
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#};
#
#$SPEC{get_args_from_array} = {
#    v => 1.1,
#    summary => 'Get subroutine arguments (%args) from array',
#    description => <<'_',
#
#Using information in metadata's `args` property (particularly the `pos` and
#`greedy` arg type clauses), extract arguments from an array into a hash
#`\%args`, suitable for passing into subs.
#
#Example:
#
#    my $meta = {
#        v => 1.1,
#        summary => 'Multiply 2 numbers (a & b)',
#        args => {
#            a => {schema=>'num*', pos=>0},
#            b => {schema=>'num*', pos=>1},
#        }
#    }
#
#then `get_args_from_array(array=>[2, 3], meta=>$meta)` will produce:
#
#    [200, "OK", {a=>2, b=>3}]
#
#_
#    args => {
#        array => {
#            schema => ['array*' => {}],
#            req => 1,
#            description => <<'_',
#
#NOTE: array will be modified/emptied (elements will be taken from the array as
#they are put into the resulting args). Copy your array first if you want to
#preserve its content.
#
#_
#        },
#        meta => {
#            schema => ['hash*' => {}],
#            req => 1,
#        },
#        meta_is_normalized => {
#            summary => 'Can be set to 1 if your metadata is normalized, '.
#                'to avoid duplicate effort',
#            schema => 'bool',
#            default => 0,
#        },
#        allow_extra_elems => {
#            schema => ['bool' => {default=>0}],
#            summary => 'Allow extra/unassigned elements in array',
#            description => <<'_',
#
#If set to 1, then if there are array elements unassigned to one of the arguments
#(due to missing `pos`, for example), instead of generating an error, the
#function will just ignore them.
#
#_
#        },
#    },
#};
#sub get_args_from_array {
#    my %fargs = @_;
#    my $ary  = $fargs{array} or return [400, "Please specify array"];
#    my $meta = $fargs{meta} or return [400, "Please specify meta"];
#    unless ($fargs{meta_is_normalized}) {
#        require Perinci::Sub::Normalize;
#        $meta = Perinci::Sub::Normalize::normalize_function_metadata(
#            $meta);
#    }
#    my $allow_extra_elems = $fargs{allow_extra_elems} // 0;
#
#    my $rargs = {};
#
#    my $args_p = $meta->{args} // {};
#    for my $i (reverse 0..@$ary-1) {
#        while (my ($a, $as) = each %$args_p) {
#            my $o = $as->{pos};
#            if (defined($o) && $o == $i) {
#                if ($as->{greedy}) {
#                    my $type = $as->{schema}[0];
#                    my @elems = splice(@$ary, $i);
#                    if ($type eq 'array') {
#                        $rargs->{$a} = \@elems;
#                    } elsif ($type eq 'hash') {
#                        $rargs->{$a} = {};
#                        for my $j (0..$#elems) {
#                            my $elem = $elems[$j];
#                            unless ($elem =~ /(.*?)=(.*)/) {
#                                return [400, "Invalid key=value pair in element #$j"];
#                            }
#                            $rargs->{$a}{$1} = $2;
#                        }
#                    } else {
#                        $rargs->{$a} = join " ", @elems;
#                    }
#                } else {
#                    $rargs->{$a} = splice(@$ary, $i, 1);
#                }
#            }
#        }
#    }
#
#    return [400, "There are extra, unassigned elements in array: [".
#                join(", ", @$ary)."]"] if @$ary && !$allow_extra_elems;
#
#    [200, "OK", $rargs];
#}
#
#1;
#
#__END__
#
### Perinci/Sub/Normalize.pm ###
#package Perinci::Sub::Normalize;
#
#our $DATE = '2018-09-10'; 
#our $VERSION = '0.200'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       normalize_function_metadata
#               );
#
#sub _normalize{
#    my ($meta, $ver, $opts, $proplist, $nmeta, $prefix, $modprefix) = @_;
#
#    my $opt_aup = $opts->{allow_unknown_properties};
#    my $opt_nss = $opts->{normalize_sah_schemas};
#    my $opt_rip = $opts->{remove_internal_properties};
#
#    if (defined $ver) {
#        defined($meta->{v}) && $meta->{v} eq $ver
#            or die "$prefix: Metadata version must be $ver";
#    }
#
#  KEY:
#    for my $k (keys %$meta) {
#        die "Invalid prop/attr syntax '$k', must be word/dotted-word only"
#            unless $k =~ /\A(\w+)(?:\.(\w+(?:\.\w+)*))?(?:\((\w+)\))?\z/;
#
#        my ($prop, $attr);
#        if (defined $3) {
#            $prop = $1;
#            $attr = defined($2) ? "$2.alt.lang.$3" : "alt.lang.$3";
#        } else {
#            $prop = $1;
#            $attr = $2;
#        }
#
#        my $nk = "$prop" . (defined($attr) ? ".$attr" : "");
#
#        if ($prop =~ /\A_/ || defined($attr) && $attr =~ /\A_|\._/) {
#            unless ($opt_rip) {
#                $nmeta->{$nk} = $meta->{$k};
#            }
#            next KEY;
#        }
#
#        my $prop_proplist = $proplist->{$prop};
#
#        if (!$opt_aup && !$prop_proplist) {
#            $modprefix //= $prefix;
#            my $mod = "Perinci/Sub/Property$modprefix/$prop.pm";
#            eval { require $mod };
#            if ($@) {
#                die "Unknown property '$prefix/$prop' (and couldn't ".
#                    "load property module '$mod'): $@" if $@;
#            }
#            $prop_proplist = $proplist->{$prop};
#        }
#        die "Unknown property '$prefix/$prop'"
#            unless $opt_aup || $prop_proplist;
#
#        if ($prop_proplist && $prop_proplist->{_prop}) {
#            die "Property '$prefix/$prop' must be a hash"
#                unless ref($meta->{$k}) eq 'HASH';
#            $nmeta->{$nk} = {};
#            _normalize(
#                $meta->{$k},
#                $prop_proplist->{_ver},
#                $opts,
#                $prop_proplist->{_prop},
#                $nmeta->{$nk},
#                "$prefix/$prop",
#            );
#        } elsif ($prop_proplist && $prop_proplist->{_elem_prop}) {
#            die "Property '$prefix/$prop' must be an array"
#                unless ref($meta->{$k}) eq 'ARRAY';
#            $nmeta->{$nk} = [];
#            my $i = 0;
#            for (@{ $meta->{$k} }) {
#                my $href = {};
#                if (ref($_) eq 'HASH') {
#                    _normalize(
#                        $_,
#                        $prop_proplist->{_ver},
#                        $opts,
#                        $prop_proplist->{_elem_prop},
#                        $href,
#                        "$prefix/$prop/$i",
#                    );
#                    push @{ $nmeta->{$nk} }, $href;
#                } else {
#                    push @{ $nmeta->{$nk} }, $_;
#                }
#                $i++;
#            }
#        } elsif ($prop_proplist && $prop_proplist->{_value_prop}) {
#            die "Property '$prefix/$prop' must be a hash"
#                unless ref($meta->{$k}) eq 'HASH';
#            $nmeta->{$nk} = {};
#            for (keys %{ $meta->{$k} }) {
#                $nmeta->{$nk}{$_} = {};
#                die "Property '$prefix/$prop/$_' must be a hash"
#                    unless ref($meta->{$k}{$_}) eq 'HASH';
#                _normalize(
#                    $meta->{$k}{$_},
#                    $prop_proplist->{_ver},
#                    $opts,
#                    $prop_proplist->{_value_prop},
#                    $nmeta->{$nk}{$_},
#                    "$prefix/$prop/$_",
#                    ($prop eq 'args' ? "$prefix/arg" : undef),
#                );
#            }
#        } else {
#            if ($k eq 'schema' && $opt_nss) { 
#                require Data::Sah::Normalize;
#                $nmeta->{$nk} = Data::Sah::Normalize::normalize_schema(
#                    $meta->{$k});
#            } else {
#                $nmeta->{$nk} = $meta->{$k};
#            }
#        }
#    }
#
#    $nmeta;
#}
#
#sub normalize_function_metadata($;$) {
#    my ($meta, $opts) = @_;
#
#    $opts //= {};
#
#    $opts->{allow_unknown_properties}    //= 0;
#    $opts->{normalize_sah_schemas}       //= 1;
#    $opts->{remove_internal_properties}  //= 0;
#
#    require Sah::Schema::rinci::function_meta;
#    my $sch = $Sah::Schema::rinci::function_meta::schema;
#    my $sch_proplist = $sch->[1]{_prop}
#        or die "BUG: Rinci schema structure changed (1a)";
#
#    _normalize($meta, 1.1, $opts, $sch_proplist, {}, '');
#}
#
#1;
#
#__END__
#
### Perinci/Sub/To/CLIDocData.pm ###
#package Perinci::Sub::To::CLIDocData;
#
#our $DATE = '2016-10-27'; 
#our $VERSION = '0.28'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Perinci::Object;
#use Perinci::Sub::Util qw(err);
#
#our %SPEC;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(gen_cli_doc_data_from_meta);
#
#sub _has_cats {
#    for my $spec (@{ $_[0] }) {
#        for (@{ $spec->{tags} // [] }) {
#            my $tag_name = ref($_) ? $_->{name} : $_;
#            if ($tag_name =~ /^category:/) {
#                return 1;
#            }
#        }
#    }
#    0;
#}
#
#sub _add_category_from_spec {
#    my ($cats_spec, $thing, $spec, $noun, $has_cats) = @_;
#    my @cats;
#    for (@{ $spec->{tags} // [] }) {
#        my $tag_name = ref($_) ? $_->{name} : $_;
#        if ($tag_name =~ /^category(\d+)?:(.+)/) {
#            my $cat = ucfirst($2);
#            my $ordering = $1 // 50;
#            $cat =~ s/-/ /g;
#            $cat .= " " . $noun;
#            push @cats, [$cat, $ordering]; 
#        }
#    }
#    if (!@cats) {
#        @cats = [$has_cats ? "Other $noun" : ucfirst($noun), 99]; 
#    }
#
#    $thing->{category} = $cats[0][0];
#    $thing->{categories} = [map {$_->[0]} @cats];
#
#    $cats_spec->{$_->[0]}{order} //= $_->[1] for @cats;
#}
#
#sub _add_default_from_arg_spec {
#    my ($opt, $arg_spec) = @_;
#    if (exists $arg_spec->{default}) {
#        $opt->{default} = $arg_spec->{default};
#    } elsif ($arg_spec->{schema} && exists($arg_spec->{schema}[1]{default})) {
#        $opt->{default} = $arg_spec->{schema}[1]{default};
#    }
#}
#
#sub _dash_prefix {
#    length($_[0]) > 1 ? "--$_[0]" : "-$_[0]";
#}
#
#sub _fmt_opt {
#    my $spec = shift;
#    my @ospecs = @_;
#    my @res;
#    my $i = 0;
#    for my $ospec (@ospecs) {
#        my $j = 0;
#        my $parsed = $ospec->{parsed};
#        for (@{ $parsed->{opts} }) {
#            my $opt = _dash_prefix($_);
#            if ($i==0 && $j==0) {
#                if ($parsed->{type}) {
#                    if ($spec->{'x.schema.entity'}) {
#                        $opt .= "=".$spec->{'x.schema.entity'};
#                    } elsif ($spec->{'x.schema.element_entity'}) {
#                        $opt .= "=".$spec->{'x.schema.element_entity'};
#                    } else {
#                        $opt .= "=$parsed->{type}";
#                    }
#                }
#                $opt .= "*" if $spec->{req} && !$ospec->{is_base64} &&
#                    !$ospec->{is_json} && !$ospec->{is_yaml};
#            }
#            push @res, $opt;
#            $j++;
#        }
#        $i++;
#    }
#    join ", ", @res;
#}
#
#$SPEC{gen_cli_doc_data_from_meta} = {
#    v => 1.1,
#    summary => 'From Rinci function metadata, generate structure convenient '.
#        'for producing CLI documentation (help/usage/POD)',
#    description => <<'_',
#
#This function calls <pm:Perinci::Sub::GetArgs::Argv>'s
#`gen_getopt_long_spec_from_meta()` (or receive its result as an argument, if
#passed, to avoid calling the function twice) and post-processes it: produce
#command usage line, format the options, include information from metadata, group
#the options by category. It also selects examples in the `examples` property
#which are applicable to CLI environment and format them.
#
#The resulting data structure is convenient to use when one wants to produce a
#documentation for CLI program (including help/usage message and POD).
#
#_
#    args => {
#        meta => {
#            schema => 'hash*', 
#            req => 1,
#            pos => 0,
#        },
#        meta_is_normalized => {
#            schema => 'bool*',
#        },
#        common_opts => {
#            summary => 'Will be passed to gen_getopt_long_spec_from_meta()',
#            schema  => 'hash*',
#        },
#        ggls_res => {
#            summary => 'Full result from gen_getopt_long_spec_from_meta()',
#            schema  => 'array*', 
#            description => <<'_',
#
#If you already call <pm:Perinci::Sub::GetArgs::Argv>'s
#`gen_getopt_long_spec_from_meta()`, you can pass the _full_ enveloped result
#here, to avoid calculating twice. What will be useful for the function is the
#extra result in result metadata (`func.*` keys in `$res->[3]` hash).
#
#_
#        },
#        per_arg_json => {
#            schema => 'bool',
#            summary => 'Pass per_arg_json=1 to Perinci::Sub::GetArgs::Argv',
#        },
#        per_arg_yaml => {
#            schema => 'bool',
#            summary => 'Pass per_arg_json=1 to Perinci::Sub::GetArgs::Argv',
#        },
#        lang => {
#            schema => 'str*',
#        },
#    },
#    result => {
#        schema => 'hash*',
#    },
#};
#sub gen_cli_doc_data_from_meta {
#    require Getopt::Long::Negate::EN;
#
#    my %args = @_;
#
#    my $lang = $args{lang};
#    my $meta = $args{meta} or return [400, 'Please specify meta'];
#    my $common_opts = $args{common_opts};
#    unless ($args{meta_is_normalized}) {
#        require Perinci::Sub::Normalize;
#        $meta = Perinci::Sub::Normalize::normalize_function_metadata($meta);
#    }
#    my $ggls_res = $args{ggls_res} // do {
#        require Perinci::Sub::GetArgs::Argv;
#        Perinci::Sub::GetArgs::Argv::gen_getopt_long_spec_from_meta(
#            meta=>$meta, meta_is_normalized=>1, common_opts=>$common_opts,
#            per_arg_json => $args{per_arg_json},
#            per_arg_yaml => $args{per_arg_yaml},
#        );
#    };
#    $ggls_res->[0] == 200 or return $ggls_res;
#
#    my $args_prop = $meta->{args} // {};
#    my $clidocdata = {
#        option_categories => {},
#        example_categories => {},
#    };
#
#    {
#        my @args;
#        my %args_prop = %$args_prop; 
#        my $max_pos = -1;
#        for (values %args_prop) {
#            $max_pos = $_->{pos}
#                if defined($_->{pos}) && $_->{pos} > $max_pos;
#        }
#        my $pos = 0;
#        while ($pos <= $max_pos) {
#            my ($arg, $arg_spec);
#            for (keys %args_prop) {
#                $arg_spec = $args_prop{$_};
#                if (defined($arg_spec->{pos}) && $arg_spec->{pos}==$pos) {
#                    $arg = $_;
#                    last;
#                }
#            }
#            $pos++;
#            next unless defined($arg);
#            if ($arg_spec->{greedy}) {
#                $arg = $arg_spec->{'x.name.singular'}
#                    if $arg_spec->{'x.name.is_plural'} &&
#                    defined $arg_spec->{'x.name.singular'};
#            }
#            if ($arg_spec->{req}) {
#                push @args, "<$arg>";
#            } else {
#                push @args, "[$arg]";
#            }
#            $args[-1] .= " ..." if $arg_spec->{greedy};
#            delete $args_prop{$arg};
#        }
#        unshift @args, "[options]" if keys(%args_prop) || keys(%$common_opts); 
#        $clidocdata->{usage_line} = "[[prog]]".
#            (@args ? " ".join(" ", @args) : "");
#    }
#
#    my %opts;
#    {
#        my $ospecs = $ggls_res->[3]{'func.specmeta'};
#        my (@k, @k_aliases);
#      OSPEC1:
#        for (sort keys %$ospecs) {
#            my $ospec = $ospecs->{$_};
#            {
#                last unless $ospec->{is_alias};
#                next if $ospec->{is_code};
#                my $arg_spec = $args_prop->{$ospec->{arg}};
#                my $alias_spec = $arg_spec->{cmdline_aliases}{$ospec->{alias}};
#                next if $alias_spec->{summary};
#                push @k_aliases, $_;
#                next OSPEC1;
#            }
#            push @k, $_;
#        }
#
#        my %negs; 
#
#      OSPEC2:
#        while (@k) {
#            my $k = shift @k;
#            my $ospec = $ospecs->{$k};
#            my $opt;
#            my $optkey;
#
#            if ($ospec->{is_alias} || defined($ospec->{arg})) {
#                my $arg_spec;
#                my $alias_spec;
#
#                if ($ospec->{is_alias}) {
#
#                    $arg_spec = $args_prop->{ $ospec->{arg} };
#                    $alias_spec = $arg_spec->{cmdline_aliases}{$ospec->{alias}};
#                    my $rimeta = rimeta($alias_spec);
#                    $optkey = _fmt_opt($arg_spec, $ospec);
#                    $opt = {
#                        opt_parsed => $ospec->{parsed},
#                        orig_opt => $k,
#                        is_alias => 1,
#                        alias_for => $ospec->{alias_for},
#                        summary => $rimeta->langprop({lang=>$lang}, 'summary') //
#                            "Alias for "._dash_prefix($ospec->{parsed}{opts}[0]),
#                        description =>
#                            $rimeta->langprop({lang=>$lang}, 'description'),
#                    };
#                } else {
#
#                    $arg_spec = $args_prop->{$ospec->{arg}};
#                    my $rimeta = rimeta($arg_spec);
#                    $opt = {
#                        opt_parsed => $ospec->{parsed},
#                        orig_opt => $k,
#                    };
#
#                    if (defined($ospec->{is_neg})) {
#                        my $default = $arg_spec->{default} //
#                            $arg_spec->{schema}[1]{default};
#                        next OSPEC2 if  $default && !$ospec->{is_neg};
#                        next OSPEC2 if !$default &&  $ospec->{is_neg};
#                        if ($ospec->{is_neg}) {
#                            next OSPEC2 if $negs{$ospec->{arg}}++;
#                        }
#                    }
#
#                    if ($ospec->{is_neg}) {
#                        $opt->{summary} =
#                            $rimeta->langprop({lang=>$lang}, 'summary.alt.bool.not');
#                    } elsif (defined $ospec->{is_neg}) {
#                        $opt->{summary} =
#                            $rimeta->langprop({lang=>$lang}, 'summary.alt.bool.yes') //
#                                $rimeta->langprop({lang=>$lang}, 'summary');
#                    } elsif (($ospec->{parsed}{type}//'') eq 's@') {
#                        $opt->{summary} =
#                            $rimeta->langprop({lang=>$lang}, 'summary.alt.plurality.singular') //
#                                $rimeta->langprop({lang=>$lang}, 'summary');
#                    } else {
#                        $opt->{summary} =
#                            $rimeta->langprop({lang=>$lang}, 'summary');
#                    }
#                    $opt->{description} =
#                        $rimeta->langprop({lang=>$lang}, 'description');
#
#                    my @aliases;
#                    my $j = $#k_aliases;
#                    while ($j >= 0) {
#                        my $aospec = $ospecs->{ $k_aliases[$j] };
#                        {
#                            last unless $aospec->{arg} eq $ospec->{arg};
#                            push @aliases, $aospec;
#                            splice @k_aliases, $j, 1;
#                        }
#                        $j--;
#                    }
#
#                    $optkey = _fmt_opt($arg_spec, $ospec, @aliases);
#                }
#
#                $opt->{arg_spec} = $arg_spec;
#                $opt->{alias_spec} = $alias_spec if $alias_spec;
#
#                for (qw/arg fqarg is_base64 is_json is_yaml/) {
#                    $opt->{$_} = $ospec->{$_} if defined $ospec->{$_};
#                }
#
#                for (qw/req pos greedy is_password links tags/) {
#                    $opt->{$_} = $arg_spec->{$_} if defined $arg_spec->{$_};
#                }
#
#                {
#                    local $arg_spec->{tags} = ['category0:main']
#                        if !$arg_spec->{tags} || !@{$arg_spec->{tags}};
#                    _add_category_from_spec($clidocdata->{option_categories},
#                                            $opt, $arg_spec, "options", 1);
#                }
#                _add_default_from_arg_spec($opt, $arg_spec);
#
#            } else {
#
#                my $spec = $common_opts->{$ospec->{common_opt}};
#
#                my $show_neg = $ospec->{parsed}{is_neg} && $spec->{default};
#
#                local $ospec->{parsed}{opts} = do {
#                    my @opts = Getopt::Long::Negate::EN::negations_for_option(
#                        $ospec->{parsed}{opts}[0]);
#                    [ $opts[0] ];
#                } if $show_neg;
#
#                $optkey = _fmt_opt($spec, $ospec);
#                my $rimeta = rimeta($spec);
#                $opt = {
#                    opt_parsed => $ospec->{parsed},
#                    orig_opt => $k,
#                    common_opt => $ospec->{common_opt},
#                    common_opt_spec => $spec,
#                    summary => $show_neg ?
#                        $rimeta->langprop({lang=>$lang}, 'summary.alt.bool.not') :
#                            $rimeta->langprop({lang=>$lang}, 'summary'),
#                    (schema => $spec->{schema}) x !!$spec->{schema},
#                    ('x.schema.entity' => $spec->{'x.schema.entity'}) x !!$spec->{'x.schema.entity'},
#                    ('x.schema.element_entity' => $spec->{'x.schema.element_entity'}) x !!$spec->{'x.schema.element_entity'},
#                    description =>
#                        $rimeta->langprop({lang=>$lang}, 'description'),
#                    (default => $spec->{default}) x !!(exists($spec->{default}) && !$show_neg),
#                };
#
#                _add_category_from_spec($clidocdata->{option_categories},
#                                        $opt, $spec, "options", 1);
#
#            }
#
#            $opts{$optkey} = $opt;
#        }
#
#      OPT1:
#        for my $k (keys %opts) {
#            my $opt = $opts{$k};
#            next unless $opt->{is_alias} || $opt->{is_base64} ||
#                $opt->{is_json} || $opt->{is_yaml};
#            for my $k2 (keys %opts) {
#                my $arg_opt = $opts{$k2};
#                next if $arg_opt->{is_alias} || $arg_opt->{is_base64} ||
#                    $arg_opt->{is_json} || $arg_opt->{is_yaml};
#                next unless defined($arg_opt->{arg}) &&
#                    $arg_opt->{arg} eq $opt->{arg};
#                $opt->{main_opt} = $k2;
#                next OPT1;
#            }
#        }
#
#    }
#    $clidocdata->{opts} = \%opts;
#
#    my @examples;
#    {
#        my $examples = $meta->{examples} // [];
#        my $has_cats = _has_cats($examples);
#
#        for my $eg (@$examples) {
#            my $rimeta = rimeta($eg);
#            my $argv;
#            my $cmdline;
#            if (defined($eg->{src})) {
#                if ($eg->{src_plang} =~ /^(sh|bash)$/) {
#                    $cmdline = $eg->{src};
#                } else {
#                    next;
#                }
#            } else {
#                require String::ShellQuote;
#                if ($eg->{argv}) {
#                    $argv = $eg->{argv};
#                } else {
#                    require Perinci::Sub::ConvertArgs::Argv;
#                    my $res = Perinci::Sub::ConvertArgs::Argv::convert_args_to_argv(
#                        args => $eg->{args}, meta => $meta, use_pos => 1);
#                    return err($res, 500, "Can't convert args to argv")
#                        unless $res->[0] == 200;
#                    $argv = $res->[2];
#                }
#                $cmdline = "[[prog]]";
#                for my $arg (@$argv) {
#                    my $qarg = String::ShellQuote::shell_quote($arg);
#                    $cmdline .= " $qarg"; 
#                }
#            }
#            my $egdata = {
#                cmdline      => $cmdline,
#                summary      => $rimeta->langprop({lang=>$lang}, 'summary'),
#                description  => $rimeta->langprop({lang=>$lang}, 'description'),
#                example_spec => $eg,
#            };
#            _add_category_from_spec($clidocdata->{example_categories},
#                                    $egdata, $eg, "examples", $has_cats);
#            push @examples, $egdata;
#        }
#    }
#    $clidocdata->{examples} = \@examples;
#
#    [200, "OK", $clidocdata];
#}
#
#1;
#
#__END__
#
### Perinci/Sub/Util.pm ###
#package Perinci::Sub::Util;
#
#our $DATE = '2017-01-31'; 
#our $VERSION = '0.46'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       err
#                       caller
#                       warn_err
#                       die_err
#                       gen_modified_sub
#                       gen_curried_sub
#               );
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Helper when writing functions',
#};
#
#our $STACK_TRACE;
#our @_c; 
#our $_i; 
#sub err {
#    require Scalar::Util;
#
#    my @caller = CORE::caller(1);
#    if (!@caller) {
#        @caller = ("main", "-e", 1, "program");
#    }
#
#    my ($status, $msg, $meta, $prev);
#
#    for (@_) {
#        my $ref = ref($_);
#        if ($ref eq 'ARRAY') { $prev = $_ }
#        elsif ($ref eq 'HASH') { $meta = $_ }
#        elsif (!$ref) {
#            if (Scalar::Util::looks_like_number($_)) {
#                $status = $_;
#            } else {
#                $msg = $_;
#            }
#        }
#    }
#
#    $status //= 500;
#    $msg  //= "$caller[3] failed";
#    $meta //= {};
#    $meta->{prev} //= $prev if $prev;
#
#    if (!$meta->{logs}) {
#
#        my $stack_trace;
#        {
#            no warnings;
#            last unless $STACK_TRACE // $INC{"Carp/Always.pm"};
#            last if $prev && ref($prev->[3]) eq 'HASH' &&
#                ref($prev->[3]{logs}) eq 'ARRAY' &&
#                    ref($prev->[3]{logs}[0]) eq 'HASH' &&
#                        $prev->[3]{logs}[0]{stack_trace};
#            $stack_trace = [];
#            $_i = 1;
#            while (1) {
#                {
#                    package DB;
#                    @_c = CORE::caller($_i);
#                    if (@_c) {
#                        $_c[4] = [@DB::args];
#                    }
#                }
#                last unless @_c;
#                push @$stack_trace, [@_c];
#                $_i++;
#            }
#        }
#        push @{ $meta->{logs} }, {
#            type    => 'create',
#            time    => time(),
#            package => $caller[0],
#            file    => $caller[1],
#            line    => $caller[2],
#            func    => $caller[3],
#            ( stack_trace => $stack_trace ) x !!$stack_trace,
#        };
#    }
#
#    [$status, $msg, undef, $meta];
#}
#
#sub warn_err {
#    require Carp;
#
#    my $res = err(@_);
#    Carp::carp("ERROR $res->[0]: $res->[1]");
#}
#
#sub die_err {
#    require Carp;
#
#    my $res = err(@_);
#    Carp::croak("ERROR $res->[0]: $res->[1]");
#}
#
#sub caller {
#    my $n0 = shift;
#    my $n  = $n0 // 0;
#
#    my $pkg = $Perinci::Sub::Wrapper::default_wrapped_package //
#        'Perinci::Sub::Wrapped';
#
#    my @r;
#    my $i =  0;
#    my $j = -1;
#    while ($i <= $n+1) { 
#        $j++;
#        @r = CORE::caller($j);
#        last unless @r;
#        if ($r[0] eq $pkg && $r[1] =~ /^\(eval /) {
#            next;
#        }
#        $i++;
#    }
#
#    return unless @r;
#    return defined($n0) ? @r : $r[0];
#}
#
#$SPEC{gen_modified_sub} = {
#    v => 1.1,
#    summary => 'Generate modified metadata (and subroutine) based on another',
#    description => <<'_',
#
#Often you'll want to create another sub (and its metadata) based on another, but
#with some modifications, e.g. add/remove/rename some arguments, change summary,
#add/remove some properties, and so on.
#
#Instead of cloning the Rinci metadata and modify it manually yourself, this
#routine provides some shortcuts.
#
#You can specify base sub/metadata using `base_name` (string, subroutine name,
#either qualified or not) or `base_code` (coderef) + `base_meta` (hash).
#
#_
#    args => {
#        base_name => {
#            summary => 'Subroutine name (either qualified or not)',
#            schema => 'str*',
#            description => <<'_',
#
#If not qualified with package name, will be searched in the caller's package.
#Rinci metadata will be searched in `%SPEC` package variable.
#
#Alternatively, you can also specify `base_code` and `base_meta`.
#
#_
#        },
#        base_code => {
#            summary => 'Base subroutine code',
#            schema  => 'code*',
#            description => <<'_',
#
#If you specify this, you'll also need to specify `base_meta`.
#
#Alternatively, you can specify `base_name` instead, to let this routine search
#the base subroutine from existing Perl package.
#
#_
#        },
#        base_meta => {
#            summary => 'Base Rinci metadata',
#            schema  => 'hash*', 
#        },
#        output_name => {
#            summary => 'Where to install the modified sub',
#            schema  => 'str*',
#            description => <<'_',
#
#Subroutine will be put in the specified name. If the name is not qualified with
#package name, will use caller's package. If no `output_code` is specified, the
#base subroutine reference will be assigned here.
#
#Note that this argument is optional.
#
#_
#        },
#        output_code => {
#            summary => 'Code for the modified sub',
#            schema  => 'code*',
#            description => <<'_',
#
#If not specified will use `base_code` (which will then be required).
#
#_
#        },
#        summary => {
#            summary => 'Summary for the mod subroutine',
#            schema  => 'str*',
#        },
#        description => {
#            summary => 'Description for the mod subroutine',
#            schema  => 'str*',
#        },
#        remove_args => {
#            summary => 'List of arguments to remove',
#            schema  => 'array*',
#        },
#        add_args => {
#            summary => 'Arguments to add',
#            schema  => 'hash*',
#        },
#        replace_args => {
#            summary => 'Arguments to add',
#            schema  => 'hash*',
#        },
#        rename_args => {
#            summary => 'Arguments to rename',
#            schema  => 'hash*',
#        },
#        modify_args => {
#            summary => 'Arguments to modify',
#            description => <<'_',
#
#For each argument you can specify a coderef. The coderef will receive the
#argument ($arg_spec) and is expected to modify the argument specification.
#
#_
#            schema  => 'hash*',
#        },
#        modify_meta => {
#            summary => 'Specify code to modify metadata',
#            schema  => 'code*',
#            description => <<'_',
#
#Code will be called with arguments ($meta) where $meta is the cloned Rinci
#metadata.
#
#_
#        },
#        install_sub => {
#            schema  => 'bool',
#            default => 1,
#        },
#    },
#    result => {
#        schema => ['hash*' => {
#            keys => {
#                code => ['code*'],
#                meta => ['hash*'], 
#            },
#        }],
#    },
#};
#sub gen_modified_sub {
#    require Function::Fallback::CoreOrPP;
#
#    my %args = @_;
#
#    my ($base_code, $base_meta);
#    if ($args{base_name}) {
#        my ($pkg, $leaf);
#        if ($args{base_name} =~ /(.+)::(.+)/) {
#            ($pkg, $leaf) = ($1, $2);
#        } else {
#            $pkg  = CORE::caller();
#            $leaf = $args{base_name};
#        }
#        no strict 'refs';
#        $base_code = \&{"$pkg\::$leaf"};
#        $base_meta = ${"$pkg\::SPEC"}{$leaf};
#        die "Can't find Rinci metadata for $pkg\::$leaf" unless $base_meta;
#    } elsif ($args{base_meta}) {
#        $base_meta = $args{base_meta};
#        $base_code = $args{base_code}
#            or die "Please specify base_code";
#    } else {
#        die "Please specify base_name or base_code+base_meta";
#    }
#
#    my $output_meta = Function::Fallback::CoreOrPP::clone($base_meta);
#    my $output_code = $args{output_code} // $base_code;
#
#    for (qw/summary description/) {
#        $output_meta->{$_} = $args{$_} if $args{$_};
#    }
#    if ($args{remove_args}) {
#        delete $output_meta->{args}{$_} for @{ $args{remove_args} };
#    }
#    if ($args{add_args}) {
#        for my $k (keys %{ $args{add_args} }) {
#            my $v = $args{add_args}{$k};
#            die "Can't add arg '$k' in mod sub: already exists"
#                if $output_meta->{args}{$k};
#            $output_meta->{args}{$k} = $v;
#        }
#    }
#    if ($args{replace_args}) {
#        for my $k (keys %{ $args{replace_args} }) {
#            my $v = $args{replace_args}{$k};
#            die "Can't replace arg '$k' in mod sub: doesn't exist"
#                unless $output_meta->{args}{$k};
#            $output_meta->{args}{$k} = $v;
#        }
#    }
#    if ($args{rename_args}) {
#        for my $old (keys %{ $args{rename_args} }) {
#            my $new = $args{rename_args}{$old};
#            my $as = $output_meta->{args}{$old};
#            die "Can't rename arg '$old' in mod sub: doesn't exist" unless $as;
#            die "Can't rename arg '$old'->'$new' in mod sub: ".
#                "new name already exist" if $output_meta->{args}{$new};
#            $output_meta->{args}{$new} = $as;
#            delete $output_meta->{args}{$old};
#        }
#    }
#    if ($args{modify_args}) {
#        for (keys %{ $args{modify_args} }) {
#            $args{modify_args}{$_}->($output_meta->{args}{$_});
#        }
#    }
#    if ($args{modify_meta}) {
#        $args{modify_meta}->($output_meta);
#    }
#
#    if ($args{output_name}) {
#        my ($pkg, $leaf);
#        if ($args{output_name} =~ /(.+)::(.+)/) {
#            ($pkg, $leaf) = ($1, $2);
#        } else {
#            $pkg  = CORE::caller();
#            $leaf = $args{output_name};
#        }
#        no strict 'refs';
#        no warnings 'redefine';
#        *{"$pkg\::$leaf"}       = $output_code if $args{install_sub} // 1;
#        ${"$pkg\::SPEC"}{$leaf} = $output_meta;
#    }
#
#    [200, "OK", {code=>$output_code, meta=>$output_meta}];
#}
#
#$SPEC{gen_curried_sub} = {
#    v => 1.1,
#    summary => 'Generate curried subroutine (and its metadata)',
#    description => <<'_',
#
#This is a more convenient helper than `gen_modified_sub` if you want to create a
#new subroutine that has some of its arguments preset (so they no longer need to
#be present in the new metadata).
#
#For more general needs of modifying a subroutine (e.g. add some arguments,
#modify some arguments, etc) use `gen_modified_sub`.
#
#_
#    args => {
#        base_name => {
#            summary => 'Subroutine name (either qualified or not)',
#            schema => 'str*',
#            description => <<'_',
#
#If not qualified with package name, will be searched in the caller's package.
#Rinci metadata will be searched in `%SPEC` package variable.
#
#_
#            req => 1,
#            pos => 0,
#        },
#        set_args => {
#            summary => 'Arguments to set',
#            schema  => 'hash*',
#        },
#        output_name => {
#            summary => 'Where to install the modified sub',
#            schema  => 'str*',
#            description => <<'_',
#
#Subroutine will be put in the specified name. If the name is not qualified with
#package name, will use caller's package.
#
#_
#            req => 1,
#            pos => 2,
#        },
#    },
#    args_as => 'array',
#    result_naked => 1,
#};
#sub gen_curried_sub {
#    my ($base_name, $set_args, $output_name) = @_;
#
#    my $caller = CORE::caller();
#
#    my ($base_pkg, $base_leaf);
#    if ($base_name =~ /(.+)::(.+)/) {
#        ($base_pkg, $base_leaf) = ($1, $2);
#    } else {
#        $base_pkg  = $caller;
#        $base_leaf = $base_name;
#    }
#
#    my ($output_pkg, $output_leaf);
#    if ($output_name =~ /(.+)::(.+)/) {
#        ($output_pkg, $output_leaf) = ($1, $2);
#    } else {
#        $output_pkg  = $caller;
#        $output_leaf = $output_name;
#    }
#
#    my $base_sub = \&{"$base_pkg\::$base_leaf"};
#
#    my $res = gen_modified_sub(
#        base_name   => "$base_pkg\::$base_leaf",
#        output_name => "$output_pkg\::$output_leaf",
#        output_code => sub {
#            no strict 'refs';
#            $base_sub->(@_, %$set_args);
#        },
#        remove_args => [keys %$set_args],
#        install => 1,
#    );
#
#    die "Can't generate curried sub: $res->[0] - $res->[1]"
#        unless $res->[0] == 200;
#
#    1;
#}
#
#1;
#
#__END__
#
### Perinci/Sub/Util/Args.pm ###
#package Perinci::Sub::Util::Args;
#
#our $DATE = '2017-01-31'; 
#our $VERSION = '0.46'; 
#
#use 5.010001;
#use strict 'subs', 'vars';
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       args_by_tag
#                       argnames_by_tag
#                       func_args_by_tag
#                       func_argnames_by_tag
#                       call_with_its_args
#);
#
#sub args_by_tag {
#    my ($meta, $args, $tag) = @_;
#
#    my @res;
#    my $args_prop = $meta->{args} or return ();
#    my $neg = $tag =~ s/\A!//;
#    for my $argname (keys %$args_prop) {
#        my $argspec = $args_prop->{$argname};
#        if ($neg) {
#            next unless !$argspec->{tags} ||
#                !(grep {$_ eq $tag} @{$argspec->{tags}});
#        } else {
#            next unless $argspec->{tags} &&
#                grep {$_ eq $tag} @{$argspec->{tags}};
#        }
#        push @res, $argname, $args->{$argname}
#            if exists $args->{$argname};
#    }
#    @res;
#}
#
#sub argnames_by_tag {
#    my ($meta, $tag) = @_;
#
#    my @res;
#    my $args_prop = $meta->{args} or return ();
#    my $neg = 1 if $tag =~ s/\A!//;
#    for my $argname (keys %$args_prop) {
#        my $argspec = $args_prop->{$argname};
#        if ($neg) {
#            next unless !$argspec->{tags} ||
#                !(grep {$_ eq $tag} @{$argspec->{tags}});
#        } else {
#            next unless $argspec->{tags} &&
#                grep {$_ eq $tag} @{$argspec->{tags}};
#        }
#        push @res, $argname;
#    }
#    sort @res;
#}
#
#sub _find_meta {
#    my $caller = shift;
#    my $func_name = shift;
#
#    if ($func_name =~ /(.+)::(.+)/) {
#        return ${"$1::SPEC"}{$2};
#    } else {
#        return ${"$caller->[0]::SPEC"}{$func_name};
#    }
#}
#
#sub func_args_by_tag {
#    my ($func_name, $args, $tag) = @_;
#    my $meta = _find_meta([caller(1)], $func_name)
#        or die "Can't find Rinci function metadata for $func_name";
#    args_by_tag($meta, $args, $tag);
#}
#
#sub func_argnames_by_tag {
#    my ($func_name, $tag) = @_;
#    my $meta = _find_meta([caller(1)], $func_name)
#        or die "Can't find Rinci function metadata for $func_name";
#    argnames_by_tag($meta, $tag);
#}
#
#sub call_with_its_args {
#    my ($func_name, $args) = @_;
#
#    my ($meta, $func);
#    if ($func_name =~ /(.+)::(.+)/) {
#        defined &{$func_name}
#            or die "Function $func_name not defined";
#        $func = \&{$func_name};
#        $meta = ${"$1::SPEC"}{$2};
#    } else {
#        my @caller = caller(1);
#        my $fullname = "$caller[0]::$func_name";
#        defined &{$fullname}
#            or die "Function $fullname not defined";
#        $func = \&{$fullname};
#        $meta = ${"$caller[0]::SPEC"}{$func_name};
#    }
#    $meta or die "Can't find Rinci function metadata for $func_name";
#
#    my @args;
#    if ($meta->{args}) {
#        for my $argname (keys %{ $meta->{args} }) {
#            push @args, $argname, $args->{$argname}
#                if exists $args->{$argname};
#        }
#    }
#    $func->(@args);
#}
#
#1;
#
#__END__
#
### Perinci/Sub/Util/ResObj.pm ###
#package Perinci::Sub::Util::ResObj;
#
#our $DATE = '2017-01-31'; 
#our $VERSION = '0.46'; 
#
#use Carp;
#use overload
#    q("") => sub {
#        my $res = shift; "ERROR $err->[0]: $err->[1]\n" . Carp::longmess();
#    };
#
#1;
#
#__END__
#
### Perinci/Sub/Util/Sort.pm ###
#package Perinci::Sub::Util::Sort;
#
#our $DATE = '2017-01-31'; 
#our $VERSION = '0.46'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       sort_args
#               );
#
#our %SPEC;
#
#sub sort_args {
#    my $args = shift;
#    sort {
#        (($args->{$a}{pos} // 9999) <=> ($args->{$b}{pos} // 9999)) ||
#            $a cmp $b
#        } keys %$args;
#}
#
#1;
#
#__END__
#
### Proc/ChildError.pm ###
#package Proc::ChildError;
#
#our $DATE = '2016-01-06'; 
#our $VERSION = '0.04'; 
#
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(explain_child_error);
#
#sub explain_child_error {
#    my $opts;
#    if (ref($_[0]) eq 'HASH') {
#        $opts = shift;
#    } else {
#        $opts = {};
#    }
#
#    my ($num, $str);
#    if (defined $_[0]) {
#        $num = $_[0];
#        $str = $_[1];
#    } else {
#        $num = $?;
#        $str = $!;
#    }
#
#    my $prefix = "";
#    if (defined $opts->{prog}) {
#        $prefix = "$opts->{prog} ";
#    }
#
#    if ($num == -1) {
#        return "${prefix}failed to execute: ".($str ? "$str ":"")."($num)";
#    } elsif ($num & 127) {
#        return sprintf(
#            "${prefix}died with signal %d, %s coredump",
#            ($num & 127),
#            (($num & 128) ? 'with' : 'without'));
#    } else {
#        return sprintf("${prefix}exited with code %d", $num >> 8);
#    }
#}
#
#1;
#
#__END__
#
### Progress/Any.pm ###
#package Progress::Any;
#
#our $DATE = '2018-03-26'; 
#our $VERSION = '0.214'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Time::Duration qw();
#use Time::HiRes qw(time);
#
#sub import {
#    my ($self, @args) = @_;
#    my $caller = caller();
#    for (@args) {
#        if ($_ eq '$progress') {
#            my $progress = $self->get_indicator(task => '');
#            {
#                no strict 'refs';
#                my $v = "$caller\::progress";
#                *$v = \$progress;
#            }
#        } else {
#            die "Unknown import argument: $_";
#        }
#    }
#}
#
#our %indicators;  
#
#our %outputs;     
#
#
#sub _init_indicator {
#    my ($class, $task) = @_;
#
#
#    return $indicators{$task} if $indicators{$task};
#
#    my $progress = bless({
#        task        => $task,
#        title       => $task,
#        target      => undef,
#        pos         => 0,
#        state       => 'stopped',
#
#        _remaining          => undef,
#        _set_remaining_time => undef,
#        _elapsed            => 0,
#        _start_time         => 0,
#    }, $class);
#    $indicators{$task} = $progress;
#
#    if ($task =~ s/\.?\w+\z//) {
#        $class->_init_indicator($task);
#    }
#
#    $progress;
#}
#
#sub get_indicator {
#    my ($class, %args) = @_;
#
#    my %oargs = %args;
#
#    my $task   = delete($args{task});
#    if (!defined($task)) {
#        my @caller = caller(0);
#        $task = $caller[0] eq '(eval)' ? 'main' : $caller[0];
#        $task =~ s/::/./g;
#        $task =~ s/[^.\w]+/_/g;
#    }
#    die "Invalid task syntax '$task', please only use dotted words"
#        unless $task =~ /\A(?:\w+(\.\w+)*)?\z/;
#
#    my %uargs;
#
#    my $p = $class->_init_indicator($task);
#    for my $an (qw/title target pos remaining state/) {
#        if (exists $args{$an}) {
#            $uargs{$an} = delete($args{$an});
#        }
#    }
#    die "Unknown argument(s) to get_indicator(): ".join(", ", keys(%args))
#        if keys(%args);
#    $p->_update(%uargs) if keys %uargs;
#
#    $p;
#}
#
#my %attrs = (
#    title     => {is => 'rw'},
#    target    => {is => 'rw'},
#    pos       => {is => 'rw'},
#    state     => {is => 'rw'},
#);
#
#for my $an (keys %attrs) {
#    next if $attrs{$an}{manual};
#    my $code;
#    if ($attrs{$an}{is} eq 'rw') {
#        $code = sub {
#            my $self = shift;
#            if (@_) {
#                $self->_update($an => shift);
#            }
#            $self->{$an};
#        };
#    } else {
#        $code = sub {
#            my $self = shift;
#            die "Can't set value, $an is an ro attribute" if @_;
#            $self->{$an};
#        };
#    }
#    no strict 'refs';
#    *{$an} = $code;
#}
#
#sub elapsed {
#    my $self = shift;
#
#    if ($self->{state} eq 'started') {
#        return $self->{_elapsed} + (time()-$self->{_start_time});
#    } else {
#        return $self->{_elapsed};
#    }
#}
#
#sub total_pos {
#    my $self = shift;
#
#    my $t = $self->{task};
#
#    my $res = $self->{pos};
#    for (keys %indicators) {
#        if ($t eq '') {
#            next if $_ eq '';
#        } else {
#            next unless index($_, "$t.") == 0;
#        }
#        $res += $indicators{$_}{pos};
#    }
#    $res;
#}
#
#sub total_target {
#    my $self = shift;
#
#    my $t = $self->{task};
#
#    my $res = $self->{target};
#    return undef unless defined($res);
#
#    for (keys %indicators) {
#        if ($t eq '') {
#            next if $_ eq '';
#        } else {
#            next unless index($_, "$t.") == 0;
#        }
#        return undef unless defined $indicators{$_}{target};
#        $res += $indicators{$_}{target};
#    }
#    $res;
#}
#
#sub percent_complete {
#    my $self = shift;
#
#    my $total_pos    = $self->total_pos;
#    my $total_target = $self->total_target;
#
#    return undef unless defined($total_target);
#    if ($total_target == 0) {
#        if ($self->{state} eq 'finished') {
#            return 100;
#        } else {
#            return 0;
#        }
#    } else {
#        return $total_pos / $total_target * 100;
#    }
#}
#
#sub remaining {
#    my $self = shift;
#
#    if (defined $self->{_remaining}) {
#        if ($self->{state} eq 'started') {
#            my $r = $self->{_remaining}-(time()-$self->{_set_remaining_time});
#            return $r > 0 ? $r : 0;
#        } else {
#            return $self->{_remaining};
#        }
#    } else {
#        if (defined $self->{target}) {
#            if ($self->{pos} == 0) {
#                return 0;
#            } else {
#                return ($self->{target} - $self->{pos})/$self->{pos} *
#                    $self->elapsed;
#            }
#        } else {
#            return undef;
#        }
#    }
#}
#
#sub total_remaining {
#    my $self = shift;
#
#    my $t = $self->{task};
#
#    my $res = $self->remaining;
#    return undef unless defined $res;
#
#    for (keys %indicators) {
#        if ($t eq '') {
#            next if $_ eq '';
#        } else {
#            next unless index($_, "$t.") == 0;
#        }
#        my $res2 = $indicators{$_}->remaining;
#        return undef unless defined $res2;
#        $res += $res2;
#    }
#    $res;
#}
#
#sub _update {
#    my ($self, %args) = @_;
#
#
#    my $now = time();
#
#    my $task = $self->{task};
#
#  SET_TITLE:
#    {
#        last unless exists $args{title};
#        my $val = $args{title};
#        die "Invalid value for title, must be defined"
#            unless defined($val);
#        $self->{title} = $val;
#    }
#
#  SET_TARGET:
#    {
#        last unless exists $args{target};
#        my $val = $args{target};
#        die "Invalid value for target, must be a positive number or undef"
#            unless !defined($val) || $val >= 0;
#        if (defined($val) && $self->{pos} > $val) {
#            $self->{pos} = $val;
#        }
#        $self->{target} = $val;
#        undef $self->{_remaining};
#    }
#
#  SET_POS:
#    {
#        last unless exists $args{pos};
#        my $val = $args{pos};
#        die "Invalid value for pos, must be a positive number"
#            unless defined($val) && $val >= 0;
#        if (defined($self->{target}) && $val > $self->{target}) {
#            $val = $self->{target};
#        }
#        $self->{pos} = $val;
#        undef $self->{_remaining};
#    }
#
#  SET_REMAINING:
#    {
#        last unless exists $args{remaining};
#        my $val = $args{remaining};
#        die "Invalid value for remaining, must be a positive number"
#            unless defined($val) && $val >= 0;
#        $self->{_remaining} = $val;
#        $self->{_set_remaining_time} = $now;
#    }
#
#  SET_STATE:
#    {
#        last unless exists $args{state};
#        my $old = $self->{state};
#        my $val = $args{state} // 'started';
#        die "Invalid value for state, must be stopped/started/finished"
#            unless $val =~ /\A(?:stopped|started|finished)\z/;
#        last if $old eq $val;
#        if ($val eq 'started') {
#            $self->{_start_time} = $now;
#
#            my @parents;
#            {
#                my $t = $task;
#                while (1) {
#                    last unless $t =~ s/\.\w+\z//;
#                    push @parents, $t;
#                }
#                push @parents, '';
#            }
#            for my $t (@parents) {
#                my $p = $indicators{$t};
#                if ($p->{state} ne 'started') {
#                    $p->{state}       = 'started';
#                    $p->{_start_time} = $now;
#                }
#            }
#        } else {
#            $self->{_elapsed} += $now - $self->{_start_time};
#            if ($val eq 'finished') {
#                die "BUG: Can't finish task '$task', pos is still < target"
#                    if defined($self->{target}) &&
#                        $self->{pos} < $self->{target};
#                $self->{_remaining} = 0;
#                $self->{_set_remaining_time} = $now;
#            }
#        }
#        $self->{state} = $val;
#    }
#
#  DONE:
#    return;
#}
#
#sub _should_update_output {
#    my ($self, $output, $now, $priority) = @_;
#
#    my $key = "$output";
#    if (!defined($output->{_mtime})) {
#        return 1;
#    } elsif ($self->{state} eq 'finished') {
#        return 1;
#    } elsif ($output->{force_update}) {
#        delete $output->{force_update};
#        return 1;
#    } elsif ($priority eq 'high') {
#        return 1;
#    } else {
#        if (!defined($output->{freq})) {
#            $output->{freq} = -0.5;
#        }
#        if ($output->{freq} == 0) {
#            return 1;
#        } if ($output->{freq} < 0) {
#            return 1 if $now >= $output->{_mtime} - $output->{freq};
#        } else {
#            return 1 if abs($self->{pos} - $output->{_pos}) >= $output->{freq};
#        }
#        return 0;
#    }
#}
#
#sub update {
#    my ($self, %args) = @_;
#
#    my $pos   = delete($args{pos}) // $self->{pos} + 1;
#    my $state = delete($args{state}) // 'started';
#    $self->_update(pos => $pos, state => $state);
#
#    my $message  = delete($args{message});
#    my $priority = delete($args{priority}) // 'normal';
#    die "Unknown argument(s) to update(): ".join(", ", keys(%args))
#        if keys(%args);
#
#    my $now = time();
#
#    {
#        last unless $ENV{PROGRESS} // 1;
#        my $task = $self->{task};
#        while (1) {
#            if ($outputs{$task}) {
#                for my $output (@{ $outputs{$task} }) {
#                    next unless $self->_should_update_output($output, $now, $priority);
#                    if (ref($message) eq 'CODE') {
#                        $message = $message->();
#                    }
#                    $output->update(
#                        indicator => $indicators{$task},
#                        message   => $message,
#                        priority  => $priority,
#                        time      => $now,
#                    );
#                    $output->{_mtime} = $now;
#                    $output->{_pos}   = $pos;
#                }
#            }
#            last unless $task =~ s/\.?\w+\z//;
#        }
#    }
#}
#
#sub start {
#    my $self = shift;
#    $self->_update(state => 'started');
#}
#
#sub stop {
#    my $self = shift;
#    $self->_update(state => 'stopped');
#}
#
#sub finish {
#    my ($self, %args) = @_;
#    $self->update(pos=>$self->{target}, state=>'finished', %args);
#}
#
#our $template_regex = qr{( # all=1
#                             %
#                             ( #width=2
#                                 -?\d+ )?
#                             ( #dot=3
#                                 \.?)
#                             ( #prec=4
#                                 \d+)?
#                             ( #conv=5
#                                 [A-Za-z%])
#                         )}x;
#
#sub fill_template {
#    my ($self, $template0, %args) = @_;
#
#
#    my ($template, $opts);
#    if (ref $template0 eq 'HASH') {
#        $opts = $template0;
#        $template = $opts->{template};
#    } else {
#        $template = $template0;
#        $opts = {};
#    }
#
#    state $sub = sub {
#        my %args = @_;
#
#        my ($all, $width, $dot, $prec, $conv) = ($1, $2, $3, $4, $5);
#
#        my $p = $args{indicator};
#
#        my ($fmt, $sconv, $data);
#        if ($conv eq 'n') {
#            $data = $p->{task};
#        } elsif ($conv eq 't') {
#            $data = $p->{title};
#        } elsif ($conv eq '%') {
#            $data = '%';
#        } elsif ($conv eq 'm') {
#            $data = $args{message} // '';
#        } elsif ($conv eq 'p') {
#            my $val = $p->percent_complete;
#            $width //= 3;
#            if (defined $val) {
#                $data = $val;
#                $prec //= 0;
#                $sconv = "f";
#            } else {
#                $data = '?';
#            }
#        } elsif ($conv eq 'P') {
#            $data = $p->total_pos;
#            $prec //= 0;
#            $sconv = "f";
#        } elsif ($conv eq 'T') {
#            my $val = $p->total_target;
#            if (defined $val) {
#                $data = $val;
#                $prec //= 0;
#                $sconv = "f";
#            } else {
#                $data = '?';
#            }
#        } elsif ($conv eq 'e') {
#            my $val = $p->elapsed;
#            $val = 1 if $val < 1; 
#            $data = Time::Duration::concise(Time::Duration::duration($val));
#            $width //= -8;
#        } elsif ($conv eq 'r') {
#            my $val = $p->total_remaining;
#            if (defined $val) {
#                $val = 1 if $val < 1; 
#                $data = Time::Duration::concise(Time::Duration::duration($val));
#            } else {
#                $data = '?';
#            }
#            $width //= -8;
#        } elsif ($conv eq 'R') {
#            my $val = $p->total_remaining;
#            if (defined $val) {
#                $val = 1 if $val < 1; 
#                $data = Time::Duration::concise(Time::Duration::duration($val)).
#                    " left"; 
#            } else {
#                $val = $p->elapsed;
#                $val = 1 if $val < 1; 
#                $data = Time::Duration::concise(Time::Duration::duration($val)).
#                    " elapsed"; 
#            }
#            $width //= -(8 + 1 + 7);
#        } else {
#            if ($opts->{handle_unknown_conversion}) {
#                my @res = $opts->{handle_unknown_conversion}->(
#                    indicator => $p,
#                    args  => \%args,
#
#                    all   => $all,
#                    width => $width,
#                    dot   => $dot,
#                    conv  => $conv,
#                    prec  => $prec,
#                );
#                if (@res) {
#                    ($fmt, $data) = @res;
#                } else {
#                    $fmt = '%s';
#                    $data = $all;
#                }
#            } else {
#                $fmt = '%s';
#                $data = $all;
#            }
#        }
#
#        $sconv //= 's';
#        $dot = "." if $sconv eq 'f';
#        $fmt //= join("", grep {defined} ("%", $width, $dot, $prec, $sconv));
#
#        sprintf $fmt, $data;
#    };
#    $template =~ s{$template_regex}{$sub->(%args, indicator=>$self)}egox;
#
#    $template;
#}
#
#1;
#
#__END__
#
### Progress/Any/Output.pm ###
#package Progress::Any::Output;
#
#our $DATE = '2018-03-26'; 
#our $VERSION = '0.214'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Progress::Any;
#
#sub import {
#    my $self = shift;
#    __PACKAGE__->set(@_) if @_;
#}
#
#sub _set_or_add {
#    my $class = shift;
#    my $which = shift;
#
#    my $opts;
#    if (@_ && ref($_[0]) eq 'HASH') {
#        $opts = shift;
#    } else {
#        $opts = {};
#    }
#
#    my $output = shift or die "Please specify output name";
#    $output =~ /\A(?:\w+(::\w+)*)?\z/ or die "Invalid output syntax '$output'";
#
#    my $task = $opts->{task} // "";
#
#    my $outputo;
#    unless (ref $outputo) {
#        my $outputpm = $output; $outputpm =~ s!::!/!g; $outputpm .= ".pm";
#        require "Progress/Any/Output/$outputpm";
#        no strict 'refs';
#        $outputo = "Progress::Any::Output::$output"->new(@_);
#    }
#
#    if ($which eq 'set') {
#        $Progress::Any::outputs{$task} = [$outputo];
#    } else {
#        $Progress::Any::outputs{$task} //= [];
#        push @{ $Progress::Any::outputs{$task} }, $outputo;
#    }
#
#    $outputo;
#}
#
#sub set {
#    my $class = shift;
#    $class->_set_or_add('set', @_);
#}
#
#sub add {
#    my $class = shift;
#    $class->_set_or_add('add', @_);
#}
#
#1;
#
#__END__
#
### Progress/Any/Output/Null.pm ###
#package Progress::Any::Output::Null;
#
#use 5.010;
#use strict;
#use warnings;
#
#our $VERSION = '0.214'; 
#
#sub new {
#    my ($class, %args) = @_;
#    bless \%args, $class;
#}
#
#sub update {
#    1;
#}
#
#1;
#
#__END__
#
### Progress/Any/Output/TermProgressBarColor.pm ###
#package Progress::Any::Output::TermProgressBarColor;
#
#our $DATE = '2018-03-27'; 
#our $VERSION = '0.245'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Color::ANSI::Util qw(ansifg ansibg);
#require Win32::Console::ANSI if $^O =~ /Win/;
#
#$|++;
#
#my ($ph1, $ph2);
#
#sub _patch {
#    my $out = shift;
#
#    return if $ph1;
#    require Monkey::Patch::Action;
#    if (defined &{"Log::Any::Adapter::Screen::hook_before_log"}) {
#        $ph1 = Monkey::Patch::Action::patch_package(
#            'Log::Any::Adapter::Screen', 'hook_before_log', 'replace',
#            sub {
#                $out->cleanup(1);
#                $Progress::Any::output_data{"$out"}{force_update} = 1;
#            }
#        );
#    } elsif (defined  &{"Log::ger::Output::Screen::hook_before_log"}) {
#        $ph1 = Monkey::Patch::Action::patch_package(
#            'Log::ger::Output::Screen', 'hook_before_log', 'replace',
#            sub {
#                $out->cleanup(1);
#                $Progress::Any::output_data{"$out"}{force_update} = 1;
#            }
#        );
#    }
#
#    if (defined &{"Log::Any::Adapter::Screen::hook_after_log"}) {
#        $ph2 = Monkey::Patch::Action::patch_package(
#            'Log::Any::Adapter::Screen', 'hook_after_log', 'replace',
#            sub {
#                my ($self, $msg) = @_;
#                print { $self->{_fh} } "\n" unless $msg =~ /\R\z/;
#
#                $out->keep_delay_showing if $out->{show_delay};
#
#                print { $self->{_fh} } $out->{_bar} if $out->{_bar};
#            }
#        );
#    } elsif (defined &{"Log::ger::Output::Screen::hook_after_log"}) {
#        $ph2 = Monkey::Patch::Action::patch_package(
#            'Log::ger::Output::Screen', 'hook_after_log', 'replace',
#            sub {
#                my ($ctx, $msg) = @_;
#                print { $ctx->{_fh} } "\n" unless $msg =~ /\R\z/;
#
#                $out->keep_delay_showing if $out->{show_delay};
#
#                print { $ctx->{_fh} } $out->{_bar} if $out->{_bar};
#            }
#        );
#    }
#}
#
#sub _unpatch {
#    undef $ph1;
#    undef $ph2;
#}
#
#sub _template_length {
#    require Progress::Any; 
#    no warnings 'once'; 
#
#    my ($self, $template) = @_;
#
#    my $template_length = length($template);
#
#    while ($template =~ /$Progress::Any::template_regex/g) {
#        my ($all, $width, $dot, $prec, $conv) =
#            ($1, $2, $3, $4, $5);
#
#        if (defined $template_length) {
#
#            if ($conv eq '%') {
#                $width //= 1;
#            } elsif ($conv eq 'b' || $conv eq 'B') {
#                $width //= $self->{_default_b_width};
#            } elsif ($conv eq 'p') {
#                $width //= 3;
#            } elsif ($conv eq 'e') {
#                $width //= -8;
#            } elsif ($conv eq 'r') {
#                $width //= -8;
#            } elsif ($conv eq 'R') {
#                $width //= -(8 + 1 + 7);
#            }
#
#            if (defined $width) {
#                $template_length += abs($width) - length($all);
#            } else {
#                $template_length = undef;
#            }
#
#        }
#    }
#
#    $template_length;
#}
#
#sub new {
#    my ($class, %args0) = @_;
#
#    my %args;
#
#    $args{width} = delete($args0{width});
#    if (!defined($args{width})) {
#        my ($cols, $rows);
#        if ($ENV{COLUMNS}) {
#            $cols = $ENV{COLUMNS};
#        } elsif (eval { require Term::Size; 1 }) {
#            ($cols, $rows) = Term::Size::chars();
#        } else {
#            $cols = 80;
#        }
#        $args{width} = $^O =~ /Win/ ? $cols-1 : $cols;
#    }
#
#    $args{fh} = delete($args0{fh});
#    $args{fh} //= \*STDERR;
#
#    $args{show_delay} = delete($args0{show_delay});
#
#    $args{freq} = delete($args0{freq});
#
#    $args{wide} = delete($args0{wide});
#
#    $args{template} = delete($args0{template}) //
#        '<color ffff00>%p%%</color> <color 808000>[</color>%B<color 808000>]</color><color ffff00>%R</color>';
#
#    keys(%args0) and die "Unknown output parameter(s): ".
#        join(", ", keys(%args0));
#
#    $args{_last_hide_time} = time();
#
#    require Text::ANSI::Util;
#    if ($args{wide}) {
#        require Text::ANSI::WideUtil;
#    }
#
#    my $self = bless \%args, $class;
#
#    {
#        $self->{_default_b_width} = 0;
#        (my $template = $args{template}) =~ s!<color \w+>|</color>!!g;
#        my $len = $self->_template_length($template) // 16;
#        $self->{_default_b_width} = $args{width} - $len;
#    }
#
#    ($self->{_template} = $self->{template}) =~ s!<color (\w+)>|<(/)color>!$1 ? ansifg($1) : "\e[0m"!eg;
#
#    $self;
#}
#
#sub _handle_unknown_conversion {
#    my %args = @_;
#
#    my $conv = $args{conv};
#    return () unless $conv eq 'b' || $conv eq 'B';
#
#    my $p = $args{indicator};
#    my $self = $args{self};
#
#    my $tottgt = $p->total_target;
#    my $totpos = $p->total_pos;
#
#    my $bar_bar = '';
#    my $bwidth = abs($args{width} // $self->{_default_b_width});
#
#    if ($tottgt) {
#        my $bfilled = int($totpos / $tottgt * $bwidth);
#        $bfilled = $bwidth if $bfilled > $bwidth;
#        $bar_bar = ("=" x $bfilled) . (" " x ($bwidth-$bfilled));
#    } else {
#        my $bfilled = int(0.15 * $bwidth);
#        $bfilled = 1 if $bfilled < 1;
#        $self->{_x}++;
#        if ($self->{_x} > $bwidth-$bfilled) {
#            $self->{_x} = 0;
#        }
#        $bar_bar = (" " x $self->{_x}) . ("=" x $bfilled) .
#            (" " x ($bwidth-$self->{_x}-$bfilled));
#    }
#
#    my $msg = $args{args}{message};
#    if ($conv eq 'B' && defined $msg) {
#        if ($msg =~ m!</elspan!) {
#            require String::Elide::Parts;
#            $msg = String::Elide::Parts::elide($msg, $bwidth);
#        }
#        my $mwidth;
#        if ($self->{wide}) {
#            $msg = Text::ANSI::WideUtil::ta_mbtrunc($msg, $bwidth);
#            $mwidth = Text::ANSI::WideUtil::ta_mbswidth($msg);
#        } else {
#            $msg = Text::ANSI::Util::ta_trunc($msg, $bwidth);
#            $mwidth = Text::ANSI::Util::ta_length($msg);
#        }
#        $bar_bar = $msg . substr($bar_bar, $mwidth);
#    }
#
#    return ("%s", $bar_bar);
#}
#
#sub update {
#    my ($self, %args) = @_;
#
#    return unless $ENV{PROGRESS_TERM_BAR} // $ENV{PROGRESS} // (-t $self->{fh});
#
#    my $now = time();
#
#    if (defined $self->{show_delay}) {
#        return if $now - $self->{show_delay} < $self->{_last_hide_time};
#    }
#
#    $self->_patch;
#
#    $self->cleanup;
#
#    my $p = $args{indicator};
#    my $is_finished = $p->{state} eq 'finished';
#    if ($is_finished) {
#        if ($self->{_lastlen}) {
#            $self->{_last_hide_time} = $now;
#        }
#        return;
#    }
#
#    my $bar = $p->fill_template(
#        {
#            template => $self->{_template},
#            handle_unknown_conversion => sub {
#                _handle_unknown_conversion(
#                    self => $self,
#                    @_,
#                );
#            },
#        },
#        %args,
#    );
#
#    my $len = Text::ANSI::Util::ta_length($bar);
#    $self->{_bar}   = $bar . ("\b" x $len);
#    print { $self->{fh} } $self->{_bar};
#    $self->{_lastlen} = $len;
#}
#
#sub cleanup {
#    my ($self, $dont_reset_lastlen) = @_;
#
#
#    my $ll = $self->{_lastlen};
#    return unless $ll;
#    print { $self->{fh} } " " x $ll, "\b" x $ll;
#    undef $self->{_lastlen} unless $dont_reset_lastlen;
#}
#
#sub keep_delay_showing {
#    my $self = shift;
#
#    $self->{_last_hide_time} = time();
#}
#
#sub DESTROY {
#    my $self = shift;
#    $self->_unpatch;
#}
#
#1;
#
#__END__
#
### Regexp/Stringify.pm ###
#package Regexp::Stringify;
#
#our $DATE = '2016-10-29'; 
#our $VERSION = '0.06'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use re qw(regexp_pattern);
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(stringify_regexp);
#
#our %SPEC;
#
#$SPEC{stringify_regexp} = {
#    v => 1.1,
#    summary => 'Stringify a Regexp object',
#    description => <<'_',
#
#This routine is an alternative to Perl's default stringification of Regexp
#object (i.e.:`"$re"`) and has some features/options, e.g.: producing regexp
#string that is compatible with certain perl versions.
#
#If given a string (or other non-Regexp object), will return it as-is.
#
#_
#    args => {
#        regexp => {
#            schema => 're*',
#            req => 1,
#            pos => 0,
#        },
#        plver => {
#            summary => 'Target perl version',
#            schema => 'str*',
#            description => <<'_',
#
#Try to produce a regexp object compatible with a certain perl version (should at
#least be >= 5.10).
#
#For example, in perl 5.14 regex stringification changes, e.g. `qr/hlagh/i` would
#previously be stringified as `(?i-xsm:hlagh)`, but now it's stringified as
#`(?^i:hlagh)`. If you set `plver` to 5.10 or 5.12, then this routine will
#still produce the former. It will also ignore regexp modifiers that are
#introduced in newer perls.
#
#Note that not all regexp objects are translatable to older perls, e.g. if they
#contain constructs not known to older perls like `(?^...)` before perl 5.14.
#
#_
#        },
#        with_qr => {
#            schema  => 'bool',
#            description => <<'_',
#
#If you set this to 1, then `qr/a/i` will be stringified as `'qr/a/i'` instead as
#`'(?^i:a)'`. The resulting string can then be eval-ed to recreate the Regexp
#object.
#
#_
#        },
#    },
#    result_naked => 1,
#    result => {
#        schema => 'str*',
#    },
#};
#sub stringify_regexp {
#    my %args = @_;
#
#    my $re = $args{regexp};
#    return $re unless ref($re) eq 'Regexp';
#    my $plver = $args{plver} // $^V;
#
#    my ($pat, $mod) = regexp_pattern($re);
#
#    my $ge_5140 = version->parse($plver) >= version->parse('5.14.0');
#    unless ($ge_5140) {
#        $mod =~ s/[adlu]//g;
#    }
#
#    if ($args{with_qr}) {
#        return "qr($pat)$mod";
#    } else {
#        if ($ge_5140) {
#            return "(^$mod:$pat)";
#        } else {
#            return "(?:(?$mod-)$pat)";
#        }
#    }
#}
#
#1;
#
#__END__
#
### Role/Tiny.pm ###
#package Role::Tiny;
#
#sub _getglob { \*{$_[0]} }
#sub _getstash { \%{"$_[0]::"} }
#
#use strict;
#use warnings;
#
#our $VERSION = '2.000005';
#$VERSION = eval $VERSION;
#
#our %INFO;
#our %APPLIED_TO;
#our %COMPOSED;
#our %COMPOSITE_INFO;
#our @ON_ROLE_CREATE;
#
#
#BEGIN {
#  *_WORK_AROUND_BROKEN_MODULE_STATE = "$]" < 5.009 ? sub(){1} : sub(){0};
#  *_MRO_MODULE = "$]" < 5.010 ? sub(){"MRO/Compat.pm"} : sub(){"mro.pm"};
#}
#
#sub croak {
#  require Carp;
#  no warnings 'redefine';
#  *croak = \&Carp::croak;
#  goto &Carp::croak;
#}
#
#sub Role::Tiny::__GUARD__::DESTROY {
#  delete $INC{$_[0]->[0]} if @{$_[0]};
#}
#
#sub _load_module {
#  (my $proto = $_[0]) =~ s/::/\//g;
#  $proto .= '.pm';
#  return 1 if $INC{$proto};
#  return 1 if grep !/::$/, keys %{_getstash($_[0])||{}};
#  my $guard = _WORK_AROUND_BROKEN_MODULE_STATE
#    && bless([ $proto ], 'Role::Tiny::__GUARD__');
#  require $proto;
#  pop @$guard if _WORK_AROUND_BROKEN_MODULE_STATE;
#  return 1;
#}
#
#sub import {
#  my $target = caller;
#  my $me = shift;
#  strict->import;
#  warnings->import;
#  $me->_install_subs($target);
#  return if $me->is_role($target); 
#  $INFO{$target}{is_role} = 1;
#  my $stash = _getstash($target);
#  my @not_methods = (map { *$_{CODE}||() } grep !ref($_), values %$stash);
#  @{$INFO{$target}{not_methods}={}}{@not_methods} = @not_methods;
#  $APPLIED_TO{$target} = { $target => undef };
#  foreach my $hook (@ON_ROLE_CREATE) {
#    $hook->($target);
#  }
#}
#
#sub _install_subs {
#  my ($me, $target) = @_;
#  return if $me->is_role($target);
#  foreach my $type (qw(before after around)) {
#    *{_getglob "${target}::${type}"} = sub {
#      push @{$INFO{$target}{modifiers}||=[]}, [ $type => @_ ];
#      return;
#    };
#  }
#  *{_getglob "${target}::requires"} = sub {
#    push @{$INFO{$target}{requires}||=[]}, @_;
#    return;
#  };
#  *{_getglob "${target}::with"} = sub {
#    $me->apply_roles_to_package($target, @_);
#    return;
#  };
#}
#
#sub role_application_steps {
#  qw(_install_methods _check_requires _install_modifiers _copy_applied_list);
#}
#
#sub apply_single_role_to_package {
#  my ($me, $to, $role) = @_;
#
#  _load_module($role);
#
#  croak "This is apply_role_to_package" if ref($to);
#  croak "${role} is not a Role::Tiny" unless $me->is_role($role);
#
#  foreach my $step ($me->role_application_steps) {
#    $me->$step($to, $role);
#  }
#}
#
#sub _copy_applied_list {
#  my ($me, $to, $role) = @_;
#  @{$APPLIED_TO{$to}||={}}{keys %{$APPLIED_TO{$role}}} = ();
#}
#
#sub apply_roles_to_object {
#  my ($me, $object, @roles) = @_;
#  croak "No roles supplied!" unless @roles;
#  my $class = ref($object);
#  bless($_[1], $me->create_class_with_roles($class, @roles));
#}
#
#my $role_suffix = 'A000';
#sub _composite_name {
#  my ($me, $superclass, @roles) = @_;
#
#  my $new_name = join(
#    '__WITH__', $superclass, my $compose_name = join '__AND__', @roles
#  );
#
#  if (length($new_name) > 252) {
#    $new_name = $COMPOSED{abbrev}{$new_name} ||= do {
#      my $abbrev = substr $new_name, 0, 250 - length $role_suffix;
#      $abbrev =~ s/(?<!:):$//;
#      $abbrev.'__'.$role_suffix++;
#    };
#  }
#  return wantarray ? ($new_name, $compose_name) : $new_name;
#}
#
#sub create_class_with_roles {
#  my ($me, $superclass, @roles) = @_;
#
#  croak "No roles supplied!" unless @roles;
#
#  _load_module($superclass);
#  {
#    my %seen;
#    if (my @dupes = grep 1 == $seen{$_}++, @roles) {
#      croak "Duplicated roles: ".join(', ', @dupes);
#    }
#  }
#
#  my ($new_name, $compose_name) = $me->_composite_name($superclass, @roles);
#
#  return $new_name if $COMPOSED{class}{$new_name};
#
#  foreach my $role (@roles) {
#    _load_module($role);
#    croak "${role} is not a Role::Tiny" unless $me->is_role($role);
#  }
#
#  require(_MRO_MODULE);
#
#  my $composite_info = $me->_composite_info_for(@roles);
#  my %conflicts = %{$composite_info->{conflicts}};
#  if (keys %conflicts) {
#    my $fail =
#      join "\n",
#        map {
#          "Method name conflict for '$_' between roles "
#          ."'".join("' and '", sort values %{$conflicts{$_}})."'"
#          .", cannot apply these simultaneously to an object."
#        } keys %conflicts;
#    croak $fail;
#  }
#
#  my @composable = map $me->_composable_package_for($_), reverse @roles;
#
#  my @requires = grep {
#    my $method = $_;
#    !grep $_->can($method) && !$COMPOSED{role}{$_}{modifiers_only}{$method},
#      @composable
#  } @{$composite_info->{requires}};
#
#  $me->_check_requires(
#    $superclass, $compose_name, \@requires
#  );
#
#  *{_getglob("${new_name}::ISA")} = [ @composable, $superclass ];
#
#  @{$APPLIED_TO{$new_name}||={}}{
#    map keys %{$APPLIED_TO{$_}}, @roles
#  } = ();
#
#  $COMPOSED{class}{$new_name} = 1;
#  return $new_name;
#}
#
#
#sub apply_role_to_package { shift->apply_single_role_to_package(@_) }
#
#sub apply_roles_to_package {
#  my ($me, $to, @roles) = @_;
#
#  return $me->apply_role_to_package($to, $roles[0]) if @roles == 1;
#
#  my %conflicts = %{$me->_composite_info_for(@roles)->{conflicts}};
#  my @have = grep $to->can($_), keys %conflicts;
#  delete @conflicts{@have};
#
#  if (keys %conflicts) {
#    my $fail =
#      join "\n",
#        map {
#          "Due to a method name conflict between roles "
#          ."'".join(' and ', sort values %{$conflicts{$_}})."'"
#          .", the method '$_' must be implemented by '${to}'"
#        } keys %conflicts;
#    croak $fail;
#  }
#
#  my @role_methods = map $me->_concrete_methods_of($_), @roles;
#  local @{$_}{@have} for @role_methods;
#  delete @{$_}{@have} for @role_methods;
#
#  if ($INFO{$to}) {
#    delete $INFO{$to}{methods}; 
#  }
#
#  our %BACKCOMPAT_HACK;
#  if($me ne __PACKAGE__
#      and exists $BACKCOMPAT_HACK{$me} ? $BACKCOMPAT_HACK{$me} :
#      $BACKCOMPAT_HACK{$me} =
#        $me->can('role_application_steps')
#          == \&role_application_steps
#        && $me->can('apply_single_role_to_package')
#          != \&apply_single_role_to_package
#  ) {
#    foreach my $role (@roles) {
#      $me->apply_single_role_to_package($to, $role);
#    }
#  }
#  else {
#    foreach my $step ($me->role_application_steps) {
#      foreach my $role (@roles) {
#        $me->$step($to, $role);
#      }
#    }
#  }
#  $APPLIED_TO{$to}{join('|',@roles)} = 1;
#}
#
#sub _composite_info_for {
#  my ($me, @roles) = @_;
#  $COMPOSITE_INFO{join('|', sort @roles)} ||= do {
#    foreach my $role (@roles) {
#      _load_module($role);
#    }
#    my %methods;
#    foreach my $role (@roles) {
#      my $this_methods = $me->_concrete_methods_of($role);
#      $methods{$_}{$this_methods->{$_}} = $role for keys %$this_methods;
#    }
#    my %requires;
#    @requires{map @{$INFO{$_}{requires}||[]}, @roles} = ();
#    delete $requires{$_} for keys %methods;
#    delete $methods{$_} for grep keys(%{$methods{$_}}) == 1, keys %methods;
#    +{ conflicts => \%methods, requires => [keys %requires] }
#  };
#}
#
#sub _composable_package_for {
#  my ($me, $role) = @_;
#  my $composed_name = 'Role::Tiny::_COMPOSABLE::'.$role;
#  return $composed_name if $COMPOSED{role}{$composed_name};
#  $me->_install_methods($composed_name, $role);
#  my $base_name = $composed_name.'::_BASE';
#  _getstash($base_name);
#  { no strict 'refs'; @{"${composed_name}::ISA"} = ( $base_name ); }
#  my $modifiers = $INFO{$role}{modifiers}||[];
#  my @mod_base;
#  my @modifiers = grep !$composed_name->can($_),
#    do { my %h; @h{map @{$_}[1..$#$_-1], @$modifiers} = (); keys %h };
#  foreach my $modified (@modifiers) {
#    push @mod_base, "sub ${modified} { shift->next::method(\@_) }";
#  }
#  my $e;
#  {
#    local $@;
#    eval(my $code = join "\n", "package ${base_name};", @mod_base);
#    $e = "Evaling failed: $@\nTrying to eval:\n${code}" if $@;
#  }
#  die $e if $e;
#  $me->_install_modifiers($composed_name, $role);
#  $COMPOSED{role}{$composed_name} = {
#    modifiers_only => { map { $_ => 1 } @modifiers },
#  };
#  return $composed_name;
#}
#
#sub _check_requires {
#  my ($me, $to, $name, $requires) = @_;
#  return unless my @requires = @{$requires||$INFO{$name}{requires}||[]};
#  if (my @requires_fail = grep !$to->can($_), @requires) {
#    if (my $to_info = $INFO{$to}) {
#      push @{$to_info->{requires}||=[]}, @requires_fail;
#    } else {
#      croak "Can't apply ${name} to ${to} - missing ".join(', ', @requires_fail);
#    }
#  }
#}
#
#sub _concrete_methods_of {
#  my ($me, $role) = @_;
#  my $info = $INFO{$role};
#  my $stash = _getstash($role);
#  my $not_methods = { reverse %{$info->{not_methods}||{}} };
#  $info->{methods} ||= +{
#    map {;
#      no strict 'refs';
#      my $code = exists &{"${role}::$_"} ? \&{"${role}::$_"} : undef;
#      ( ! $code or exists $not_methods->{$code} ) ? () : ($_ => $code)
#    } grep !ref($stash->{$_}), keys %$stash
#  };
#}
#
#sub methods_provided_by {
#  my ($me, $role) = @_;
#  croak "${role} is not a Role::Tiny" unless $me->is_role($role);
#  (keys %{$me->_concrete_methods_of($role)}, @{$INFO{$role}->{requires}||[]});
#}
#
#sub _install_methods {
#  my ($me, $to, $role) = @_;
#
#  my $info = $INFO{$role};
#
#  my $methods = $me->_concrete_methods_of($role);
#
#  my $stash = _getstash($to);
#
#  my %has_methods;
#  @has_methods{grep
#    +(ref($stash->{$_}) || *{$stash->{$_}}{CODE}),
#    keys %$stash
#  } = ();
#
#  foreach my $i (grep !exists $has_methods{$_}, keys %$methods) {
#    no warnings 'once';
#    my $glob = _getglob "${to}::${i}";
#    *$glob = $methods->{$i};
#
#    next
#      unless $i =~ /^\(/
#        && ((defined &overload::nil && $methods->{$i} == \&overload::nil)
#            || (defined &overload::_nil && $methods->{$i} == \&overload::_nil));
#
#    my $overload = ${ *{_getglob "${role}::${i}"}{SCALAR} };
#    next
#      unless defined $overload;
#
#    *$glob = \$overload;
#  }
#
#  $me->_install_does($to);
#}
#
#sub _install_modifiers {
#  my ($me, $to, $name) = @_;
#  return unless my $modifiers = $INFO{$name}{modifiers};
#  my $info = $INFO{$to};
#  my $existing = ($info ? $info->{modifiers} : $COMPOSED{modifiers}{$to}) ||= [];
#  my @modifiers = grep {
#    my $modifier = $_;
#    !grep $_ == $modifier, @$existing;
#  } @{$modifiers||[]};
#  push @$existing, @modifiers;
#
#  if (!$info) {
#    foreach my $modifier (@modifiers) {
#      $me->_install_single_modifier($to, @$modifier);
#    }
#  }
#}
#
#my $vcheck_error;
#
#sub _install_single_modifier {
#  my ($me, @args) = @_;
#  defined($vcheck_error) or $vcheck_error = do {
#    local $@;
#    eval {
#      require Class::Method::Modifiers;
#      Class::Method::Modifiers->VERSION(1.05);
#      1;
#    } ? 0 : $@;
#  };
#  $vcheck_error and die $vcheck_error;
#  Class::Method::Modifiers::install_modifier(@args);
#}
#
#my $FALLBACK = sub { 0 };
#sub _install_does {
#  my ($me, $to) = @_;
#
#  return if $me->is_role($to);
#
#  my $does = $me->can('does_role');
#  *{_getglob "${to}::does"} = $does unless $to->can('does');
#
#  return
#    if $to->can('DOES') and $to->can('DOES') != (UNIVERSAL->can('DOES') || 0);
#
#  my $existing = $to->can('DOES') || $to->can('isa') || $FALLBACK;
#  my $new_sub = sub {
#    my ($proto, $role) = @_;
#    $proto->$does($role) or $proto->$existing($role);
#  };
#  no warnings 'redefine';
#  return *{_getglob "${to}::DOES"} = $new_sub;
#}
#
#sub does_role {
#  my ($proto, $role) = @_;
#  require(_MRO_MODULE);
#  foreach my $class (@{mro::get_linear_isa(ref($proto)||$proto)}) {
#    return 1 if exists $APPLIED_TO{$class}{$role};
#  }
#  return 0;
#}
#
#sub is_role {
#  my ($me, $role) = @_;
#  return !!($INFO{$role} && ($INFO{$role}{is_role} || $INFO{$role}{not_methods}));
#}
#
#1;
#__END__
#
### Role/Tiny/With.pm ###
#package Role::Tiny::With;
#
#use strict;
#use warnings;
#
#our $VERSION = '2.000005';
#$VERSION = eval $VERSION;
#
#use Role::Tiny ();
#
#use Exporter 'import';
#our @EXPORT = qw( with );
#
#sub with {
#    my $target = caller;
#    Role::Tiny->apply_roles_to_package($target, @_)
#}
#
#1;
#
#
#
### Sah/Schema/rinci/function_meta.pm ###
#package Sah::Schema::rinci::function_meta;
#
#our $DATE = '2018-11-29'; 
#our $VERSION = '1.1.87.0'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Data::Sah::Normalize ();
#use Sah::Schema::rinci::meta ();
#
#our $schema = [hash => {
#    summary => 'Rinci function metadata',
#
#    _ver => 1.1,
#    _prop => {
#        %Sah::Schema::rinci::meta::_dh_props,
#
#        entity_v => {},
#        entity_date => {},
#        links => {},
#
#        is_func => {},
#        is_meth => {},
#        is_class_meth => {},
#        args => {
#            _value_prop => {
#                %Sah::Schema::rinci::meta::_dh_props,
#
#                links => {},
#
#                schema => {},
#                filters => {},
#                default => {},
#                req => {},
#                pos => {},
#                greedy => {},
#                partial => {},
#                stream => {},
#                is_password => {},
#                cmdline_aliases => {
#                    _value_prop => {
#                        summary => {},
#                        description => {},
#                        schema => {},
#                        code => {},
#                        is_flag => {},
#                    },
#                },
#                cmdline_on_getopt => {},
#                cmdline_prompt => {},
#                completion => {},
#                index_completion => {},
#                element_completion => {},
#                cmdline_src => {},
#                meta => 'fix',
#                element_meta => 'fix',
#                deps => {
#                    _keys => {
#                        arg => {},
#                        all => {},
#                        any => {},
#                        none => {},
#                    },
#                },
#                examples => {},
#            },
#        },
#        args_as => {},
#        args_rels => {},
#        result => {
#            _prop => {
#                %Sah::Schema::rinci::meta::_dh_props,
#
#                schema => {},
#                statuses => {
#                    _value_prop => {
#                        summary => {},
#                        description => {},
#                        schema => {},
#                    },
#                },
#                partial => {},
#                stream => {},
#            },
#        },
#        result_naked => {},
#        examples => {
#            _elem_prop => {
#                %Sah::Schema::rinci::meta::_dh_props,
#
#                args => {},
#                argv => {},
#                src => {},
#                src_plang => {},
#                status => {},
#                result => {},
#                test => {},
#            },
#        },
#        features => {
#            _keys => {
#                reverse => {},
#                tx => {},
#                dry_run => {},
#                pure => {},
#                immutable => {},
#                idempotent => {},
#                check_arg => {},
#            },
#        },
#        deps => {
#            _keys => {
#                all => {},
#                any => {},
#                none => {},
#                env => {},
#                prog => {},
#                pkg => {},
#                func => {},
#                code => {},
#                tmp_dir => {},
#                trash_dir => {},
#            },
#        },
#    },
#}, {}];
#
#$schema->[1]{_prop}{args}{_value_prop}{meta} = $schema->[1];
#$schema->[1]{_prop}{args}{_value_prop}{element_meta} = $schema->[1];
#
#
#$schema = Data::Sah::Normalize::normalize_schema($schema);
#
#1;
#
#__END__
#
### Sah/Schema/rinci/meta.pm ###
#package Sah::Schema::rinci::meta;
#
#our $DATE = '2018-11-29'; 
#our $VERSION = '1.1.87.0'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#our %_dh_props = (
#    v => {},
#    defhash_v => {},
#    name => {},
#    caption => {},
#    summary => {},
#    description => {},
#    tags => {},
#    default_lang => {},
#    x => {},
#);
#
#our $schema = [hash => {
#    summary => 'Rinci metadata',
#    _ver => 1.1, 
#    _prop => {
#        %_dh_props,
#
#        entity_v => {},
#        entity_date => {},
#        links => {
#            _elem_prop => {
#                %_dh_props,
#
#                url => {},
#            },
#        },
#    },
#}, {}];
#
#1;
#
#__END__
#
### Sah/Schema/rinci/result_meta.pm ###
#package Sah::Schema::rinci::result_meta;
#
#our $DATE = '2018-11-29'; 
#our $VERSION = '1.1.87.0'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Sah::Schema::rinci::meta;
#
#our $schema = [hash => {
#    summary => 'Rinci envelope result metadata',
#
#    _ver => 1.1,
#    _prop => {
#        %Sah::Schema::rinci::meta::_dh_props,
#
#        perm_err => {},
#        func => {}, 
#        cmdline => {}, 
#        logs => {},
#        prev => {},
#        results => {},
#        part_start => {},
#        part_len => {},
#        len => {},
#        stream => {},
#    },
#}, {}];
#
#1;
#
#__END__
#
### Sah/SchemaR/rinci/function_meta.pm ###
#package Sah::SchemaR::rinci::function_meta;
#
#our $DATE = '2018-11-29'; 
#our $VERSION = '1.1.87.0'; 
#
#our $rschema = do{my$a=["hash",[{_prop=>{args=>{_value_prop=>{caption=>{},cmdline_aliases=>{_value_prop=>{code=>{},description=>{},is_flag=>{},schema=>{},summary=>{}}},cmdline_on_getopt=>{},cmdline_prompt=>{},cmdline_src=>{},completion=>{},default=>{},default_lang=>{},defhash_v=>{},deps=>{_keys=>{all=>{},any=>{},arg=>{},none=>{}}},description=>{},element_completion=>{},element_meta=>{_prop=>'fix',_ver=>1.1,summary=>"Rinci function metadata"},examples=>{},filters=>{},greedy=>{},index_completion=>{},is_password=>{},links=>{},meta=>'fix',name=>{},partial=>{},pos=>{},req=>{},schema=>{},stream=>{},summary=>{},tags=>{},v=>{},x=>{}}},args_as=>{},args_rels=>{},caption=>'fix',default_lang=>'fix',defhash_v=>'fix',deps=>{_keys=>{all=>{},any=>{},code=>{},env=>{},func=>{},none=>{},pkg=>{},prog=>{},tmp_dir=>{},trash_dir=>{}}},description=>'fix',entity_date=>{},entity_v=>{},examples=>{_elem_prop=>{args=>{},argv=>{},caption=>'fix',default_lang=>'fix',defhash_v=>'fix',description=>'fix',name=>'fix',result=>{},src=>{},src_plang=>{},status=>{},summary=>'fix',tags=>'fix',test=>{},v=>'fix',x=>'fix'}},features=>{_keys=>{check_arg=>{},dry_run=>{},idempotent=>{},immutable=>{},pure=>{},reverse=>{},tx=>{}}},is_class_meth=>{},is_func=>{},is_meth=>{},links=>{},name=>'fix',result=>{_prop=>{caption=>'fix',default_lang=>'fix',defhash_v=>'fix',description=>'fix',name=>'fix',partial=>{},schema=>{},statuses=>{_value_prop=>{description=>{},schema=>{},summary=>{}}},stream=>{},summary=>'fix',tags=>'fix',v=>'fix',x=>'fix'}},result_naked=>{},summary=>'fix',tags=>'fix',v=>'fix',x=>'fix'},_ver=>1.1,summary=>"Rinci function metadata"}],["hash"]];$a->[1][0]{_prop}{args}{_value_prop}{element_meta}{_prop}=$a->[1][0]{_prop};$a->[1][0]{_prop}{args}{_value_prop}{meta}=$a->[1][0]{_prop}{args}{_value_prop}{element_meta};$a->[1][0]{_prop}{caption}=$a->[1][0]{_prop}{args}{_value_prop}{caption};$a->[1][0]{_prop}{default_lang}=$a->[1][0]{_prop}{args}{_value_prop}{default_lang};$a->[1][0]{_prop}{defhash_v}=$a->[1][0]{_prop}{args}{_value_prop}{defhash_v};$a->[1][0]{_prop}{description}=$a->[1][0]{_prop}{args}{_value_prop}{description};$a->[1][0]{_prop}{examples}{_elem_prop}{caption}=$a->[1][0]{_prop}{args}{_value_prop}{caption};$a->[1][0]{_prop}{examples}{_elem_prop}{default_lang}=$a->[1][0]{_prop}{args}{_value_prop}{default_lang};$a->[1][0]{_prop}{examples}{_elem_prop}{defhash_v}=$a->[1][0]{_prop}{args}{_value_prop}{defhash_v};$a->[1][0]{_prop}{examples}{_elem_prop}{description}=$a->[1][0]{_prop}{args}{_value_prop}{description};$a->[1][0]{_prop}{examples}{_elem_prop}{name}=$a->[1][0]{_prop}{args}{_value_prop}{name};$a->[1][0]{_prop}{examples}{_elem_prop}{summary}=$a->[1][0]{_prop}{args}{_value_prop}{summary};$a->[1][0]{_prop}{examples}{_elem_prop}{tags}=$a->[1][0]{_prop}{args}{_value_prop}{tags};$a->[1][0]{_prop}{examples}{_elem_prop}{v}=$a->[1][0]{_prop}{args}{_value_prop}{v};$a->[1][0]{_prop}{examples}{_elem_prop}{x}=$a->[1][0]{_prop}{args}{_value_prop}{x};$a->[1][0]{_prop}{name}=$a->[1][0]{_prop}{args}{_value_prop}{name};$a->[1][0]{_prop}{result}{_prop}{caption}=$a->[1][0]{_prop}{args}{_value_prop}{caption};$a->[1][0]{_prop}{result}{_prop}{default_lang}=$a->[1][0]{_prop}{args}{_value_prop}{default_lang};$a->[1][0]{_prop}{result}{_prop}{defhash_v}=$a->[1][0]{_prop}{args}{_value_prop}{defhash_v};$a->[1][0]{_prop}{result}{_prop}{description}=$a->[1][0]{_prop}{args}{_value_prop}{description};$a->[1][0]{_prop}{result}{_prop}{name}=$a->[1][0]{_prop}{args}{_value_prop}{name};$a->[1][0]{_prop}{result}{_prop}{summary}=$a->[1][0]{_prop}{args}{_value_prop}{summary};$a->[1][0]{_prop}{result}{_prop}{tags}=$a->[1][0]{_prop}{args}{_value_prop}{tags};$a->[1][0]{_prop}{result}{_prop}{v}=$a->[1][0]{_prop}{args}{_value_prop}{v};$a->[1][0]{_prop}{result}{_prop}{x}=$a->[1][0]{_prop}{args}{_value_prop}{x};$a->[1][0]{_prop}{summary}=$a->[1][0]{_prop}{args}{_value_prop}{summary};$a->[1][0]{_prop}{tags}=$a->[1][0]{_prop}{args}{_value_prop}{tags};$a->[1][0]{_prop}{v}=$a->[1][0]{_prop}{args}{_value_prop}{v};$a->[1][0]{_prop}{x}=$a->[1][0]{_prop}{args}{_value_prop}{x};$a};
#
#1;
#
#__END__
#
### Sah/SchemaR/rinci/meta.pm ###
#package Sah::SchemaR::rinci::meta;
#
#our $DATE = '2018-11-29'; 
#our $VERSION = '1.1.87.0'; 
#
#our $rschema = do{my$a=["hash",[{_prop=>{caption=>{},default_lang=>{},defhash_v=>{},description=>{},entity_date=>{},entity_v=>{},links=>{_elem_prop=>{caption=>'fix',default_lang=>'fix',defhash_v=>'fix',description=>'fix',name=>{},summary=>{},tags=>{},url=>{},v=>{},x=>{}}},name=>'fix',summary=>'fix',tags=>'fix',v=>'fix',x=>'fix'},_ver=>1.1,summary=>"Rinci metadata"}],["hash"]];$a->[1][0]{_prop}{links}{_elem_prop}{caption}=$a->[1][0]{_prop}{caption};$a->[1][0]{_prop}{links}{_elem_prop}{default_lang}=$a->[1][0]{_prop}{default_lang};$a->[1][0]{_prop}{links}{_elem_prop}{defhash_v}=$a->[1][0]{_prop}{defhash_v};$a->[1][0]{_prop}{links}{_elem_prop}{description}=$a->[1][0]{_prop}{description};$a->[1][0]{_prop}{name}=$a->[1][0]{_prop}{links}{_elem_prop}{name};$a->[1][0]{_prop}{summary}=$a->[1][0]{_prop}{links}{_elem_prop}{summary};$a->[1][0]{_prop}{tags}=$a->[1][0]{_prop}{links}{_elem_prop}{tags};$a->[1][0]{_prop}{v}=$a->[1][0]{_prop}{links}{_elem_prop}{v};$a->[1][0]{_prop}{x}=$a->[1][0]{_prop}{links}{_elem_prop}{x};$a};
#
#1;
#
#__END__
#
### Sah/SchemaR/rinci/result_meta.pm ###
#package Sah::SchemaR::rinci::result_meta;
#
#our $DATE = '2018-11-29'; 
#our $VERSION = '1.1.87.0'; 
#
#our $rschema = ["hash",[{_prop=>{caption=>{},cmdline=>{},default_lang=>{},defhash_v=>{},description=>{},func=>{},len=>{},logs=>{},name=>{},part_len=>{},part_start=>{},perm_err=>{},prev=>{},results=>{},stream=>{},summary=>{},tags=>{},v=>{},x=>{}},_ver=>1.1,summary=>"Rinci envelope result metadata"}],["hash"]];
#
#1;
#
#__END__
#
### Sah/Schemas/Rinci.pm ###
#package Sah::Schemas::Rinci;
#
#our $DATE = '2018-11-29'; 
#our $VERSION = '1.1.87.0'; 
#
#1;
#
#__END__
#
### Scalar/Util/Numeric/PP.pm ###
#package Scalar::Util::Numeric::PP;
#
#our $DATE = '2016-01-22'; 
#our $VERSION = '0.04'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       isint
#                       isnum
#                       isnan
#                       isinf
#                       isneg
#                       isfloat
#               );
#
#sub isint {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?(?:0|[1-9][0-9]*)\s*\z/s;
#    0;
#}
#
#sub isnan($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?nan\s*\z/is;
#    0;
#}
#
#sub isinf($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?inf(?:inity)?\s*\z/is;
#    0;
#}
#
#sub isneg($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*-/;
#    0;
#}
#
#sub isnum($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if isint($_);
#    return 1 if isfloat($_);
#    0;
#}
#
#sub isfloat($) {
#    local $_ = shift;
#    return 0 unless defined;
#    return 1 if /\A\s*[+-]?
#                 (?: (?:0|[1-9][0-9]*)(\.[0-9]+)? | (\.[0-9]+) )
#                 ([eE][+-]?[0-9]+)?\s*\z/sx && $1 || $2 || $3;
#    return 1 if isnan($_) || isinf($_);
#    0;
#}
#
#1;
#
#__END__
#
### Sort/BySpec.pm ###
#package Sort::BySpec;
#
#our $DATE = '2017-02-17'; 
#our $VERSION = '0.03'; 
#
#use 5.010001;
#use strict 'subs', 'vars';
#use warnings;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(sort_by_spec cmp_by_spec);
#
#our %SPEC;
#
#$SPEC{':package'} = {
#    v => 1.1,
#    summary => 'Sort array (or create a list sorter) according to '.
#        'specification',
#};
#
#$SPEC{sort_by_spec} = {
#    v => 1.1,
#    summary => 'Sort array (or create a list sorter) according to '.
#        'specification',
#    description => <<'_',
#
#
#_
#    args => {
#        spec => {
#            schema => 'array*',
#            req => 1,
#            pos => 0,
#        },
#        xform => {
#            schema => 'code*',
#            summary => 'Code to return sort keys from data elements',
#            description => <<'_',
#
#This is just like `xform` in `Sort::ByExample`.
#
#_
#        },
#        reverse => {
#            summary => 'If set to true, will reverse the sort order',
#            schema => ['bool*', is=>1],
#        },
#        array => {
#            schema => 'array*',
#        },
#    },
#    result => {
#        summary => 'Sorted array, or sort coderef',
#        schema => ['any*', of=>['array*','code*']],
#        description => <<'_',
#
#If array is specified, will returned the sorted array. If array is not specified
#in the argument, will return a sort subroutine that can be used to sort a list
#and return the sorted list.
#
#_
#    },
#    result_naked => 1,
#    examples => [
#        {
#            summary => 'Sort according to a sequence of scalars (like Sort::ByExample)',
#            args => {
#                spec => ['foo', 'bar', 'baz'],
#                array => [1, 2, 3, 'bar', 'a', 'b', 'c', 'baz'],
#            },
#        },
#        {
#            summary => 'Like previous example, but reversed',
#            args => {
#                spec => ['foo', 'bar', 'baz'],
#                array => [1, 2, 3, 'bar', 'a', 'b', 'c', 'baz'],
#                reverse => 1,
#            },
#        },
#        {
#            summary => 'Put integers first (in descending order), then '.
#                'a sequence of scalars, then others (in ascending order)',
#            args => {
#                spec => [
#                    qr/\A\d+\z/ => sub { $_[1] <=> $_[0] },
#                    'foo', 'bar', 'baz',
#                    qr// => sub { $_[0] cmp $_[1] },
#                ],
#                array => ["qux", "b", "a", "bar", "foo", 1, 10, 2],
#            },
#        },
#    ],
#};
#sub sort_by_spec {
#    my %args = @_;
#
#    my $spec  = $args{spec};
#    my $xform = $args{xform};
#
#    my $code_get_rank = sub {
#        my $val = shift;
#
#        my $j;
#        for my $which (0..2) { 
#            $j = -1;
#            while ($j < $#{$spec}) {
#                $j++;
#                my $spec_elem = $spec->[$j];
#                my $ref = ref($spec_elem);
#                if (!$ref) {
#                    if ($which == 0 && $val eq $spec_elem) {
#                        return($j);
#                    }
#                } elsif ($ref eq 'Regexp') {
#                    my $sortsub;
#                    if ($j < $#{$spec} && ref($spec->[$j+1]) eq 'CODE') {
#                        $sortsub = $spec->[$j+1];
#                    }
#                    if ($which == 1 && $val =~ $spec_elem) {
#                        return($j, $sortsub);
#                    }
#                    $j++ if $sortsub;
#                } elsif ($ref eq 'CODE') {
#                    my $sortsub;
#                    if ($j < $#{$spec} && ref($spec->[$j+1]) eq 'CODE') {
#                        $sortsub = $spec->[$j+1];
#                    }
#                    if ($which == 2 && $spec_elem->($val)) {
#                        return($j, $sortsub);
#                    }
#                    $j++ if $sortsub;
#                } else {
#                    die "Invalid spec[$j]: not a scalar/Regexp/code";
#                }
#            } 
#        } 
#        return($j+1);
#    };
#
#    if ($args{_return_cmp}) {
#        my $cmp = sub {
#            my ($a, $b);
#
#            if (@_ >= 2) {
#                $a = $_[0];
#                $b = $_[1];
#            } else {
#                my $caller = caller();
#                $a = ${"caller\::a"};
#                $b = ${"caller\::b"};
#            }
#
#            if ($xform) {
#                $a = $xform->($a);
#                $b = $xform->($b);
#            }
#
#            if ($args{reverse}) {
#                ($a, $b) = ($b, $a);
#            }
#
#            my ($rank_a, $sortsub) = $code_get_rank->($a);
#            my ($rank_b          ) = $code_get_rank->($b);
#
#            if ($rank_a != $rank_b) {
#                return $rank_a <=> $rank_b;
#            }
#            return 0 unless $sortsub;
#            return $sortsub->($a, $b);
#        };
#        return $cmp;
#    } else {
#        my $sorter = sub {
#            return map { $_->[0] }
#                sort {
#                    $a->[2] <=> $b->[2] ||
#                        ($a->[3] ? $a->[3]($a->[1], $b->[1]) : 0) }
#                    map {
#                        my $x = $xform ? $xform->($_) : $_;
#                        [$_, $x, $code_get_rank->($x)]
#                    } @_;
#        };
#
#        if ($args{array}) {
#            return [$sorter->(@{ $args{array} })];
#        }
#        return $sorter;
#    }
#}
#
#$SPEC{cmp_by_spec} = do {
#    my $meta = { %{ $SPEC{sort_by_spec} } };
#    $meta->{summary} = 'Create a compare subroutine to be used in sort()';
#    $meta->{args} = { %{$meta->{args}} };
#    delete $meta->{args}{array};
#    $meta->{result} = {
#        schema => ['code*'],
#    };
#    delete $meta->{examples};
#    $meta;
#};
#sub cmp_by_spec {
#    sort_by_spec(
#        @_,
#        _return_cmp => 1,
#    );
#}
#
#1;
#
#__END__
#
### String/Elide/Parts.pm ###
#package String::Elide::Parts;
#
#our $DATE = '2017-01-29'; 
#our $VERSION = '0.07'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(elide);
#
#sub _elide_part {
#    my ($str, $len, $marker, $truncate) = @_;
#
#    my $len_marker = length($marker);
#    if ($len <= $len_marker) {
#        return substr($marker, 0, $len);
#    }
#
#    if ($truncate eq 'left') {
#        return $marker . substr($str, length($str) - $len+$len_marker);
#    } elsif ($truncate eq 'middle') {
#        my $left  = substr($str, 0,
#                           ($len-$len_marker)/2);
#        my $right = substr($str,
#                           length($str) - ($len-$len_marker-length($left)));
#        return $left . $marker . $right;
#    } elsif ($truncate eq 'ends') {
#        if ($len <= 2*$len_marker) {
#            return substr($marker . $marker, 0, $len);
#        }
#        return $marker . substr($str, (length($str)-$len)/2 + $len_marker,
#                                $len-2*$len_marker) . $marker;
#    } else { 
#        return substr($str, 0, $len-$len_marker) . $marker;
#    }
#}
#
#sub elide {
#    my ($str, $len, $opts) = @_;
#
#    $opts //= {};
#    my $truncate  = $opts->{truncate} // 'right';
#    my $marker = $opts->{marker} // '..';
#    my $default_prio = $opts->{default_prio} // 1;
#
#    my @parts;
#    my @parts_attrs;
#    while ($str =~ m#<elspan([^>]*)>(.*?)</elspan>|(.*?)(?=<elspan)|(.*)#gs) {
#        if (defined $1) {
#            next unless length $2;
#            push @parts, $2;
#            push @parts_attrs, $1;
#        } elsif (defined $3) {
#            next unless length $3;
#            push @parts, $3;
#            push @parts_attrs, undef;
#        } elsif (defined $4) {
#            next unless length $4;
#            push @parts, $4;
#            push @parts_attrs, undef;
#        }
#    }
#    return "" unless @parts && $len > 0;
#    for my $i (0..@parts-1) {
#        if (defined $parts_attrs[$i]) {
#            my $attrs = {};
#            $attrs->{truncate} = $1 // $2
#                if $parts_attrs[$i] =~ /\btruncate=(?:"([^"]*)"|(\S+))/;
#            $attrs->{marker} = $1 // $2
#                if $parts_attrs[$i] =~ /\bmarker=(?:"([^"]*)"|(\S+))/;
#            $attrs->{prio} = $1 // $2
#                if $parts_attrs[$i] =~ /\bprio(?:rity)?=(?:"([^"]*)"|(\S+))/;
#            $parts_attrs[$i] = $attrs;
#        } else {
#            $parts_attrs[$i] = {prio=>$default_prio};
#        }
#    }
#
#
#  PRIO:
#    while (1) {
#        my $all_parts_len = 0;
#        $all_parts_len += length($_) for @parts;
#
#        if ($all_parts_len <= $len) {
#            return join("", @parts);
#        }
#
#        my $highest_prio;
#        for (@parts_attrs) {
#            $highest_prio = $_->{prio} if !defined($highest_prio) ||
#                $highest_prio < $_->{prio};
#        }
#        my @high_indexes;
#        my $high_parts_len = 0;
#        for my $i (0..$#parts_attrs) {
#            if ($parts_attrs[$i]{prio} == $highest_prio) {
#                $high_parts_len += length $parts[$i];
#                push @high_indexes, $i;
#            }
#        }
#
#        if ($all_parts_len - $high_parts_len >= $len) {
#            for (reverse @high_indexes) {
#                splice @parts, $_, 1;
#                splice @parts_attrs, $_, 1;
#                next PRIO;
#            }
#        }
#
#
#        my @must_elide_total_len_after_this;
#        my $tot_to_elide = $all_parts_len - $len;
#        for my $i (0..$#high_indexes) {
#            $must_elide_total_len_after_this[$i] =
#                int( ($i+1)/@high_indexes * $tot_to_elide );
#        }
#
#        my $tot_already_elided = 0;
#        my $tot_still_to_elide = 0;
#        for my $i (reverse 0..$#high_indexes) {
#            my $idx = $high_indexes[$i];
#            my $part_len = length $parts[$idx];
#            my $to_elide = $must_elide_total_len_after_this[$#high_indexes - $i] -
#                $tot_already_elided;
#            if ($to_elide <= 0) {
#            } elsif ($part_len <= $to_elide) {
#                splice @parts, $idx, 1;
#                splice @parts_attrs, $idx, 1;
#                $tot_already_elided += $part_len;
#                $tot_still_to_elide += ($to_elide - $part_len);
#            } else {
#                $parts[$idx] = _elide_part(
#                    $parts[$idx],
#                    $part_len - $to_elide,
#                    $parts_attrs[$idx]{marker} // $marker,
#                    $parts_attrs[$idx]{truncate} // $truncate,
#                );
#                $tot_already_elided += $to_elide;
#                $tot_still_to_elide = 0;
#            }
#        }
#
#    } 
#}
#
#1;
#
#__END__
#
### String/LineNumber.pm ###
#package String::LineNumber;
#
#our $DATE = '2014-12-10'; 
#our $VERSION = '0.01'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       linenum
#               );
#
#sub linenum {
#    my ($str, $opts) = @_;
#    $opts //= {};
#    $opts->{width}      //= 4;
#    $opts->{zeropad}    //= 0;
#    $opts->{skip_empty} //= 1;
#
#    my $i = 0;
#    $str =~ s/^(([\t ]*\S)?.*)/
#        sprintf(join("",
#                     "%",
#                     ($opts->{zeropad} && !($opts->{skip_empty}
#                                                && !defined($2)) ? "0" : ""),
#                     $opts->{width}, "s",
#                     "|%s"),
#                ++$i && $opts->{skip_empty} && !defined($2) ? "" : $i,
#                $1)/meg;
#
#    $str;
#}
#
#1;
#
#__END__
#
### String/PerlQuote.pm ###
#package String::PerlQuote;
#
#our $DATE = '2016-10-07'; 
#our $VERSION = '0.02'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       single_quote
#                       double_quote
#               );
#
#my %esc = (
#    "\a" => "\\a",
#    "\b" => "\\b",
#    "\t" => "\\t",
#    "\n" => "\\n",
#    "\f" => "\\f",
#    "\r" => "\\r",
#    "\e" => "\\e",
#);
#
#sub double_quote {
#  local($_) = $_[0];
#  s/([\\\"\@\$])/\\$1/g;
#  return qq("$_") unless /[^\040-\176]/;  
#
#  s/([\a\b\t\n\f\r\e])/$esc{$1}/g;
#
#  s/([\0-\037])(?!\d)/sprintf('\\%o',ord($1))/eg;
#
#  s/([\0-\037\177-\377])/sprintf('\\x%02X',ord($1))/eg;
#  s/([^\040-\176])/sprintf('\\x{%X}',ord($1))/eg;
#
#  return qq("$_");
#}
#
#sub single_quote {
#  local($_) = $_[0];
#  s/([\\'])/\\$1/g;
#  return qq('$_');
#}
#1;
#
#__END__
#
### String/ShellQuote.pm ###
#
#
#package String::ShellQuote;
#
#use strict;
#use vars qw($VERSION @ISA @EXPORT);
#
#require Exporter;
#
#$VERSION	= '1.04';
#@ISA		= qw(Exporter);
#@EXPORT		= qw(shell_quote shell_quote_best_effort shell_comment_quote);
#
#sub croak {
#    require Carp;
#    goto &Carp::croak;
#}
#
#sub _shell_quote_backend {
#    my @in = @_;
#    my @err = ();
#
#    if (0) {
#	require RS::Handy;
#	print RS::Handy::data_dump(\@in);
#    }
#
#    return \@err, '' unless @in;
#
#    my $ret = '';
#    my $saw_non_equal = 0;
#    foreach (@in) {
#	if (!defined $_ or $_ eq '') {
#	    $_ = "''";
#	    next;
#	}
#
#	if (s/\x00//g) {
#	    push @err, "No way to quote string containing null (\\000) bytes";
#	}
#
#    	my $escape = 0;
#
#
#	if (/=/) {
#	    if (!$saw_non_equal) {
#	    	$escape = 1;
#	    }
#	}
#	else {
#	    $saw_non_equal = 1;
#	}
#
#	if (m|[^\w!%+,\-./:=@^]|) {
#	    $escape = 1;
#	}
#
#	if ($escape
#		|| (!$saw_non_equal && /=/)) {
#
#    	    s/'/'\\''/g;
#
#    	    s|((?:'\\''){2,})|q{'"} . (q{'} x (length($1) / 4)) . q{"'}|ge;
#
#	    $_ = "'$_'";
#	    s/^''//;
#	    s/''$//;
#	}
#    }
#    continue {
#	$ret .= "$_ ";
#    }
#
#    chop $ret;
#    return \@err, $ret;
#}
#
#
#sub shell_quote {
#    my ($rerr, $s) = _shell_quote_backend @_;
#
#    if (@$rerr) {
#    	my %seen;
#    	@$rerr = grep { !$seen{$_}++ } @$rerr;
#	my $s = join '', map { "shell_quote(): $_\n" } @$rerr;
#	chomp $s;
#	croak $s;
#    }
#    return $s;
#}
#
#
#sub shell_quote_best_effort {
#    my ($rerr, $s) = _shell_quote_backend @_;
#
#    return $s;
#}
#
#
#sub shell_comment_quote {
#    return '' unless @_;
#    unless (@_ == 1) {
#	croak "Too many arguments to shell_comment_quote "
#	    	    . "(got " . @_ . " expected 1)";
#    }
#    local $_ = shift;
#    s/\n/\n#/g;
#    return $_;
#}
#
#1;
#
#__END__
#
### String/Wildcard/Bash.pm ###
#package String::Wildcard::Bash;
#
#use 5.010001;
#use strict;
#use warnings;
#
#our $VERSION = '0.03'; 
#
#use Exporter;
#our @ISA = qw(Exporter);
#our @EXPORT_OK = qw(
#                       $RE_WILDCARD_BASH
#                       contains_wildcard
#                       convert_wildcard_to_sql
#               );
#
#our $RE_WILDCARD_BASH =
#    qr(
#          # non-escaped brace expression, with at least one comma
#          (?P<brace>
#              (?<!\\)(?:\\\\)*\{
#              (?:           \\\\ | \\\{ | \\\} | [^\\\{\}] )*
#              (?:, (?:  \\\\ | \\\{ | \\\} | [^\\\{\}] )* )+
#              (?<!\\)(?:\\\\)*\}
#          )
#      |
#          # non-escaped brace expression, to catch * or ? or [...] inside so
#          # they don't go to below pattern, because bash doesn't consider them
#          # wildcards, e.g. '/{et?,us*}' expands to '/etc /usr', but '/{et?}'
#          # doesn't expand at all to /etc.
#          (?P<braceno>
#              (?<!\\)(?:\\\\)*\{
#              (?:           \\\\ | \\\{ | \\\} | [^\\\{\}] )*
#              (?<!\\)(?:\\\\)*\}
#          )
#      |
#          (?P<class>
#              # non-empty, non-escaped character class
#              (?<!\\)(?:\\\\)*\[
#              (?:  \\\\ | \\\[ | \\\] | [^\\\[\]] )+
#              (?<!\\)(?:\\\\)*\]
#          )
#      |
#          (?P<joker>
#              # non-escaped * and ?
#              (?<!\\)(?:\\\\)*[*?]
#          )
#      |
#          (?P<sql_wc>
#              # non-escaped % and ?
#              (?<!\\)(?:\\\\)*[%_]
#          )
#      )ox;
#
#sub contains_wildcard {
#    my $str = shift;
#
#    while ($str =~ /$RE_WILDCARD_BASH/go) {
#        my %m = %+;
#        return 1 if $m{brace} || $m{class} || $m{joker};
#    }
#    0;
#}
#
#sub convert_wildcard_to_sql {
#    my $str = shift;
#
#    $str =~ s/$RE_WILDCARD_BASH/
#        if ($+{joker}) {
#            if ($+{joker} eq '*') {
#                "%";
#            } else {
#                "_";
#            }
#        } elsif ($+{sql_wc}) {
#            "\\$+{sql_wc}";
#        } else {
#            $&;
#        }
#    /eg;
#
#    $str;
#}
#
#1;
#
#__END__
#
### Sub/Delete.pm ###
#use 5.008003;
#
#package Sub::Delete;
#
#$VERSION = '1.00002';
#@EXPORT = delete_sub;
#
#use Exporter 5.57 'import';
#use constant point0 => 0+$] eq 5.01;
#
#sub strict_eval($) {
# local %^H if point0;
# local *@;
# use
#  strict 'vars';
# local $SIG{__WARN__} = sub {};
# eval shift
#}
#
#my %sigils = qw( SCALAR $  ARRAY @  HASH % );
#
#sub delete_sub {
#	my $sub = shift;
#	my($stashname, $key) = $sub =~ /(.*::)((?:(?!::).)*)\z/s
#		? ($1,$2) : (caller()."::", $sub);
#	exists +(my $stash = \%$stashname)->{$key} or return;
#	ref $stash->{$key} eq 'SCALAR' and  
#		delete $stash->{$key}, return;
#	my $globname = "$stashname$key"; 
#	my $glob = *$globname; 
#	defined *$glob{CODE} or return;  
#	my $check_importedness
#	 = $stashname =~ /^(?:(?!\d)\w*(?:::\w*)*)\z/
#	   && $key    =~ /^(?!\d)\w+\z/;
#	my %imported_slots;
#	my $package;
#	if($check_importedness) {
#		$package = substr $stashname, 0, -2;
#		for (qw "SCALAR ARRAY HASH") {
#			defined *$glob{$_} or next;
#			$imported_slots{$_} = strict_eval
#			  "package $package; 0 && $sigils{$_}$key; 1"
#		}
#	}
#        delete $stash->{$key};
#	keys %imported_slots == 1 and exists $imported_slots{SCALAR}
#	 and !$imported_slots{SCALAR} and Internals'SvREFCNT $$glob =>== 1
#	 and !defined *$glob{IO} and !defined *$glob{FORMAT}
#	 and return; 
#	my $newglob = \*$globname;
#	local *alias = *$newglob;
#	defined *$glob{$_} and (
#	 !$check_importedness || $imported_slots{$_}
#	  ? *$newglob
#	  : *alias
#	) = *$glob{$_}
#		for qw "SCALAR ARRAY HASH";
#	defined *$glob{$_} and *$newglob = *$glob{$_}
#		for qw "IO FORMAT";
#	return 
#}
#
#1;
#
#__END__
#
### Test/Config/IOD/Common.pm ###
#package Test::Config::IOD::Common;
#
#our $DATE = '2019-01-17'; 
#our $VERSION = '0.342'; 
#
#use 5.010;
#use strict;
#use warnings;
#
#use Test::More 0.98;
#
#our $CLASS = "Config::IOD::Reader";
#
#sub test_common_iod {
#
#    eval "require $CLASS"; die if $@;
#
#    subtest "opt: default_section" => sub {
#        test_read_iod(
#            args  => {default_section=>'bawaan'},
#            input => <<'_',
#a=1
#_
#            result => {bawaan=>{a=>1}},
#        );
#    };
#
#    subtest "opt: allow_directives" => sub {
#        test_read_iod(
#            args  => {allow_directives=>['merge']},
#            input => <<'_',
#;!noop
#_
#            dies  => 1,
#        );
#        test_read_iod(
#            args  => {allow_directives=>['noop']},
#            input => <<'_',
#;!noop
#_
#            result => {},
#        );
#    };
#
#    subtest "opt: disallow_directives" => sub {
#        test_read_iod(
#            args  => {disallow_directives=>['noop']},
#            input => <<'_',
#;!noop
#_
#            dies  => 1,
#        );
#        test_read_iod(
#            args  => {disallow_directives=>['merge']},
#            input => <<'_',
#;!noop
#_
#            result => {},
#        );
#    };
#
#    subtest "opt: allow_directives + disallow_directives" => sub {
#        test_read_iod(
#            args  => {
#                allow_directives    => ['noop'],
#                disallow_directives => ['noop'],
#            },
#            input => <<'_',
#;!noop
#_
#            dies  => 1,
#        );
#    };
#
#    subtest "opt: enable_directive=0" => sub {
#        test_read_iod(
#            args  => {enable_directive=>0},
#            input => <<'_',
#[s1]
#a=1
#[s2]
#;!merge s1
#b=2
#_
#            result => {s1=>{a=>1}, s2=>{b=>2}},
#        );
#        test_read_iod(
#            args  => {enable_directive=>0},
#            input => <<'_',
#[s1]
#a=1
#[s2]
#!merge s1
#b=2
#_
#            dies => 1,
#        );
#    };
#
#    subtest "opt: enable_quoting=0" => sub {
#        test_read_iod(
#            args  => {enable_quoting=>0},
#            input => <<'_',
#name="1\n2"
#_
#            result => {GLOBAL=>{name=>'"1\\n2"'}},
#        );
#    };
#
#    subtest "opt: enable_bracket=0" => sub {
#        test_read_iod(
#            args  => {enable_bracket=>0},
#            input => <<'_',
#name=[1,2,3]
#_
#            result => {GLOBAL=>{name=>'[1,2,3]'}},
#        );
#    };
#
#    subtest "opt: enable_brace=0" => sub {
#        test_read_iod(
#            args  => {enable_brace=>0},
#            input => <<'_',
#name={"a":1}
#_
#            result => {GLOBAL=>{name=>'{"a":1}'}},
#        );
#    };
#
#    subtest "opt: enable_encoding=0" => sub {
#        test_read_iod(
#            args  => {enable_encoding=>0},
#            input => <<'_',
#name=!hex 5e5e
#_
#            result => {GLOBAL=>{name=>'!hex 5e5e'}},
#        );
#    };
#
#    subtest "opt: allow_encodings" => sub {
#        test_read_iod(
#            args  => {allow_encodings=>['hex']},
#            input => <<'_',
#name=!json "1\n2"
#_
#            dies => 1,
#        );
#        test_read_iod(
#            args  => {allow_encodings=>['json']},
#            input => <<'_',
#name=!json "1\n2"
#name2=!j "3\n4"
#_
#            result => {GLOBAL=>{name=>"1\n2", name2=>"3\n4"}},
#        );
#    };
#
#    subtest "opt: disallow_encodings" => sub {
#        test_read_iod(
#            args  => {disallow_encodings=>['json']},
#            input => <<'_',
#name=!json "1\n2"
#_
#            dies => 1,
#        );
#        test_read_iod(
#            args  => {disallow_encodings=>['json']},
#            input => <<'_',
#name=!j "1\n2"
#_
#            dies => 1,
#        );
#        test_read_iod(
#            args  => {disallow_encodings=>['hex']},
#            input => <<'_',
#name=!json "1\n2"
#_
#            result => {GLOBAL=>{name=>"1\n2"}},
#        );
#    };
#
#    subtest "opt: allow_encodings + disallow_encodings" => sub {
#        test_read_iod(
#            args  => {
#                allow_encodings   =>['json'],
#                disallow_encodings=>['json'],
#            },
#            input => <<'_',
#name=!json "1\n2"
#_
#            dies => 1,
#        );
#    };
#
#    subtest "opt: allow_bang_only=0" => sub {
#        test_read_iod(
#            args  => {allow_bang_only=>0},
#            input => <<'_',
#a=1
#!noop
#_
#            dies => 1,
#        );
#    };
#
#    subtest "opt: allow_duplicate_key=0" => sub {
#        test_read_iod(
#            args  => {allow_duplicate_key=>0},
#            input => <<'_',
#a=1
#a=2
#_
#            dies => 1,
#        );
#    };
#
#    subtest "opt: ignore_unknown_directive=1" => sub {
#        test_read_iod(
#            args  => {ignore_unknown_directive=>1},
#            input => <<'_',
#;!foo bar
#_
#            result => {},
#        );
#    };
#
#    subtest "expr" => sub {
#        test_read_iod(
#            name  => "must be enabled first",
#            args  => {},
#            input => <<'_',
#a=!e 1+1
#_
#            dies => 1,
#        );
#        test_read_iod(
#            name  => "must be valid",
#            args  => {enable_expr=>1},
#            input => <<'_',
#a=!e 1+
#_
#            dies => 1,
#        );
#        test_read_iod(
#            args  => {enable_expr=>1},
#            input => <<'_',
#a=!e 1+1
#[sect]
#b=!e val("GLOBAL.a")*3
#c=!e val("b") x 3
#_
#            result => {GLOBAL=>{a=>2}, sect=>{b=>6, c=>666}},
#        );
#    };
#}
#
#sub test_read_iod {
#    my %args = @_;
#
#    my $parser_args = $args{args};
#    my $test_name = $args{name} //
#        "{". join(", ",
#                  (map {"$_=$parser_args->{$_}"}
#                       sort keys %$parser_args),
#              ) . "}";
#    subtest $test_name => sub {
#
#        my $parser = $CLASS->new(%$parser_args);
#
#        my $res;
#        eval {
#            if ($CLASS eq 'Config::IOD') {
#                $res = $parser->read_string($args{input})->dump;
#            } else {
#                $res = $parser->read_string($args{input});
#            }
#        };
#        my $err = $@;
#        if ($args{dies}) {
#            ok($err, "dies") or diag explain $res;
#            return;
#        } else {
#            ok(!$err, "doesn't die")
#                or do { diag explain "err=$err"; return };
#            is_deeply($res, $args{result}, 'result')
#                or diag explain $res;
#        }
#    };
#}
#
#1;
#
#__END__
#
### Test/Data/Sah.pm ###
#
#package Test::Data::Sah;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010;
#use strict;
#use warnings;
#use Test::More 0.98;
#
#use Data::Dump qw(dump);
#use Data::Sah qw(gen_validator);
#use File::chdir;
#use File::Slurper qw(read_text);
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(
#                       test_sah_cases
#                       run_spectest
#                       all_match
#                       any_match
#                       none_match
#               );
#
#sub test_sah_cases {
#    my $tests = shift;
#    my $opts  = shift // {};
#
#    my $sah = Data::Sah->new;
#    my $plc = $sah->get_compiler('perl');
#
#    my $gvopts = $opts->{gen_validator_opts} // {};
#    my $rt = $gvopts->{return_type} // 'bool';
#
#    for my $test (@$tests) {
#        my $v = gen_validator($test->{schema}, $gvopts);
#        my $res = $v->($test->{input});
#        my $name = $test->{name} //
#            "data " . dump($test->{input}) . " should".
#                ($test->{valid} ? " pass" : " not pass"). " schema " .
#                    dump($test->{schema});
#        my $testres;
#        if ($test->{valid}) {
#            if ($rt eq 'bool') {
#                $testres = ok($res, $name);
#            } elsif ($rt eq 'str') {
#                $testres = is($res, "", $name) or diag explain $res;
#            } elsif ($rt eq 'full') {
#                $testres = is(~~keys(%{$res->{errors}}), 0, $name) or diag explain $res;
#            }
#        } else {
#            if ($rt eq 'bool') {
#                $testres = ok(!$res, $name);
#            } elsif ($rt eq 'str') {
#                $testres = isnt($res, "", $name) or diag explain $res;
#            } elsif ($rt eq 'full') {
#                $testres = isnt(~~keys(%{$res->{errors}}), 0, $name) or diag explain $res;
#            }
#        }
#        next if $testres;
#
#        my $cd = $plc->compile(schema => $test->{schema});
#        diag "schema compilation result:\n----begin generated code----\n",
#            explain($cd->{result}), "\n----end generated code----\n",
#                "that code should return ", ($test->{valid} ? "true":"false"),
#                    " when fed \$data=", dump($test->{input}),
#                        " but instead returns ", dump($res);
#
#        my $vfull = gen_validator($test->{schema}, {return_type=>"full"});
#        diag "\nvalidator result (full):\n----begin result----\n",
#            explain($vfull->($test->{input})), "----end result----";
#    }
#}
#
#sub _decode_json {
#    state $json = do {
#        require JSON;
#        JSON->new->allow_nonref;
#    };
#    $json->decode(@_);
#}
#
#sub run_spectest {
#    require File::ShareDir;
#    require File::ShareDir::Tarball;
#    require Sah;
#
#    my %args = @_;
#
#    my $sah = Data::Sah->new;
#
#    my $dir;
#    if (version->parse($Sah::VERSION) == version->parse("0.9.27")) {
#        $dir = File::ShareDir::dist_dir("Sah");
#    } else {
#        $dir = File::ShareDir::Tarball::dist_dir("Sah");
#    }
#    $dir && (-d $dir) or die "Can't find spectest, have you installed Sah?";
#    (-f "$dir/spectest/00-normalize_schema.json")
#        or die "Something's wrong, spectest doesn't contain the correct files";
#
#    my @specfiles;
#    {
#        local $CWD = "$dir/spectest";
#        @specfiles = glob("*.json");
#    }
#
#    my @files;
#    if ($ENV{TEST_SAH_SPECTEST_FILES}) {
#        @files = split /\s*,\s*|\s+/, $ENV{TEST_SAH_SPECTEST_FILES};
#    } else {
#        @files = @ARGV;
#    }
#
#    my @types;
#    if ($ENV{TEST_SAH_SPECTEST_TYPES}) {
#        @types = split /\s*,\s*|\s+/, $ENV{TEST_SAH_SPECTEST_TYPES};
#    }
#
#    my @include_tags;
#    if ($ENV{TEST_SAH_SPECTEST_INCLUDE_TAGS}) {
#        @include_tags = split /\s*,\s*|\s+/,
#            $ENV{TEST_SAH_SPECTEST_INCLUDE_TAGS};
#    }
#
#    my @exclude_tags;
#    if ($ENV{TEST_SAH_SPECTEST_EXCLUDE_TAGS}) {
#        @exclude_tags = split /\s*,\s*|\s+/,
#            $ENV{TEST_SAH_SPECTEST_EXCLUDE_TAGS};
#    }
#
#    my $code_test_excluded = sub {
#        my $test = shift;
#
#        if ($test->{tags} && @exclude_tags) {
#            if (any_match(\@exclude_tags, $test->{tags})) {
#                return "contains excluded tag(s) (".
#                    join(", ", @exclude_tags).")";
#            }
#        }
#        if (@include_tags) {
#            if (!all_match(\@include_tags, $test->{tags} // [])) {
#                return "does not contain all include tags (".
#                    join(", ", @include_tags).")";
#            }
#        }
#        "";
#    };
#
#    {
#        use experimental 'smartmatch';
#
#        last unless $args{test_normalize_schema};
#
#        for my $file ("00-normalize_schema.json") {
#            unless (!@files || $file ~~ @files) {
#                diag "Skipping file $file";
#                next;
#            }
#            subtest $file => sub {
#                my $tspec = _decode_json(~~read_text("$dir/spectest/$file"));
#                for my $test (@{ $tspec->{tests} }) {
#                    subtest $test->{name} => sub {
#                        if (my $reason = $code_test_excluded->($test)) {
#                            plan skip_all => "Skipping test $test->{name}: $reason";
#                            return;
#                        }
#                        eval {
#                            is_deeply(normalize_schema($test->{input}),
#                                      $test->{result}, "result");
#                        };
#                        my $eval_err = $@;
#                        if ($test->{dies}) {
#                            ok($eval_err, "dies");
#                        } else {
#                            ok(!$eval_err, "doesn't die")
#                                or diag $eval_err;
#                        }
#                    };
#                }
#                ok 1; 
#            };
#        }
#    }
#
#    {
#        use experimental 'smartmatch';
#
#        last unless $args{test_merge_clause_sets};
#
#        for my $file ("01-merge_clause_sets.json") {
#            last; 
#            unless (!@files || $file ~~ @files) {
#                diag "Skipping file $file";
#                next;
#            }
#            subtest $file => sub {
#                my $tspec = _decode_json(~~read_text("$dir/spectest/$file"));
#                for my $test (@{ $tspec->{tests} }) {
#                    subtest $test->{name} => sub {
#                        if (my $reason = $code_test_excluded->($test)) {
#                            plan skip_all => "Skipping test $test->{name}: $reason";
#                            return;
#                        }
#                        eval {
#                            is_deeply($sah->_merge_clause_sets(@{ $test->{input} }),
#                                      $test->{result}, "result");
#                        };
#                        my $eval_err = $@;
#                        if ($test->{dies}) {
#                            ok($eval_err, "dies");
#                        } else {
#                            ok(!$eval_err, "doesn't die")
#                                or diag $eval_err;
#                        }
#                    };
#                }
#                ok 1; 
#            };
#        }
#    }
#
#    {
#        use experimental 'smartmatch';
#
#        for my $file (grep {/^10-type-/} @specfiles) {
#            unless (!@files || $file ~~ @files) {
#                diag "Skipping file $file";
#                next;
#            }
#            subtest $file => sub {
#                diag "Loading $file ...";
#                my $tspec = _decode_json(~~read_text("$dir/spectest/$file"));
#                note "Test version: ", $tspec->{version};
#                my $tests = $tspec->{tests};
#                if ($args{tests_func}) {
#                    $args{tests_func}->($tests, {
#                        parent_args => \%args,
#                        code_test_excluded => $code_test_excluded,
#                    });
#                } elsif ($args{test_func}) {
#                    for my $test (@$tests) {
#                        my $skip_reason;
#                        {
#                            if ($args{skip_if}) {
#                                $skip_reason = $args{skip_if}->($test);
#                                last if $skip_reason;
#                            }
#                            $skip_reason = $code_test_excluded->($test);
#                            last if $skip_reason;
#                        }
#                        my $tname = "(tags=".join(", ", sort @{ $test->{tags} // [] }).
#                            ") $test->{name}";
#                        if ($skip_reason) {
#                            diag "Skipping test $tname: $skip_reason";
#                            next;
#                        }
#                        note explain $test;
#                        subtest $tname => sub {
#                            $args{test_func}->($test);
#                        };
#                    } 
#                    ok 1; 
#                } else {
#                    die "Please specify 'test_func' or 'tests_func'";
#                }
#            }; 
#        } 
#    }
#
#}
#
#sub all_match {
#    use experimental 'smartmatch';
#
#    my ($list1, $list2) = @_;
#
#    for (@$list1) {
#        return 0 unless $_ ~~ @$list2;
#    }
#    1;
#}
#
#sub any_match {
#    use experimental 'smartmatch';
#
#    my ($list1, $list2) = @_;
#
#    for (@$list1) {
#        return 1 if $_ ~~ @$list2;
#    }
#    0;
#}
#
#sub none_match {
#    use experimental 'smartmatch';
#
#    my ($list1, $list2) = @_;
#
#    for (@$list1) {
#        return 0 if $_ ~~ @$list2;
#    }
#    1;
#}
#
#1;
#
#__END__
#
### Test/Data/Sah/Human.pm ###
#package Test::Data::Sah::Human;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010001;
#use strict;
#use warnings;
#use Test::More 0.98;
#
#use Data::Sah;
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(test_human);
#
#sub test_human {
#    my %args = @_;
#    subtest $args{name} // $args{result}, sub {
#        my $sah = Data::Sah->new;
#        my $hc = $sah->get_compiler("human");
#        my %hargs = (
#            schema => $args{schema},
#            lang => $args{lang},
#            %{ $args{compile_opts} // {} },
#        );
#        $hargs{format} //= "inline_text";
#        my $cd = $hc->compile(%hargs);
#
#        if (defined $args{result}) {
#            if (ref($args{result}) eq 'Regexp') {
#                like($cd->{result}, $args{result}, 'result');
#            } else {
#                is($cd->{result}, $args{result}, 'result');
#            }
#        }
#    };
#}
#
#1;
#
#__END__
#
### Test/Data/Sah/Perl.pm ###
#package Test::Data::Sah::Perl;
#
#our $DATE = '2018-12-16'; 
#our $VERSION = '0.895'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use Test::Data::Sah qw(run_spectest all_match);
#use Test::More 0.98;
#
#use Data::Sah qw(gen_validator);
#
#use Exporter qw(import);
#our @EXPORT_OK = qw(run_spectest_for_perl);
#
#sub run_spectest_for_perl {
#    run_spectest(
#        test_merge_clause_sets => 1,
#        test_func => sub {
#            my $test = shift;
#
#            my $data = $test->{input};
#            my $ho = exists($test->{output}); 
#            my $vbool;
#            eval { $vbool = gen_validator(
#                $test->{schema}, {accept_ref=>$ho}) };
#            my $eval_err = $@;
#            if ($test->{dies}) {
#                ok($eval_err, "compile error");
#                return;
#            } else {
#                ok(!$eval_err, "compile success") or do {
#                    diag $eval_err;
#                    return;
#                };
#            }
#
#            if ($test->{valid_inputs}) {
#                for my $i (0..@{ $test->{valid_inputs} }-1) {
#                    my $data = $test->{valid_inputs}[$i];
#                    ok($vbool->($ho ? \$data : $data), "valid input [$i]");
#                }
#                for my $i (0..@{ $test->{invalid_inputs} }-1) {
#                    my $data = $test->{invalid_inputs}[$i];
#                    ok(!$vbool->($ho ? \$data : $data), "invalid input [$i]");
#                }
#            } elsif (exists $test->{valid}) {
#                if ($test->{valid}) {
#                    ok($vbool->($ho ? \$data : $data), "valid (rt=bool)");
#                    if ($ho) {
#                        is_deeply($data, $test->{output}, "output");
#                    }
#                } else {
#                    ok(!$vbool->($ho ? \$data : $data), "invalid (rt=bool)");
#                }
#            }
#
#            my $vstr = gen_validator($test->{schema},
#                                     {return_type=>'str'});
#            if (exists $test->{valid}) {
#                if ($test->{valid}) {
#                    is($vstr->($test->{input}), "", "valid (rt=str)");
#                } else {
#                    like($vstr->($test->{input}), qr/\S/, "invalid (rt=str)");
#                }
#            }
#
#            my $vfull = gen_validator($test->{schema},
#                                      {return_type=>'full'});
#            my $res = $vfull->($test->{input});
#            is(ref($res), 'HASH', "validator (rt=full) returns hash");
#            if (exists($test->{errors}) || exists($test->{warnings}) ||
#                    exists($test->{valid})) {
#                my $errors = $test->{errors} // ($test->{valid} ? 0 : 1);
#                is(scalar(keys %{ $res->{errors} // {} }), $errors, "errors (rt=full)")
#                    or diag explain $res;
#                my $warnings = $test->{warnings} // 0;
#                is(scalar(keys %{ $res->{warnings} // {} }), $warnings,
#                   "warnings (rt=full)")
#                    or diag explain $res;
#            }
#        }, 
#
#        skip_if => sub {
#            my $t = shift;
#            return 0 unless $t->{tags};
#
#            return "currently failing"
#                if all_match([qw/type:bool clause:between op/], $t->{tags});
#
#            for (qw/
#
#                       check
#                       check_each_elem
#                       check_each_index
#                       check_each_key
#                       check_each_value
#                       check_prop
#                       exists
#                       if
#                       postfilters
#                       prefilters
#                       prop
#                       uniq
#
#                   /) {
#                return "clause $_ not yet implemented"
#                    if all_match(["clause:$_"], $t->{tags});
#            }
#
#            return "properties are not yet implemented"
#                if grep {/^prop:/} @{ $t->{tags} };
#
#            0;
#        }, 
#
#    );
#}
#
#1;
#
#__END__
#
### Text/ANSI/BaseUtil.pm ###
#package Text::ANSI::BaseUtil;
#
#our $DATE = '2016-03-11'; 
#our $VERSION = '0.22'; 
#
#use 5.010001;
#use strict;
#use warnings;
#
#use List::Util qw(min max);
#
#our $re       = qr/\e\[[0-9;]+m/s;
#our $re_mult  = qr/(?:\e\[[0-9;]+m)+/s;
#
#sub ta_detect {
#    my $text = shift;
#    $text =~ $re ? 1:0;
#}
#
#sub ta_length {
#    my $text = shift;
#    length(ta_strip($text));
#}
#
#sub _ta_length_height {
#    my ($is_mb, $text) = @_;
#    my $num_lines = 0;
#    my @lens;
#    for my $e (split /(\r?\n)/, ta_strip($text)) {
#        if ($e =~ /\n/) {
#            $num_lines++;
#            next;
#        }
#        $num_lines = 1 if $num_lines == 0;
#        push @lens, $is_mb ? Text::WideChar::Util::mbswidth($e) : length($e);
#    }
#    [max(@lens) // 0, $num_lines];
#}
#
#sub ta_length_height {
#    _ta_length_height(0, @_);
#}
#
#sub ta_mbswidth_height {
#    _ta_length_height(1, @_);
#}
#
#sub ta_strip {
#    my $text = shift;
#    $text =~ s/$re//go;
#    $text;
#}
#
#sub ta_extract_codes {
#    my $text = shift;
#    my $res = "";
#    $res .= $1 while $text =~ /($re_mult)/go;
#    $res;
#}
#
#sub ta_split_codes {
#    my $text = shift;
#    return split(/($re_mult)/o, $text);
#}
#
#sub ta_split_codes_single {
#    my $text = shift;
#    return split(/($re)/o, $text);
#}
#
#sub _ta_mbswidth0 {
#    my $text = shift;
#    Text::WideChar::Util::mbswidth(ta_strip($text));
#}
#
#sub ta_mbswidth {
#    my $text = shift;
#    ta_mbswidth_height($text)->[0];
#}
#
#sub _ta_wrap {
#    my ($is_mb, $text, $width, $opts) = @_;
#    $width //= 80;
#    $opts  //= {};
#
#
#    my $_re1 = $is_mb ?
#        qr/($Text::WideChar::Util::re_cjk+)|(\S+)|(\s+)/ :
#        qr/()(\S+)|(\s+)/;
#
#    my $_re2 = $is_mb ?
#        qr/($Text::WideChar::Util::re_cjk_class+)|
#           ($Text::WideChar::Util::re_cjk_negclass+)/x : undef;
#
#    my @termst; 
#    my @terms;  
#    my @pterms; 
#    my @termsw; 
#    my @termsc; 
#    {
#        my @ch = ta_split_codes_single($text);
#        my $crcode = ""; 
#        my $term      = '';
#        my $pterm     = '';
#        my $prev_type = '';
#        while (my ($pt, $c) = splice(@ch, 0, 2)) {
#
#
#            my @s; 
#            while ($pt =~ /$_re1/g) {
#                if ($is_mb && $1) {
#                    push @s, $1, 'c';
#                } elsif ($3) {
#                    push @s, $3, 's';
#                } else {
#                    if ($is_mb) {
#                        my $pt2 = $2;
#                        while ($pt2 =~ /$_re2/g) {
#                            if ($1) {
#                                push @s, $1, 'c';
#                            } else {
#                                push @s, $2, 'w';
#                            }
#                        }
#                    } else {
#                        push @s, $2, 'w';
#                    }
#                }
#            }
#
#
#            my $only_code = 1 if !@s;
#            while (1) {
#                my ($s, $s_type) = splice @s, 0, 2;
#                $s_type //= '';
#                last unless $only_code || defined($s);
#                if ($only_code) {
#                    $s = "";
#                    $term .= $c if defined $c;
#                }
#
#                if ($s_type && $s_type ne 's') {
#                    if ($prev_type eq 's') {
#                        push @termst, 's';
#                        push @terms , $term;
#                        push @pterms, $pterm;
#                        push @termsw, undef;
#                        push @termsc, $crcode;
#                        $pterm = ''; $term = '';
#                    } elsif ($prev_type && $prev_type ne $s_type) {
#                        push @termst, $prev_type;
#                        push @terms , $term;
#                        push @pterms, $pterm;
#                        push @termsw, $is_mb ? Text::WideChar::Util::mbswidth($pterm):length($pterm);
#                        push @termsc, $crcode;
#                        $pterm = ''; $term = '';
#                    }
#                    $pterm .= $s;
#                    $term  .= $s; $term .= $c if defined($c) && !@s;
#                    if (!@s && !@ch) {
#                        push @termst, $s_type;
#                        push @terms , $term;
#                        push @pterms, "";
#                        push @termsw, $is_mb ? Text::WideChar::Util::mbswidth($pterm):length($pterm);
#                        push @termsc, $crcode;
#                    }
#                } elsif (length($s)) {
#                    if ($prev_type ne 's') {
#                        push @termst, $prev_type;
#                        push @terms , $term;
#                        push @pterms, "";
#                        push @termsw, $is_mb ? Text::WideChar::Util::mbswidth($pterm):length($pterm);
#                        push @termsc, $crcode;
#                        $pterm = ''; $term = '';
#                    }
#                    $pterm .= $s;
#                    $term  .= $c if defined($c) && !@s;
#                    if (!@s && !@ch) {
#                        push @termst, 's';
#                        push @terms , $term;
#                        push @pterms, $pterm;
#                        push @termsw, undef;
#                        push @termsc, $crcode;
#                    }
#                }
#                $prev_type = $s_type;
#
#                if (!@s) {
#                    if (defined($c) && $c =~ /m\z/) {
#                        if ($c eq "\e[0m") {
#                            $crcode = "";
#                        } elsif ($c =~ /m\z/) {
#                            $crcode .= $c;
#                        }
#                    }
#                    last if $only_code;
#                }
#
#            } 
#        } 
#    }
#
#    {
#        my $i = 0;
#        while ($i < @pterms) {
#            if ($termst[$i] eq 's') {
#                if ($pterms[$i] =~ /[ \t]*(\n(?:[ \t]*\n)+)([ \t]*)/) {
#                    $pterms[$i] = $1;
#                    $termst[$i] = 'p';
#                    if ($i < @pterms-1) {
#                        $terms [$i+1] = $terms[$i] . $terms [$i+1];
#                        $terms [$i] = "";
#                    }
#                    if (length $2) {
#                        splice @termst, $i+1, 0, "s";
#                        splice @terms , $i+1, 0, "";
#                        splice @pterms, $i+1, 0, $2;
#                        splice @termsw, $i+1, 0, undef;
#                        splice @termsc, $i+1, 0, $termsc[$i];
#                        $i += 2;
#                        next;
#                    }
#                }
#            }
#            $i++;
#        }
#    }
#
#
#
#    my ($maxww, $minww);
#
#
#    my @res;
#    {
#        my $tw = $opts->{tab_width} // 8;
#        die "Please specify a positive tab width" unless $tw > 0;
#        my $optfli  = $opts->{flindent};
#        my $optfliw = Text::WideChar::Util::_get_indent_width($is_mb, $optfli, $tw) if defined $optfli;
#        my $optsli  = $opts->{slindent};
#        my $optsliw = Text::WideChar::Util::_get_indent_width($is_mb, $optsli, $tw) if defined $optsli;
#        my $pad = $opts->{pad};
#        my $x = 0;
#        my $y = 0;
#        my ($fli, $sli, $fliw, $sliw);
#        my $is_parastart = 1;
#        my $line_has_word = 0;
#        my ($termt, $prev_t);
#      TERM:
#        for my $i (0..$#terms) {
#            $prev_t = $termt if $i;
#            $termt = $termst[$i];
#            my $term  = $terms[$i];
#            my $pterm = $pterms[$i];
#            my $termw = $termsw[$i];
#            my $crcode = $i > 0 ? $termsc[$i-1] : "";
#
#            if ($termt eq 'p') {
#                my $numnl = 0;
#                $numnl++ while $pterm =~ /\n/g;
#                for (1..$numnl) {
#                    push @res, "\e[0m" if $crcode && $_ == 1;
#                    push @res, " " x ($width-$x) if $pad;
#                    push @res, "\n";
#                    $x = 0;
#                    $y++;
#                }
#                $line_has_word = 0;
#                $x = 0;
#                $is_parastart = 1;
#                next TERM;
#            }
#
#            if ($is_parastart) {
#                if (defined $optfli) {
#                    $fli  = $optfli;
#                    $fliw = $optfliw;
#                } else {
#                    if ($termt eq 's') {
#                        $fli  = $pterm;
#                        $fliw = Text::WideChar::Util::_get_indent_width($is_mb, $fli, $tw);
#                    } else {
#                        $fli  = "";
#                        $fliw = 0;
#                    }
#                    my $j = $i;
#                    $sli = undef;
#                    while ($j < @terms && $termst[$j] ne 'p') {
#                        if ($termst[$j] eq 's') {
#                            if ($pterms[$j] =~ /\n([ \t]+)/) {
#                                $sli  = $1;
#                                $sliw = Text::WideChar::Util::_get_indent_width($is_mb, $sli, $tw);
#                                last;
#                            }
#                        }
#                        $j++;
#                    }
#                    if (!defined($sli)) {
#                        $sli  = "";
#                        $sliw = 0;
#                    }
#                    die "Subsequent indent must be less than width" if $sliw >= $width;
#                }
#
#                push @res, $fli;
#                $x += $fliw;
#            } 
#
#            $is_parastart = 0;
#
#            if ($termt eq 's') {
#                push @res, $term;
#
#                if ($pterm =~ /\n/ && $i == $#terms) {
#                    push @res, "\e[0m" if $crcode;
#                    push @res, " " x ($width-$x) if $pad;
#                    push @res, "\n";
#                    $line_has_word = 0;
#                }
#            }
#
#            if ($termt ne 's') {
#                my @words;
#                my @wordsw;
#                my @wordst; 
#                my @wordswsb; 
#                my $j = 0;
#                my $c = ""; 
#                while (1) {
#                    $j++;
#                    if ($termw <= $width-$sliw || $termt eq 'c') {
#                        push @words   , $c . $term;
#                        push @wordsw  , $termw;
#                        push @wordst  , $termt;
#                        push @wordswsb, ($prev_t && $prev_t eq 's')?1:0;
#                        last;
#                    }
#                    my $res = $is_mb ? ta_mbtrunc($term, $width-$sliw, 1) :
#                        ta_trunc($term, $width-$sliw, 1);
#
#                    my ($tword, $twordw);
#                    if ($j == 1) {
#                        $tword  = $res->[0];
#                        $twordw = $res->[1];
#                    } else {
#                        $tword  = ($crcode ? "\e[0m" . $crcode : "") .
#                            $c . $res->[0];
#                        $twordw = $res->[1];
#                    }
#                    $c .= ta_extract_codes(substr($term, 0, $res->[2]));
#
#                    push @words   , $tword;
#                    push @wordsw  , $twordw;
#                    push @wordst  , $termt;
#                    push @wordswsb, $j == 1 ? (($prev_t && $prev_t eq 's')?1:0) : 0;
#                    $term  = substr($term, $res->[2]);
#                    $termw = $is_mb ? _ta_mbswidth0($term) : ta_length($term);
#                }
#
#
#                for my $word (@words) {
#                    my $wordw = shift @wordsw;
#                    my $wordt = shift @wordst;
#                    my $ws_before = shift @wordswsb;
#
#                    $maxww = $wordw if !defined($maxww) || $maxww < $wordw;
#                    $minww = $wordw if !defined($minww) || $minww > $wordw;
#
#                    if ($x + ($line_has_word ? 1:0) + $wordw <= $width) {
#                        if ($line_has_word && $ws_before) {
#                            push @res, " ";
#                            $x++;
#                        }
#                        push @res, $word;
#                        $x += $wordw;
#                    } else {
#                        while (1) {
#                            if ($wordt eq 'c') {
#                                my $res;
#                                if ($ws_before) {
#                                    $res = ta_mbtrunc($word, $width-$x-1, 1);
#                                    push @res, " ", $res->[0];
#                                } else {
#                                    $res = ta_mbtrunc($word, $width-$x, 1);
#                                    push @res, $res->[0];
#                                }
#                                $word = $res->[3];
#                                $wordw = _ta_mbswidth0($res->[3]);
#                            } else {
#                                push @res, "\e[0m" if $crcode;
#                            }
#                            push @res, " " x ($width-$x) if $pad;
#                            push @res, "\n";
#                            $y++;
#                            push @res, $crcode;
#                            push @res, $sli;
#
#                            if ($sliw + $wordw <= $width) {
#                                push @res, $word;
#                                $x = $sliw + $wordw;
#                                last;
#                            } else {
#                                $x = $sliw;
#                            }
#                        }
#                    }
#                    $line_has_word++;
#                }
#
#            }
#        } 
#        push @res, " " x ($width-$x) if $line_has_word && $pad;
#    }
#
#    if ($opts->{return_stats}) {
#        return [join("", @res), {
#            max_word_width => $maxww,
#            min_word_width => $minww,
#        }];
#    } else {
#        return join("", @res);
#    }
#}
#
#sub ta_wrap {
#    _ta_wrap(0, @_);
#}
#
#sub ta_mbwrap {
#    _ta_wrap(1, @_);
#}
#
#sub _ta_pad {
#    my ($is_mb, $text, $width, $which, $padchar, $is_trunc) = @_;
#    if ($which) {
#        $which = substr($which, 0, 1);
#    } else {
#        $which = "r";
#    }
#    $padchar //= " ";
#
#    my $w = $is_mb ? _ta_mbswidth0($text) : ta_length($text);
#    if ($is_trunc && $w > $width) {
#        my $res = $is_mb ?
#            ta_mbtrunc($text, $width, 1) : ta_trunc($text, $width, 1);
#        $text = $res->[0] . ($padchar x ($width-$res->[1]));
#    } else {
#        if ($which eq 'l') {
#            $text = ($padchar x ($width-$w)) . $text;
#        } elsif ($which eq 'c') {
#            my $n = int(($width-$w)/2);
#            $text = ($padchar x $n) . $text . ($padchar x ($width-$w-$n));
#        } else {
#            $text .= ($padchar x ($width-$w)) if $width > $w;
#        }
#    }
#    $text;
#}
#
#sub ta_pad {
#    _ta_pad(0, @_);
#}
#
#sub ta_mbpad {
#    _ta_pad(1, @_);
#}
#
#sub _ta_trunc {
#    my ($is_mb, $text, $width, $return_extra) = @_;
#
#
#    my $w = $is_mb ? _ta_mbswidth0($text) : ta_length($text);
#    if ($w <= $width) {
#        return $return_extra ? [$text, $w, length($text), ''] : $text;
#    }
#    my @p = ta_split_codes_single($text);
#    my $res = '';
#    my $append = 1; 
#    my $code4rest = '';
#    my $rest = '';
#    $w = 0;
#    my $c = 0;
#    while (my ($t, $ansi) = splice @p, 0, 2) {
#        if ($append) {
#            my $tw = $is_mb ? Text::WideChar::Util::mbswidth($t) : length($t);
#            if ($w+$tw <= $width) {
#                $res .= $t;
#                $w += $tw;
#                $c += length($t);
#                $append = 0 if $w == $width;
#            } else {
#                my $tres = $is_mb ?
#                    Text::WideChar::Util::mbtrunc($t, $width-$w, 1) :
#                      [substr($t, 0, $width-$w), $width-$w, $width-$w];
#                $res .= $tres->[0];
#                $w += $tres->[1];
#                $c += $tres->[2];
#                $rest = substr($t, $tres->[2]);
#                $append = 0;
#            }
#        } else {
#            $rest .= $t;
#        }
#        if (defined $ansi) {
#            if ($append) {
#                if ($ansi eq "\e[0m") {
#                    $c = length($ansi);
#                    $code4rest = $ansi;
#                } else {
#                    $c += length($ansi);
#                    $code4rest .= $ansi;
#                }
#                $res .= $ansi;
#            } else {
#                $res .= $ansi;
#                $rest .= $ansi;
#            }
#        }
#    }
#
#
#    if ($return_extra) {
#        return [$res, $w, $c, $code4rest . $rest];
#    } else {
#        return $res;
#    }
#}
#
#sub _ta_prune_codes {
#    my $text = shift;
#    $text =~ s/($re_mult)\e\[0m/\e\[0m/g;
#    $text;
#}
#
#sub ta_trunc {
#    _ta_trunc(0, @_);
#}
#
#sub ta_mbtrunc {
#    _ta_trunc(1, @_);
#}
#
#sub _ta_highlight {
#    my ($is_all, $text, $needle, $color) = @_;
#
#    my (@chptext, @chcode, @chsavedc); 
#    my $sc = "";
#    my $plaintext = "";
#    my @ch = ta_split_codes_single($text);
#    while (my ($pt, $c) = splice(@ch, 0, 2)) {
#        push @chptext , $pt;
#        push @chcode  , $c;
#        push @chsavedc, $sc;
#        $plaintext .= $pt;
#        if (defined($c) && $c =~ /m\z/) {
#            if ($c eq "\e[0m") {
#                $sc = "";
#            } elsif ($c =~ /m\z/) {
#                $sc .= $c;
#            }
#        }
#    }
#
#    my (@needle, @npos);
#    if (ref($needle) eq 'Regexp') {
#        my @m = $plaintext =~ /$needle/g;
#        return $text unless @m;
#        my $pos = 0;
#        while ($pos < length($plaintext)) {
#            my @pt;
#            for (@m) {
#                my $p = index($plaintext, $_, $pos);
#                push @pt, [$p, $_] if $p >= 0;
#            }
#            last unless @pt;
#            my $pmin = $pt[0][0];
#            my $t = $pt[0][1];
#            for (@pt) {
#                if ($pmin > $_->[0] ||
#                        $pmin==$_->[0] && length($t) < length($_->[1])) {
#                    $pmin = $_->[0];
#                    $t = $_->[1];
#                }
#            }
#            push @needle, $t;
#            push @npos  , $pmin;
#            last unless $is_all;
#            $pos = $pmin + length($t);
#        }
#    } else {
#        my $pos = 0;
#        while (1) {
#            my $p = index($plaintext, $needle, $pos);
#            last if $p < 0;
#            push @needle, $needle;
#            push @npos  , $p;
#            last unless $is_all;
#            $pos = $p + length($needle);
#            last if $pos >= length($plaintext);
#        }
#        return $text unless @needle;
#    }
#
#    my @res;
#    my $found = 1;
#    my $pos = 0;
#    my $i = 0;
#    my $curneed = shift @needle;
#    my $npos    = shift @npos;
#  CHUNK:
#    while (1) {
#        last if $i >= @chptext;
#        my $pos2  = $pos+length($chptext[$i])-1;
#        my $npos2 = $npos+length($curneed)-1;
#        if ($pos > $npos2 || $pos2 < $npos || !$found) {
#            push @res, $chptext[$i];
#            push @res, $chcode[$i] if defined $chcode[$i];
#            goto L1;
#        }
#
#        if ($pos < $npos) {
#            my $pre = substr($chptext[$i], 0, $npos-$pos);
#            push @res, $pre;
#        }
#
#        my $npart = substr($curneed,
#                           max(0, $pos-$npos),
#                           min($pos2, $npos2)-max($pos, $npos)+1);
#        if (length($npart)) {
#            push @res, $color, $npart;
#            push @res, "\e[0m";
#            push @res, $chsavedc[$i];
#        }
#
#        if ($npos2 <= $pos2) {
#            my $post = substr($chptext[$i], $npos2-$pos+1);
#
#            if (@needle) {
#                $curneed = shift @needle;
#                $npos    = shift @npos;
#                $pos     = $npos2+1;
#                $chptext[$i] = $post;
#                $found = 1;
#                redo CHUNK;
#            } else {
#                $found = 0;
#            }
#
#            if (!$found) {
#                push @res, $post;
#                push @res, $chcode[$i] if defined $chcode[$i];
#            }
#        }
#
#      L1:
#        $pos = $pos2+1;
#        $i++;
#    }
#
#    join "", @res;
#}
#
#sub ta_highlight {
#    _ta_highlight(0, @_);
#}
#
#sub ta_highlight_all {
#    _ta_highlight(1, @_);
#}
#
#sub ta_add_color_resets {
#    my (@text) = @_;
#
#    my @res;
#    my $i = 0;
#    my $savedc = "";
#    for my $text (@text) {
#        $i++;
#        my $newt = $i > 1 && !$savedc ? "\e[0m" : $savedc;
#
#        my @ch = ta_split_codes_single($text);
#        while (my ($t, $c) = splice(@ch, 0, 2)) {
#            $newt .= $t;
#            if (defined($c) && $c =~ /m\z/) {
#                $newt .= $c;
#                if ($c eq "\e[0m") {
#                    $savedc = "";
#                } elsif ($c =~ /m\z/) {
#                    $savedc .= $c;
#                }
#            }
#        }
#
#        $newt .= "\e[0m" if $savedc && $i < @text;
#        push @res, $newt;
#    }
#
#    @res;
#}
#
#sub _ta_substr {
#    my $is_mb = shift;
#    my $str   = shift;
#    my $pos   = shift;
#    my $len   = shift;
#
#    my $res1 = _ta_trunc($is_mb, $str, $pos, 1);
#    my $res2 = _ta_trunc($is_mb, $res1->[3], $len, 1);
#
#    if (@_) {
#        return _ta_prune_codes($res1->[0] . $_[0] . $res2->[3]);
#    } else {
#        return _ta_prune_codes($res2->[0]);
#    }
#}
#
#sub ta_substr {
#    _ta_substr(0, @_);
#}
#
#sub ta_mbsubstr {
#    _ta_substr(1, @_);
#}
#
#
#1;
#
#__END__
#
### Text/ANSI/Util.pm ###
#package Text::ANSI::Util;
#
#our $DATE = '2016-03-11'; 
#our $VERSION = '0.22'; 
#
#use 5.010001;
#use strict 'subs', 'vars';
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT_OK = qw(
#                       ta_add_color_resets
#                       ta_detect
#                       ta_extract_codes
#                       ta_highlight
#                       ta_highlight_all
#                       ta_length
#                       ta_length_height
#                       ta_pad
#                       ta_split_codes
#                       ta_split_codes_single
#                       ta_strip
#                       ta_substr
#                       ta_trunc
#                       ta_wrap
#               );
#
#use Text::ANSI::BaseUtil ();
#
#our $re = $Text::ANSI::BaseUtil::re;
#*{$_} = \&{"Text::ANSI::BaseUtil::$_"} for @EXPORT_OK;
#
#1;
#
#__END__
#
### Text/Table/ASV.pm ###
#package Text::Table::ASV;
#
#our $DATE = '2018-07-23'; 
#our $VERSION = '0.001'; 
#
#
#sub _encode {
#    my $val = shift;
#    $val =~ s/[\x1c\x1d\x1e\x1f]/ /g;
#    $val;
#}
#
#sub table {
#    my %params = @_;
#    my $rows = $params{rows} or die "Must provide rows!";
#
#    my $header_row = defined $params{header_row} ? $params{header_row} : 1;
#    my $max_index = _max_array_index($rows);
#
#    my @table;
#
#    my $i = 0;
#    foreach my $row ( @{ $rows }[0..$#$rows] ) {
#        $i++;
#        next if $i==1 && !$header_row;
#        push @table, join(
#	    "\x1f",
#	    map { _encode(defined($row->[$_]) ? $row->[$_] : '') } (0..$max_index)
#	);
#    }
#
#    return join("\x1e", grep {$_} @table);
#}
#
#sub max {
#    return undef unless @_;
#    my $res = $_[0];
#    my $i = 0;
#    while (++$i < @_) { $res = $_[$i] if $_[$i] > $res }
#    $res;
#}
#
#sub _max_array_index {
#    my $rows = shift;
#    return max( map { $#$_ } @$rows );
#}
#
#1;
#
#__END__
#
### Text/Table/Any.pm ###
#package Text::Table::Any;
#
#our $DATE = '2019-01-11'; 
#our $VERSION = '0.094'; 
#
#
#our @BACKENDS = qw(
#                      Text::Table::Tiny
#                      Text::Table::TinyColor
#                      Text::Table::TinyColorWide
#                      Text::Table::TinyWide
#                      Text::Table::Org
#                      Text::Table::CSV
#                      Text::Table::TSV
#                      Text::Table::LTSV
#                      Text::Table::ASV
#                      Text::Table::HTML
#                      Text::Table::HTML::DataTables
#                      Text::Table::Paragraph
#                      Text::ANSITable
#                      Text::ASCIITable
#                      Text::FormatTable
#                      Text::MarkdownTable
#                      Text::Table
#                      Text::TabularDisplay
#                      Text::Table::XLSX
#              );
#
#sub _encode {
#    my $val = shift;
#    $val =~ s/([\\"])/\\$1/g;
#    "\"$val\"";
#}
#
#sub backends {
#    @BACKENDS;
#}
#
#sub table {
#    my %params = @_;
#
#    my $rows       = $params{rows} or die "Must provide rows!";
#    my $backend    = $params{backend} || 'Text::Table::Tiny';
#    my $header_row = $params{header_row} // 1;
#
#    if ($backend eq 'Text::Table::Tiny') {
#        require Text::Table::Tiny;
#        return Text::Table::Tiny::table(
#            rows => $rows, header_row => $header_row) . "\n";
#    } elsif ($backend eq 'Text::Table::TinyColor') {
#        require Text::Table::TinyColor;
#        return Text::Table::TinyColor::table(
#            rows => $rows, header_row => $header_row) . "\n";
#    } elsif ($backend eq 'Text::Table::TinyColorWide') {
#        require Text::Table::TinyColorWide;
#        return Text::Table::TinyColorWide::table(
#            rows => $rows, header_row => $header_row) . "\n";
#    } elsif ($backend eq 'Text::Table::TinyWide') {
#        require Text::Table::TinyWide;
#        return Text::Table::TinyWide::table(
#            rows => $rows, header_row => $header_row) . "\n";
#    } elsif ($backend eq 'Text::Table::Org') {
#        require Text::Table::Org;
#        return Text::Table::Org::table(
#            rows => $rows, header_row => $header_row);
#    } elsif ($backend eq 'Text::Table::CSV') {
#        require Text::Table::CSV;
#        return Text::Table::CSV::table(
#            rows => $rows, header_row => $header_row);
#    } elsif ($backend eq 'Text::Table::TSV') {
#        require Text::Table::TSV;
#        return Text::Table::TSV::table(
#            rows => $rows, header_row => $header_row);
#    } elsif ($backend eq 'Text::Table::LTSV') {
#        require Text::Table::LTSV;
#        return Text::Table::LTSV::table(
#            rows => $rows);
#    } elsif ($backend eq 'Text::Table::ASV') {
#        require Text::Table::ASV;
#        return Text::Table::ASV::table(
#            rows => $rows, header_row => $header_row);
#    } elsif ($backend eq 'Text::Table::HTML') {
#        require Text::Table::HTML;
#        return Text::Table::HTML::table(
#            rows => $rows, header_row => $header_row);
#    } elsif ($backend eq 'Text::Table::HTML::DataTables') {
#        require Text::Table::HTML::DataTables;
#        return Text::Table::HTML::DataTables::table(
#            rows => $rows, header_row => $header_row);
#    } elsif ($backend eq 'Text::Table::Paragraph') {
#        require Text::Table::Paragraph;
#        return Text::Table::Paragraph::table(
#            rows => $rows, header_row => $header_row);
#    } elsif ($backend eq 'Text::ANSITable') {
#        require Text::ANSITable;
#        my $t = Text::ANSITable->new(
#            use_utf8 => 0,
#            use_box_chars => 0,
#            use_color => 0,
#            border_style => 'Default::single_ascii',
#        );
#        if ($header_row) {
#            $t->columns($rows->[0]);
#            $t->add_row($rows->[$_]) for 1..@$rows-1;
#        } else {
#            $t->columns([ map {"col$_"} 0..$#{$rows->[0]} ]);
#            $t->add_row($_) for @$rows;
#        }
#        return $t->draw;
#    } elsif ($backend eq 'Text::ASCIITable') {
#        require Text::ASCIITable;
#        my $t = Text::ASCIITable->new();
#        if ($header_row) {
#            $t->setCols(@{ $rows->[0] });
#            $t->addRow(@{ $rows->[$_] }) for 1..@$rows-1;
#        } else {
#            $t->setCols(map { "col$_" } 0..$#{ $rows->[0] });
#            $t->addRow(@$_) for @$rows;
#        }
#        return "$t";
#    } elsif ($backend eq 'Text::FormatTable') {
#        require Text::FormatTable;
#        my $t = Text::FormatTable->new(join('|', ('l') x @{ $rows->[0] }));
#        $t->head(@{ $rows->[0] });
#        $t->row(@{ $rows->[$_] }) for 1..@$rows-1;
#        return $t->render;
#    } elsif ($backend eq 'Text::MarkdownTable') {
#        require Text::MarkdownTable;
#        my $out = "";
#        my $fields =  $header_row ?
#            $rows->[0] : [map {"col$_"} 0..$#{ $rows->[0] }];
#        my $t = Text::MarkdownTable->new(file => \$out, columns => $fields);
#        foreach (($header_row ? 1:0) .. $#{$rows}) {
#            my $row = $rows->[$_];
#            $t->add( {
#                map { $fields->[$_] => $row->[$_] } 0..@$fields-1
#            });
#        }
#        $t->done;
#        return $out;
#    } elsif ($backend eq 'Text::Table') {
#        require Text::Table;
#        my $t = Text::Table->new(@{ $rows->[0] });
#        $t->load(@{ $rows }[1..@$rows-1]);
#        return $t;
#    } elsif ($backend eq 'Text::TabularDisplay') {
#        require Text::TabularDisplay;
#        my $t = Text::TabularDisplay->new(@{ $rows->[0] });
#        $t->add(@{ $rows->[$_] }) for 1..@$rows-1;
#        return $t->render . "\n";
#    } elsif ($backend eq 'Text::Table::XLSX') {
#        require Text::Table::XLSX;
#        return Text::Table::XLSX::table(
#            rows => $rows, header_row => $header_row);
#    } else {
#        die "Unknown backend '$backend'";
#    }
#}
#
#1;
#
#__END__
#
### Text/Table/Tiny.pm ###
#use 5.006;
#use strict;
#use warnings;
#package Text::Table::Tiny;
#$Text::Table::Tiny::VERSION = '0.04';
#use parent 'Exporter';
#use List::Util qw();
#
#our @EXPORT_OK = qw/ generate_table /;
#
#
#
#our $COLUMN_SEPARATOR = '|';
#our $ROW_SEPARATOR = '-';
#our $CORNER_MARKER = '+';
#our $HEADER_ROW_SEPARATOR = '=';
#our $HEADER_CORNER_MARKER = 'O';
#
#sub generate_table {
#
#    my %params = @_;
#    my $rows = $params{rows} or die "Must provide rows!";
#
#    my $widths = _maxwidths($rows);
#    my $max_index = _max_array_index($rows);
#
#    my $format = _get_format($widths);
#    my $row_sep = _get_row_separator($widths);
#    my $head_row_sep = _get_header_row_separator($widths);
#
#    my @table;
#    push @table, $row_sep;
#
#    my $data_begins = 0;
#    if ( $params{header_row} ) {
#        my $header_row = $rows->[0];
#        $data_begins++;
#        push @table, sprintf(
#                         $format, 
#                         map { defined($header_row->[$_]) ? $header_row->[$_] : '' } (0..$max_index)
#                     );
#        push @table, $params{separate_rows} ? $head_row_sep : $row_sep;
#    }
#
#    foreach my $row ( @{ $rows }[$data_begins..$#$rows] ) {
#        push @table, sprintf(
#	    $format, 
#	    map { defined($row->[$_]) ? $row->[$_] : '' } (0..$max_index)
#	);
#        push @table, $row_sep if $params{separate_rows};
#    }
#
#    push @table, $row_sep unless $params{separate_rows};
#    return join("\n",grep {$_} @table);
#}
#
#sub _get_cols_and_rows ($) {
#    my $rows = shift;
#    return ( List::Util::max( map { scalar @$_ } @$rows), scalar @$rows);
#}
#
#sub _maxwidths {
#    my $rows = shift;
#    my $max_index = _max_array_index($rows);
#    my $widths = [];
#    for my $i (0..$max_index) {
#        my $max = List::Util::max(map {defined $$_[$i] ? length($$_[$i]) : 0} @$rows);
#        push @$widths, $max;
#    }
#    return $widths;
#}
#
#sub _max_array_index {
#    my $rows = shift;
#    return List::Util::max( map { $#$_ } @$rows );
#}
#
#sub _get_format {
#    my $widths = shift;
#    return "$COLUMN_SEPARATOR ".join(" $COLUMN_SEPARATOR ",map { "%-${_}s" } @$widths)." $COLUMN_SEPARATOR";
#}
#
#sub _get_row_separator {
#    my $widths = shift;
#    return "$CORNER_MARKER$ROW_SEPARATOR".join("$ROW_SEPARATOR$CORNER_MARKER$ROW_SEPARATOR",map { $ROW_SEPARATOR x $_ } @$widths)."$ROW_SEPARATOR$CORNER_MARKER";
#}
#
#sub _get_header_row_separator {
#    my $widths = shift;
#    return "$HEADER_CORNER_MARKER$HEADER_ROW_SEPARATOR".join("$HEADER_ROW_SEPARATOR$HEADER_CORNER_MARKER$HEADER_ROW_SEPARATOR",map { $HEADER_ROW_SEPARATOR x $_ } @$widths)."$HEADER_ROW_SEPARATOR$HEADER_CORNER_MARKER";
#}
#
#*table = \&generate_table;
#
#1;
#
#__END__
#
#
### Text/sprintfn.pm ###
#package Text::sprintfn;
#
#use 5.010001;
#use strict;
#use warnings;
#
#require Exporter;
#our @ISA       = qw(Exporter);
#our @EXPORT    = qw(sprintfn printfn);
#
#our $VERSION = '0.08'; 
#
#our $distance  = 10;
#
#my  $re1   = qr/[^)]+/s;
#my  $re2   = qr{(?<fmt>
#                    %
#                       (?<pi> \d+\$ | \((?<npi>$re1)\)\$?)?
#                       (?<flags> [ +0#-]+)?
#                       (?<vflag> \*?[v])?
#                       (?<width> -?\d+ |
#                           \*\d+\$? |
#                           \((?<nwidth>$re1)\))?
#                       (?<dot>\.?)
#                       (?<prec>
#                           (?: \d+ | \* |
#                           \((?<nprec>$re1)\) ) ) ?
#                       (?<conv> [%csduoxefgXEGbBpniDUOF])
#                   )}x;
#our $regex = qr{($re2|%|[^%]+)}s;
#
#if (1) {
#    $regex = qr{( #all=1
#                    ( #fmt=2
#                        %
#                        (#pi=3
#                            \d+\$ | \(
#                            (#npi=4
#                                [^)]+)\)\$?)?
#                        (#flags=5
#                            [ +0#-]+)?
#                        (#vflag=6
#                            \*?[v])?
#                        (#width=7
#                            -?\d+ |
#                            \*\d+\$? |
#                            \((#nwidth=8
#                                [^)]+)\))?
#                        (#dot=9
#                            \.?)
#                        (#prec=10
#                            (?: \d+ | \* |
#                                \((#nprec=11
#                                    [^)]+)\) ) ) ?
#                        (#conv=12
#                            [%csduoxefgXEGbBpniDUOF])
#                    ) | % | [^%]+
#                )}xs;
#}
#
#sub sprintfn {
#    my ($format, @args) = @_;
#
#    my $hash;
#    if (ref($args[0]) eq 'HASH') {
#        $hash = shift(@args);
#    }
#    return sprintf($format, @args) if !$hash;
#
#    my %indexes; 
#    push @args, (undef) x $distance;
#
#    $format =~ s{$regex}{
#        my ($all, $fmt, $pi, $npi, $flags,
#            $vflag, $width, $nwidth, $dot, $prec,
#            $nprec, $conv) =
#            ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12);
#
#        my $res;
#        if ($fmt) {
#
#            if (defined $npi) {
#                my $i = $indexes{$npi};
#                if (!$i) {
#                    $i = @args + 1;
#                    push @args, $hash->{$npi};
#                    $indexes{$npi} = $i;
#                }
#                $pi = "${i}\$";
#            }
#
#            if (defined $nwidth) {
#                $width = $hash->{$nwidth};
#            }
#
#            if (defined $nprec) {
#                $prec = $hash->{$nprec};
#            }
#
#            $res = join("",
#                grep {defined} (
#                    "%",
#                    $pi, $flags, $vflag,
#                    $width, $dot, $prec, $conv)
#                );
#        } else {
#            my $i = @args + 1;
#            push @args, $all;
#            $res = "\%${i}\$s";
#        }
#        $res;
#    }xego;
#
#
#    sprintf $format, @args;
#}
#
#sub printfn {
#    print sprintfn @_;
#}
#
#1;
#
#__END__
#
### Tie/IxHash.pm ###
#
#require 5.005;
#
#package Tie::IxHash;
#use strict;
#use integer;
#require Tie::Hash;
#use vars qw/@ISA $VERSION/;
#@ISA = qw(Tie::Hash);
#
#$VERSION = $VERSION = '1.23';
#
#
#sub TIEHASH {
#  my($c) = shift;
#  my($s) = [];
#  $s->[0] = {};   
#  $s->[1] = [];   
#  $s->[2] = [];   
#  $s->[3] = 0;    
#
#  bless $s, $c;
#
#  $s->Push(@_) if @_;
#
#  return $s;
#}
#
#
#sub FETCH {
#  my($s, $k) = (shift, shift);
#  return exists( $s->[0]{$k} ) ? $s->[2][ $s->[0]{$k} ] : undef;
#}
#
#sub STORE {
#  my($s, $k, $v) = (shift, shift, shift);
#  
#  if (exists $s->[0]{$k}) {
#    my($i) = $s->[0]{$k};
#    $s->[1][$i] = $k;
#    $s->[2][$i] = $v;
#    $s->[0]{$k} = $i;
#  }
#  else {
#    push(@{$s->[1]}, $k);
#    push(@{$s->[2]}, $v);
#    $s->[0]{$k} = $#{$s->[1]};
#  }
#}
#
#sub DELETE {
#  my($s, $k) = (shift, shift);
#
#  if (exists $s->[0]{$k}) {
#    my($i) = $s->[0]{$k};
#    for ($i+1..$#{$s->[1]}) {    
#      $s->[0]{ $s->[1][$_] }--;    
#    }
#    if ( $i == $s->[3]-1 ) {
#      $s->[3]--;
#    }
#    delete $s->[0]{$k};
#    splice @{$s->[1]}, $i, 1;
#    return (splice(@{$s->[2]}, $i, 1))[0];
#  }
#  return undef;
#}
#
#sub EXISTS {
#  exists $_[0]->[0]{ $_[1] };
#}
#
#sub FIRSTKEY {
#  $_[0][3] = 0;
#  &NEXTKEY;
#}
#
#sub NEXTKEY {
#  return $_[0][1][ $_[0][3]++ ] if ($_[0][3] <= $#{ $_[0][1] } );
#  return undef;
#}
#
#
#
#
#sub new { TIEHASH(@_) }
#
#sub Clear {
#  my $s = shift;
#  $s->[0] = {};   
#  $s->[1] = [];   
#  $s->[2] = [];   
#  $s->[3] = 0;    
#  return;
#}
#
#sub Push {
#  my($s) = shift;
#  while (@_) {
#    $s->STORE(shift, shift);
#  }
#  return scalar(@{$s->[1]});
#}
#
#sub Push2 {
#  my($s) = shift;
#  $s->Splice($#{$s->[1]}+1, 0, @_);
#  return scalar(@{$s->[1]});
#}
#
#sub Pop {
#  my($s) = shift;
#  my($k, $v, $i);
#  $k = pop(@{$s->[1]});
#  $v = pop(@{$s->[2]});
#  if (defined $k) {
#    delete $s->[0]{$k};
#    return ($k, $v);
#  }
#  return undef;
#}
#
#sub Pop2 {
#  return $_[0]->Splice(-1);
#}
#
#sub Shift {
#  my($s) = shift;
#  my($k, $v, $i);
#  $k = shift(@{$s->[1]});
#  $v = shift(@{$s->[2]});
#  if (defined $k) {
#    delete $s->[0]{$k};
#    for (keys %{$s->[0]}) {
#      $s->[0]{$_}--;
#    }
#    return ($k, $v);
#  }
#  return undef;
#}
#
#sub Shift2 {
#  return $_[0]->Splice(0, 1);
#}
#
#sub Unshift {
#  my($s) = shift;
#  my($k, $v, @k, @v, $len, $i);
#
#  while (@_) {
#    ($k, $v) = (shift, shift);
#    if (exists $s->[0]{$k}) {
#      $i = $s->[0]{$k};
#      $s->[1][$i] = $k;
#      $s->[2][$i] = $v;
#      $s->[0]{$k} = $i;
#    }
#    else {
#      push(@k, $k);
#      push(@v, $v);
#      $len++;
#    }
#  }
#  if (defined $len) {
#    for (keys %{$s->[0]}) {
#      $s->[0]{$_} += $len;
#    }
#    $i = 0;
#    for (@k) {
#      $s->[0]{$_} = $i++;
#    }
#    unshift(@{$s->[1]}, @k);
#    return unshift(@{$s->[2]}, @v);
#  }
#  return scalar(@{$s->[1]});
#}
#
#sub Unshift2 {
#  my($s) = shift;
#  $s->Splice(0,0,@_);
#  return scalar(@{$s->[1]});
#}
#
#sub Splice {
#  my($s, $start, $len) = (shift, shift, shift);
#  my($k, $v, @k, @v, @r, $i, $siz);
#  my($end);                   
#
#  ($start, $end, $len) = $s->_lrange($start, $len);
#
#  if (defined $start) {
#    if ($len > 0) {
#      my(@k) = splice(@{$s->[1]}, $start, $len);
#      my(@v) = splice(@{$s->[2]}, $start, $len);
#      while (@k) {
#        $k = shift(@k);
#        delete $s->[0]{$k};
#        push(@r, $k, shift(@v));
#      }
#      for ($start..$#{$s->[1]}) {
#        $s->[0]{$s->[1][$_]} -= $len;
#      }
#    }
#    while (@_) {
#      ($k, $v) = (shift, shift);
#      if (exists $s->[0]{$k}) {
#        $i = $s->[0]{$k};
#        $s->[1][$i] = $k;
#        $s->[2][$i] = $v;
#        $s->[0]{$k} = $i;
#      }
#      else {
#        push(@k, $k);
#        push(@v, $v);
#        $siz++;
#      }
#    }
#    if (defined $siz) {
#      for ($start..$#{$s->[1]}) {
#        $s->[0]{$s->[1][$_]} += $siz;
#      }
#      $i = $start;
#      for (@k) {
#        $s->[0]{$_} = $i++;
#      }
#      splice(@{$s->[1]}, $start, 0, @k);
#      splice(@{$s->[2]}, $start, 0, @v);
#    }
#  }
#  return @r;
#}
#
#sub Delete {
#  my($s) = shift;
#
#  for (@_) {
#    $s->DELETE($_);
#  }
#}
#
#sub Replace {
#  my($s) = shift;
#  my($i, $v, $k) = (shift, shift, shift);
#  if (defined $i and $i <= $#{$s->[1]} and $i >= 0) {
#    if (defined $k) {
#      delete $s->[0]{ $s->[1][$i] };
#      $s->DELETE($k) ; 
#      $s->[1][$i] = $k;
#      $s->[2][$i] = $v;
#      $s->[0]{$k} = $i;
#      return $k;
#    }
#    else {
#      $s->[2][$i] = $v;
#      return $s->[1][$i];
#    }
#  }
#  return undef;
#}
#
#sub _lrange {
#  my($s) = shift;
#  my($offset, $len) = @_;
#  my($start, $end);         
#  my($size) = $#{$s->[1]}+1;
#
#  return undef unless defined $offset;
#  if($offset < 0) {
#    $start = $offset + $size;
#    $start = 0 if $start < 0;
#  }
#  else {
#    ($offset > $size) ? ($start = $size) : ($start = $offset);
#  }
#
#  if (defined $len) {
#    $len = -$len if $len < 0;
#    $len = $size - $start if $len > $size - $start;
#  }
#  else {
#    $len = $size - $start;
#  }
#  $end = $start + $len - 1;
#
#  return ($start, $end, $len);
#}
#
#sub Keys   { 
#  my($s) = shift;
#  return ( @_ == 1
#	 ? $s->[1][$_[0]]
#	 : ( @_
#	   ? @{$s->[1]}[@_]
#	   : @{$s->[1]} ) );
#}
#
#sub Values {
#  my($s) = shift;
#  return ( @_ == 1
#	 ? $s->[2][$_[0]]
#	 : ( @_
#	   ? @{$s->[2]}[@_]
#	   : @{$s->[2]} ) );
#}
#
#sub Indices { 
#  my($s) = shift;
#  return ( @_ == 1 ? $s->[0]{$_[0]} : @{$s->[0]}{@_} );
#}
#
#sub Length {
# return scalar @{$_[0]->[1]};
#}
#
#sub Reorder {
#  my($s) = shift;
#  my(@k, @v, %x, $i);
#  return unless @_;
#
#  $i = 0;
#  for (@_) {
#    if (exists $s->[0]{$_}) {
#      push(@k, $_);
#      push(@v, $s->[2][ $s->[0]{$_} ] );
#      $x{$_} = $i++;
#    }
#  }
#  $s->[1] = \@k;
#  $s->[2] = \@v;
#  $s->[0] = \%x;
#  return $s;
#}
#
#sub SortByKey {
#  my($s) = shift;
#  $s->Reorder(sort $s->Keys);
#}
#
#sub SortByValue {
#  my($s) = shift;
#  $s->Reorder(sort { $s->FETCH($a) cmp $s->FETCH($b) } $s->Keys)
#}
#
#1;
#__END__
#
### Time/Duration.pm ###
#package Time::Duration;
#$Time::Duration::VERSION = '1.20';
#use 5.006;
#use strict;
#use warnings;
#use constant DEBUG => 0;
#
#require Exporter;
#
#our @ISA         = ('Exporter');
#our @EXPORT      = qw( later later_exact earlier earlier_exact
#                       ago ago_exact from_now from_now_exact
#                       duration duration_exact
#                       concise
#                     );
#our @EXPORT_OK   = ('interval', @EXPORT);
#our $MILLISECOND = 0;
#
#
#
#sub concise ($) {
#  my $string = $_[0];
#  DEBUG and print "in : $string\n";
#  $string =~ tr/,//d;
#  $string =~ s/\band\b//;
#  $string =~ s/\b(year|day|hour|minute|second)s?\b/substr($1,0,1)/eg;
#  $string =~ s/\b(millisecond)s?\b/ms/g;
#  $string =~ s/\s*(\d+)\s*/$1/g;
#  return $string;
#}
#
#sub later {
#  interval(      $_[0], $_[1], ' earlier', ' later', 'right then'); }
#sub later_exact {
#  interval_exact($_[0], $_[1], ' earlier', ' later', 'right then'); }
#sub earlier {
#  interval(      $_[0], $_[1], ' later', ' earlier', 'right then'); }
#sub earlier_exact {
#  interval_exact($_[0], $_[1], ' later', ' earlier', 'right then'); }
#sub ago {
#  interval(      $_[0], $_[1], ' from now', ' ago', 'right now'); }
#sub ago_exact {
#  interval_exact($_[0], $_[1], ' from now', ' ago', 'right now'); }
#sub from_now {
#  interval(      $_[0], $_[1], ' ago', ' from now', 'right now'); }
#sub from_now_exact {
#  interval_exact($_[0], $_[1], ' ago', ' from now', 'right now'); }
#
#sub duration_exact {
#  my $span = $_[0];   
#  my $precision = int($_[1] || 0) || 2;  
#  return '0 seconds' unless $span;
#  _render('',
#          _separate(abs $span));
#}
#
#sub duration {
#  my $span = $_[0];   
#  my $precision = int($_[1] || 0) || 2;  
#  return '0 seconds' unless $span;
#  _render('',
#          _approximate($precision,
#                       _separate(abs $span)));
#}
#
#
#sub interval_exact {
#  my $span = $_[0];                    
#  my $direction = ($span < 0) ? $_[2]  
#                : ($span > 0) ? $_[3]  
#                : return        $_[4]; 
#  _render($direction,
#          _separate($span));
#}
#
#sub interval {
#  my $span = $_[0];                     
#  my $precision = int($_[1] || 0) || 2; 
#  my $direction = ($span < 0) ? $_[2]   
#                : ($span > 0) ? $_[3]   
#                : return        $_[4];  
#  _render($direction,
#          _approximate($precision,
#                       _separate($span)));
#}
#
#
#use constant MINUTE => 60;
#use constant HOUR => 3600;
#use constant DAY  => 24 * HOUR;
#use constant YEAR => 365 * DAY;
#
#sub _separate {
#  
#  my $remainder = abs $_[0]; 
#  my $this; 
#  my @wheel; 
#  
#  $this = int($remainder / (365 * 24 * 60 * 60));
#  push @wheel, ['year', $this, 1_000_000_000];
#  $remainder -= $this * (365 * 24 * 60 * 60);
#    
#  $this = int($remainder / (24 * 60 * 60));
#  push @wheel, ['day', $this, 365];
#  $remainder -= $this * (24 * 60 * 60);
#    
#  $this = int($remainder / (60 * 60));
#  push @wheel, ['hour', $this, 24];
#  $remainder -= $this * (60 * 60);
#  
#  $this = int($remainder / 60);
#  push @wheel, ['minute', $this, 60];
#  $remainder -= $this * 60;
#  
#  push @wheel, ['second', int($remainder), 60];
#
#	if ($MILLISECOND) {
#		$remainder -= int($remainder);
#		push @wheel, ['millisecond', sprintf("%0.f", $remainder * 1000), 1000];
#	}
#
#  return @wheel;
#}
#
#sub _approximate {
#  my($precision, @wheel) = @_;
#
# Fix:
#  {
#  
#    my $nonzero_count = 0;
#    my $improperly_expressed;
#
#    DEBUG and print join ' ', '#', (map "${$_}[1] ${$_}[0]",  @wheel), "\n";
#    for(my $i = 0; $i < @wheel; $i++) {
#      my $this = $wheel[$i];
#      next if $this->[1] == 0; 
#      ++$nonzero_count;
#      next if $i == 0; 
#      
#      if($nonzero_count > $precision) {
#        DEBUG and print '', $this->[0], " is one nonzero too many!\n";
#
#        if($this->[1] >= ($this->[-1] / 2)) {
#          DEBUG and printf "incrementing %s from %s to %s\n",
#           $wheel[$i-1][0], $wheel[$i-1][1], 1 + $wheel[$i-1][1], ;
#          ++$wheel[$i-1][1];
#        }
#
#        for(my $j = $i; $j < @wheel; $j++) { $wheel[$j][1] = 0 }
#        redo Fix; 
#      } elsif($this->[1] >= $this->[-1]) {
#        $improperly_expressed = $i;
#        DEBUG and print '', $this->[0], ' (', $this->[1], 
#           ") is improper!\n";
#      }
#    }
#    
#    if(defined $improperly_expressed) {
#      DEBUG and printf "incrementing %s from %s to %s\n",
#       $wheel[$improperly_expressed-1][0], $wheel[$improperly_expressed-1][1], 
#        1 + $wheel[$improperly_expressed-1][1], ;
#      ++$wheel[ $improperly_expressed - 1][1];
#      $wheel[ $improperly_expressed][1] = 0;
#      redo Fix; 
#    }
#    
#  }
#
#  return @wheel;
#}
#
#sub _render {
#
#  my $direction = shift @_;
#  my @wheel = map
#        {;
#            (  $_->[1] == 0) ? ()  
#            : ($_->[1] == 1) ? "${$_}[1] ${$_}[0]"  
#            :                  "${$_}[1] ${$_}[0]s" 
#        }
#        @_
#  ;
#  return "just now" unless @wheel; 
#  $wheel[-1] .= $direction;
#  return $wheel[0] if @wheel == 1;
#  return "$wheel[0] and $wheel[1]" if @wheel == 2;
#  $wheel[-1] = "and $wheel[-1]";
#  return join q{, }, @wheel;
#}
#
#1;
#
#__END__
#
#so "1y 0d 1h 50m 50s", N=3, so you round at minutes to "1y 0d 1h 51m 0s",
##That's okay, so fall thru.
#
#so "1y 1d 0h 59m 50s", N=3, so you round at minutes to "1y 1d 0h 60m 0s",
#but that's not improperly expressed, so you loop around and get
#"1y 1d 1h 0m 0s", which is short enough, and is properly expressed.
#
#
#
### YAML/Old.pm ###
#package YAML::Old;
#our $VERSION = '1.23';
#
#use YAML::Old::Mo;
#
#use Exporter;
#push @YAML::Old::ISA, 'Exporter';
#our @EXPORT = qw{ Dump Load };
#our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
#our (
#    $UseCode, $DumpCode, $LoadCode,
#    $SpecVersion,
#    $UseHeader, $UseVersion, $UseBlock, $UseFold, $UseAliases,
#    $Indent, $SortKeys, $Preserve,
#    $AnchorPrefix, $CompressSeries, $InlineSeries, $Purity,
#    $Stringify, $Numify
#);
#
#
#use YAML::Old::Node; 
#use Scalar::Util qw/ openhandle /;
#
#use constant VALUE => "\x07YAML\x07VALUE\x07";
#
#has dumper_class => default => sub {'YAML::Old::Dumper'};
#has loader_class => default => sub {'YAML::Old::Loader'};
#has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
#has loader_object => default => sub {$_[0]->init_action_object("loader")};
#
#sub Dump {
#    my $yaml = YAML::Old->new;
#    $yaml->dumper_class($YAML::DumperClass)
#        if $YAML::DumperClass;
#    return $yaml->dumper_object->dump(@_);
#}
#
#sub Load {
#    my $yaml = YAML::Old->new;
#    $yaml->loader_class($YAML::LoaderClass)
#        if $YAML::LoaderClass;
#    return $yaml->loader_object->load(@_);
#}
#
#{
#    no warnings 'once';
#    *freeze = \ &Dump;
#    *thaw   = \ &Load;
#}
#
#sub DumpFile {
#    my $OUT;
#    my $filename = shift;
#    if (openhandle $filename) {
#        $OUT = $filename;
#    }
#    else {
#        my $mode = '>';
#        if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
#            ($mode, $filename) = ($1, $2);
#        }
#        open $OUT, $mode, $filename
#          or YAML::Old::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, "$!");
#    }
#    binmode $OUT, ':utf8';  
#    local $/ = "\n"; 
#    print $OUT Dump(@_);
#    unless (ref $filename eq 'GLOB') {
#        close $OUT
#          or do {
#              my $errsav = $!;
#              YAML::Old::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT_CLOSE', $filename, $errsav);
#          }
#    }
#}
#
#sub LoadFile {
#    my $IN;
#    my $filename = shift;
#    if (openhandle $filename) {
#        $IN = $filename;
#    }
#    else {
#        open $IN, '<', $filename
#          or YAML::Old::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, "$!");
#    }
#    binmode $IN, ':utf8';  
#    return Load(do { local $/; <$IN> });
#}
#
#sub init_action_object {
#    my $self = shift;
#    my $object_class = (shift) . '_class';
#    my $module_name = $self->$object_class;
#    eval "require $module_name";
#    $self->die("Error in require $module_name - $@")
#        if $@ and "$@" !~ /Can't locate/;
#    my $object = $self->$object_class->new;
#    $object->set_global_options;
#    return $object;
#}
#
#my $global = {};
#sub Bless {
#    require YAML::Old::Dumper::Base;
#    YAML::Old::Dumper::Base::bless($global, @_)
#}
#sub Blessed {
#    require YAML::Old::Dumper::Base;
#    YAML::Old::Dumper::Base::blessed($global, @_)
#}
#sub global_object { $global }
#
#1;
### YAML/Old/Dumper.pm ###
#package YAML::Old::Dumper;
#
#use YAML::Old::Mo;
#extends 'YAML::Old::Dumper::Base';
#
#use YAML::Old::Dumper::Base;
#use YAML::Old::Node;
#use YAML::Old::Types;
#use Scalar::Util qw();
#use B ();
#use Carp ();
#
#use constant KEY       => 3;
#use constant BLESSED   => 4;
#use constant FROMARRAY => 5;
#use constant VALUE     => "\x07YAML\x07VALUE\x07";
#
#my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
#my $LIT_CHAR    = '|';
#
#sub dump {
#    my $self = shift;
#    $self->stream('');
#    $self->document(0);
#    for my $document (@_) {
#        $self->{document}++;
#        $self->transferred({});
#        $self->id_refcnt({});
#        $self->id_anchor({});
#        $self->anchor(1);
#        $self->level(0);
#        $self->offset->[0] = 0 - $self->indent_width;
#        $self->_prewalk($document);
#        $self->_emit_header($document);
#        $self->_emit_node($document);
#    }
#    return $self->stream;
#}
#
#sub _emit_header {
#    my $self = shift;
#    my ($node) = @_;
#    if (not $self->use_header and
#        $self->document == 1
#       ) {
#        $self->die('YAML_DUMP_ERR_NO_HEADER')
#          unless ref($node) =~ /^(HASH|ARRAY)$/;
#        $self->die('YAML_DUMP_ERR_NO_HEADER')
#          if ref($node) eq 'HASH' and keys(%$node) == 0;
#        $self->die('YAML_DUMP_ERR_NO_HEADER')
#          if ref($node) eq 'ARRAY' and @$node == 0;
#        $self->headless(1);
#        return;
#    }
#    $self->{stream} .= '---';
#    if ($self->use_version) {
#    }
#}
#
#sub _prewalk {
#    my $self = shift;
#    my $stringify = $self->stringify;
#    my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
#
#    if ($type eq 'GLOB') {
#        $self->transferred->{$node_id} =
#          YAML::Old::Type::glob->yaml_dump($_[0]);
#        $self->_prewalk($self->transferred->{$node_id});
#        return;
#    }
#
#    if (ref($_[0]) eq 'Regexp') {
#        return;
#    }
#
#    if (not ref $_[0]) {
#        $self->{id_refcnt}{$node_id}++ if $self->purity;
#        return;
#    }
#
#    my $value = $_[0];
#    ($class, $type, $node_id) = $self->node_info($value, $stringify);
#
#    return if (ref($value) and not $type);
#
#    if ($self->transferred->{$node_id}) {
#        (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
#          ? $self->node_info($self->transferred->{$node_id}, $stringify)
#          : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
#        $self->{id_refcnt}{$node_id}++;
#        return;
#    }
#
#    if ($type eq 'CODE') {
#        $self->transferred->{$node_id} = 'placeholder';
#        YAML::Old::Type::code->yaml_dump(
#            $self->dump_code,
#            $_[0],
#            $self->transferred->{$node_id}
#        );
#        ($class, $type, $node_id) =
#          $self->node_info(\ $self->transferred->{$node_id}, $stringify);
#        $self->{id_refcnt}{$node_id}++;
#        return;
#    }
#
#    if (defined $class) {
#        if ($value->can('yaml_dump')) {
#            $value = $value->yaml_dump;
#        }
#        elsif ($type eq 'SCALAR') {
#            $self->transferred->{$node_id} = 'placeholder';
#            YAML::Old::Type::blessed->yaml_dump
#              ($_[0], $self->transferred->{$node_id});
#            ($class, $type, $node_id) =
#              $self->node_info(\ $self->transferred->{$node_id}, $stringify);
#            $self->{id_refcnt}{$node_id}++;
#            return;
#        }
#        else {
#            $value = YAML::Old::Type::blessed->yaml_dump($value);
#        }
#        $self->transferred->{$node_id} = $value;
#        (undef, $type, $node_id) = $self->node_info($value, $stringify);
#    }
#
#    require YAML::Old;
#    if (defined YAML::Old->global_object()->{blessed_map}{$node_id}) {
#        $value = YAML::Old->global_object()->{blessed_map}{$node_id};
#        $self->transferred->{$node_id} = $value;
#        ($class, $type, $node_id) = $self->node_info($value, $stringify);
#        $self->_prewalk($value);
#        return;
#    }
#
#    if ($type eq 'REF' or $type eq 'SCALAR') {
#        $value = YAML::Old::Type::ref->yaml_dump($value);
#        $self->transferred->{$node_id} = $value;
#        (undef, $type, $node_id) = $self->node_info($value, $stringify);
#    }
#
#    elsif ($type eq 'GLOB') {
#        my $ref_ynode = $self->transferred->{$node_id} =
#          YAML::Old::Type::ref->yaml_dump($value);
#
#        my $glob_ynode = $ref_ynode->{&VALUE} =
#          YAML::Old::Type::glob->yaml_dump($$value);
#
#        (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
#        $self->transferred->{$node_id} = $glob_ynode;
#        $self->_prewalk($glob_ynode);
#        return;
#    }
#
#    return if ++($self->{id_refcnt}{$node_id}) > 1;
#
#    if ($type eq 'HASH') {
#        $self->_prewalk($value->{$_})
#            for keys %{$value};
#        return;
#    }
#    elsif ($type eq 'ARRAY') {
#        $self->_prewalk($_)
#            for @{$value};
#        return;
#    }
#
#    $self->warn(<<"...");
#YAML::Old::Dumper can't handle dumping this type of data.
#Please report this to the author.
#
#id:    $node_id
#type:  $type
#class: $class
#value: $value
#
#...
#
#    return;
#}
#
#sub _emit_node {
#    my $self = shift;
#    my ($type, $node_id);
#    my $ref = ref($_[0]);
#    if ($ref) {
#        if ($ref eq 'Regexp') {
#            $self->_emit(' !!perl/regexp');
#            $self->_emit_str("$_[0]");
#            return;
#        }
#        (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
#    }
#    else {
#        $type = $ref || 'SCALAR';
#        (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
#    }
#
#    my ($ynode, $tag) = ('') x 2;
#    my ($value, $context) = (@_, 0);
#
#    if (defined $self->transferred->{$node_id}) {
#        $value = $self->transferred->{$node_id};
#        $ynode = ynode($value);
#        if (ref $value) {
#            $tag = defined $ynode ? $ynode->tag->short : '';
#            (undef, $type, $node_id) =
#              $self->node_info($value, $self->stringify);
#        }
#        else {
#            $ynode = ynode($self->transferred->{$node_id});
#            $tag = defined $ynode ? $ynode->tag->short : '';
#            $type = 'SCALAR';
#            (undef, undef, $node_id) =
#              $self->node_info(
#                  \ $self->transferred->{$node_id},
#                  $self->stringify
#              );
#        }
#    }
#    elsif ($ynode = ynode($value)) {
#        $tag = $ynode->tag->short;
#    }
#
#    if ($self->use_aliases) {
#        $self->{id_refcnt}{$node_id} ||= 0;
#        if ($self->{id_refcnt}{$node_id} > 1) {
#            if (defined $self->{id_anchor}{$node_id}) {
#                $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
#                return;
#            }
#            my $anchor = $self->anchor_prefix . $self->{anchor}++;
#            $self->{stream} .= ' &' . $anchor;
#            $self->{id_anchor}{$node_id} = $anchor;
#        }
#    }
#
#    return $self->_emit_str("$value")   
#      if ref($value) and not $type;
#    return $self->_emit_scalar($value, $tag)
#      if $type eq 'SCALAR' and $tag;
#    return $self->_emit_str($value)
#      if $type eq 'SCALAR';
#    return $self->_emit_mapping($value, $tag, $node_id, $context)
#      if $type eq 'HASH';
#    return $self->_emit_sequence($value, $tag)
#      if $type eq 'ARRAY';
#    $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
#    return $self->_emit_str("$value");
#}
#
#sub _emit_mapping {
#    my $self = shift;
#    my ($value, $tag, $node_id, $context) = @_;
#    $self->{stream} .= " !$tag" if $tag;
#
#    my $empty_hash = not(eval {keys %$value});
#    $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
#    return ($self->{stream} .= " {}\n") if $empty_hash;
#
#    if ($context == FROMARRAY and
#        $self->compress_series and
#        not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
#       ) {
#        $self->{stream} .= ' ';
#        $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
#    }
#    else {
#        $context = 0;
#        $self->{stream} .= "\n"
#          unless $self->headless && not($self->headless(0));
#        $self->offset->[$self->level+1] =
#          $self->offset->[$self->level] + $self->indent_width;
#    }
#
#    $self->{level}++;
#    my @keys;
#    if ($self->sort_keys == 1) {
#        if (ynode($value)) {
#            @keys = keys %$value;
#        }
#        else {
#            @keys = sort keys %$value;
#        }
#    }
#    elsif ($self->sort_keys == 2) {
#        @keys = sort keys %$value;
#    }
#    elsif (ref($self->sort_keys) eq 'ARRAY') {
#        my $i = 1;
#        my %order = map { ($_, $i++) } @{$self->sort_keys};
#        @keys = sort {
#            (defined $order{$a} and defined $order{$b})
#              ? ($order{$a} <=> $order{$b})
#              : ($a cmp $b);
#        } keys %$value;
#    }
#    else {
#        @keys = keys %$value;
#    }
#    if (exists $value->{&VALUE}) {
#        for (my $i = 0; $i < @keys; $i++) {
#            if ($keys[$i] eq &VALUE) {
#                splice(@keys, $i, 1);
#                push @keys, &VALUE;
#                last;
#            }
#        }
#    }
#
#    for my $key (@keys) {
#        $self->_emit_key($key, $context);
#        $context = 0;
#        $self->{stream} .= ':';
#        $self->_emit_node($value->{$key});
#    }
#    $self->{level}--;
#}
#
#sub _emit_sequence {
#    my $self = shift;
#    my ($value, $tag) = @_;
#    $self->{stream} .= " !$tag" if $tag;
#
#    return ($self->{stream} .= " []\n") if @$value == 0;
#
#    $self->{stream} .= "\n"
#      unless $self->headless && not($self->headless(0));
#
#    if ($self->inline_series and
#        @$value <= $self->inline_series and
#        not (scalar grep {ref or /\n/} @$value)
#       ) {
#        $self->{stream} =~ s/\n\Z/ /;
#        $self->{stream} .= '[';
#        for (my $i = 0; $i < @$value; $i++) {
#            $self->_emit_str($value->[$i], KEY);
#            last if $i == $#{$value};
#            $self->{stream} .= ', ';
#        }
#        $self->{stream} .= "]\n";
#        return;
#    }
#
#    $self->offset->[$self->level + 1] =
#      $self->offset->[$self->level] + $self->indent_width;
#    $self->{level}++;
#    for my $val (@$value) {
#        $self->{stream} .= ' ' x $self->offset->[$self->level];
#        $self->{stream} .= '-';
#        $self->_emit_node($val, FROMARRAY);
#    }
#    $self->{level}--;
#}
#
#sub _emit_key {
#    my $self = shift;
#    my ($value, $context) = @_;
#    $self->{stream} .= ' ' x $self->offset->[$self->level]
#      unless $context == FROMARRAY;
#    $self->_emit_str($value, KEY);
#}
#
#sub _emit_scalar {
#    my $self = shift;
#    my ($value, $tag) = @_;
#    $self->{stream} .= " !$tag";
#    $self->_emit_str($value, BLESSED);
#}
#
#sub _emit {
#    my $self = shift;
#    $self->{stream} .= join '', @_;
#}
#
#sub _emit_str {
#    my $self = shift;
#    my $type = $_[1] || 0;
#
#    $self->offset->[$self->level + 1] =
#      $self->offset->[$self->level] + $self->indent_width;
#    $self->{level}++;
#
#    my $sf = $type == KEY ? '' : ' ';
#    my $sb = $type == KEY ? '? ' : ' ';
#    my $ef = $type == KEY ? '' : "\n";
#    my $eb = "\n";
#
#    while (1) {
#        $self->_emit($sf),
#        $self->_emit_plain($_[0]),
#        $self->_emit($ef), last
#          if not defined $_[0];
#        $self->_emit($sf, '=', $ef), last
#          if $_[0] eq VALUE;
#        $self->_emit($sf),
#        $self->_emit_double($_[0]),
#        $self->_emit($ef), last
#          if $_[0] =~ /$ESCAPE_CHAR/;
#        if ($_[0] =~ /\n/) {
#            $self->_emit($sb),
#            $self->_emit_block($LIT_CHAR, $_[0]),
#            $self->_emit($eb), last
#              if $self->use_block;
#              Carp::cluck "[YAML::Old] \$UseFold is no longer supported"
#              if $self->use_fold;
#            $self->_emit($sf),
#            $self->_emit_double($_[0]),
#            $self->_emit($ef), last
#              if length $_[0] <= 30;
#            $self->_emit($sf),
#            $self->_emit_double($_[0]),
#            $self->_emit($ef), last
#              if $_[0] !~ /\n\s*\S/;
#            $self->_emit($sb),
#            $self->_emit_block($LIT_CHAR, $_[0]),
#            $self->_emit($eb), last;
#        }
#        $self->_emit($sf),
#        $self->_emit_number($_[0]),
#        $self->_emit($ef), last
#          if $self->is_literal_number($_[0]);
#        $self->_emit($sf),
#        $self->_emit_plain($_[0]),
#        $self->_emit($ef), last
#          if $self->is_valid_plain($_[0]);
#        $self->_emit($sf),
#        $self->_emit_double($_[0]),
#        $self->_emit($ef), last
#          if $_[0] =~ /'/;
#        $self->_emit($sf),
#        $self->_emit_single($_[0]),
#        $self->_emit($ef);
#        last;
#    }
#
#    $self->{level}--;
#
#    return;
#}
#
#sub is_literal_number {
#    my $self = shift;
#    return B::svref_2object(\$_[0])->FLAGS & (B::SVp_IOK | B::SVp_NOK)
#            && 0 + $_[0] eq $_[0];
#}
#
#sub _emit_number {
#    my $self = shift;
#    return $self->_emit_plain($_[0]);
#}
#
#sub is_valid_plain {
#    my $self = shift;
#    return 0 unless length $_[0];
#    return 0 if $self->quote_numeric_strings and Scalar::Util::looks_like_number($_[0]);
#    return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
#    return 0 if $_[0] =~ /[\{\[\]\},]/;
#    return 0 if $_[0] =~ /[:\-\?]\s/;
#    return 0 if $_[0] =~ /\s#/;
#    return 0 if $_[0] =~ /\:(\s|$)/;
#    return 0 if $_[0] =~ /[\s\|\>]$/;
#    return 0 if $_[0] eq '-';
#    return 1;
#}
#
#sub _emit_block {
#    my $self = shift;
#    my ($indicator, $value) = @_;
#    $self->{stream} .= $indicator;
#    $value =~ /(\n*)\Z/;
#    my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
#    $value = '~' if not defined $value;
#    $self->{stream} .= $chomp;
#    $self->{stream} .= $self->indent_width if $value =~ /^\s/;
#    $self->{stream} .= $self->indent($value);
#}
#
#sub _emit_plain {
#    my $self = shift;
#    $self->{stream} .= defined $_[0] ? $_[0] : '~';
#}
#
#sub _emit_double {
#    my $self = shift;
#    (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
#    $self->{stream} .= qq{"$escaped"};
#}
#
#sub _emit_single {
#    my $self = shift;
#    my $item = shift;
#    $item =~ s{'}{''}g;
#    $self->{stream} .= "'$item'";
#}
#
#
#sub indent {
#    my $self = shift;
#    my ($text) = @_;
#    return $text unless length $text;
#    $text =~ s/\n\Z//;
#    my $indent = ' ' x $self->offset->[$self->level];
#    $text =~ s/^/$indent/gm;
#    $text = "\n$text";
#    return $text;
#}
#
#my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
#                 \x08 \t   \n   \v   \f   \r   \x0e \x0f
#                 \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
#                 \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
#                );
#
#sub escape {
#    my $self = shift;
#    my ($text) = @_;
#    $text =~ s/\\/\\\\/g;
#    $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
#    return $text;
#}
#
#1;
### YAML/Old/Dumper/Base.pm ###
#package YAML::Old::Dumper::Base;
#
#use YAML::Old::Mo;
#
#use YAML::Old::Node;
#
#has spec_version    => default => sub {'1.0'};
#has indent_width    => default => sub {2};
#has use_header      => default => sub {1};
#has use_version     => default => sub {0};
#has sort_keys       => default => sub {1};
#has anchor_prefix   => default => sub {''};
#has dump_code       => default => sub {0};
#has use_block       => default => sub {0};
#has use_fold        => default => sub {0};
#has compress_series => default => sub {1};
#has inline_series   => default => sub {0};
#has use_aliases     => default => sub {1};
#has purity          => default => sub {0};
#has stringify       => default => sub {0};
#has quote_numeric_strings => default => sub {0};
#
#has stream      => default => sub {''};
#has document    => default => sub {0};
#has transferred => default => sub {{}};
#has id_refcnt   => default => sub {{}};
#has id_anchor   => default => sub {{}};
#has anchor      => default => sub {1};
#has level       => default => sub {0};
#has offset      => default => sub {[]};
#has headless    => default => sub {0};
#has blessed_map => default => sub {{}};
#
#sub set_global_options {
#    my $self = shift;
#    $self->spec_version($YAML::SpecVersion)
#      if defined $YAML::SpecVersion;
#    $self->indent_width($YAML::Indent)
#      if defined $YAML::Indent;
#    $self->use_header($YAML::UseHeader)
#      if defined $YAML::UseHeader;
#    $self->use_version($YAML::UseVersion)
#      if defined $YAML::UseVersion;
#    $self->sort_keys($YAML::SortKeys)
#      if defined $YAML::SortKeys;
#    $self->anchor_prefix($YAML::AnchorPrefix)
#      if defined $YAML::AnchorPrefix;
#    $self->dump_code($YAML::DumpCode || $YAML::UseCode)
#      if defined $YAML::DumpCode or defined $YAML::UseCode;
#    $self->use_block($YAML::UseBlock)
#      if defined $YAML::UseBlock;
#    $self->use_fold($YAML::UseFold)
#      if defined $YAML::UseFold;
#    $self->compress_series($YAML::CompressSeries)
#      if defined $YAML::CompressSeries;
#    $self->inline_series($YAML::InlineSeries)
#      if defined $YAML::InlineSeries;
#    $self->use_aliases($YAML::UseAliases)
#      if defined $YAML::UseAliases;
#    $self->purity($YAML::Purity)
#      if defined $YAML::Purity;
#    $self->stringify($YAML::Stringify)
#      if defined $YAML::Stringify;
#    $self->quote_numeric_strings($YAML::QuoteNumericStrings)
#      if defined $YAML::QuoteNumericStrings;
#}
#
#sub dump {
#    my $self = shift;
#    $self->die('dump() not implemented in this class.');
#}
#
#sub blessed {
#    my $self = shift;
#    my ($ref) = @_;
#    $ref = \$_[0] unless ref $ref;
#    my (undef, undef, $node_id) = YAML::Old::Mo::Object->node_info($ref);
#    $self->{blessed_map}->{$node_id};
#}
#
#sub bless {
#    my $self = shift;
#    my ($ref, $blessing) = @_;
#    my $ynode;
#    $ref = \$_[0] unless ref $ref;
#    my (undef, undef, $node_id) = YAML::Old::Mo::Object->node_info($ref);
#    if (not defined $blessing) {
#        $ynode = YAML::Old::Node->new($ref);
#    }
#    elsif (ref $blessing) {
#        $self->die() unless ynode($blessing);
#        $ynode = $blessing;
#    }
#    else {
#        no strict 'refs';
#        my $transfer = $blessing . "::yaml_dump";
#        $self->die() unless defined &{$transfer};
#        $ynode = &{$transfer}($ref);
#        $self->die() unless ynode($ynode);
#    }
#    $self->{blessed_map}->{$node_id} = $ynode;
#    my $object = ynode($ynode) or $self->die();
#    return $object;
#}
#
#1;
### YAML/Old/Error.pm ###
#package YAML::Old::Error;
#
#use YAML::Old::Mo;
#
#has 'code';
#has 'type' => default => sub {'Error'};
#has 'line';
#has 'document';
#has 'arguments' => default => sub {[]};
#
#my ($error_messages, %line_adjust);
#
#sub format_message {
#    my $self = shift;
#    my $output = 'YAML::Old ' . $self->type . ': ';
#    my $code = $self->code;
#    if ($error_messages->{$code}) {
#        $code = sprintf($error_messages->{$code}, @{$self->arguments});
#    }
#    $output .= $code . "\n";
#
#    $output .= '   Code: ' . $self->code . "\n"
#        if defined $self->code;
#    $output .= '   Line: ' . $self->line . "\n"
#        if defined $self->line;
#    $output .= '   Document: ' . $self->document . "\n"
#        if defined $self->document;
#    return $output;
#}
#
#sub error_messages {
#    $error_messages;
#}
#
#%$error_messages = map {s/^\s+//;s/\\n/\n/;$_} split "\n", <<'...';
#YAML_PARSE_ERR_BAD_CHARS
#  Invalid characters in stream. This parser only supports printable ASCII
#YAML_PARSE_ERR_BAD_MAJOR_VERSION
#  Can't parse a %s document with a 1.0 parser
#YAML_PARSE_WARN_BAD_MINOR_VERSION
#  Parsing a %s document with a 1.0 parser
#YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
#  '%s directive used more than once'
#YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
#  No text allowed after indicator
#YAML_PARSE_ERR_NO_ANCHOR
#  No anchor for alias '*%s'
#YAML_PARSE_ERR_NO_SEPARATOR
#  Expected separator '---'
#YAML_PARSE_ERR_SINGLE_LINE
#  Couldn't parse single line value
#YAML_PARSE_ERR_BAD_ANCHOR
#  Invalid anchor
#YAML_DUMP_ERR_INVALID_INDENT
#  Invalid Indent width specified: '%s'
#YAML_LOAD_USAGE
#  usage: YAML::Old::Load($yaml_stream_scalar)
#YAML_PARSE_ERR_BAD_NODE
#  Can't parse node
#YAML_PARSE_ERR_BAD_EXPLICIT
#  Unsupported explicit transfer: '%s'
#YAML_DUMP_USAGE_DUMPCODE
#  Invalid value for DumpCode: '%s'
#YAML_LOAD_ERR_FILE_INPUT
#  Couldn't open %s for input:\n%s
#YAML_DUMP_ERR_FILE_CONCATENATE
#  Can't concatenate to YAML file %s
#YAML_DUMP_ERR_FILE_OUTPUT
#  Couldn't open %s for output:\n%s
#YAML_DUMP_ERR_FILE_OUTPUT_CLOSE
#  Error closing %s:\n%s
#YAML_DUMP_ERR_NO_HEADER
#  With UseHeader=0, the node must be a plain hash or array
#YAML_DUMP_WARN_BAD_NODE_TYPE
#  Can't perform serialization for node type: '%s'
#YAML_EMIT_WARN_KEYS
#  Encountered a problem with 'keys':\n%s
#YAML_DUMP_WARN_DEPARSE_FAILED
#  Deparse failed for CODE reference
#YAML_DUMP_WARN_CODE_DUMMY
#  Emitting dummy subroutine for CODE reference
#YAML_PARSE_ERR_MANY_EXPLICIT
#  More than one explicit transfer
#YAML_PARSE_ERR_MANY_IMPLICIT
#  More than one implicit request
#YAML_PARSE_ERR_MANY_ANCHOR
#  More than one anchor
#YAML_PARSE_ERR_ANCHOR_ALIAS
#  Can't define both an anchor and an alias
#YAML_PARSE_ERR_BAD_ALIAS
#  Invalid alias
#YAML_PARSE_ERR_MANY_ALIAS
#  More than one alias
#YAML_LOAD_ERR_NO_CONVERT
#  Can't convert implicit '%s' node to explicit '%s' node
#YAML_LOAD_ERR_NO_DEFAULT_VALUE
#  No default value for '%s' explicit transfer
#YAML_LOAD_ERR_NON_EMPTY_STRING
#  Only the empty string can be converted to a '%s'
#YAML_LOAD_ERR_BAD_MAP_TO_SEQ
#  Can't transfer map as sequence. Non numeric key '%s' encountered.
#YAML_DUMP_ERR_BAD_GLOB
#  '%s' is an invalid value for Perl glob
#YAML_DUMP_ERR_BAD_REGEXP
#  '%s' is an invalid value for Perl Regexp
#YAML_LOAD_ERR_BAD_MAP_ELEMENT
#  Invalid element in map
#YAML_LOAD_WARN_DUPLICATE_KEY
#  Duplicate map key '%s' found. Ignoring.
#YAML_LOAD_ERR_BAD_SEQ_ELEMENT
#  Invalid element in sequence
#YAML_PARSE_ERR_INLINE_MAP
#  Can't parse inline map
#YAML_PARSE_ERR_INLINE_SEQUENCE
#  Can't parse inline sequence
#YAML_PARSE_ERR_BAD_DOUBLE
#  Can't parse double quoted string
#YAML_PARSE_ERR_BAD_SINGLE
#  Can't parse single quoted string
#YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
#  Can't parse inline implicit value '%s'
#YAML_PARSE_ERR_BAD_IMPLICIT
#  Unrecognized implicit value '%s'
#YAML_PARSE_ERR_INDENTATION
#  Error. Invalid indentation level
#YAML_PARSE_ERR_INCONSISTENT_INDENTATION
#  Inconsistent indentation level
#YAML_LOAD_WARN_UNRESOLVED_ALIAS
#  Can't resolve alias *%s
#YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
#  No 'REGEXP' element for Perl regexp
#YAML_LOAD_WARN_BAD_REGEXP_ELEM
#  Unknown element '%s' in Perl regexp
#YAML_LOAD_WARN_GLOB_NAME
#  No 'NAME' element for Perl glob
#YAML_LOAD_WARN_PARSE_CODE
#  Couldn't parse Perl code scalar: %s
#YAML_LOAD_WARN_CODE_DEPARSE
#  Won't parse Perl code unless $YAML::LoadCode is set
#YAML_EMIT_ERR_BAD_LEVEL
#  Internal Error: Bad level detected
#YAML_PARSE_WARN_AMBIGUOUS_TAB
#  Amibiguous tab converted to spaces
#YAML_LOAD_WARN_BAD_GLOB_ELEM
#  Unknown element '%s' in Perl glob
#YAML_PARSE_ERR_ZERO_INDENT
#  Can't use zero as an indentation width
#YAML_LOAD_WARN_GLOB_IO
#  Can't load an IO filehandle. Yet!!!
#...
#
#%line_adjust = map {($_, 1)}
#  qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
#     YAML_PARSE_WARN_BAD_MINOR_VERSION
#     YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
#     YAML_PARSE_ERR_NO_ANCHOR
#     YAML_PARSE_ERR_MANY_EXPLICIT
#     YAML_PARSE_ERR_MANY_IMPLICIT
#     YAML_PARSE_ERR_MANY_ANCHOR
#     YAML_PARSE_ERR_ANCHOR_ALIAS
#     YAML_PARSE_ERR_BAD_ALIAS
#     YAML_PARSE_ERR_MANY_ALIAS
#     YAML_LOAD_ERR_NO_CONVERT
#     YAML_LOAD_ERR_NO_DEFAULT_VALUE
#     YAML_LOAD_ERR_NON_EMPTY_STRING
#     YAML_LOAD_ERR_BAD_MAP_TO_SEQ
#     YAML_LOAD_ERR_BAD_STR_TO_INT
#     YAML_LOAD_ERR_BAD_STR_TO_DATE
#     YAML_LOAD_ERR_BAD_STR_TO_TIME
#     YAML_LOAD_WARN_DUPLICATE_KEY
#     YAML_PARSE_ERR_INLINE_MAP
#     YAML_PARSE_ERR_INLINE_SEQUENCE
#     YAML_PARSE_ERR_BAD_DOUBLE
#     YAML_PARSE_ERR_BAD_SINGLE
#     YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
#     YAML_PARSE_ERR_BAD_IMPLICIT
#     YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
#     YAML_LOAD_WARN_BAD_REGEXP_ELEM
#     YAML_LOAD_WARN_REGEXP_CREATE
#     YAML_LOAD_WARN_GLOB_NAME
#     YAML_LOAD_WARN_PARSE_CODE
#     YAML_LOAD_WARN_CODE_DEPARSE
#     YAML_LOAD_WARN_BAD_GLOB_ELEM
#     YAML_PARSE_ERR_ZERO_INDENT
#    );
#
#package YAML::Old::Warning;
#
#our @ISA = 'YAML::Old::Error';
#
#1;
### YAML/Old/Loader.pm ###
#package YAML::Old::Loader;
#
#use YAML::Old::Mo;
#extends 'YAML::Old::Loader::Base';
#
#use YAML::Old::Loader::Base;
#use YAML::Old::Types;
#use YAML::Old::Node;
#
#use constant LEAF       => 1;
#use constant COLLECTION => 2;
#use constant VALUE      => "\x07YAML\x07VALUE\x07";
#use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
#
#my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
#my $FOLD_CHAR   = '>';
#my $LIT_CHAR    = '|';
#my $LIT_CHAR_RX = "\\$LIT_CHAR";
#
#sub load {
#    my $self = shift;
#    $self->stream($_[0] || '');
#    return $self->_parse();
#}
#
#sub _parse {
#    my $self = shift;
#    my (%directives, $preface);
#    $self->{stream} =~ s|\015\012|\012|g;
#    $self->{stream} =~ s|\015|\012|g;
#    $self->line(0);
#    $self->die('YAML_PARSE_ERR_BAD_CHARS')
#      if $self->stream =~ /$ESCAPE_CHAR/;
#    $self->{stream} =~ s/(.)\n\Z/$1/s;
#    $self->lines([split /\x0a/, $self->stream, -1]);
#    $self->line(1);
#    $self->_parse_throwaway_comments();
#    $self->document(0);
#    $self->documents([]);
#    if (not $self->eos) {
#        if ($self->lines->[0] !~ /^---(\s|$)/) {
#            unshift @{$self->lines}, '---';
#            $self->{line}--;
#        }
#    }
#
#    while (not $self->eos) {
#        $self->anchor2node({});
#        $self->{document}++;
#        $self->done(0);
#        $self->level(0);
#        $self->offset->[0] = -1;
#
#        if ($self->lines->[0] =~ /^---\s*(.*)$/) {
#            my @words = split /\s+/, $1;
#            %directives = ();
#            while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
#                my ($key, $value) = ($1, $2);
#                shift(@words);
#                if (defined $directives{$key}) {
#                    $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
#                      $key, $self->document);
#                    next;
#                }
#                $directives{$key} = $value;
#            }
#            $self->preface(join ' ', @words);
#        }
#        else {
#            $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
#        }
#
#        if (not $self->done) {
#            $self->_parse_next_line(COLLECTION);
#        }
#        if ($self->done) {
#            $self->{indent} = -1;
#            $self->content('');
#        }
#
#        $directives{YAML} ||= '1.0';
#        $directives{TAB} ||= 'NONE';
#        ($self->{major_version}, $self->{minor_version}) =
#          split /\./, $directives{YAML}, 2;
#        $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
#          if $self->major_version ne '1';
#        $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
#          if $self->minor_version ne '0';
#        $self->die('Unrecognized TAB policy')
#          unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
#
#        push @{$self->documents}, $self->_parse_node();
#    }
#    return wantarray ? @{$self->documents} : $self->documents->[-1];
#}
#
#sub _parse_node {
#    my $self = shift;
#    my $preface = $self->preface;
#    $self->preface('');
#    my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
#    my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
#    ($anchor, $alias, $explicit, $implicit, $preface) =
#      $self->_parse_qualifiers($preface);
#    if ($anchor) {
#        $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
#    }
#    $self->inline('');
#    while (length $preface) {
#        my $line = $self->line - 1;
#        if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) {
#            $indicator = $1;
#            $chomp = $2 if defined($2);
#        }
#        else {
#            $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
#            $self->inline($preface);
#            $preface = '';
#        }
#    }
#    if ($alias) {
#        $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
#          unless defined $self->anchor2node->{$alias};
#        if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
#            $node = $self->anchor2node->{$alias};
#        }
#        else {
#            $node = do {my $sv = "*$alias"};
#            push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
#        }
#    }
#    elsif (length $self->inline) {
#        $node = $self->_parse_inline(1, $implicit, $explicit);
#        if (length $self->inline) {
#            $self->die('YAML_PARSE_ERR_SINGLE_LINE');
#        }
#    }
#    elsif ($indicator eq $LIT_CHAR) {
#        $self->{level}++;
#        $node = $self->_parse_block($chomp);
#        $node = $self->_parse_implicit($node) if $implicit;
#        $self->{level}--;
#    }
#    elsif ($indicator eq $FOLD_CHAR) {
#        $self->{level}++;
#        $node = $self->_parse_unfold($chomp);
#        $node = $self->_parse_implicit($node) if $implicit;
#        $self->{level}--;
#    }
#    else {
#        $self->{level}++;
#        $self->offset->[$self->level] ||= 0;
#        if ($self->indent == $self->offset->[$self->level]) {
#            if ($self->content =~ /^-( |$)/) {
#                $node = $self->_parse_seq($anchor);
#            }
#            elsif ($self->content =~ /(^\?|\:( |$))/) {
#                $node = $self->_parse_mapping($anchor);
#            }
#            elsif ($preface =~ /^\s*$/) {
#                $node = $self->_parse_implicit('');
#            }
#            else {
#                $self->die('YAML_PARSE_ERR_BAD_NODE');
#            }
#        }
#        else {
#            $node = undef;
#        }
#        $self->{level}--;
#    }
#    $#{$self->offset} = $self->level;
#
#    if ($explicit) {
#        if ($class) {
#            if (not ref $node) {
#                my $copy = $node;
#                undef $node;
#                $node = \$copy;
#            }
#            CORE::bless $node, $class;
#        }
#        else {
#            $node = $self->_parse_explicit($node, $explicit);
#        }
#    }
#    if ($anchor) {
#        if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
#            for my $ref (@{$self->anchor2node->{$anchor}}) {
#                ${$ref->[0]} = $node;
#                $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
#                    $anchor, $ref->[1]);
#            }
#        }
#        $self->anchor2node->{$anchor} = $node;
#    }
#    return $node;
#}
#
#sub _parse_qualifiers {
#    my $self = shift;
#    my ($preface) = @_;
#    my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
#    $self->inline('');
#    while ($preface =~ /^[&*!]/) {
#        my $line = $self->line - 1;
#        if ($preface =~ s/^\!(\S+)\s*//) {
#            $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
#            $explicit = $1;
#        }
#        elsif ($preface =~ s/^\!\s*//) {
#            $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
#            $implicit = 1;
#        }
#        elsif ($preface =~ s/^\&([^ ,:]*)\s*//) {
#            $token = $1;
#            $self->die('YAML_PARSE_ERR_BAD_ANCHOR')
#              unless $token =~ /^[a-zA-Z0-9]+$/;
#            $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
#            $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
#            $anchor = $token;
#        }
#        elsif ($preface =~ s/^\*([^ ,:]*)\s*//) {
#            $token = $1;
#            $self->die('YAML_PARSE_ERR_BAD_ALIAS')
#              unless $token =~ /^[a-zA-Z0-9]+$/;
#            $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
#            $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
#            $alias = $token;
#        }
#    }
#    return ($anchor, $alias, $explicit, $implicit, $preface);
#}
#
#sub _parse_explicit {
#    my $self = shift;
#    my ($node, $explicit) = @_;
#    my ($type, $class);
#    if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
#        ($type, $class) = (($1 || ''), ($2 || ''));
#
#
#        if ( $type eq "ref" ) {
#            $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
#            unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
#
#            my $value = $node->{VALUE()};
#            $node = \$value;
#        }
#
#        if ( $type eq "scalar" and length($class) and !ref($node) ) {
#            my $value = $node;
#            $node = \$value;
#        }
#
#        if ( length($class) ) {
#            CORE::bless($node, $class);
#        }
#
#        return $node;
#    }
#    if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
#        ($type, $class) = (($1 || ''), ($2 || ''));
#        my $type_class = "YAML::Old::Type::$type";
#        no strict 'refs';
#        if ($type_class->can('yaml_load')) {
#            return $type_class->yaml_load($node, $class, $self);
#        }
#        else {
#            $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
#        }
#    }
#    elsif ($YAML::TagClass->{$explicit} ||
#           $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
#          ) {
#        $class = $YAML::TagClass->{$explicit} || $2;
#        if ($class->can('yaml_load')) {
#            require YAML::Old::Node;
#            return $class->yaml_load(YAML::Old::Node->new($node, $explicit));
#        }
#        else {
#            if (ref $node) {
#                return CORE::bless $node, $class;
#            }
#            else {
#                return CORE::bless \$node, $class;
#            }
#        }
#    }
#    elsif (ref $node) {
#        require YAML::Old::Node;
#        return YAML::Old::Node->new($node, $explicit);
#    }
#    else {
#        return $node;
#    }
#}
#
#sub _parse_mapping {
#    my $self = shift;
#    my ($anchor) = @_;
#    my $mapping = $self->preserve ? YAML::Old::Node->new({}) : {};
#    $self->anchor2node->{$anchor} = $mapping;
#    my $key;
#    while (not $self->done and $self->indent == $self->offset->[$self->level]) {
#        if ($self->{content} =~ s/^\?\s*//) {
#            $self->preface($self->content);
#            $self->_parse_next_line(COLLECTION);
#            $key = $self->_parse_node();
#            $key = "$key";
#        }
#        elsif ($self->{content} =~ s/^\=\s*//) {
#            $key = VALUE;
#        }
#        elsif ($self->{content} =~ s/^\=\s*//) {
#            $key = COMMENT;
#        }
#        else {
#            $self->inline($self->content);
#            $key = $self->_parse_inline();
#            $key = "$key";
#            $self->content($self->inline);
#            $self->inline('');
#        }
#
#        unless ($self->{content} =~ s/^:\s*//) {
#            $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
#        }
#        $self->preface($self->content);
#        my $line = $self->line;
#        $self->_parse_next_line(COLLECTION);
#        my $value = $self->_parse_node();
#        if (exists $mapping->{$key}) {
#            $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY', $key);
#        }
#        else {
#            $mapping->{$key} = $value;
#        }
#    }
#    return $mapping;
#}
#
#sub _parse_seq {
#    my $self = shift;
#    my ($anchor) = @_;
#    my $seq = [];
#    $self->anchor2node->{$anchor} = $seq;
#    while (not $self->done and $self->indent == $self->offset->[$self->level]) {
#        if ($self->content =~ /^-(?: (.*))?$/) {
#            $self->preface(defined($1) ? $1 : '');
#        }
#        else {
#            $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
#        }
#
#        my $preface = $self->preface;
#        if ( $preface =~ /^ (\s*) ( \w .*?               \: (?:\ |$).*) $/x  or
#             $preface =~ /^ (\s*) ((') (?:''|[^'])*? ' \s* \: (?:\ |$).*) $/x or
#             $preface =~ /^ (\s*) ((") (?:\\\\|[^"])*? " \s* \: (?:\ |$).*) $/x
#           ) {
#            $self->indent($self->offset->[$self->level] + 2 + length($1));
#            $self->content($2);
#            $self->level($self->level + 1);
#            $self->offset->[$self->level] = $self->indent;
#            $self->preface('');
#            push @$seq, $self->_parse_mapping('');
#            $self->{level}--;
#            $#{$self->offset} = $self->level;
#        }
#        else {
#            $self->_parse_next_line(COLLECTION);
#            push @$seq, $self->_parse_node();
#        }
#    }
#    return $seq;
#}
#
#sub _parse_inline {
#    my $self = shift;
#    my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
#    $self->{inline} =~ s/^\s*(.*)\s*$/$1/; 
#    my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
#    ($anchor, $alias, $explicit, $implicit, $self->{inline}) =
#      $self->_parse_qualifiers($self->inline);
#    if ($anchor) {
#        $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
#    }
#    $implicit ||= $top_implicit;
#    $explicit ||= $top_explicit;
#    ($top_implicit, $top_explicit) = ('', '');
#    if ($alias) {
#        $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
#          unless defined $self->anchor2node->{$alias};
#        if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
#            $node = $self->anchor2node->{$alias};
#        }
#        else {
#            $node = do {my $sv = "*$alias"};
#            push @{$self->anchor2node->{$alias}}, [\$node, $self->line];
#        }
#    }
#    elsif ($self->inline =~ /^\{/) {
#        $node = $self->_parse_inline_mapping($anchor);
#    }
#    elsif ($self->inline =~ /^\[/) {
#        $node = $self->_parse_inline_seq($anchor);
#    }
#    elsif ($self->inline =~ /^"/) {
#        $node = $self->_parse_inline_double_quoted();
#        $node = $self->_unescape($node);
#        $node = $self->_parse_implicit($node) if $implicit;
#    }
#    elsif ($self->inline =~ /^'/) {
#        $node = $self->_parse_inline_single_quoted();
#        $node = $self->_parse_implicit($node) if $implicit;
#    }
#    else {
#        if ($top) {
#            $node = $self->inline;
#            $self->inline('');
#        }
#        else {
#            $node = $self->_parse_inline_simple();
#        }
#        $node = $self->_parse_implicit($node) unless $explicit;
#
#        if ($self->numify and defined $node and not ref $node and length $node
#            and $node =~ m/\A-?(?:0|[1-9][0-9]*)?(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?\z/) {
#            $node += 0;
#        }
#    }
#    if ($explicit) {
#        $node = $self->_parse_explicit($node, $explicit);
#    }
#    if ($anchor) {
#        if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
#            for my $ref (@{$self->anchor2node->{$anchor}}) {
#                ${$ref->[0]} = $node;
#                $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
#                    $anchor, $ref->[1]);
#            }
#        }
#        $self->anchor2node->{$anchor} = $node;
#    }
#    return $node;
#}
#
#sub _parse_inline_mapping {
#    my $self = shift;
#    my ($anchor) = @_;
#    my $node = {};
#    $self->anchor2node->{$anchor} = $node;
#
#    $self->die('YAML_PARSE_ERR_INLINE_MAP')
#      unless $self->{inline} =~ s/^\{\s*//;
#    while (not $self->{inline} =~ s/^\s*\}\s*//) {
#        my $key = $self->_parse_inline();
#        $self->die('YAML_PARSE_ERR_INLINE_MAP')
#          unless $self->{inline} =~ s/^\: \s*//;
#        my $value = $self->_parse_inline();
#        if (exists $node->{$key}) {
#            $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY', $key);
#        }
#        else {
#            $node->{$key} = $value;
#        }
#        next if $self->inline =~ /^\s*\}/;
#        $self->die('YAML_PARSE_ERR_INLINE_MAP')
#          unless $self->{inline} =~ s/^\,\s*//;
#    }
#    return $node;
#}
#
#sub _parse_inline_seq {
#    my $self = shift;
#    my ($anchor) = @_;
#    my $node = [];
#    $self->anchor2node->{$anchor} = $node;
#
#    $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
#      unless $self->{inline} =~ s/^\[\s*//;
#    while (not $self->{inline} =~ s/^\s*\]\s*//) {
#        my $value = $self->_parse_inline();
#        push @$node, $value;
#        next if $self->inline =~ /^\s*\]/;
#        $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
#          unless $self->{inline} =~ s/^\,\s*//;
#    }
#    return $node;
#}
#
#sub _parse_inline_double_quoted {
#    my $self = shift;
#    my $node;
#    if ($self->inline =~ /^"((?:(?:\\"|[^"]){0,32766}){0,32766})"\s*(.*)$/) {
#        $node = $1;
#        $self->inline($2);
#        $node =~ s/\\"/"/g;
#    }
#    else {
#        $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
#    }
#    return $node;
#}
#
#
#sub _parse_inline_single_quoted {
#    my $self = shift;
#    my $node;
#    if ($self->inline =~ /^'((?:(?:''|[^']){0,32766}){0,32766})'\s*(.*)$/) {
#        $node = $1;
#        $self->inline($2);
#        $node =~ s/''/'/g;
#    }
#    else {
#        $self->die('YAML_PARSE_ERR_BAD_SINGLE');
#    }
#    return $node;
#}
#
#sub _parse_inline_simple {
#    my $self = shift;
#    my $value;
#    if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
#        $value = $1;
#        substr($self->{inline}, 0, length($1)) = '';
#    }
#    else {
#        $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
#    }
#    return $value;
#}
#
#sub _parse_implicit {
#    my $self = shift;
#    my ($value) = @_;
#    $value =~ s/\s*$//;
#    return $value if $value eq '';
#    return undef if $value =~ /^~$/;
#    return $value
#      unless $value =~ /^[\@\`]/ or
#             $value =~ /^[\-\?]\s/;
#    $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
#}
#
#sub _parse_unfold {
#    my $self = shift;
#    my ($chomp) = @_;
#    my $node = '';
#    my $space = 0;
#    while (not $self->done and $self->indent == $self->offset->[$self->level]) {
#        $node .= $self->content. "\n";
#        $self->_parse_next_line(LEAF);
#    }
#    $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
#    $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
#    $node =~ s/\n*\Z// unless $chomp eq '+';
#    $node .= "\n" unless $chomp;
#    return $node;
#}
#
#sub _parse_block {
#    my $self = shift;
#    my ($chomp) = @_;
#    my $node = '';
#    while (not $self->done and $self->indent == $self->offset->[$self->level]) {
#        $node .= $self->content . "\n";
#        $self->_parse_next_line(LEAF);
#    }
#    return $node if '+' eq $chomp;
#    $node =~ s/\n*\Z/\n/;
#    $node =~ s/\n\Z// if $chomp eq '-';
#    return $node;
#}
#
#sub _parse_throwaway_comments {
#    my $self = shift;
#    while (@{$self->lines} and
#           $self->lines->[0] =~ m{^\s*(\#|$)}
#          ) {
#        shift @{$self->lines};
#        $self->{line}++;
#    }
#    $self->eos($self->{done} = not @{$self->lines});
#}
#
#sub _parse_next_line {
#    my $self = shift;
#    my ($type) = @_;
#    my $level = $self->level;
#    my $offset = $self->offset->[$level];
#    $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
#    shift @{$self->lines};
#    $self->eos($self->{done} = not @{$self->lines});
#    if ($self->eos) {
#        $self->offset->[$level + 1] = $offset + 1;
#        return;
#    }
#    $self->{line}++;
#
#    if ($self->preface =~
#        qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
#       ) {
#        $self->die('YAML_PARSE_ERR_ZERO_INDENT')
#          if length($1) and $1 == 0;
#        $type = LEAF;
#        if (length($1)) {
#            $self->offset->[$level + 1] = $offset + $1;
#        }
#        else {
#            while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
#                $self->lines->[0] =~ /^( *)/;
#                last unless length($1) <= $offset;
#                shift @{$self->lines};
#                $self->{line}++;
#            }
#            $self->eos($self->{done} = not @{$self->lines});
#            return if $self->eos;
#            if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
#                $self->offset->[$level+1] = length($1);
#            }
#            else {
#                $self->offset->[$level+1] = $offset + 1;
#            }
#        }
#        $offset = $self->offset->[++$level];
#    }
#    elsif ($type == COLLECTION and
#           $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
#        $self->_parse_throwaway_comments();
#        if ($self->eos) {
#            $self->offset->[$level+1] = $offset + 1;
#            return;
#        }
#        else {
#            $self->lines->[0] =~ /^( *)\S/ or
#                $self->die('YAML_PARSE_ERR_NONSPACE_INDENTATION');
#            if (length($1) > $offset) {
#                $self->offset->[$level+1] = length($1);
#            }
#            else {
#                $self->offset->[$level+1] = $offset + 1;
#            }
#        }
#        $offset = $self->offset->[++$level];
#    }
#
#    if ($type == LEAF) {
#        while (@{$self->lines} and
#               $self->lines->[0] =~ m{^( *)(\#)} and
#               length($1) < $offset
#              ) {
#            shift @{$self->lines};
#            $self->{line}++;
#        }
#        $self->eos($self->{done} = not @{$self->lines});
#    }
#    else {
#        $self->_parse_throwaway_comments();
#    }
#    return if $self->eos;
#
#    if ($self->lines->[0] =~ /^---(\s|$)/) {
#        $self->done(1);
#        return;
#    }
#    if ($type == LEAF and
#        $self->lines->[0] =~ /^ {$offset}(.*)$/
#       ) {
#        $self->indent($offset);
#        $self->content($1);
#    }
#    elsif ($self->lines->[0] =~ /^\s*$/) {
#        $self->indent($offset);
#        $self->content('');
#    }
#    else {
#        $self->lines->[0] =~ /^( *)(\S.*)$/;
#        while ($self->offset->[$level] > length($1)) {
#            $level--;
#        }
#        $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION')
#          if $self->offset->[$level] != length($1);
#        $self->indent(length($1));
#        $self->content($2);
#    }
#    $self->die('YAML_PARSE_ERR_INDENTATION')
#      if $self->indent - $offset > 1;
#}
#
#
#my %unescapes = (
#   0 => "\x00",
#   a => "\x07",
#   t => "\x09",
#   n => "\x0a",
#   'v' => "\x0b", 
#   f => "\x0c",
#   r => "\x0d",
#   e => "\x1b",
#   '\\' => '\\',
#  );
#
#sub _unescape {
#    my $self = shift;
#    my ($node) = @_;
#    $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
#              (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
#    return $node;
#}
#
#1;
### YAML/Old/Loader/Base.pm ###
#package YAML::Old::Loader::Base;
#
#use YAML::Old::Mo;
#
#has load_code     => default => sub {0};
#has preserve      => default => sub {0};
#has stream        => default => sub {''};
#has document      => default => sub {0};
#has line          => default => sub {0};
#has documents     => default => sub {[]};
#has lines         => default => sub {[]};
#has eos           => default => sub {0};
#has done          => default => sub {0};
#has anchor2node   => default => sub {{}};
#has level         => default => sub {0};
#has offset        => default => sub {[]};
#has preface       => default => sub {''};
#has content       => default => sub {''};
#has indent        => default => sub {0};
#has major_version => default => sub {0};
#has minor_version => default => sub {0};
#has inline        => default => sub {''};
#has numify        => default => sub {0};
#
#sub set_global_options {
#    my $self = shift;
#    $self->load_code($YAML::LoadCode || $YAML::UseCode)
#      if defined $YAML::LoadCode or defined $YAML::UseCode;
#    $self->preserve($YAML::Preserve) if defined $YAML::Preserve;
#    $self->numify($YAML::Numify) if defined $YAML::Numify;
#}
#
#sub load {
#    die 'load() not implemented in this class.';
#}
#
#1;
### YAML/Old/Marshall.pm ###
#use strict; use warnings;
#package YAML::Old::Marshall;
#
#use YAML::Old::Node ();
#
#sub import {
#    my $class = shift;
#    no strict 'refs';
#    my $package = caller;
#    unless (grep { $_ eq $class} @{$package . '::ISA'}) {
#        push @{$package . '::ISA'}, $class;
#    }
#
#    my $tag = shift;
#    if ( $tag ) {
#        no warnings 'once';
#        $YAML::TagClass->{$tag} = $package;
#        ${$package . "::YamlTag"} = $tag;
#    }
#}
#
#sub yaml_dump {
#    my $self = shift;
#    no strict 'refs';
#    my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
#    $self->yaml_node($self, $tag);
#}
#
#sub yaml_load {
#    my ($class, $node) = @_;
#    if (my $ynode = $class->yaml_ynode($node)) {
#        $node = $ynode->{NODE};
#    }
#    bless $node, $class;
#}
#
#sub yaml_node {
#    shift;
#    YAML::Old::Node->new(@_);
#}
#
#sub yaml_ynode {
#    shift;
#    YAML::Old::Node::ynode(@_);
#}
#
#1;
### YAML/Old/Mo.pm ###
#package YAML::Old::Mo;
#no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{my$c=shift;my$s=bless{@_},$c;my%n=%{$c.'::'.':E'};map{$s->{$_}=$n{$_}->()if!exists$s->{$_}}keys%n;$s};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};@_=(default,@_)if!($#_%2);$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=\&{$P.$b}and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;exists$a{default}or return$m;my($d,$r)=$a{default};my$g='HASH'eq($r=ref$d)?sub{+{%$d}}:'ARRAY'eq$r?sub{[@$d]}:'CODE'eq$r?$d:sub{$d};my$i=exists$a{lazy}?$a{lazy}:!${$P.':N'};$i or ${$P.':E'}{$n}=$g and return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$g->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not$_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
#
#our $DumperModule = 'Data::Dumper';
#
#my ($_new_error, $_info, $_scalar_info);
#
#no strict 'refs';
#*{$M.'Object::die'} = sub {
#    my $self = shift;
#    my $error = $self->$_new_error(@_);
#    $error->type('Error');
#    Carp::croak($error->format_message);
#};
#
#*{$M.'Object::warn'} = sub {
#    my $self = shift;
#    return unless $^W;
#    my $error = $self->$_new_error(@_);
#    $error->type('Warning');
#    Carp::cluck($error->format_message);
#};
#
#*{$M.'Object::node_info'} = sub {
#    my $self = shift;
#    my $stringify = $_[1] || 0;
#    my ($class, $type, $id) =
#        ref($_[0])
#        ? $stringify
#          ? &$_info("$_[0]")
#          : do {
#              require overload;
#              my @info = &$_info(overload::StrVal($_[0]));
#              if (ref($_[0]) eq 'Regexp') {
#                  @info[0, 1] = (undef, 'REGEXP');
#              }
#              @info;
#          }
#        : &$_scalar_info($_[0]);
#    ($class, $type, $id) = &$_scalar_info("$_[0]")
#        unless $id;
#    return wantarray ? ($class, $type, $id) : $id;
#};
#
#$_info = sub {
#    return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
#};
#
#$_scalar_info = sub {
#    my $id = 'undef';
#    if (defined $_[0]) {
#        \$_[0] =~ /\((\w+)\)$/o or CORE::die();
#        $id = "$1-S";
#    }
#    return (undef, undef, $id);
#};
#
#$_new_error = sub {
#    require Carp;
#    my $self = shift;
#    require YAML::Old::Error;
#
#    my $code = shift || 'unknown error';
#    my $error = YAML::Old::Error->new(code => $code);
#    $error->line($self->line) if $self->can('line');
#    $error->document($self->document) if $self->can('document');
#    $error->arguments([@_]);
#    return $error;
#};
#
#1;
### YAML/Old/Node.pm ###
#use strict; use warnings;
#package YAML::Old::Node;
#
#use YAML::Old::Tag;
#require YAML::Old::Mo;
#
#use Exporter;
#our @ISA     = qw(Exporter YAML::Old::Mo::Object);
#our @EXPORT  = qw(ynode);
#
#sub ynode {
#    my $self;
#    if (ref($_[0]) eq 'HASH') {
#        $self = tied(%{$_[0]});
#    }
#    elsif (ref($_[0]) eq 'ARRAY') {
#        $self = tied(@{$_[0]});
#    }
#    elsif (ref(\$_[0]) eq 'GLOB') {
#        $self = tied(*{$_[0]});
#    }
#    else {
#        $self = tied($_[0]);
#    }
#    return (ref($self) =~ /^yaml_/) ? $self : undef;
#}
#
#sub new {
#    my ($class, $node, $tag) = @_;
#    my $self;
#    $self->{NODE} = $node;
#    my (undef, $type) = YAML::Old::Mo::Object->node_info($node);
#    $self->{KIND} = (not defined $type) ? 'scalar' :
#                    ($type eq 'ARRAY') ? 'sequence' :
#                    ($type eq 'HASH') ? 'mapping' :
#                    $class->die("Can't create YAML::Old::Node from '$type'");
#    tag($self, ($tag || ''));
#    if ($self->{KIND} eq 'scalar') {
#        yaml_scalar->new($self, $_[1]);
#        return \ $_[1];
#    }
#    my $package = "yaml_" . $self->{KIND};
#    $package->new($self)
#}
#
#sub node { $_->{NODE} }
#sub kind { $_->{KIND} }
#sub tag {
#    my ($self, $value) = @_;
#    if (defined $value) {
#               $self->{TAG} = YAML::Old::Tag->new($value);
#        return $self;
#    }
#    else {
#       return $self->{TAG};
#    }
#}
#sub keys {
#    my ($self, $value) = @_;
#    if (defined $value) {
#               $self->{KEYS} = $value;
#        return $self;
#    }
#    else {
#       return $self->{KEYS};
#    }
#}
#
#package yaml_scalar;
#
#@yaml_scalar::ISA = qw(YAML::Old::Node);
#
#sub new {
#    my ($class, $self) = @_;
#    tie $_[2], $class, $self;
#}
#
#sub TIESCALAR {
#    my ($class, $self) = @_;
#    bless $self, $class;
#    $self
#}
#
#sub FETCH {
#    my ($self) = @_;
#    $self->{NODE}
#}
#
#sub STORE {
#    my ($self, $value) = @_;
#    $self->{NODE} = $value
#}
#
#package yaml_sequence;
#
#@yaml_sequence::ISA = qw(YAML::Old::Node);
#
#sub new {
#    my ($class, $self) = @_;
#    my $new;
#    tie @$new, $class, $self;
#    $new
#}
#
#sub TIEARRAY {
#    my ($class, $self) = @_;
#    bless $self, $class
#}
#
#sub FETCHSIZE {
#    my ($self) = @_;
#    scalar @{$self->{NODE}};
#}
#
#sub FETCH {
#    my ($self, $index) = @_;
#    $self->{NODE}[$index]
#}
#
#sub STORE {
#    my ($self, $index, $value) = @_;
#    $self->{NODE}[$index] = $value
#}
#
#sub undone {
#    die "Not implemented yet"; 
#}
#
#*STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
#*STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS =
#*undone; 
#
#package yaml_mapping;
#
#@yaml_mapping::ISA = qw(YAML::Old::Node);
#
#sub new {
#    my ($class, $self) = @_;
#    @{$self->{KEYS}} = sort keys %{$self->{NODE}};
#    my $new;
#    tie %$new, $class, $self;
#    $new
#}
#
#sub TIEHASH {
#    my ($class, $self) = @_;
#    bless $self, $class
#}
#
#sub FETCH {
#    my ($self, $key) = @_;
#    if (exists $self->{NODE}{$key}) {
#        return (grep {$_ eq $key} @{$self->{KEYS}})
#               ? $self->{NODE}{$key} : undef;
#    }
#    return $self->{HASH}{$key};
#}
#
#sub STORE {
#    my ($self, $key, $value) = @_;
#    if (exists $self->{NODE}{$key}) {
#        $self->{NODE}{$key} = $value;
#    }
#    elsif (exists $self->{HASH}{$key}) {
#        $self->{HASH}{$key} = $value;
#    }
#    else {
#        if (not grep {$_ eq $key} @{$self->{KEYS}}) {
#            push(@{$self->{KEYS}}, $key);
#        }
#        $self->{HASH}{$key} = $value;
#    }
#    $value
#}
#
#sub DELETE {
#    my ($self, $key) = @_;
#    my $return;
#    if (exists $self->{NODE}{$key}) {
#        $return = $self->{NODE}{$key};
#    }
#    elsif (exists $self->{HASH}{$key}) {
#        $return = delete $self->{NODE}{$key};
#    }
#    for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
#        if ($self->{KEYS}[$i] eq $key) {
#            splice(@{$self->{KEYS}}, $i, 1);
#        }
#    }
#    return $return;
#}
#
#sub CLEAR {
#    my ($self) = @_;
#    @{$self->{KEYS}} = ();
#    %{$self->{HASH}} = ();
#}
#
#sub FIRSTKEY {
#    my ($self) = @_;
#    $self->{ITER} = 0;
#    $self->{KEYS}[0]
#}
#
#sub NEXTKEY {
#    my ($self) = @_;
#    $self->{KEYS}[++$self->{ITER}]
#}
#
#sub EXISTS {
#    my ($self, $key) = @_;
#    exists $self->{NODE}{$key}
#}
#
#1;
### YAML/Old/Tag.pm ###
#use strict; use warnings;
#package YAML::Old::Tag;
#
#use overload '""' => sub { ${$_[0]} };
#
#sub new {
#    my ($class, $self) = @_;
#    bless \$self, $class
#}
#
#sub short {
#    ${$_[0]}
#}
#
#sub canonical {
#    ${$_[0]}
#}
#
#1;
### YAML/Old/Types.pm ###
#package YAML::Old::Types;
#
#use YAML::Old::Mo;
#use YAML::Old::Node;
#
#package YAML::Old::Type::blessed;
#
#use YAML::Old::Mo; 
#
#sub yaml_dump {
#    my $self = shift;
#    my ($value) = @_;
#    my ($class, $type) = YAML::Old::Mo::Object->node_info($value);
#    no strict 'refs';
#    my $kind = lc($type) . ':';
#    my $tag = ${$class . '::ClassTag'} ||
#              "!perl/$kind$class";
#    if ($type eq 'REF') {
#        YAML::Old::Node->new(
#            {(&YAML::Old::VALUE, ${$_[0]})}, $tag
#        );
#    }
#    elsif ($type eq 'SCALAR') {
#        $_[1] = $$value;
#        YAML::Old::Node->new($_[1], $tag);
#    }
#    elsif ($type eq 'GLOB') {
#        return YAML::Old::Type::glob->yaml_dump($value, $tag);
#    } else {
#        YAML::Old::Node->new($value, $tag);
#    }
#}
#
#package YAML::Old::Type::undef;
#
#sub yaml_dump {
#    my $self = shift;
#}
#
#sub yaml_load {
#    my $self = shift;
#}
#
#package YAML::Old::Type::glob;
#
#sub yaml_dump {
#    my $self = shift;
#    my $tag = pop @_ if 2==@_;
#
#    $tag = '!perl/glob:' unless defined $tag;
#    my $ynode = YAML::Old::Node->new({}, $tag);
#    for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
#        my $value = *{$_[0]}{$type};
#        $value = $$value if $type eq 'SCALAR';
#        if (defined $value) {
#            if ($type eq 'IO') {
#                my @stats = qw(device inode mode links uid gid rdev size
#                               atime mtime ctime blksize blocks);
#                undef $value;
#                $value->{stat} = YAML::Old::Node->new({});
#                if ($value->{fileno} = fileno(*{$_[0]})) {
#                    local $^W;
#                    map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
#                    $value->{tell} = tell(*{$_[0]});
#                }
#            }
#            $ynode->{$type} = $value;
#        }
#    }
#    return $ynode;
#}
#
#sub yaml_load {
#    my $self = shift;
#    my ($node, $class, $loader) = @_;
#    my ($name, $package);
#    if (defined $node->{NAME}) {
#        $name = $node->{NAME};
#        delete $node->{NAME};
#    }
#    else {
#        $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
#        return undef;
#    }
#    if (defined $node->{PACKAGE}) {
#        $package = $node->{PACKAGE};
#        delete $node->{PACKAGE};
#    }
#    else {
#        $package = 'main';
#    }
#    no strict 'refs';
#    if (exists $node->{SCALAR}) {
#        *{"${package}::$name"} = \$node->{SCALAR};
#        delete $node->{SCALAR};
#    }
#    for my $elem (qw(ARRAY HASH CODE IO)) {
#        if (exists $node->{$elem}) {
#            if ($elem eq 'IO') {
#                $loader->warn('YAML_LOAD_WARN_GLOB_IO');
#                delete $node->{IO};
#                next;
#            }
#            *{"${package}::$name"} = $node->{$elem};
#            delete $node->{$elem};
#        }
#    }
#    for my $elem (sort keys %$node) {
#        $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
#    }
#    return *{"${package}::$name"};
#}
#
#package YAML::Old::Type::code;
#
#my $dummy_warned = 0;
#my $default = '{ "DUMMY" }';
#
#sub yaml_dump {
#    my $self = shift;
#    my $code;
#    my ($dumpflag, $value) = @_;
#    my ($class, $type) = YAML::Old::Mo::Object->node_info($value);
#    my $tag = "!perl/code";
#    $tag .= ":$class" if defined $class;
#    if (not $dumpflag) {
#        $code = $default;
#    }
#    else {
#        bless $value, "CODE" if $class;
#        eval { require B::Deparse };
#        return if $@;
#        my $deparse = B::Deparse->new();
#        eval {
#            local $^W = 0;
#            $code = $deparse->coderef2text($value);
#        };
#        if ($@) {
#            warn YAML::Old::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
#            $code = $default;
#        }
#        bless $value, $class if $class;
#        chomp $code;
#        $code .= "\n";
#    }
#    $_[2] = $code;
#    YAML::Old::Node->new($_[2], $tag);
#}
#
#sub yaml_load {
#    my $self = shift;
#    my ($node, $class, $loader) = @_;
#    if ($loader->load_code) {
#        my $code = eval "package main; sub $node";
#        if ($@) {
#            $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
#            return sub {};
#        }
#        else {
#            CORE::bless $code, $class if $class;
#            return $code;
#        }
#    }
#    else {
#        return CORE::bless sub {}, $class if $class;
#        return sub {};
#    }
#}
#
#package YAML::Old::Type::ref;
#
#sub yaml_dump {
#    my $self = shift;
#    YAML::Old::Node->new({(&YAML::Old::VALUE, ${$_[0]})}, '!perl/ref')
#}
#
#sub yaml_load {
#    my $self = shift;
#    my ($node, $class, $loader) = @_;
#    $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
#      unless exists $node->{&YAML::Old::VALUE};
#    return \$node->{&YAML::Old::VALUE};
#}
#
#package YAML::Old::Type::regexp;
#
#sub yaml_dump {
#    die "YAML::Old::Type::regexp::yaml_dump not currently implemented";
#}
#
#use constant _QR_TYPES => {
#    '' => sub { qr{$_[0]} },
#    x => sub { qr{$_[0]}x },
#    i => sub { qr{$_[0]}i },
#    s => sub { qr{$_[0]}s },
#    m => sub { qr{$_[0]}m },
#    ix => sub { qr{$_[0]}ix },
#    sx => sub { qr{$_[0]}sx },
#    mx => sub { qr{$_[0]}mx },
#    si => sub { qr{$_[0]}si },
#    mi => sub { qr{$_[0]}mi },
#    ms => sub { qr{$_[0]}sm },
#    six => sub { qr{$_[0]}six },
#    mix => sub { qr{$_[0]}mix },
#    msx => sub { qr{$_[0]}msx },
#    msi => sub { qr{$_[0]}msi },
#    msix => sub { qr{$_[0]}msix },
#};
#
#sub yaml_load {
#    my $self = shift;
#    my ($node, $class) = @_;
#    return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
#    my ($flags, $re) = ($1, $2);
#    $flags =~ s/-.*//;
#    $flags =~ s/^\^//;
#    my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
#    my $qr = &$sub($re);
#    bless $qr, $class if length $class;
#    return $qr;
#}
#
#1;
### experimental.pm ###
#package experimental;
#$experimental::VERSION = '0.016';
#use strict;
#use warnings;
#use version ();
#
#use feature ();
#use Carp qw/croak carp/;
#
#my %warnings = map { $_ => 1 } grep { /^experimental::/ } keys %warnings::Offsets;
#my %features = map { $_ => 1 } $] > 5.015006 ? keys %feature::feature : do {
#	my @features;
#	if ($] >= 5.010) {
#		push @features, qw/switch say state/;
#		push @features, 'unicode_strings' if $] > 5.011002;
#	}
#	@features;
#};
#
#my %min_version = (
#	array_base      => '5',
#	autoderef       => '5.14.0',
#	bitwise         => '5.22.0',
#	current_sub     => '5.16.0',
#	evalbytes       => '5.16.0',
#	fc              => '5.16.0',
#	lexical_topic   => '5.10.0',
#	lexical_subs    => '5.18.0',
#	postderef       => '5.20.0',
#	postderef_qq    => '5.20.0',
#	refaliasing     => '5.22.0',
#	regex_sets      => '5.18.0',
#	say             => '5.10.0',
#	smartmatch      => '5.10.0',
#	signatures      => '5.20.0',
#	state           => '5.10.0',
#	switch          => '5.10.0',
#	unicode_eval    => '5.16.0',
#	unicode_strings => '5.12.0',
#);
#my %max_version = (
#	lexical_topic   => '5.23.4',
#);
#
#$_ = version->new($_) for values %min_version;
#$_ = version->new($_) for values %max_version;
#
#my %additional = (
#	postderef  => ['postderef_qq'],
#	switch     => ['smartmatch'],
#);
#
#sub _enable {
#	my $pragma = shift;
#	if ($warnings{"experimental::$pragma"}) {
#		warnings->unimport("experimental::$pragma");
#		feature->import($pragma) if exists $features{$pragma};
#		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
#	}
#	elsif ($features{$pragma}) {
#		feature->import($pragma);
#		_enable(@{ $additional{$pragma} }) if $additional{$pragma};
#	}
#	elsif (not exists $min_version{$pragma}) {
#		croak "Can't enable unknown feature $pragma";
#	}
#	elsif ($] < $min_version{$pragma}) {
#		my $stable = $min_version{$pragma};
#		if ($stable->{version}[1] % 2) {
#			$stable = version->new(
#				"5.".($stable->{version}[1]+1).'.0'
#			);
#		}
#		croak "Need perl $stable or later for feature $pragma";
#	}
#	elsif ($] >= ($max_version{$pragma} || 7)) {
#		croak "Experimental feature $pragma has been removed from perl in version $max_version{$pragma}";
#	}
#}
#
#sub import {
#	my ($self, @pragmas) = @_;
#
#	for my $pragma (@pragmas) {
#		_enable($pragma);
#	}
#	return;
#}
#
#sub _disable {
#	my $pragma = shift;
#	if ($warnings{"experimental::$pragma"}) {
#		warnings->import("experimental::$pragma");
#		feature->unimport($pragma) if exists $features{$pragma};
#		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
#	}
#	elsif ($features{$pragma}) {
#		feature->unimport($pragma);
#		_disable(@{ $additional{$pragma} }) if $additional{$pragma};
#	}
#	elsif (not exists $min_version{$pragma}) {
#		carp "Can't disable unknown feature $pragma, ignoring";
#	}
#}
#
#sub unimport {
#	my ($self, @pragmas) = @_;
#
#	for my $pragma (@pragmas) {
#		_disable($pragma);
#	}
#	return;
#}
#
#1;
#
#
#__END__
#
### subroutines.pm ###
#package subroutines;
#
#our $DATE = '2018-12-15'; 
#our $VERSION = '0.001'; 
#
#
#sub _package_exists {
#    my $pkg = shift;
#
#    if ($pkg =~ s/::(\w+)\z//) {
#        return !!${$pkg . "::"}{$1 . "::"};
#    } else {
#        return !!$::{$pkg . "::"};
#    }
#}
#
#sub import {
#    my $class = shift;
#    my $noreq = $_[0] eq '-norequire' ? shift : 0;
#    my $orig  = shift;
#
#    my $caller = caller();
#
#    unless ($noreq) {
#        (my $orig_pm = "$orig.pm") =~ s!::!/!g;
#        require $orig_pm;
#    }
#
#    die "Cannot use subroutines from '$orig': package does not exist" unless
#        _package_exists($orig);
#
#    my $symtbl = \%{$orig . "::"};
#
#    while (my ($k, $v) = each %$symtbl) {
#        next if $k =~ /::$/; 
#        if ("$v" !~ /^\*/) {
#            *{"$caller\::$k"} = \*{$orig . "::"};
#        } elsif (defined *$v{CODE}) {
#            *{"$caller\::$k"} = *$v{CODE};
#        }
#    }
#}
#
#1;
#
#__END__
#
