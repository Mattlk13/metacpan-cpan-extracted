SYNOPSIS

     use File::Flock::Retry;
    
     # try to acquire exclusive lock. if fail to acquire lock within 60s, die.
     my $lock = File::Flock::Retry->lock($file);
    
     # explicitly unlock
     $lock->release;
    
     # automatically unlock if object is DESTROY-ed.
     undef $lock;

DESCRIPTION

    This is yet another flock module. It is a more lightweight alternative
    to File::Flock with some other differences:

      * OO interface only

      * Autoretry (by default for 60s) when trying to acquire lock

      I prefer this approach to blocking/waiting indefinitely or failing
      immediately.

METHODS

 $lock = File::Flock::Retry->lock($path, \%opts)

    Attempt to acquire an exclusive lock on $path. $path will be created if
    not already exists. If $path is already locked by another process, will
    retry every second for a number of seconds (by default 60). Will die if
    failed to acquire lock after all retries.

    Will automatically unlock if $lock goes out of scope. Upon unlock, will
    remove $path if it was created and is still empty (this behavior is the
    same as File::Flock).

    Available options:

      * retries => int (default: 60)

      Number of retries (equals number of seconds, since retry is done
      every second).

      * shared => bool (default: 0)

      By default, an exclusive lock (LOCK_EX) is attempted. However, if
      this option is set to true, a shared lock (LOCK_SH) is attempted.

 $lock->unlock

    Unlock.

 $lock->release

    Synonym for unlock().

CAVEATS

    Not yet tested on Windows. Some filesystems do not support inode?

SEE ALSO

    File::Flock

    File::Flock::Tiny which is also tiny, but does not have the autoremove
    and autoretry capability which I want. See also:
    https://github.com/trinitum/perl-File-Flock-Tiny/issues/1

    flock() Perl function.

