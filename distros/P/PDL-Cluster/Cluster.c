/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.31 from the
 * contents of Cluster.xs. Do not edit this file, edit Cluster.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Cluster.xs"

/*
 * THIS FILE WAS GENERATED BY PDL::PP! Do not modify!
 */

#define PDL_COMMENT(comment)
PDL_COMMENT("This preprocessor symbol is used to add commentary in the PDL  ")
PDL_COMMENT("autogenerated code. Normally, one would use typical C-style    ")
PDL_COMMENT("multiline comments (i.e. /* comment */). However, because such ")
PDL_COMMENT("comments do not nest, it's not possible for PDL::PP users to   ")
PDL_COMMENT("comment-out sections of code using multiline comments, as is   ")
PDL_COMMENT("often the practice when debugging, for example. So, when you   ")
PDL_COMMENT("see something like this:                                       ")
PDL_COMMENT("                                                               ")
                PDL_COMMENT("Memory access")
PDL_COMMENT("                                                               ")
PDL_COMMENT("just think of it as a C multiline comment like:                ")
PDL_COMMENT("                                                               ")
PDL_COMMENT("   /* Memory access */                                         ")

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "pdl.h"
#include "pdlcore.h"
static Core* PDL; PDL_COMMENT("Structure hold core C functions")
static int __pdl_debugging = 0;
static int __pdl_boundscheck = 0;
static SV* CoreSV;       PDL_COMMENT("Gets pointer to perl var holding core structure")

#if ! 1
# define PP_INDTERM(max, at) at
#else
# define PP_INDTERM(max, at) (__pdl_boundscheck? PDL->safe_indterm(max,at, __FILE__, __LINE__) : at)
#endif

#include "cluster.h"

//#define CDEBUG 1
//#undef CDEBUG

void print_pp_dbl(int nrows, int ncols, double **pp) {
  int i,j;
  for (i=0; i<nrows; i++) {
    printf("  %d:[ ", i);
    for (j=0; j<ncols; j++) {
      printf("%d=%lf ", j, pp[i][j]);
    }
    printf("]\n");
  }
}
static
void **pp_alloc(int nrows)
{
  return ((void **)malloc(nrows*sizeof(void**)));
}
static
double **p2pp_dbl(int nrows, int ncols, double *p, double **matrix)
{
  int i;
  if (!(p && nrows && ncols)) return NULL;
  if (!matrix) matrix = (double **)pp_alloc(nrows);
  for (i=0; i < nrows; i++) {
    matrix[i] = p + (i*ncols);
#ifdef CDEBUG
    printf("p2pp_dbl(nr=%d,nc=%d,p=%p) : (p+%d*%d)=%p\n", nrows,ncols,p, i,ncols,matrix[i]);
#endif
  }
  return matrix;
}
int **p2pp_int(int nrows, int ncols, int *p, int **matrix)
{
  int i;
  if (!(p && nrows && ncols)) return NULL;
  if (!matrix) matrix = (int **)pp_alloc(nrows);
  for (i=0; i < nrows; i++) {
    matrix[i] = p + (i*ncols);
  }
  return matrix;
}
static
double **p2pp_dbl_ragged(int nrows, int ncols, double *p, double **matrix)
{
  int i;
  if (!(p && nrows && ncols)) return NULL;
  if (!matrix) matrix = (double **)pp_alloc(nrows);
  for (i=0; i < nrows; i++) {
    matrix[i] = p + (i*ncols);
  }
  return matrix;
}
static
void pp2pdl_ragged_dbl(int nrows, int ncols, double **pp, double *p)
{
  int i,j;
  if (!(pp && nrows && ncols)) return;
  for (i=0; i<nrows; i++) {
    for (j=0; j<i; j++) {
      p[i*ncols+j] = pp[i][j];
      p[j*ncols+i] = pp[i][j];
    }
    p[i*ncols+i] = 0;
  }
}
static
void pp2pdl_dbl(int nrows, int ncols, double **pp, double *p)
{
  int i,j;
  if (!(pp && nrows && ncols)) return;
  for (i=0; i<nrows; i++) {
    for (j=0; j<ncols; j++) {
      p[i*ncols+j] = pp[i][j];
    }
  }
}
static
Node* p2node(int nnodes, int* tree, double *lnkdist)
{
  int i;
  Node *nod = NULL;
  if (!(nnodes && (tree || lnkdist))) return NULL;
  nod = (Node*)malloc(nnodes*sizeof(Node));
  for (i=0; i < nnodes; ++i) {
    nod[i].left     = tree    ? tree[i*2+0] : 0;
    nod[i].right    = tree    ? tree[i*2+1] : 0;
    nod[i].distance = lnkdist ? lnkdist[i] : 0;
  }
  return nod;
}

void node2p(int nnodes, Node* nod, int* tree, double *lnkdist)
{
  int i;
  if (!(nnodes && nod && (tree || lnkdist))) return;
  for (i=0; i < nnodes; ++i) {
    if (tree) {
      tree[i*2+0] = nod[i].left;
      tree[i*2+1] = nod[i].right;
    }
    if (lnkdist) {
      lnkdist[i] = nod[i].distance;
    }
  }
  return;
}

typedef struct pdl_cmean_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Indx  __inc_a_n;PDL_Indx  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_cmean_struct;

void pdl_cmean_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_cmean_struct *__privtrans = (pdl_cmean_struct *) __tr;
	
	{
	    PDL_Indx __creating[2];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_a_n = __privtrans->__inc_a_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"a","b"};
		static PDL_Indx __realdims[] = {1,0};
		static char __funcname[] = "PDL::Cluster::cmean";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cmean:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
if(!__creating[1]) {
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n = 0; else
		 __privtrans->__inc_a_n = __privtrans->pdls[0]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_cmean_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_cmean_struct *__privtrans = (pdl_cmean_struct *) __tr;
	
	{
	    pdl_cmean_struct *__copy = malloc(sizeof(pdl_cmean_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_a_n=__copy->__inc_a_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_cmean_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_cmean_struct *__privtrans = (pdl_cmean_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	a_datap += __offsp[0];
	b_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,a_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,b_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,a_datap += __tinc0_0
			,b_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_a_n = __privtrans->__inc_a_n;

(b_datap)[0] PDL_COMMENT("ACCESS()")  = mean(__privtrans->__n_size, a_datap);
}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	a_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	b_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_cmean_free(pdl_trans *__tr ) {
	int __dim;
	pdl_cmean_struct *__privtrans = (pdl_cmean_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_cmean_vtable_flags[] =
	 	{ 0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_cmean_vtable = {
		0,0, 1, 2, pdl_cmean_vtable_flags,
		pdl_cmean_redodims, pdl_cmean_readdata, NULL,
		pdl_cmean_free,NULL,NULL,pdl_cmean_copy,
		sizeof(pdl_cmean_struct),"pdl_cmean_vtable"
	 };

typedef struct pdl_cmedian_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Indx  __inc_a_n;PDL_Indx  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_cmedian_struct;

void pdl_cmedian_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_cmedian_struct *__privtrans = (pdl_cmedian_struct *) __tr;
	
	{
	    PDL_Indx __creating[2];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_a_n = __privtrans->__inc_a_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"a","b"};
		static PDL_Indx __realdims[] = {1,0};
		static char __funcname[] = "PDL::Cluster::cmedian";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cmedian:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
if(!__creating[1]) {
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_a_n = 0; else
		 __privtrans->__inc_a_n = __privtrans->pdls[0]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_cmedian_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_cmedian_struct *__privtrans = (pdl_cmedian_struct *) __tr;
	
	{
	    pdl_cmedian_struct *__copy = malloc(sizeof(pdl_cmedian_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_a_n=__copy->__inc_a_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_cmedian_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_cmedian_struct *__privtrans = (pdl_cmedian_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_D: {
	PDL_Double * a_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * a_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * b_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * b_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	a_datap += __offsp[0];
	b_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,a_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,b_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,a_datap += __tinc0_0
			,b_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_a_n = __privtrans->__inc_a_n;

(b_datap)[0] PDL_COMMENT("ACCESS()")  = median(__privtrans->__n_size, a_datap);
}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	a_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	b_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_cmedian_free(pdl_trans *__tr ) {
	int __dim;
	pdl_cmedian_struct *__privtrans = (pdl_cmedian_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;
			}
			
	}
    }
    



static char pdl_cmedian_vtable_flags[] =
	 	{ 0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_cmedian_vtable = {
		0,0, 1, 2, pdl_cmedian_vtable_flags,
		pdl_cmedian_redodims, pdl_cmedian_readdata, NULL,
		pdl_cmedian_free,NULL,NULL,pdl_cmedian_copy,
		sizeof(pdl_cmedian_struct),"pdl_cmedian_vtable"
	 };

typedef struct pdl_calculate_weights_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_oweights_d;PDL_Indx  __n_size;PDL_Indx  __d_size;
		char  *distFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_calculate_weights_struct;

void pdl_calculate_weights_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_calculate_weights_struct *__privtrans = (pdl_calculate_weights_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","cutoff","exponent","oweights"};
		static PDL_Indx __realdims[] = {2,2,1,0,0,1};
		static char __funcname[] = "PDL::Cluster::calculate_weights";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in calculate_weights:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in calculate_weights:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in calculate_weights:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in calculate_weights:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in calculate_weights:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
if(!__creating[5]) {
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in calculate_weights:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_oweights_d = 0; else
		 __privtrans->__inc_oweights_d = PDL_REPRINC(__privtrans->pdls[5],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_calculate_weights_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_calculate_weights_struct *__privtrans = (pdl_calculate_weights_struct *) __tr;
	
	{
	    pdl_calculate_weights_struct *__copy = malloc(sizeof(pdl_calculate_weights_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_oweights_d=__copy->__inc_oweights_d;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_calculate_weights_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_calculate_weights_struct *__privtrans = (pdl_calculate_weights_struct *) __tr;
	
	{
	    {register PDL_Indx __d_size = __privtrans->__d_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cutoff_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cutoff_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Double * exponent_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * exponent_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Double * oweights_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * oweights_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_oweights_d = __privtrans->__inc_oweights_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    i;
  double *owp;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	cutoff_datap += __offsp[3];
	exponent_datap += __offsp[4];
	oweights_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cutoff_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,exponent_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,oweights_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,cutoff_datap += __tinc0_3
			,exponent_datap += __tinc0_4
			,oweights_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
     owp =  calculate_weights(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                              weight_datap, transpose, *__privtrans->distFlag,
                              (cutoff_datap)[0] PDL_COMMENT("ACCESS()") , (exponent_datap)[0] PDL_COMMENT("ACCESS()") );
    if (owp)  {
      {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
        (oweights_datap)[0+(__inc_oweights_d*PP_INDTERM(__privtrans->__d_size, d))] PDL_COMMENT("ACCESS()")  = owp[d];
      }} PDL_COMMENT("Close d")
      free(owp);
    }
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cutoff_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	exponent_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	oweights_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_calculate_weights_free(pdl_trans *__tr ) {
	int __dim;
	pdl_calculate_weights_struct *__privtrans = (pdl_calculate_weights_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;
			}
			
	}
    }
    



static char pdl_calculate_weights_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_calculate_weights_vtable = {
		0,0, 5, 6, pdl_calculate_weights_vtable_flags,
		pdl_calculate_weights_redodims, pdl_calculate_weights_readdata, NULL,
		pdl_calculate_weights_free,NULL,NULL,pdl_calculate_weights_copy,
		sizeof(pdl_calculate_weights_struct),"pdl_calculate_weights_vtable"
	 };

typedef struct pdl_clusterdistance_struct {
		PDL_TRANS_START(8);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_index1_n1;PDL_Indx  __inc_index2_n2;PDL_Indx  __n1_size;PDL_Indx  __n2_size;PDL_Indx  __n_size;PDL_Indx  __d_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clusterdistance_struct;

void pdl_clusterdistance_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistance_struct *__privtrans = (pdl_clusterdistance_struct *) __tr;
	
	{
	    PDL_Indx __creating[8];
__privtrans->__n1_size = -1;
__privtrans->__n2_size = -1;
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[7]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","n1","n2","index1","index2","dist"};
		static PDL_Indx __realdims[] = {2,2,1,0,0,1,1,0};
		static char __funcname[] = "PDL::Cluster::clusterdistance";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 8
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,8,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistance:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistance:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistance:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistance:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistance:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__n1_size <= 1) __privtrans->__n1_size = 1;
   }
   if(__privtrans->__n1_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n1_size == 1)) {
      __privtrans->__n1_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n1_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistance:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));
   if(((__privtrans->pdls[6]))->ndims < 1) {
      if (((__privtrans->pdls[6]))->ndims < 1 && __privtrans->__n2_size <= 1) __privtrans->__n2_size = 1;
   }
   if(__privtrans->__n2_size == -1 || (((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__n2_size == 1)) {
      __privtrans->__n2_size = ((__privtrans->pdls[6]))->dims[0];
   } else if(((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__n2_size != ((__privtrans->pdls[6]))->dims[0]) {
      if(((__privtrans->pdls[6]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistance:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[6])));
if(!__creating[7]) {
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,7,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[7] && 
     __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[7]->hdrsv != hdrp ){
	 if( __privtrans->pdls[7]->hdrsv && __privtrans->pdls[7]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[7]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[7]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[7]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_index1_n1 = 0; else
		 __privtrans->__inc_index1_n1 = __privtrans->pdls[5]->dimincs[0];if(__privtrans->pdls[6]->ndims <= 0 || __privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_index2_n2 = 0; else
		 __privtrans->__inc_index2_n2 = __privtrans->pdls[6]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clusterdistance_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistance_struct *__privtrans = (pdl_clusterdistance_struct *) __tr;
	
	{
	    pdl_clusterdistance_struct *__copy = malloc(sizeof(pdl_clusterdistance_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_index1_n1=__copy->__inc_index1_n1;__privtrans->__inc_index2_n2=__copy->__inc_index2_n2;__copy->__n1_size=__privtrans->__n1_size;__copy->__n2_size=__privtrans->__n2_size;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clusterdistance_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistance_struct *__privtrans = (pdl_clusterdistance_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * n1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * n1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * n2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * n2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * index1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * index1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_index1_n1 = __privtrans->__inc_index1_n1;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  double retval;

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	n1_datap += __offsp[3];
	n2_datap += __offsp[4];
	index1_datap += __offsp[5];
	index2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,n1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,n2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,index1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,index2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,n1_datap += __tinc0_3
			,n2_datap += __tinc0_4
			,index1_datap += __tinc0_5
			,index2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                             weight_datap, (n1_datap)[0] PDL_COMMENT("ACCESS()") , (n2_datap)[0] PDL_COMMENT("ACCESS()") , index1_datap, index2_datap,
                             *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    (dist_datap)[0] PDL_COMMENT("ACCESS()")  = retval;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	n1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	n2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	index1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	index2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clusterdistance_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistance_struct *__privtrans = (pdl_clusterdistance_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_clusterdistance_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clusterdistance_vtable = {
		0,0, 7, 8, pdl_clusterdistance_vtable_flags,
		pdl_clusterdistance_redodims, pdl_clusterdistance_readdata, NULL,
		pdl_clusterdistance_free,NULL,NULL,pdl_clusterdistance_copy,
		sizeof(pdl_clusterdistance_struct),"pdl_clusterdistance_vtable"
	 };

typedef struct pdl_distancematrix_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_dists_n0;PDL_Indx  __inc_dists_n1;PDL_Indx  __n_size;PDL_Indx  __d_size;
		char  *distFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_distancematrix_struct;

void pdl_distancematrix_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_distancematrix_struct *__privtrans = (pdl_distancematrix_struct *) __tr;
	
	{
	    PDL_Indx __creating[4];
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","dists"};
		static PDL_Indx __realdims[] = {2,2,1,2};
		static char __funcname[] = "PDL::Cluster::distancematrix";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in distancematrix:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in distancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in distancematrix:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in distancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in distancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
if(!__creating[3]) {
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in distancematrix:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in distancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_dists_n0 = 0; else
		 __privtrans->__inc_dists_n0 = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_dists_n1 = 0; else
		 __privtrans->__inc_dists_n1 = __privtrans->pdls[3]->dimincs[1]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_distancematrix_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_distancematrix_struct *__privtrans = (pdl_distancematrix_struct *) __tr;
	
	{
	    pdl_distancematrix_struct *__copy = malloc(sizeof(pdl_distancematrix_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_dists_n0=__copy->__inc_dists_n0;__privtrans->__inc_dists_n1=__copy->__inc_dists_n1;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_distancematrix_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_distancematrix_struct *__privtrans = (pdl_distancematrix_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dists_n0 = __privtrans->__inc_dists_n0;
register PDL_Indx __inc_dists_n1 = __privtrans->__inc_dists_n1;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  double **retval;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	dists_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,dists_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,dists_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    retval = distancematrix(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                            weight_datap, *__privtrans->distFlag, transpose);
        if (!retval) barf("Cluster matrix allocation failed!");
    pp2pdl_ragged_dbl(__privtrans->__n_size, __privtrans->__n_size, retval, dists_datap);
        if (retval) free(retval);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	dists_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_distancematrix_free(pdl_trans *__tr ) {
	int __dim;
	pdl_distancematrix_struct *__privtrans = (pdl_distancematrix_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_distancematrix_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_distancematrix_vtable = {
		0,0, 3, 4, pdl_distancematrix_vtable_flags,
		pdl_distancematrix_redodims, pdl_distancematrix_readdata, NULL,
		pdl_distancematrix_free,NULL,NULL,pdl_distancematrix_copy,
		sizeof(pdl_distancematrix_struct),"pdl_distancematrix_vtable"
	 };

typedef struct pdl_getclustercentroids_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_clusterids_n;PDL_Indx  __inc_cdata_d;PDL_Indx  __inc_cdata_k;PDL_Indx  __inc_cmask_d;PDL_Indx  __inc_cmask_k;PDL_Indx  __n_size;PDL_Indx  __d_size;PDL_Indx  __k_size;
		char  *ctrMethodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_getclustercentroids_struct;

void pdl_getclustercentroids_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustercentroids_struct *__privtrans = (pdl_getclustercentroids_struct *) __tr;
	
	{
	    PDL_Indx __creating[5];
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__privtrans->__k_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","clusterids","cdata","cmask"};
		static PDL_Indx __realdims[] = {2,2,1,2,2};
		static char __funcname[] = "PDL::Cluster::getclustercentroids";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
if(!__creating[3]) {
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;dims[1] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 2) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[4]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[4]))->dims[1];
   } else if(((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[4]))->dims[1]) {
      if(((__privtrans->pdls[4]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclustercentroids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;dims[1] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_cdata_d = 0; else
		 __privtrans->__inc_cdata_d = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_cdata_k = 0; else
		 __privtrans->__inc_cdata_k = __privtrans->pdls[3]->dimincs[1];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_cmask_d = 0; else
		 __privtrans->__inc_cmask_d = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 1 || __privtrans->pdls[4]->dims[1] <= 1)
		  __privtrans->__inc_cmask_k = 0; else
		 __privtrans->__inc_cmask_k = __privtrans->pdls[4]->dimincs[1]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_getclustercentroids_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustercentroids_struct *__privtrans = (pdl_getclustercentroids_struct *) __tr;
	
	{
	    pdl_getclustercentroids_struct *__copy = malloc(sizeof(pdl_getclustercentroids_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->ctrMethodFlag) = malloc(strlen(__privtrans->ctrMethodFlag)+1); strcpy(__copy->ctrMethodFlag,__privtrans->ctrMethodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__privtrans->__inc_cdata_d=__copy->__inc_cdata_d;__privtrans->__inc_cdata_k=__copy->__inc_cdata_k;__privtrans->__inc_cmask_d=__copy->__inc_cmask_d;__privtrans->__inc_cmask_k=__copy->__inc_cmask_k;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;__copy->__k_size=__privtrans->__k_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_getclustercentroids_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustercentroids_struct *__privtrans = (pdl_getclustercentroids_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);

  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);

    getclustercentroids(__privtrans->__k_size, __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                        clusterids_datap, cdatapp, cmaskpp, transpose, *__privtrans->ctrMethodFlag);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_getclustercentroids_free(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustercentroids_struct *__privtrans = (pdl_getclustercentroids_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->ctrMethodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_getclustercentroids_vtable_flags[] =
	 	{ 0,0,0,0,0};
	 pdl_transvtable pdl_getclustercentroids_vtable = {
		0,0, 3, 5, pdl_getclustercentroids_vtable_flags,
		pdl_getclustercentroids_redodims, pdl_getclustercentroids_readdata, NULL,
		pdl_getclustercentroids_free,NULL,NULL,pdl_getclustercentroids_copy,
		sizeof(pdl_getclustercentroids_struct),"pdl_getclustercentroids_vtable"
	 };

typedef struct pdl_getclustermedoids_struct {
		PDL_TRANS_START(4);
		pdl_thread  __pdlthread;PDL_Indx  __inc_distance_n0;PDL_Indx  __inc_distance_n1;PDL_Indx  __inc_clusterids_n;PDL_Indx  __inc_centroids_k;PDL_Indx  __inc_errors_k;PDL_Indx  __n_size;PDL_Indx  __k_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_getclustermedoids_struct;

void pdl_getclustermedoids_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustermedoids_struct *__privtrans = (pdl_getclustermedoids_struct *) __tr;
	
	{
	    PDL_Indx __creating[4];
__privtrans->__n_size = -1;
__privtrans->__k_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"distance","clusterids","centroids","errors"};
		static PDL_Indx __realdims[] = {2,1,1,1};
		static char __funcname[] = "PDL::Cluster::getclustermedoids";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 4
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,4,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustermedoids:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclustermedoids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustermedoids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustermedoids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}if(!__creating[3]) {
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclustermedoids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_distance_n0 = 0; else
		 __privtrans->__inc_distance_n0 = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_distance_n1 = 0; else
		 __privtrans->__inc_distance_n1 = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_centroids_k = 0; else
		 __privtrans->__inc_centroids_k = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_errors_k = 0; else
		 __privtrans->__inc_errors_k = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_getclustermedoids_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustermedoids_struct *__privtrans = (pdl_getclustermedoids_struct *) __tr;
	
	{
	    pdl_getclustermedoids_struct *__copy = malloc(sizeof(pdl_getclustermedoids_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_distance_n0=__copy->__inc_distance_n0;__privtrans->__inc_distance_n1=__copy->__inc_distance_n1;__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__privtrans->__inc_centroids_k=__copy->__inc_centroids_k;__privtrans->__inc_errors_k=__copy->__inc_errors_k;__copy->__n_size=__privtrans->__n_size;__copy->__k_size=__privtrans->__k_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_getclustermedoids_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustermedoids_struct *__privtrans = (pdl_getclustermedoids_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_S: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_US: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_L: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_IND: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_LL: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_F: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_D: {
	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * centroids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * centroids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * errors_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * errors_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

{register PDL_Indx __inc_centroids_k = __privtrans->__inc_centroids_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;
register PDL_Indx __inc_errors_k = __privtrans->__inc_errors_k;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	distance_datap += __offsp[0];
	clusterids_datap += __offsp[1];
	centroids_datap += __offsp[2];
	errors_datap += __offsp[3];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,distance_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clusterids_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,centroids_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,errors_datap += __tinc1_3 - __tinc0_3 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,distance_datap += __tinc0_0
			,clusterids_datap += __tinc0_1
			,centroids_datap += __tinc0_2
			,errors_datap += __tinc0_3
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    getclustermedoids(__privtrans->__k_size, __privtrans->__n_size, distpp,
                      clusterids_datap, centroids_datap, errors_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	distance_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clusterids_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	centroids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	errors_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (distpp) free(distpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_getclustermedoids_free(pdl_trans *__tr ) {
	int __dim;
	pdl_getclustermedoids_struct *__privtrans = (pdl_getclustermedoids_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;
			}
			
	}
    }
    



static char pdl_getclustermedoids_vtable_flags[] =
	 	{ 0,0,0,0};
	 pdl_transvtable pdl_getclustermedoids_vtable = {
		0,0, 2, 4, pdl_getclustermedoids_vtable_flags,
		pdl_getclustermedoids_redodims, pdl_getclustermedoids_readdata, NULL,
		pdl_getclustermedoids_free,NULL,NULL,pdl_getclustermedoids_copy,
		sizeof(pdl_getclustermedoids_struct),"pdl_getclustermedoids_vtable"
	 };

typedef struct pdl_kcluster_struct {
		PDL_TRANS_START(8);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_clusterids_n;PDL_Indx  __d_size;PDL_Indx  __n_size;
		char  *distFlag;char  *ctrMethodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_kcluster_struct;

void pdl_kcluster_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_kcluster_struct *__privtrans = (pdl_kcluster_struct *) __tr;
	
	{
	    PDL_Indx __creating[8];
__privtrans->__d_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
__creating[6] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[6]);
__creating[7] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[7]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"nclusters","data","mask","weight","npass","clusterids","error","nfound"};
		static PDL_Indx __realdims[] = {0,2,2,1,0,1,0,0};
		static char __funcname[] = "PDL::Cluster::kcluster";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 8
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,8,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in kcluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in kcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in kcluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in kcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in kcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
if(!__creating[5]) {
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in kcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}if(!__creating[6]) {
PDL->make_physical(((__privtrans->pdls[6])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,6,dims,0);
}if(!__creating[7]) {
PDL->make_physical(((__privtrans->pdls[7])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,7,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[6] && 
     __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[7] && 
     __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[6]->hdrsv != hdrp ){
	 if( __privtrans->pdls[6]->hdrsv && __privtrans->pdls[6]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[6]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[6]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[6]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[7]->hdrsv != hdrp ){
	 if( __privtrans->pdls[7]->hdrsv && __privtrans->pdls[7]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[7]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[7]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[7]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[2]->dimincs[1];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = __privtrans->pdls[5]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_kcluster_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_kcluster_struct *__privtrans = (pdl_kcluster_struct *) __tr;
	
	{
	    pdl_kcluster_struct *__copy = malloc(sizeof(pdl_kcluster_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->ctrMethodFlag) = malloc(strlen(__privtrans->ctrMethodFlag)+1); strcpy(__copy->ctrMethodFlag,__privtrans->ctrMethodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__copy->__d_size=__privtrans->__d_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_kcluster_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_kcluster_struct *__privtrans = (pdl_kcluster_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	nclusters_datap += __offsp[0];
	data_datap += __offsp[1];
	mask_datap += __offsp[2];
	weight_datap += __offsp[3];
	npass_datap += __offsp[4];
	clusterids_datap += __offsp[5];
	error_datap += __offsp[6];
	nfound_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,data_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,mask_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,weight_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,npass_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clusterids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,error_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,nfound_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,data_datap += __tinc0_1
			,mask_datap += __tinc0_2
			,weight_datap += __tinc0_3
			,npass_datap += __tinc0_4
			,clusterids_datap += __tinc0_5
			,error_datap += __tinc0_6
			,nfound_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    kcluster((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
             weight_datap, transpose, (npass_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->ctrMethodFlag, *__privtrans->distFlag,
             clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	data_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	mask_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	weight_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	npass_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clusterids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	error_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	nfound_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_kcluster_free(pdl_trans *__tr ) {
	int __dim;
	pdl_kcluster_struct *__privtrans = (pdl_kcluster_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->ctrMethodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;
			}
			
	}
    }
    



static char pdl_kcluster_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,0,0,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_kcluster_vtable = {
		0,0, 5, 8, pdl_kcluster_vtable_flags,
		pdl_kcluster_redodims, pdl_kcluster_readdata, NULL,
		pdl_kcluster_free,NULL,NULL,pdl_kcluster_copy,
		sizeof(pdl_kcluster_struct),"pdl_kcluster_vtable"
	 };

typedef struct pdl_kmedoids_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_distance_n0;PDL_Indx  __inc_distance_n1;PDL_Indx  __inc_clusterids_n;PDL_Indx  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_kmedoids_struct;

void pdl_kmedoids_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_kmedoids_struct *__privtrans = (pdl_kmedoids_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"nclusters","distance","npass","clusterids","error","nfound"};
		static PDL_Indx __realdims[] = {0,2,0,1,0,0};
		static char __funcname[] = "PDL::Cluster::kmedoids";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in kmedoids:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in kmedoids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
if(!__creating[3]) {
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in kmedoids:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 PDL_Indx dims[1]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_distance_n0 = 0; else
		 __privtrans->__inc_distance_n0 = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_distance_n1 = 0; else
		 __privtrans->__inc_distance_n1 = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = __privtrans->pdls[3]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_kmedoids_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_kmedoids_struct *__privtrans = (pdl_kmedoids_struct *) __tr;
	
	{
	    pdl_kmedoids_struct *__copy = malloc(sizeof(pdl_kmedoids_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_distance_n0=__copy->__inc_distance_n0;__privtrans->__inc_distance_n1=__copy->__inc_distance_n1;__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_kmedoids_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_kmedoids_struct *__privtrans = (pdl_kmedoids_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_S: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_US: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_L: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_IND: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_LL: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_F: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	} break; case PDL_D: {
	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Double * distance_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * distance_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Long * npass_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * npass_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * error_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * error_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * nfound_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * nfound_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_distance_n0 = __privtrans->__inc_distance_n0;
register PDL_Indx __inc_distance_n1 = __privtrans->__inc_distance_n1;


  double **distpp = (double **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	nclusters_datap += __offsp[0];
	distance_datap += __offsp[1];
	npass_datap += __offsp[2];
	clusterids_datap += __offsp[3];
	error_datap += __offsp[4];
	nfound_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,nclusters_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,distance_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,npass_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clusterids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,error_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,nfound_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,nclusters_datap += __tinc0_0
			,distance_datap += __tinc0_1
			,npass_datap += __tinc0_2
			,clusterids_datap += __tinc0_3
			,error_datap += __tinc0_4
			,nfound_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distance_datap, distpp);
    kmedoids((nclusters_datap)[0] PDL_COMMENT("ACCESS()") , __privtrans->__n_size, distpp,
             (npass_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap, error_datap, nfound_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	nclusters_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	distance_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	npass_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clusterids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	error_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	nfound_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (distpp) free(distpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_kmedoids_free(pdl_trans *__tr ) {
	int __dim;
	pdl_kmedoids_struct *__privtrans = (pdl_kmedoids_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_kmedoids_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK,0,0,0};
	 pdl_transvtable pdl_kmedoids_vtable = {
		0,0, 3, 6, pdl_kmedoids_vtable_flags,
		pdl_kmedoids_redodims, pdl_kmedoids_readdata, NULL,
		pdl_kmedoids_free,NULL,NULL,pdl_kmedoids_copy,
		sizeof(pdl_kmedoids_struct),"pdl_kmedoids_vtable"
	 };

typedef struct pdl_treecluster_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_tree_2;PDL_Indx  __inc_tree_n;PDL_Indx  __inc_lnkdist_n;PDL_Indx  __n_size;PDL_Indx  __d_size;PDL_Indx  __2_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_treecluster_struct;

void pdl_treecluster_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_treecluster_struct *__privtrans = (pdl_treecluster_struct *) __tr;
	
	{
	    PDL_Indx __creating[5];
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__privtrans->__2_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","tree","lnkdist"};
		static PDL_Indx __realdims[] = {2,2,1,2,1};
		static char __funcname[] = "PDL::Cluster::treecluster";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
if(!__creating[3]) {
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__2_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treecluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_tree_2 = 0; else
		 __privtrans->__inc_tree_2 = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_tree_n = 0; else
		 __privtrans->__inc_tree_n = __privtrans->pdls[3]->dimincs[1];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_lnkdist_n = 0; else
		 __privtrans->__inc_lnkdist_n = __privtrans->pdls[4]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_treecluster_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_treecluster_struct *__privtrans = (pdl_treecluster_struct *) __tr;
	
	{
	    pdl_treecluster_struct *__copy = malloc(sizeof(pdl_treecluster_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_tree_2=__copy->__inc_tree_2;__privtrans->__inc_tree_n=__copy->__inc_tree_n;__privtrans->__inc_lnkdist_n=__copy->__inc_lnkdist_n;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;__copy->__2_size=__privtrans->__2_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_treecluster_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_treecluster_struct *__privtrans = (pdl_treecluster_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = NULL;
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	tree_datap += __offsp[3];
	lnkdist_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,tree_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,lnkdist_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,tree_datap += __tinc0_3
			,lnkdist_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      NULL);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	tree_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	lnkdist_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (nod)    free(nod);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_treecluster_free(pdl_trans *__tr ) {
	int __dim;
	pdl_treecluster_struct *__privtrans = (pdl_treecluster_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_treecluster_vtable_flags[] =
	 	{ 0,0,0,0,0};
	 pdl_transvtable pdl_treecluster_vtable = {
		0,0, 3, 5, pdl_treecluster_vtable_flags,
		pdl_treecluster_redodims, pdl_treecluster_readdata, NULL,
		pdl_treecluster_free,NULL,NULL,pdl_treecluster_copy,
		sizeof(pdl_treecluster_struct),"pdl_treecluster_vtable"
	 };

typedef struct pdl_treeclusterd_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_distances_n0;PDL_Indx  __inc_distances_n1;PDL_Indx  __inc_tree_2;PDL_Indx  __inc_tree_n;PDL_Indx  __inc_lnkdist_n;PDL_Indx  __2_size;PDL_Indx  __d_size;PDL_Indx  __n_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_treeclusterd_struct;

void pdl_treeclusterd_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_treeclusterd_struct *__privtrans = (pdl_treeclusterd_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__2_size = -1;
__privtrans->__d_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","distances","tree","lnkdist"};
		static PDL_Indx __realdims[] = {2,2,1,2,2,1};
		static char __funcname[] = "PDL::Cluster::treeclusterd";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[3])));
if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 2) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[4]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[4]))->dims[1];
   } else if(((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[4]))->dims[1]) {
      if(((__privtrans->pdls[4]))->dims[1] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__2_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}if(!__creating[5]) {
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in treeclusterd:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_distances_n0 = 0; else
		 __privtrans->__inc_distances_n0 = __privtrans->pdls[3]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_distances_n1 = 0; else
		 __privtrans->__inc_distances_n1 = __privtrans->pdls[3]->dimincs[1];if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_tree_2 = 0; else
		 __privtrans->__inc_tree_2 = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 1 || __privtrans->pdls[4]->dims[1] <= 1)
		  __privtrans->__inc_tree_n = 0; else
		 __privtrans->__inc_tree_n = __privtrans->pdls[4]->dimincs[1];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_lnkdist_n = 0; else
		 __privtrans->__inc_lnkdist_n = __privtrans->pdls[5]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_treeclusterd_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_treeclusterd_struct *__privtrans = (pdl_treeclusterd_struct *) __tr;
	
	{
	    pdl_treeclusterd_struct *__copy = malloc(sizeof(pdl_treeclusterd_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_distances_n0=__copy->__inc_distances_n0;__privtrans->__inc_distances_n1=__copy->__inc_distances_n1;__privtrans->__inc_tree_2=__copy->__inc_tree_2;__privtrans->__inc_tree_n=__copy->__inc_tree_n;__privtrans->__inc_lnkdist_n=__copy->__inc_lnkdist_n;__copy->__2_size=__privtrans->__2_size;__copy->__d_size=__privtrans->__d_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_treeclusterd_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_treeclusterd_struct *__privtrans = (pdl_treeclusterd_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * distances_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * distances_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * lnkdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * lnkdist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_distances_n0 = __privtrans->__inc_distances_n0;
register PDL_Indx __inc_distances_n1 = __privtrans->__inc_distances_n1;
register PDL_Indx __inc_lnkdist_n = __privtrans->__inc_lnkdist_n;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **distpp  = (double **)pp_alloc(__privtrans->__n_size);
  Node    *nod     = NULL;
  int      nmax    = __privtrans->__n_size-1;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	distances_datap += __offsp[3];
	tree_datap += __offsp[4];
	lnkdist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,distances_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,tree_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,lnkdist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,distances_datap += __tinc0_3
			,tree_datap += __tinc0_4
			,lnkdist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl_ragged(__privtrans->__n_size, __privtrans->__n_size, distances_datap, distpp);
    nod = treecluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                      weight_datap, transpose, *__privtrans->distFlag, *__privtrans->methodFlag,
                      distpp);

    node2p(nmax, nod, tree_datap, lnkdist_datap);
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 0))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (tree_datap)[0+(__inc_tree_2*PP_INDTERM(__privtrans->__2_size, 1))+(__inc_tree_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
    (lnkdist_datap)[0+(__inc_lnkdist_n*PP_INDTERM(__privtrans->__n_size, nmax))] PDL_COMMENT("ACCESS()")  = 0;
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	distances_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	tree_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	lnkdist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (distpp) free(distpp);
  if (nod)    free(nod);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_treeclusterd_free(pdl_trans *__tr ) {
	int __dim;
	pdl_treeclusterd_struct *__privtrans = (pdl_treeclusterd_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_treeclusterd_vtable_flags[] =
	 	{ 0,0,0,0,0,0};
	 pdl_transvtable pdl_treeclusterd_vtable = {
		0,0, 4, 6, pdl_treeclusterd_vtable_flags,
		pdl_treeclusterd_redodims, pdl_treeclusterd_readdata, NULL,
		pdl_treeclusterd_free,NULL,NULL,pdl_treeclusterd_copy,
		sizeof(pdl_treeclusterd_struct),"pdl_treeclusterd_vtable"
	 };

typedef struct pdl_cuttree_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Indx  __inc_tree_2;PDL_Indx  __inc_tree_n;PDL_Indx  __inc_clusterids_n;PDL_Indx  __2_size;PDL_Indx  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_cuttree_struct;

void pdl_cuttree_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_cuttree_struct *__privtrans = (pdl_cuttree_struct *) __tr;
	
	{
	    PDL_Indx __creating[3];
__privtrans->__2_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"tree","nclusters","clusterids"};
		static PDL_Indx __realdims[] = {2,0,1};
		static char __funcname[] = "PDL::Cluster::cuttree";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cuttree:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in cuttree:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in cuttree:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_tree_2 = 0; else
		 __privtrans->__inc_tree_2 = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_tree_n = 0; else
		 __privtrans->__inc_tree_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = __privtrans->pdls[2]->dimincs[0]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_cuttree_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_cuttree_struct *__privtrans = (pdl_cuttree_struct *) __tr;
	
	{
	    pdl_cuttree_struct *__copy = malloc(sizeof(pdl_cuttree_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_tree_2=__copy->__inc_tree_2;__privtrans->__inc_tree_n=__copy->__inc_tree_n;__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__copy->__2_size=__privtrans->__2_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_cuttree_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_cuttree_struct *__privtrans = (pdl_cuttree_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_S: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_US: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_L: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_IND: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_LL: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_F: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_D: {
	PDL_Long * tree_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * tree_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * nclusters_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * nclusters_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	tree_datap += __offsp[0];
	nclusters_datap += __offsp[1];
	clusterids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,tree_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,nclusters_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,tree_datap += __tinc0_0
			,nclusters_datap += __tinc0_1
			,clusterids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_tree_2 = __privtrans->__inc_tree_2;
register PDL_Indx __inc_tree_n = __privtrans->__inc_tree_n;


    Node *nod = p2node(__privtrans->__n_size-1,tree_datap,NULL);
    cuttree(__privtrans->__n_size, nod, (nclusters_datap)[0] PDL_COMMENT("ACCESS()") , clusterids_datap);
    if (nod) free(nod);

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	tree_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	nclusters_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_cuttree_free(pdl_trans *__tr ) {
	int __dim;
	pdl_cuttree_struct *__privtrans = (pdl_cuttree_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_cuttree_vtable_flags[] =
	 	{ 0,PDL_TPDL_VAFFINE_OK,0};
	 pdl_transvtable pdl_cuttree_vtable = {
		0,0, 2, 3, pdl_cuttree_vtable_flags,
		pdl_cuttree_redodims, pdl_cuttree_readdata, NULL,
		pdl_cuttree_free,NULL,NULL,pdl_cuttree_copy,
		sizeof(pdl_cuttree_struct),"pdl_cuttree_vtable"
	 };

typedef struct pdl_somcluster_struct {
		PDL_TRANS_START(8);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_clusterids_2;PDL_Indx  __inc_clusterids_n;PDL_Indx  __2_size;PDL_Indx  __n_size;PDL_Indx  __d_size;
		char  *distFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_somcluster_struct;

void pdl_somcluster_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_somcluster_struct *__privtrans = (pdl_somcluster_struct *) __tr;
	
	{
	    PDL_Indx __creating[8];
__privtrans->__2_size = -1;
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[7]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","nxnodes","nynodes","inittau","niter","clusterids"};
		static PDL_Indx __realdims[] = {2,2,1,0,0,0,0,2};
		static char __funcname[] = "PDL::Cluster::somcluster";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 8
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,8,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in somcluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in somcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in somcluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in somcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in somcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
if(!__creating[7]) {
   if(((__privtrans->pdls[7]))->ndims < 2) {
      if (((__privtrans->pdls[7]))->ndims < 1 && __privtrans->__2_size <= 1) __privtrans->__2_size = 1;
      if (((__privtrans->pdls[7]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__2_size == -1 || (((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__2_size == 1)) {
      __privtrans->__2_size = ((__privtrans->pdls[7]))->dims[0];
   } else if(((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__2_size != ((__privtrans->pdls[7]))->dims[0]) {
      if(((__privtrans->pdls[7]))->dims[0] != 1) {
         PDL->pdl_barf("Error in somcluster:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[7]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[7]))->dims[1];
   } else if(((__privtrans->pdls[7]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[7]))->dims[1]) {
      if(((__privtrans->pdls[7]))->dims[1] != 1) {
         PDL->pdl_barf("Error in somcluster:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[7])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__2_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,7,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[7] && 
     __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[7]->hdrsv != hdrp ){
	 if( __privtrans->pdls[7]->hdrsv && __privtrans->pdls[7]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[7]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[7]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[7]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[7]->ndims <= 0 || __privtrans->pdls[7]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_2 = 0; else
		 __privtrans->__inc_clusterids_2 = __privtrans->pdls[7]->dimincs[0];if(__privtrans->pdls[7]->ndims <= 1 || __privtrans->pdls[7]->dims[1] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = __privtrans->pdls[7]->dimincs[1]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_somcluster_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_somcluster_struct *__privtrans = (pdl_somcluster_struct *) __tr;
	
	{
	    pdl_somcluster_struct *__copy = malloc(sizeof(pdl_somcluster_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_clusterids_2=__copy->__inc_clusterids_2;__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__copy->__2_size=__privtrans->__2_size;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_somcluster_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_somcluster_struct *__privtrans = (pdl_somcluster_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * nxnodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * nxnodes_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * nynodes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * nynodes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * inittau_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * inittau_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

	PDL_Long * niter_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * niter_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_clusterids_2 = __privtrans->__inc_clusterids_2;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;


  int    transpose = 0;
  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	nxnodes_datap += __offsp[3];
	nynodes_datap += __offsp[4];
	inittau_datap += __offsp[5];
	niter_datap += __offsp[6];
	clusterids_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,nxnodes_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,nynodes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,inittau_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,niter_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,clusterids_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,nxnodes_datap += __tinc0_3
			,nynodes_datap += __tinc0_4
			,inittau_datap += __tinc0_5
			,niter_datap += __tinc0_6
			,clusterids_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size, mask_datap, maskpp);
    somcluster(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp,
                weight_datap, transpose, (nxnodes_datap)[0] PDL_COMMENT("ACCESS()") , (nynodes_datap)[0] PDL_COMMENT("ACCESS()") ,
                (inittau_datap)[0] PDL_COMMENT("ACCESS()") , (niter_datap)[0] PDL_COMMENT("ACCESS()") , *__privtrans->distFlag, NULL,
                (int (*)[2])(clusterids_datap));
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	nxnodes_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	nynodes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	inittau_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	niter_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	clusterids_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_somcluster_free(pdl_trans *__tr ) {
	int __dim;
	pdl_somcluster_struct *__privtrans = (pdl_somcluster_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_somcluster_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0};
	 pdl_transvtable pdl_somcluster_vtable = {
		0,0, 7, 8, pdl_somcluster_vtable_flags,
		pdl_somcluster_redodims, pdl_somcluster_readdata, NULL,
		pdl_somcluster_free,NULL,NULL,pdl_somcluster_copy,
		sizeof(pdl_somcluster_struct),"pdl_somcluster_vtable"
	 };

typedef struct pdl_pca_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Indx  __inc_U_d;PDL_Indx  __inc_U_n;PDL_Indx  __inc_S_d;PDL_Indx  __inc_V_d0;PDL_Indx  __inc_V_d1;PDL_Indx  __n_size;PDL_Indx  __d_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_pca_struct;

void pdl_pca_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_pca_struct *__privtrans = (pdl_pca_struct *) __tr;
	
	{
	    PDL_Indx __creating[3];
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__creating[0] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[0]);
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"U","S","V"};
		static PDL_Indx __realdims[] = {2,1,2};
		static char __funcname[] = "PDL::Cluster::pca";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
if(!__creating[0]) {
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pca:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in pca:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,0,dims,0);
}if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pca:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in pca:" "Wrong dims\n");
      }
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in pca:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;dims[1] = __privtrans->__d_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	 !__creating[0] && 
     __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[0]->hdrsv != hdrp ){
	 if( __privtrans->pdls[0]->hdrsv && __privtrans->pdls[0]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[0]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[0]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[0]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_U_d = 0; else
		 __privtrans->__inc_U_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_U_n = 0; else
		 __privtrans->__inc_U_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_S_d = 0; else
		 __privtrans->__inc_S_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_V_d0 = 0; else
		 __privtrans->__inc_V_d0 = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_V_d1 = 0; else
		 __privtrans->__inc_V_d1 = __privtrans->pdls[2]->dimincs[1]; __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_pca_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_pca_struct *__privtrans = (pdl_pca_struct *) __tr;
	
	{
	    pdl_pca_struct *__copy = malloc(sizeof(pdl_pca_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_U_d=__copy->__inc_U_d;__privtrans->__inc_U_n=__copy->__inc_U_n;__privtrans->__inc_S_d=__copy->__inc_S_d;__privtrans->__inc_V_d0=__copy->__inc_V_d0;__privtrans->__inc_V_d1=__copy->__inc_V_d1;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_pca_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_pca_struct *__privtrans = (pdl_pca_struct *) __tr;
	
	{
	    {PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	} break; case PDL_S: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	} break; case PDL_US: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	} break; case PDL_L: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	} break; case PDL_IND: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	} break; case PDL_LL: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	} break; case PDL_F: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	} break; case PDL_D: {
	PDL_Double * U_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * U_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Double * S_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Double * S_physdatap = ((PDL_Double *)((__privtrans->pdls[1])->data));

	PDL_Double * V_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * V_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_U_d = __privtrans->__inc_U_d;
register PDL_Indx __inc_U_n = __privtrans->__inc_U_n;
register PDL_Indx __inc_V_d0 = __privtrans->__inc_V_d0;
register PDL_Indx __inc_V_d1 = __privtrans->__inc_V_d1;
register PDL_Indx __inc_S_d = __privtrans->__inc_S_d;


  double **Upp  = (double **)pp_alloc(__privtrans->__n_size);
  double **Vpp  = (double **)pp_alloc(__privtrans->__d_size);
  if (__privtrans->__n_size < __privtrans->__d_size) {
    barf("svd(): Number of rows (=%d) must be >= number of columns (=%d)!\n", __privtrans->__n_size, __privtrans->__d_size);
  }
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	U_datap += __offsp[0];
	S_datap += __offsp[1];
	V_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,U_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,S_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,V_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,U_datap += __tinc0_0
			,S_datap += __tinc0_1
			,V_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, U_datap, Upp);
    p2pp_dbl(__privtrans->__d_size, __privtrans->__d_size, V_datap, Vpp);
        pca(__privtrans->__n_size, __privtrans->__d_size, Upp, Vpp, S_datap);
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	U_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	S_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	V_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (Upp) free(Upp);
  if (Vpp) free(Vpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_pca_free(pdl_trans *__tr ) {
	int __dim;
	pdl_pca_struct *__privtrans = (pdl_pca_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;
			}
			
	}
    }
    



static char pdl_pca_vtable_flags[] =
	 	{ 0,0,0};
	 pdl_transvtable pdl_pca_vtable = {
		0,0, 0, 3, pdl_pca_vtable_flags,
		pdl_pca_redodims, pdl_pca_readdata, NULL,
		pdl_pca_free,NULL,NULL,pdl_pca_copy,
		sizeof(pdl_pca_struct),"pdl_pca_vtable"
	 };

typedef struct pdl_rowdistances_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_rowids1_ncmps;PDL_Indx  __inc_rowids2_ncmps;PDL_Indx  __inc_dist_ncmps;PDL_Indx  __n_size;PDL_Indx  __d_size;PDL_Indx  __ncmps_size;
		char  *distFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_rowdistances_struct;

void pdl_rowdistances_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_rowdistances_struct *__privtrans = (pdl_rowdistances_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__privtrans->__ncmps_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","rowids1","rowids2","dist"};
		static PDL_Indx __realdims[] = {2,2,1,1,1,1};
		static char __funcname[] = "PDL::Cluster::rowdistances";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__ncmps_size <= 1) __privtrans->__ncmps_size = 1;
   }
   if(__privtrans->__ncmps_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__ncmps_size == 1)) {
      __privtrans->__ncmps_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__ncmps_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__ncmps_size <= 1) __privtrans->__ncmps_size = 1;
   }
   if(__privtrans->__ncmps_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__ncmps_size == 1)) {
      __privtrans->__ncmps_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__ncmps_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
if(!__creating[5]) {
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__ncmps_size <= 1) __privtrans->__ncmps_size = 1;
   }
   if(__privtrans->__ncmps_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__ncmps_size == 1)) {
      __privtrans->__ncmps_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__ncmps_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in rowdistances:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__ncmps_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_rowids1_ncmps = 0; else
		 __privtrans->__inc_rowids1_ncmps = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_rowids2_ncmps = 0; else
		 __privtrans->__inc_rowids2_ncmps = PDL_REPRINC(__privtrans->pdls[4],0);if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_dist_ncmps = 0; else
		 __privtrans->__inc_dist_ncmps = PDL_REPRINC(__privtrans->pdls[5],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_rowdistances_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_rowdistances_struct *__privtrans = (pdl_rowdistances_struct *) __tr;
	
	{
	    pdl_rowdistances_struct *__copy = malloc(sizeof(pdl_rowdistances_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_rowids1_ncmps=__copy->__inc_rowids1_ncmps;__privtrans->__inc_rowids2_ncmps=__copy->__inc_rowids2_ncmps;__privtrans->__inc_dist_ncmps=__copy->__inc_dist_ncmps;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;__copy->__ncmps_size=__privtrans->__ncmps_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_rowdistances_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_rowdistances_struct *__privtrans = (pdl_rowdistances_struct *) __tr;
	
	{
	    {register PDL_Indx __ncmps_size = __privtrans->__ncmps_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * rowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * rowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_dist_ncmps = __privtrans->__inc_dist_ncmps;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_rowids1_ncmps = __privtrans->__inc_rowids1_ncmps;
register PDL_Indx __inc_rowids2_ncmps = __privtrans->__inc_rowids2_ncmps;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    rowid1, rowid2;
  char   methodChar = 'x'; /*-- doesnt matter --*/
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids1_datap += __offsp[3];
	rowids2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,rowids2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids1_datap += __tinc0_3
			,rowids2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      rowid1 = (rowids1_datap)[0+(__inc_rowids1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      rowid2 = (rowids2_datap)[0+(__inc_rowids2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      (dist_datap)[0+(__inc_dist_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, 1,
                                &rowid1, &rowid2,
                                *__privtrans->distFlag, methodChar, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	rowids2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_rowdistances_free(pdl_trans *__tr ) {
	int __dim;
	pdl_rowdistances_struct *__privtrans = (pdl_rowdistances_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_rowdistances_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_rowdistances_vtable = {
		0,0, 5, 6, pdl_rowdistances_vtable_flags,
		pdl_rowdistances_redodims, pdl_rowdistances_readdata, NULL,
		pdl_rowdistances_free,NULL,NULL,pdl_rowdistances_copy,
		sizeof(pdl_rowdistances_struct),"pdl_rowdistances_vtable"
	 };

typedef struct pdl_clusterdistances_struct {
		PDL_TRANS_START(6);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_rowids_nr;PDL_Indx  __inc_index2_n2;PDL_Indx  __inc_dist_nr;PDL_Indx  __nr_size;PDL_Indx  __n_size;PDL_Indx  __n2_size;PDL_Indx  __d_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clusterdistances_struct;

void pdl_clusterdistances_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistances_struct *__privtrans = (pdl_clusterdistances_struct *) __tr;
	
	{
	    PDL_Indx __creating[6];
__privtrans->__nr_size = -1;
__privtrans->__n_size = -1;
__privtrans->__n2_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[5]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","rowids","index2","dist"};
		static PDL_Indx __realdims[] = {2,2,1,1,1,1};
		static char __funcname[] = "PDL::Cluster::clusterdistances";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 6
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,6,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__nr_size <= 1) __privtrans->__nr_size = 1;
   }
   if(__privtrans->__nr_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nr_size == 1)) {
      __privtrans->__nr_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nr_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__n2_size <= 1) __privtrans->__n2_size = 1;
   }
   if(__privtrans->__n2_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n2_size == 1)) {
      __privtrans->__n2_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__n2_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
if(!__creating[5]) {
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__nr_size <= 1) __privtrans->__nr_size = 1;
   }
   if(__privtrans->__nr_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__nr_size == 1)) {
      __privtrans->__nr_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__nr_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistances:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__nr_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,5,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[5] && 
     __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[5]->hdrsv != hdrp ){
	 if( __privtrans->pdls[5]->hdrsv && __privtrans->pdls[5]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[5]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[5]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[5]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_rowids_nr = 0; else
		 __privtrans->__inc_rowids_nr = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_index2_n2 = 0; else
		 __privtrans->__inc_index2_n2 = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_dist_nr = 0; else
		 __privtrans->__inc_dist_nr = PDL_REPRINC(__privtrans->pdls[5],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clusterdistances_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistances_struct *__privtrans = (pdl_clusterdistances_struct *) __tr;
	
	{
	    pdl_clusterdistances_struct *__copy = malloc(sizeof(pdl_clusterdistances_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_rowids_nr=__copy->__inc_rowids_nr;__privtrans->__inc_index2_n2=__copy->__inc_index2_n2;__privtrans->__inc_dist_nr=__copy->__inc_dist_nr;__copy->__nr_size=__privtrans->__nr_size;__copy->__n_size=__privtrans->__n_size;__copy->__n2_size=__privtrans->__n2_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clusterdistances_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistances_struct *__privtrans = (pdl_clusterdistances_struct *) __tr;
	
	{
	    {register PDL_Indx __nr_size = __privtrans->__nr_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * index2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * index2_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[5])->data));

{register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_index2_n2 = __privtrans->__inc_index2_n2;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;


  double **datapp = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	index2_datap += __offsp[4];
	dist_datap += __offsp[5];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,index2_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,dist_datap += __tinc1_5 - __tinc0_5 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,index2_datap += __tinc0_4
			,dist_datap += __tinc0_5
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      (dist_datap)[0+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                1, __privtrans->__n2_size, &((rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ), index2_datap,
                                *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	index2_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	dist_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clusterdistances_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistances_struct *__privtrans = (pdl_clusterdistances_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_clusterdistances_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clusterdistances_vtable = {
		0,0, 5, 6, pdl_clusterdistances_vtable_flags,
		pdl_clusterdistances_redodims, pdl_clusterdistances_readdata, NULL,
		pdl_clusterdistances_free,NULL,NULL,pdl_clusterdistances_copy,
		sizeof(pdl_clusterdistances_struct),"pdl_clusterdistances_vtable"
	 };

typedef struct pdl_clustersizes_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Indx  __inc_clusterids_n;PDL_Indx  __inc_clustersizes_k;PDL_Indx  __k_size;PDL_Indx  __n_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clustersizes_struct;

void pdl_clustersizes_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clustersizes_struct *__privtrans = (pdl_clustersizes_struct *) __tr;
	
	{
	    PDL_Indx __creating[2];
__privtrans->__k_size = -1;
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);

{register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"clusterids","clustersizes"};
		static PDL_Indx __realdims[] = {1,1};
		static char __funcname[] = "PDL::Cluster::clustersizes";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clustersizes:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clustersizes:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_clustersizes_k = 0; else
		 __privtrans->__inc_clustersizes_k = PDL_REPRINC(__privtrans->pdls[1],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clustersizes_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clustersizes_struct *__privtrans = (pdl_clustersizes_struct *) __tr;
	
	{
	    pdl_clustersizes_struct *__copy = malloc(sizeof(pdl_clustersizes_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__privtrans->__inc_clustersizes_k=__copy->__inc_clustersizes_k;__copy->__k_size=__privtrans->__k_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clustersizes_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clustersizes_struct *__privtrans = (pdl_clustersizes_struct *) __tr;
	
	{
	    {register PDL_Indx __k_size = __privtrans->__k_size;
register PDL_Indx __n_size = __privtrans->__n_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_S: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_US: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_L: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_IND: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_LL: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_F: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_D: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));
	PDL_Long   clusterids_badval = 0;
	PDL_Anyval  clusterids_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[0]));
	ANYVAL_TO_CTYPE(clusterids_badval, PDL_Long, clusterids_anyval_badval);

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));
	PDL_Long   clustersizes_badval = 0;
	PDL_Anyval  clustersizes_anyval_badval = PDL->get_pdl_badvalue((__privtrans->pdls[1]));
	ANYVAL_TO_CTYPE(clustersizes_badval, PDL_Long, clustersizes_anyval_badval);


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


 int cid, csize;
 {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
 {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
   cid = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
   if (cid < 0 || cid >= __privtrans->__k_size || cid == clusterids_badval) continue; /*-- sanity check --*/
   (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
 }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clustersizes_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clustersizes_struct *__privtrans = (pdl_clustersizes_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;
			}
			
	}
    }
    



static char pdl_clustersizes_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clustersizes_vtable = {
		0,0, 1, 2, pdl_clustersizes_vtable_flags,
		pdl_clustersizes_redodims, pdl_clustersizes_readdata, NULL,
		pdl_clustersizes_free,NULL,NULL,pdl_clustersizes_copy,
		sizeof(pdl_clustersizes_struct),"pdl_clustersizes_vtable"
	 };

typedef struct pdl_clusterelements_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Indx  __inc_clusterids_n;PDL_Indx  __inc_clustersizes_k;PDL_Indx  __inc_eltids_mcsize;PDL_Indx  __inc_eltids_k;PDL_Indx  __n_size;PDL_Indx  __mcsize_size;PDL_Indx  __k_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clusterelements_struct;

void pdl_clusterelements_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelements_struct *__privtrans = (pdl_clusterelements_struct *) __tr;
	
	{
	    PDL_Indx __creating[3];
__privtrans->__n_size = -1;
__privtrans->__mcsize_size = -1;
__privtrans->__k_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"clusterids","clustersizes","eltids"};
		static PDL_Indx __realdims[] = {1,1,2};
		static char __funcname[] = "PDL::Cluster::clusterelements";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterelements:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterelements:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__mcsize_size <= 1) __privtrans->__mcsize_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__mcsize_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__mcsize_size == 1)) {
      __privtrans->__mcsize_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__mcsize_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterelements:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterelements:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__mcsize_size;dims[1] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_clustersizes_k = 0; else
		 __privtrans->__inc_clustersizes_k = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_eltids_mcsize = 0; else
		 __privtrans->__inc_eltids_mcsize = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_eltids_k = 0; else
		 __privtrans->__inc_eltids_k = PDL_REPRINC(__privtrans->pdls[2],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clusterelements_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelements_struct *__privtrans = (pdl_clusterelements_struct *) __tr;
	
	{
	    pdl_clusterelements_struct *__copy = malloc(sizeof(pdl_clusterelements_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__privtrans->__inc_clustersizes_k=__copy->__inc_clustersizes_k;__privtrans->__inc_eltids_mcsize=__copy->__inc_eltids_mcsize;__privtrans->__inc_eltids_k=__copy->__inc_eltids_k;__copy->__n_size=__privtrans->__n_size;__copy->__mcsize_size=__privtrans->__mcsize_size;__copy->__k_size=__privtrans->__k_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clusterelements_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelements_struct *__privtrans = (pdl_clusterelements_struct *) __tr;
	
	{
	    {register PDL_Indx __k_size = __privtrans->__k_size;
register PDL_Indx __n_size = __privtrans->__n_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_S: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_US: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_L: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_IND: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_LL: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_F: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_D: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	clusterids_datap += __offsp[0];
	clustersizes_datap += __offsp[1];
	eltids_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,clustersizes_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,eltids_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,clustersizes_datap += __tinc0_1
			,eltids_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;


  int cid, csize;
  {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    csize = (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()") ++;
    (eltids_datap)[0+(__inc_eltids_mcsize*PP_INDTERM(__privtrans->__mcsize_size, csize))+(__inc_eltids_k*PP_INDTERM(__privtrans->__k_size, cid))] PDL_COMMENT("ACCESS()")  = n;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	clustersizes_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	eltids_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clusterelements_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelements_struct *__privtrans = (pdl_clusterelements_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;
			}
			
	}
    }
    



static char pdl_clusterelements_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clusterelements_vtable = {
		0,0, 1, 3, pdl_clusterelements_vtable_flags,
		pdl_clusterelements_redodims, pdl_clusterelements_readdata, NULL,
		pdl_clusterelements_free,NULL,NULL,pdl_clusterelements_copy,
		sizeof(pdl_clusterelements_struct),"pdl_clusterelements_vtable"
	 };

typedef struct pdl_clusterelementmask_struct {
		PDL_TRANS_START(2);
		pdl_thread  __pdlthread;PDL_Indx  __inc_clusterids_n;PDL_Indx  __inc_eltmask_k;PDL_Indx  __inc_eltmask_n;PDL_Indx  __n_size;PDL_Indx  __k_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clusterelementmask_struct;

void pdl_clusterelementmask_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelementmask_struct *__privtrans = (pdl_clusterelementmask_struct *) __tr;
	
	{
	    PDL_Indx __creating[2];
__privtrans->__n_size = -1;
__privtrans->__k_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

{register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"clusterids","eltmask"};
		static PDL_Indx __realdims[] = {1,2};
		static char __funcname[] = "PDL::Cluster::clusterelementmask";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 2
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,2,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterelementmask:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterelementmask:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterelementmask:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;dims[1] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_n = 0; else
		 __privtrans->__inc_clusterids_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_eltmask_k = 0; else
		 __privtrans->__inc_eltmask_k = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_eltmask_n = 0; else
		 __privtrans->__inc_eltmask_n = PDL_REPRINC(__privtrans->pdls[1],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clusterelementmask_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelementmask_struct *__privtrans = (pdl_clusterelementmask_struct *) __tr;
	
	{
	    pdl_clusterelementmask_struct *__copy = malloc(sizeof(pdl_clusterelementmask_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_clusterids_n=__copy->__inc_clusterids_n;__privtrans->__inc_eltmask_k=__copy->__inc_eltmask_k;__privtrans->__inc_eltmask_n=__copy->__inc_eltmask_n;__copy->__n_size=__privtrans->__n_size;__copy->__k_size=__privtrans->__k_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clusterelementmask_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelementmask_struct *__privtrans = (pdl_clusterelementmask_struct *) __tr;
	
	{
	    {register PDL_Indx __n_size = __privtrans->__n_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_S: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_US: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_L: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_IND: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_LL: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_F: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_D: {
	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Byte * eltmask_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * eltmask_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	clusterids_datap += __offsp[0];
	eltmask_datap += __offsp[1];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,clusterids_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,eltmask_datap += __tinc1_1 - __tinc0_1 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,clusterids_datap += __tinc0_0
			,eltmask_datap += __tinc0_1
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_eltmask_k = __privtrans->__inc_eltmask_k;
register PDL_Indx __inc_eltmask_n = __privtrans->__inc_eltmask_n;
register PDL_Indx __inc_clusterids_n = __privtrans->__inc_clusterids_n;


  int cid, csize;
  {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
    cid   = (clusterids_datap)[0+(__inc_clusterids_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
    (eltmask_datap)[0+(__inc_eltmask_k*PP_INDTERM(__privtrans->__k_size, cid))+(__inc_eltmask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 1;
  }} PDL_COMMENT("Close n")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	clusterids_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	eltmask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clusterelementmask_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterelementmask_struct *__privtrans = (pdl_clusterelementmask_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_clusterelementmask_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clusterelementmask_vtable = {
		0,0, 1, 2, pdl_clusterelementmask_vtable_flags,
		pdl_clusterelementmask_redodims, pdl_clusterelementmask_readdata, NULL,
		pdl_clusterelementmask_free,NULL,NULL,pdl_clusterelementmask_copy,
		sizeof(pdl_clusterelementmask_struct),"pdl_clusterelementmask_vtable"
	 };

typedef struct pdl_clusterdistancematrix_struct {
		PDL_TRANS_START(7);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_rowids_nr;PDL_Indx  __inc_clustersizes_k;PDL_Indx  __inc_eltids_mcsize;PDL_Indx  __inc_eltids_k;PDL_Indx  __inc_dist_k;PDL_Indx  __inc_dist_nr;PDL_Indx  __n_size;PDL_Indx  __d_size;PDL_Indx  __nr_size;PDL_Indx  __k_size;PDL_Indx  __mcsize_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clusterdistancematrix_struct;

void pdl_clusterdistancematrix_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrix_struct *__privtrans = (pdl_clusterdistancematrix_struct *) __tr;
	
	{
	    PDL_Indx __creating[7];
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__privtrans->__nr_size = -1;
__privtrans->__k_size = -1;
__privtrans->__mcsize_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[6]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","rowids","clustersizes","eltids","dist"};
		static PDL_Indx __realdims[] = {2,2,1,1,1,2,2};
		static char __funcname[] = "PDL::Cluster::clusterdistancematrix";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 7
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,7,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__nr_size <= 1) __privtrans->__nr_size = 1;
   }
   if(__privtrans->__nr_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nr_size == 1)) {
      __privtrans->__nr_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nr_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[5]))->ndims < 2) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__mcsize_size <= 1) __privtrans->__mcsize_size = 1;
      if (((__privtrans->pdls[5]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__mcsize_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__mcsize_size == 1)) {
      __privtrans->__mcsize_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__mcsize_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[5]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[5]))->dims[1];
   } else if(((__privtrans->pdls[5]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[5]))->dims[1]) {
      if(((__privtrans->pdls[5]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));
if(!__creating[6]) {
   if(((__privtrans->pdls[6]))->ndims < 2) {
      if (((__privtrans->pdls[6]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
      if (((__privtrans->pdls[6]))->ndims < 2 && __privtrans->__nr_size <= 1) __privtrans->__nr_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[6]))->dims[0];
   } else if(((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[6]))->dims[0]) {
      if(((__privtrans->pdls[6]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
   if(__privtrans->__nr_size == -1 || (((__privtrans->pdls[6]))->ndims > 1 && __privtrans->__nr_size == 1)) {
      __privtrans->__nr_size = ((__privtrans->pdls[6]))->dims[1];
   } else if(((__privtrans->pdls[6]))->ndims > 1 && __privtrans->__nr_size != ((__privtrans->pdls[6]))->dims[1]) {
      if(((__privtrans->pdls[6]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrix:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;dims[1] = __privtrans->__nr_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,6,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[6] && 
     __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[6]->hdrsv != hdrp ){
	 if( __privtrans->pdls[6]->hdrsv && __privtrans->pdls[6]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[6]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[6]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[6]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_rowids_nr = 0; else
		 __privtrans->__inc_rowids_nr = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_clustersizes_k = 0; else
		 __privtrans->__inc_clustersizes_k = PDL_REPRINC(__privtrans->pdls[4],0);if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_eltids_mcsize = 0; else
		 __privtrans->__inc_eltids_mcsize = __privtrans->pdls[5]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 1 || __privtrans->pdls[5]->dims[1] <= 1)
		  __privtrans->__inc_eltids_k = 0; else
		 __privtrans->__inc_eltids_k = __privtrans->pdls[5]->dimincs[1];if(__privtrans->pdls[6]->ndims <= 0 || __privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_dist_k = 0; else
		 __privtrans->__inc_dist_k = PDL_REPRINC(__privtrans->pdls[6],0);if(__privtrans->pdls[6]->ndims <= 1 || __privtrans->pdls[6]->dims[1] <= 1)
		  __privtrans->__inc_dist_nr = 0; else
		 __privtrans->__inc_dist_nr = PDL_REPRINC(__privtrans->pdls[6],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clusterdistancematrix_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrix_struct *__privtrans = (pdl_clusterdistancematrix_struct *) __tr;
	
	{
	    pdl_clusterdistancematrix_struct *__copy = malloc(sizeof(pdl_clusterdistancematrix_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_rowids_nr=__copy->__inc_rowids_nr;__privtrans->__inc_clustersizes_k=__copy->__inc_clustersizes_k;__privtrans->__inc_eltids_mcsize=__copy->__inc_eltids_mcsize;__privtrans->__inc_eltids_k=__copy->__inc_eltids_k;__privtrans->__inc_dist_k=__copy->__inc_dist_k;__privtrans->__inc_dist_nr=__copy->__inc_dist_nr;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;__copy->__nr_size=__privtrans->__nr_size;__copy->__k_size=__privtrans->__k_size;__copy->__mcsize_size=__privtrans->__mcsize_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clusterdistancematrix_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrix_struct *__privtrans = (pdl_clusterdistancematrix_struct *) __tr;
	
	{
	    {register PDL_Indx __k_size = __privtrans->__k_size;
register PDL_Indx __nr_size = __privtrans->__nr_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * clustersizes_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * clustersizes_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * eltids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * eltids_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[6])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_eltids_mcsize = __privtrans->__inc_eltids_mcsize;
register PDL_Indx __inc_eltids_k = __privtrans->__inc_eltids_k;
register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_clustersizes_k = __privtrans->__inc_clustersizes_k;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_dist_k = __privtrans->__inc_dist_k;
register PDL_Indx __inc_dist_nr = __privtrans->__inc_dist_nr;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    **eltidspp = (int    **)pp_alloc(__privtrans->__k_size);
  int    transpose=0;
  int    rowid;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	clustersizes_datap += __offsp[4];
	eltids_datap += __offsp[5];
	dist_datap += __offsp[6];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,clustersizes_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,eltids_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,dist_datap += __tinc1_6 - __tinc0_6 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,clustersizes_datap += __tinc0_4
			,eltids_datap += __tinc0_5
			,dist_datap += __tinc0_6
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    p2pp_int(__privtrans->__k_size,   __privtrans->__mcsize_size, eltids_datap, eltidspp);
        {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      rowid = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
        (dist_datap)[0+(__inc_dist_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_dist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  1,        (clustersizes_datap)[0+(__inc_clustersizes_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ,
                                  &rowid,   eltidspp[k],
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
      }} PDL_COMMENT("Close k")
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	clustersizes_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	eltids_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	dist_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (eltidspp) free(eltidspp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clusterdistancematrix_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrix_struct *__privtrans = (pdl_clusterdistancematrix_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_clusterdistancematrix_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clusterdistancematrix_vtable = {
		0,0, 6, 7, pdl_clusterdistancematrix_vtable_flags,
		pdl_clusterdistancematrix_redodims, pdl_clusterdistancematrix_readdata, NULL,
		pdl_clusterdistancematrix_free,NULL,NULL,pdl_clusterdistancematrix_copy,
		sizeof(pdl_clusterdistancematrix_struct),"pdl_clusterdistancematrix_vtable"
	 };

typedef struct pdl_clusterdistancematrixenc_struct {
		PDL_TRANS_START(8);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_clens1_k1;PDL_Indx  __inc_crowids1_nc1;PDL_Indx  __inc_clens2_k2;PDL_Indx  __inc_crowids2_nc2;PDL_Indx  __inc_dist_k1;PDL_Indx  __inc_dist_k2;PDL_Indx  __k1_size;PDL_Indx  __nc1_size;PDL_Indx  __k2_size;PDL_Indx  __n_size;PDL_Indx  __nc2_size;PDL_Indx  __d_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clusterdistancematrixenc_struct;

void pdl_clusterdistancematrixenc_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrixenc_struct *__privtrans = (pdl_clusterdistancematrixenc_struct *) __tr;
	
	{
	    PDL_Indx __creating[8];
__privtrans->__k1_size = -1;
__privtrans->__nc1_size = -1;
__privtrans->__k2_size = -1;
__privtrans->__n_size = -1;
__privtrans->__nc2_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[7]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","clens1","crowids1","clens2","crowids2","dist"};
		static PDL_Indx __realdims[] = {2,2,1,1,1,1,1,2};
		static char __funcname[] = "PDL::Cluster::clusterdistancematrixenc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 8
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,8,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__k1_size <= 1) __privtrans->__k1_size = 1;
   }
   if(__privtrans->__k1_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__k1_size == 1)) {
      __privtrans->__k1_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__k1_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__nc1_size <= 1) __privtrans->__nc1_size = 1;
   }
   if(__privtrans->__nc1_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nc1_size == 1)) {
      __privtrans->__nc1_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nc1_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__k2_size <= 1) __privtrans->__k2_size = 1;
   }
   if(__privtrans->__k2_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__k2_size == 1)) {
      __privtrans->__k2_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__k2_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[6]))->ndims < 1) {
      if (((__privtrans->pdls[6]))->ndims < 1 && __privtrans->__nc2_size <= 1) __privtrans->__nc2_size = 1;
   }
   if(__privtrans->__nc2_size == -1 || (((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__nc2_size == 1)) {
      __privtrans->__nc2_size = ((__privtrans->pdls[6]))->dims[0];
   } else if(((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__nc2_size != ((__privtrans->pdls[6]))->dims[0]) {
      if(((__privtrans->pdls[6]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[6])));
if(!__creating[7]) {
   if(((__privtrans->pdls[7]))->ndims < 2) {
      if (((__privtrans->pdls[7]))->ndims < 1 && __privtrans->__k1_size <= 1) __privtrans->__k1_size = 1;
      if (((__privtrans->pdls[7]))->ndims < 2 && __privtrans->__k2_size <= 1) __privtrans->__k2_size = 1;
   }
   if(__privtrans->__k1_size == -1 || (((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__k1_size == 1)) {
      __privtrans->__k1_size = ((__privtrans->pdls[7]))->dims[0];
   } else if(((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__k1_size != ((__privtrans->pdls[7]))->dims[0]) {
      if(((__privtrans->pdls[7]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k2_size == -1 || (((__privtrans->pdls[7]))->ndims > 1 && __privtrans->__k2_size == 1)) {
      __privtrans->__k2_size = ((__privtrans->pdls[7]))->dims[1];
   } else if(((__privtrans->pdls[7]))->ndims > 1 && __privtrans->__k2_size != ((__privtrans->pdls[7]))->dims[1]) {
      if(((__privtrans->pdls[7]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancematrixenc:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k1_size;dims[1] = __privtrans->__k2_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,7,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[7] && 
     __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[7]->hdrsv != hdrp ){
	 if( __privtrans->pdls[7]->hdrsv && __privtrans->pdls[7]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[7]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[7]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[7]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_clens1_k1 = 0; else
		 __privtrans->__inc_clens1_k1 = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_crowids1_nc1 = 0; else
		 __privtrans->__inc_crowids1_nc1 = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_clens2_k2 = 0; else
		 __privtrans->__inc_clens2_k2 = PDL_REPRINC(__privtrans->pdls[5],0);if(__privtrans->pdls[6]->ndims <= 0 || __privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_crowids2_nc2 = 0; else
		 __privtrans->__inc_crowids2_nc2 = __privtrans->pdls[6]->dimincs[0];if(__privtrans->pdls[7]->ndims <= 0 || __privtrans->pdls[7]->dims[0] <= 1)
		  __privtrans->__inc_dist_k1 = 0; else
		 __privtrans->__inc_dist_k1 = PDL_REPRINC(__privtrans->pdls[7],0);if(__privtrans->pdls[7]->ndims <= 1 || __privtrans->pdls[7]->dims[1] <= 1)
		  __privtrans->__inc_dist_k2 = 0; else
		 __privtrans->__inc_dist_k2 = PDL_REPRINC(__privtrans->pdls[7],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clusterdistancematrixenc_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrixenc_struct *__privtrans = (pdl_clusterdistancematrixenc_struct *) __tr;
	
	{
	    pdl_clusterdistancematrixenc_struct *__copy = malloc(sizeof(pdl_clusterdistancematrixenc_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_clens1_k1=__copy->__inc_clens1_k1;__privtrans->__inc_crowids1_nc1=__copy->__inc_crowids1_nc1;__privtrans->__inc_clens2_k2=__copy->__inc_clens2_k2;__privtrans->__inc_crowids2_nc2=__copy->__inc_crowids2_nc2;__privtrans->__inc_dist_k1=__copy->__inc_dist_k1;__privtrans->__inc_dist_k2=__copy->__inc_dist_k2;__copy->__k1_size=__privtrans->__k1_size;__copy->__nc1_size=__privtrans->__nc1_size;__copy->__k2_size=__privtrans->__k2_size;__copy->__n_size=__privtrans->__n_size;__copy->__nc2_size=__privtrans->__nc2_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clusterdistancematrixenc_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrixenc_struct *__privtrans = (pdl_clusterdistancematrixenc_struct *) __tr;
	
	{
	    {register PDL_Indx __k1_size = __privtrans->__k1_size;
register PDL_Indx __k2_size = __privtrans->__k2_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * clens1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * clens1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * clens2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * clens2_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * dist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * dist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clens1_k1 = __privtrans->__inc_clens1_k1;
register PDL_Indx __inc_clens2_k2 = __privtrans->__inc_clens2_k2;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_dist_k1 = __privtrans->__inc_dist_k1;
register PDL_Indx __inc_dist_k2 = __privtrans->__inc_dist_k2;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
  int    *crowids1p, *crowids2p;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	clens1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	clens2_datap += __offsp[5];
	crowids2_datap += __offsp[6];
	dist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,clens1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,clens2_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,crowids2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,dist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,clens1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,clens2_datap += __tinc0_5
			,crowids2_datap += __tinc0_6
			,dist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
    crowids1p = crowids1_datap;
        {PDL_COMMENT("Open k1") register PDL_Indx k1;
			for(k1=0; k1<(__k1_size); k1++) {
      crowids2p = crowids2_datap;
      {PDL_COMMENT("Open k2") register PDL_Indx k2;
			for(k2=0; k2<(__k2_size); k2++) {
        (dist_datap)[0+(__inc_dist_k1*PP_INDTERM(__privtrans->__k1_size, k1))+(__inc_dist_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                  (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") , (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ,
                                  crowids1p, crowids2p,
                                  *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        crowids2p += (clens2_datap)[0+(__inc_clens2_k2*PP_INDTERM(__privtrans->__k2_size, k2))] PDL_COMMENT("ACCESS()") ;
      }} PDL_COMMENT("Close k2")
      crowids1p += (clens1_datap)[0+(__inc_clens1_k1*PP_INDTERM(__privtrans->__k1_size, k1))] PDL_COMMENT("ACCESS()") ;
    }} PDL_COMMENT("Close k1")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	clens1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	clens2_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	crowids2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	dist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clusterdistancematrixenc_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancematrixenc_struct *__privtrans = (pdl_clusterdistancematrixenc_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_clusterdistancematrixenc_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clusterdistancematrixenc_vtable = {
		0,0, 7, 8, pdl_clusterdistancematrixenc_vtable_flags,
		pdl_clusterdistancematrixenc_redodims, pdl_clusterdistancematrixenc_readdata, NULL,
		pdl_clusterdistancematrixenc_free,NULL,NULL,pdl_clusterdistancematrixenc_copy,
		sizeof(pdl_clusterdistancematrixenc_struct),"pdl_clusterdistancematrixenc_vtable"
	 };

typedef struct pdl_clusterdistancesenc_struct {
		PDL_TRANS_START(10);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_coffsets1_k1;PDL_Indx  __inc_crowids1_nc1;PDL_Indx  __inc_cwhich1_ncmps;PDL_Indx  __inc_coffsets2_k2;PDL_Indx  __inc_crowids2_nc2;PDL_Indx  __inc_cwhich2_ncmps;PDL_Indx  __inc_dists_ncmps;PDL_Indx  __k2_size;PDL_Indx  __nc2_size;PDL_Indx  __ncmps_size;PDL_Indx  __n_size;PDL_Indx  __d_size;PDL_Indx  __k1_size;PDL_Indx  __nc1_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_clusterdistancesenc_struct;

void pdl_clusterdistancesenc_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancesenc_struct *__privtrans = (pdl_clusterdistancesenc_struct *) __tr;
	
	{
	    PDL_Indx __creating[10];
__privtrans->__k2_size = -1;
__privtrans->__nc2_size = -1;
__privtrans->__ncmps_size = -1;
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__privtrans->__k1_size = -1;
__privtrans->__nc1_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = 0;
__creating[7] = 0;
__creating[8] = 0;
__creating[9] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[9]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","coffsets1","crowids1","cwhich1","coffsets2","crowids2","cwhich2","dists"};
		static PDL_Indx __realdims[] = {2,2,1,1,1,1,1,1,1,1};
		static char __funcname[] = "PDL::Cluster::clusterdistancesenc";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 10
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,10,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__k1_size <= 1) __privtrans->__k1_size = 1;
   }
   if(__privtrans->__k1_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__k1_size == 1)) {
      __privtrans->__k1_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__k1_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 1) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__nc1_size <= 1) __privtrans->__nc1_size = 1;
   }
   if(__privtrans->__nc1_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nc1_size == 1)) {
      __privtrans->__nc1_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__nc1_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
   if(((__privtrans->pdls[5]))->ndims < 1) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__ncmps_size <= 1) __privtrans->__ncmps_size = 1;
   }
   if(__privtrans->__ncmps_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__ncmps_size == 1)) {
      __privtrans->__ncmps_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__ncmps_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[6]))->ndims < 1) {
      if (((__privtrans->pdls[6]))->ndims < 1 && __privtrans->__k2_size <= 1) __privtrans->__k2_size = 1;
   }
   if(__privtrans->__k2_size == -1 || (((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__k2_size == 1)) {
      __privtrans->__k2_size = ((__privtrans->pdls[6]))->dims[0];
   } else if(((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__k2_size != ((__privtrans->pdls[6]))->dims[0]) {
      if(((__privtrans->pdls[6]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[7]))->ndims < 1) {
      if (((__privtrans->pdls[7]))->ndims < 1 && __privtrans->__nc2_size <= 1) __privtrans->__nc2_size = 1;
   }
   if(__privtrans->__nc2_size == -1 || (((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__nc2_size == 1)) {
      __privtrans->__nc2_size = ((__privtrans->pdls[7]))->dims[0];
   } else if(((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__nc2_size != ((__privtrans->pdls[7]))->dims[0]) {
      if(((__privtrans->pdls[7]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[7])));
   if(((__privtrans->pdls[8]))->ndims < 1) {
      if (((__privtrans->pdls[8]))->ndims < 1 && __privtrans->__ncmps_size <= 1) __privtrans->__ncmps_size = 1;
   }
   if(__privtrans->__ncmps_size == -1 || (((__privtrans->pdls[8]))->ndims > 0 && __privtrans->__ncmps_size == 1)) {
      __privtrans->__ncmps_size = ((__privtrans->pdls[8]))->dims[0];
   } else if(((__privtrans->pdls[8]))->ndims > 0 && __privtrans->__ncmps_size != ((__privtrans->pdls[8]))->dims[0]) {
      if(((__privtrans->pdls[8]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
if(!__creating[9]) {
   if(((__privtrans->pdls[9]))->ndims < 1) {
      if (((__privtrans->pdls[9]))->ndims < 1 && __privtrans->__ncmps_size <= 1) __privtrans->__ncmps_size = 1;
   }
   if(__privtrans->__ncmps_size == -1 || (((__privtrans->pdls[9]))->ndims > 0 && __privtrans->__ncmps_size == 1)) {
      __privtrans->__ncmps_size = ((__privtrans->pdls[9]))->dims[0];
   } else if(((__privtrans->pdls[9]))->ndims > 0 && __privtrans->__ncmps_size != ((__privtrans->pdls[9]))->dims[0]) {
      if(((__privtrans->pdls[9]))->dims[0] != 1) {
         PDL->pdl_barf("Error in clusterdistancesenc:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__ncmps_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,9,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[8]->hdrsv &&
	 (__privtrans->pdls[8]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[8]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[8]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[9] && 
     __privtrans->pdls[9]->hdrsv &&
	 (__privtrans->pdls[9]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[9]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[9]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[9]->hdrsv != hdrp ){
	 if( __privtrans->pdls[9]->hdrsv && __privtrans->pdls[9]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[9]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[9]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[9]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_coffsets1_k1 = 0; else
		 __privtrans->__inc_coffsets1_k1 = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_crowids1_nc1 = 0; else
		 __privtrans->__inc_crowids1_nc1 = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_cwhich1_ncmps = 0; else
		 __privtrans->__inc_cwhich1_ncmps = PDL_REPRINC(__privtrans->pdls[5],0);if(__privtrans->pdls[6]->ndims <= 0 || __privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_coffsets2_k2 = 0; else
		 __privtrans->__inc_coffsets2_k2 = PDL_REPRINC(__privtrans->pdls[6],0);if(__privtrans->pdls[7]->ndims <= 0 || __privtrans->pdls[7]->dims[0] <= 1)
		  __privtrans->__inc_crowids2_nc2 = 0; else
		 __privtrans->__inc_crowids2_nc2 = __privtrans->pdls[7]->dimincs[0];if(__privtrans->pdls[8]->ndims <= 0 || __privtrans->pdls[8]->dims[0] <= 1)
		  __privtrans->__inc_cwhich2_ncmps = 0; else
		 __privtrans->__inc_cwhich2_ncmps = PDL_REPRINC(__privtrans->pdls[8],0);if(__privtrans->pdls[9]->ndims <= 0 || __privtrans->pdls[9]->dims[0] <= 1)
		  __privtrans->__inc_dists_ncmps = 0; else
		 __privtrans->__inc_dists_ncmps = PDL_REPRINC(__privtrans->pdls[9],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_clusterdistancesenc_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancesenc_struct *__privtrans = (pdl_clusterdistancesenc_struct *) __tr;
	
	{
	    pdl_clusterdistancesenc_struct *__copy = malloc(sizeof(pdl_clusterdistancesenc_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_coffsets1_k1=__copy->__inc_coffsets1_k1;__privtrans->__inc_crowids1_nc1=__copy->__inc_crowids1_nc1;__privtrans->__inc_cwhich1_ncmps=__copy->__inc_cwhich1_ncmps;__privtrans->__inc_coffsets2_k2=__copy->__inc_coffsets2_k2;__privtrans->__inc_crowids2_nc2=__copy->__inc_crowids2_nc2;__privtrans->__inc_cwhich2_ncmps=__copy->__inc_cwhich2_ncmps;__privtrans->__inc_dists_ncmps=__copy->__inc_dists_ncmps;__copy->__k2_size=__privtrans->__k2_size;__copy->__nc2_size=__privtrans->__nc2_size;__copy->__ncmps_size=__privtrans->__ncmps_size;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;__copy->__k1_size=__privtrans->__k1_size;__copy->__nc1_size=__privtrans->__nc1_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_clusterdistancesenc_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancesenc_struct *__privtrans = (pdl_clusterdistancesenc_struct *) __tr;
	
	{
	    {register PDL_Indx __ncmps_size = __privtrans->__ncmps_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * coffsets1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * coffsets1_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Long * crowids1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * crowids1_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

	PDL_Long * cwhich1_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cwhich1_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * coffsets2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * coffsets2_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Long * crowids2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Long * crowids2_physdatap = ((PDL_Long *)((__privtrans->pdls[7])->data));

	PDL_Long * cwhich2_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[8]),(__privtrans->vtable->per_pdl_flags[8]))));
	PDL_Long * cwhich2_physdatap = ((PDL_Long *)((__privtrans->pdls[8])->data));

	PDL_Double * dists_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[9]),(__privtrans->vtable->per_pdl_flags[9]))));
	PDL_Double * dists_physdatap = ((PDL_Double *)((__privtrans->pdls[9])->data));

{register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_crowids1_nc1 = __privtrans->__inc_crowids1_nc1;
register PDL_Indx __inc_coffsets1_k1 = __privtrans->__inc_coffsets1_k1;
register PDL_Indx __inc_dists_ncmps = __privtrans->__inc_dists_ncmps;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_cwhich1_ncmps = __privtrans->__inc_cwhich1_ncmps;
register PDL_Indx __inc_cwhich2_ncmps = __privtrans->__inc_cwhich2_ncmps;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_coffsets2_k2 = __privtrans->__inc_coffsets2_k2;
register PDL_Indx __inc_crowids2_nc2 = __privtrans->__inc_crowids2_nc2;


  double **datapp   = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp   = (int    **)pp_alloc(__privtrans->__n_size);
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc0_8 = __privtrans->__pdlthread.incs[8];
	register PDL_Indx __tinc0_9 = __privtrans->__pdlthread.incs[9];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	register PDL_Indx __tinc1_8 = __privtrans->__pdlthread.incs[__tnpdls+8];
	register PDL_Indx __tinc1_9 = __privtrans->__pdlthread.incs[__tnpdls+9];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	coffsets1_datap += __offsp[3];
	crowids1_datap += __offsp[4];
	cwhich1_datap += __offsp[5];
	coffsets2_datap += __offsp[6];
	crowids2_datap += __offsp[7];
	cwhich2_datap += __offsp[8];
	dists_datap += __offsp[9];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,coffsets1_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,crowids1_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cwhich1_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,coffsets2_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,crowids2_datap += __tinc1_7 - __tinc0_7 * __tdims0
			,cwhich2_datap += __tinc1_8 - __tinc0_8 * __tdims0
			,dists_datap += __tinc1_9 - __tinc0_9 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,coffsets1_datap += __tinc0_3
			,crowids1_datap += __tinc0_4
			,cwhich1_datap += __tinc0_5
			,coffsets2_datap += __tinc0_6
			,crowids2_datap += __tinc0_7
			,cwhich2_datap += __tinc0_8
			,dists_datap += __tinc0_9
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    p2pp_dbl(__privtrans->__n_size,   __privtrans->__d_size,   data_datap, datapp);
    p2pp_int(__privtrans->__n_size,   __privtrans->__d_size,   mask_datap, maskpp);
        {PDL_COMMENT("Open ncmps") register PDL_Indx ncmps;
			for(ncmps=0; ncmps<(__ncmps_size); ncmps++) {
      int c1 = (cwhich1_datap)[0+(__inc_cwhich1_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int c2 = (cwhich2_datap)[0+(__inc_cwhich2_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()") ;
      int succ_c1=c1+1;
      int succ_c2=c2+1;
      int beg1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, c1))] PDL_COMMENT("ACCESS()") ;
      int beg2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, c2))] PDL_COMMENT("ACCESS()") ;
      int len1 = (coffsets1_datap)[0+(__inc_coffsets1_k1*PP_INDTERM(__privtrans->__k1_size, succ_c1))] PDL_COMMENT("ACCESS()")  - beg1;
      int len2 = (coffsets2_datap)[0+(__inc_coffsets2_k2*PP_INDTERM(__privtrans->__k2_size, succ_c2))] PDL_COMMENT("ACCESS()")  - beg2;
      int *crowids1p = crowids1_datap + beg1;
      int *crowids2p = crowids2_datap + beg2;

      (dists_datap)[0+(__inc_dists_ncmps*PP_INDTERM(__privtrans->__ncmps_size, ncmps))] PDL_COMMENT("ACCESS()")  = clusterdistance(__privtrans->__n_size, __privtrans->__d_size, datapp, maskpp, weight_datap,
                                 len1,      len2,
                                 crowids1p, crowids2p,
                                 *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
    }} PDL_COMMENT("Close ncmps")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	coffsets1_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	crowids1_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cwhich1_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	coffsets2_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	crowids2_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	cwhich2_datap -= __tinc1_8 * __tdims1 + __offsp[8];
	dists_datap -= __tinc1_9 * __tdims1 + __offsp[9];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
  /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_clusterdistancesenc_free(pdl_trans *__tr ) {
	int __dim;
	pdl_clusterdistancesenc_struct *__privtrans = (pdl_clusterdistancesenc_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_clusterdistancesenc_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_clusterdistancesenc_vtable = {
		0,0, 9, 10, pdl_clusterdistancesenc_vtable_flags,
		pdl_clusterdistancesenc_redodims, pdl_clusterdistancesenc_readdata, NULL,
		pdl_clusterdistancesenc_free,NULL,NULL,pdl_clusterdistancesenc_copy,
		sizeof(pdl_clusterdistancesenc_struct),"pdl_clusterdistancesenc_vtable"
	 };

typedef struct pdl_getclusterwsum_struct {
		PDL_TRANS_START(5);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_clusterwts_k;PDL_Indx  __inc_clusterwts_n;PDL_Indx  __inc_cdata_d;PDL_Indx  __inc_cdata_k;PDL_Indx  __inc_cmask_d;PDL_Indx  __inc_cmask_k;PDL_Indx  __k_size;PDL_Indx  __n_size;PDL_Indx  __d_size;
		
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_getclusterwsum_struct;

void pdl_getclusterwsum_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_getclusterwsum_struct *__privtrans = (pdl_getclusterwsum_struct *) __tr;
	
	{
	    PDL_Indx __creating[5];
__privtrans->__k_size = -1;
__privtrans->__n_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[3]);
__creating[4] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[4]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));

{register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","clusterwts","cdata","cmask"};
		static PDL_Indx __realdims[] = {2,2,2,2,2};
		static char __funcname[] = "PDL::Cluster::getclusterwsum";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 5
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,5,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[2]))->ndims < 2) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
      if (((__privtrans->pdls[2]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[1];
   } else if(((__privtrans->pdls[2]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[1]) {
      if(((__privtrans->pdls[2]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
if(!__creating[3]) {
   if(((__privtrans->pdls[3]))->ndims < 2) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[3]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[3]))->dims[1];
   } else if(((__privtrans->pdls[3]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[3]))->dims[1]) {
      if(((__privtrans->pdls[3]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;dims[1] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,3,dims,0);
}if(!__creating[4]) {
   if(((__privtrans->pdls[4]))->ndims < 2) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[4]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[4]))->dims[1];
   } else if(((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[4]))->dims[1]) {
      if(((__privtrans->pdls[4]))->dims[1] != 1) {
         PDL->pdl_barf("Error in getclusterwsum:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[3]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__d_size;dims[1] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,4,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[3] && 
     __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[4] && 
     __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[3]->hdrsv != hdrp ){
	 if( __privtrans->pdls[3]->hdrsv && __privtrans->pdls[3]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[3]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[3]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[3]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[4]->hdrsv != hdrp ){
	 if( __privtrans->pdls[4]->hdrsv && __privtrans->pdls[4]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[4]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[4]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[4]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = PDL_REPRINC(__privtrans->pdls[0],1);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = PDL_REPRINC(__privtrans->pdls[1],1);if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_clusterwts_k = 0; else
		 __privtrans->__inc_clusterwts_k = PDL_REPRINC(__privtrans->pdls[2],0);if(__privtrans->pdls[2]->ndims <= 1 || __privtrans->pdls[2]->dims[1] <= 1)
		  __privtrans->__inc_clusterwts_n = 0; else
		 __privtrans->__inc_clusterwts_n = PDL_REPRINC(__privtrans->pdls[2],1);if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_cdata_d = 0; else
		 __privtrans->__inc_cdata_d = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[3]->ndims <= 1 || __privtrans->pdls[3]->dims[1] <= 1)
		  __privtrans->__inc_cdata_k = 0; else
		 __privtrans->__inc_cdata_k = PDL_REPRINC(__privtrans->pdls[3],1);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_cmask_d = 0; else
		 __privtrans->__inc_cmask_d = PDL_REPRINC(__privtrans->pdls[4],0);if(__privtrans->pdls[4]->ndims <= 1 || __privtrans->pdls[4]->dims[1] <= 1)
		  __privtrans->__inc_cmask_k = 0; else
		 __privtrans->__inc_cmask_k = PDL_REPRINC(__privtrans->pdls[4],1); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_getclusterwsum_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_getclusterwsum_struct *__privtrans = (pdl_getclusterwsum_struct *) __tr;
	
	{
	    pdl_getclusterwsum_struct *__copy = malloc(sizeof(pdl_getclusterwsum_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_clusterwts_k=__copy->__inc_clusterwts_k;__privtrans->__inc_clusterwts_n=__copy->__inc_clusterwts_n;__privtrans->__inc_cdata_d=__copy->__inc_cdata_d;__privtrans->__inc_cdata_k=__copy->__inc_cdata_k;__privtrans->__inc_cmask_d=__copy->__inc_cmask_d;__privtrans->__inc_cmask_k=__copy->__inc_cmask_k;__copy->__k_size=__privtrans->__k_size;__copy->__n_size=__privtrans->__n_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_getclusterwsum_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_getclusterwsum_struct *__privtrans = (pdl_getclusterwsum_struct *) __tr;
	
	{
	    {register PDL_Indx __d_size = __privtrans->__d_size;
register PDL_Indx __k_size = __privtrans->__k_size;
register PDL_Indx __n_size = __privtrans->__n_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * clusterwts_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * clusterwts_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[3])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[4])->data));


	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	clusterwts_datap += __offsp[2];
	cdata_datap += __offsp[3];
	cmask_datap += __offsp[4];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,clusterwts_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,cdata_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cmask_datap += __tinc1_4 - __tinc0_4 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,clusterwts_datap += __tinc0_2
			,cdata_datap += __tinc0_3
			,cmask_datap += __tinc0_4
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal."){register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterwts_k = __privtrans->__inc_clusterwts_k;
register PDL_Indx __inc_clusterwts_n = __privtrans->__inc_clusterwts_n;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;


 int rid, rwt, cmaskdk;
 {PDL_COMMENT("Open d") register PDL_Indx d;
			for(d=0; d<(__d_size); d++) {
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     cmaskdk = 0;
     {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
       if ((mask_datap)[0+(__inc_mask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_mask_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ) {
         cmaskdk = 1;
	 (cdata_datap)[0+(__inc_cdata_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cdata_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  += (clusterwts_datap)[0+(__inc_clusterwts_k*PP_INDTERM(__privtrans->__k_size, k))+(__inc_clusterwts_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  * (data_datap)[0+(__inc_data_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_data_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
       }
     }} PDL_COMMENT("Close n")
     (cmask_datap)[0+(__inc_cmask_d*PP_INDTERM(__privtrans->__d_size, d))+(__inc_cmask_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = cmaskdk;
   }} PDL_COMMENT("Close k")
 }} PDL_COMMENT("Close d")

}
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	clusterwts_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	cdata_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cmask_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_getclusterwsum_free(pdl_trans *__tr ) {
	int __dim;
	pdl_getclusterwsum_struct *__privtrans = (pdl_getclusterwsum_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_getclusterwsum_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_getclusterwsum_vtable = {
		0,0, 3, 5, pdl_getclusterwsum_vtable_flags,
		pdl_getclusterwsum_redodims, pdl_getclusterwsum_readdata, NULL,
		pdl_getclusterwsum_free,NULL,NULL,pdl_getclusterwsum_copy,
		sizeof(pdl_getclusterwsum_struct),"pdl_getclusterwsum_vtable"
	 };

typedef struct pdl_attachtonearest_struct {
		PDL_TRANS_START(8);
		pdl_thread  __pdlthread;PDL_Indx  __inc_data_d;PDL_Indx  __inc_data_n;PDL_Indx  __inc_mask_d;PDL_Indx  __inc_mask_n;PDL_Indx  __inc_weight_d;PDL_Indx  __inc_rowids_nr;PDL_Indx  __inc_cdata_d;PDL_Indx  __inc_cdata_k;PDL_Indx  __inc_cmask_d;PDL_Indx  __inc_cmask_k;PDL_Indx  __inc_clusterids_nr;PDL_Indx  __inc_cdist_nr;PDL_Indx  __n_size;PDL_Indx  __nr_size;PDL_Indx  __k_size;PDL_Indx  __d_size;
		char  *distFlag;char  *methodFlag;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_attachtonearest_struct;

void pdl_attachtonearest_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_attachtonearest_struct *__privtrans = (pdl_attachtonearest_struct *) __tr;
	
	{
	    PDL_Indx __creating[8];
__privtrans->__n_size = -1;
__privtrans->__nr_size = -1;
__privtrans->__k_size = -1;
__privtrans->__d_size = -1;
__creating[0] = 0;
__creating[1] = 0;
__creating[2] = 0;
__creating[3] = 0;
__creating[4] = 0;
__creating[5] = 0;
__creating[6] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[6]);
__creating[7] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[7]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"data","mask","weight","rowids","cdata","cmask","clusterids","cdist"};
		static PDL_Indx __realdims[] = {2,2,1,1,2,2,1,1};
		static char __funcname[] = "PDL::Cluster::attachtonearest";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 8
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,8,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 2) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[0]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[1];
   } else if(((__privtrans->pdls[0]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[1]) {
      if(((__privtrans->pdls[0]))->dims[1] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[0])));
   if(((__privtrans->pdls[1]))->ndims < 2) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[1]))->ndims < 2 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[1];
   } else if(((__privtrans->pdls[1]))->ndims > 1 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[1]) {
      if(((__privtrans->pdls[1]))->dims[1] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[1])));
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[2])));
   if(((__privtrans->pdls[3]))->ndims < 1) {
      if (((__privtrans->pdls[3]))->ndims < 1 && __privtrans->__nr_size <= 1) __privtrans->__nr_size = 1;
   }
   if(__privtrans->__nr_size == -1 || (((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nr_size == 1)) {
      __privtrans->__nr_size = ((__privtrans->pdls[3]))->dims[0];
   } else if(((__privtrans->pdls[3]))->ndims > 0 && __privtrans->__nr_size != ((__privtrans->pdls[3]))->dims[0]) {
      if(((__privtrans->pdls[3]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
   if(((__privtrans->pdls[4]))->ndims < 2) {
      if (((__privtrans->pdls[4]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[4]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[4]))->dims[0];
   } else if(((__privtrans->pdls[4]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[4]))->dims[0]) {
      if(((__privtrans->pdls[4]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[4]))->dims[1];
   } else if(((__privtrans->pdls[4]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[4]))->dims[1]) {
      if(((__privtrans->pdls[4]))->dims[1] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[4])));
   if(((__privtrans->pdls[5]))->ndims < 2) {
      if (((__privtrans->pdls[5]))->ndims < 1 && __privtrans->__d_size <= 1) __privtrans->__d_size = 1;
      if (((__privtrans->pdls[5]))->ndims < 2 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__d_size == -1 || (((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__d_size == 1)) {
      __privtrans->__d_size = ((__privtrans->pdls[5]))->dims[0];
   } else if(((__privtrans->pdls[5]))->ndims > 0 && __privtrans->__d_size != ((__privtrans->pdls[5]))->dims[0]) {
      if(((__privtrans->pdls[5]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[5]))->ndims > 1 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[5]))->dims[1];
   } else if(((__privtrans->pdls[5]))->ndims > 1 && __privtrans->__k_size != ((__privtrans->pdls[5]))->dims[1]) {
      if(((__privtrans->pdls[5]))->dims[1] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
PDL->make_physical(((__privtrans->pdls[5])));
if(!__creating[6]) {
   if(((__privtrans->pdls[6]))->ndims < 1) {
      if (((__privtrans->pdls[6]))->ndims < 1 && __privtrans->__nr_size <= 1) __privtrans->__nr_size = 1;
   }
   if(__privtrans->__nr_size == -1 || (((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__nr_size == 1)) {
      __privtrans->__nr_size = ((__privtrans->pdls[6]))->dims[0];
   } else if(((__privtrans->pdls[6]))->ndims > 0 && __privtrans->__nr_size != ((__privtrans->pdls[6]))->dims[0]) {
      if(((__privtrans->pdls[6]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__nr_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,6,dims,0);
}if(!__creating[7]) {
   if(((__privtrans->pdls[7]))->ndims < 1) {
      if (((__privtrans->pdls[7]))->ndims < 1 && __privtrans->__nr_size <= 1) __privtrans->__nr_size = 1;
   }
   if(__privtrans->__nr_size == -1 || (((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__nr_size == 1)) {
      __privtrans->__nr_size = ((__privtrans->pdls[7]))->dims[0];
   } else if(((__privtrans->pdls[7]))->ndims > 0 && __privtrans->__nr_size != ((__privtrans->pdls[7]))->dims[0]) {
      if(((__privtrans->pdls[7]))->dims[0] != 1) {
         PDL->pdl_barf("Error in attachtonearest:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__nr_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,7,dims,0);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[3]->hdrsv &&
	 (__privtrans->pdls[3]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[3]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[3]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[4]->hdrsv &&
	 (__privtrans->pdls[4]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[4]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[4]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	      __privtrans->pdls[5]->hdrsv &&
	 (__privtrans->pdls[5]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[5]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[5]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[6] && 
     __privtrans->pdls[6]->hdrsv &&
	 (__privtrans->pdls[6]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[6]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[6]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[7] && 
     __privtrans->pdls[7]->hdrsv &&
	 (__privtrans->pdls[7]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[7]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[7]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[6]->hdrsv != hdrp ){
	 if( __privtrans->pdls[6]->hdrsv && __privtrans->pdls[6]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[6]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[6]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[6]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[7]->hdrsv != hdrp ){
	 if( __privtrans->pdls[7]->hdrsv && __privtrans->pdls[7]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[7]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[7]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[7]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_data_d = 0; else
		 __privtrans->__inc_data_d = __privtrans->pdls[0]->dimincs[0];if(__privtrans->pdls[0]->ndims <= 1 || __privtrans->pdls[0]->dims[1] <= 1)
		  __privtrans->__inc_data_n = 0; else
		 __privtrans->__inc_data_n = __privtrans->pdls[0]->dimincs[1];if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_mask_d = 0; else
		 __privtrans->__inc_mask_d = __privtrans->pdls[1]->dimincs[0];if(__privtrans->pdls[1]->ndims <= 1 || __privtrans->pdls[1]->dims[1] <= 1)
		  __privtrans->__inc_mask_n = 0; else
		 __privtrans->__inc_mask_n = __privtrans->pdls[1]->dimincs[1];if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_weight_d = 0; else
		 __privtrans->__inc_weight_d = __privtrans->pdls[2]->dimincs[0];if(__privtrans->pdls[3]->ndims <= 0 || __privtrans->pdls[3]->dims[0] <= 1)
		  __privtrans->__inc_rowids_nr = 0; else
		 __privtrans->__inc_rowids_nr = PDL_REPRINC(__privtrans->pdls[3],0);if(__privtrans->pdls[4]->ndims <= 0 || __privtrans->pdls[4]->dims[0] <= 1)
		  __privtrans->__inc_cdata_d = 0; else
		 __privtrans->__inc_cdata_d = __privtrans->pdls[4]->dimincs[0];if(__privtrans->pdls[4]->ndims <= 1 || __privtrans->pdls[4]->dims[1] <= 1)
		  __privtrans->__inc_cdata_k = 0; else
		 __privtrans->__inc_cdata_k = __privtrans->pdls[4]->dimincs[1];if(__privtrans->pdls[5]->ndims <= 0 || __privtrans->pdls[5]->dims[0] <= 1)
		  __privtrans->__inc_cmask_d = 0; else
		 __privtrans->__inc_cmask_d = __privtrans->pdls[5]->dimincs[0];if(__privtrans->pdls[5]->ndims <= 1 || __privtrans->pdls[5]->dims[1] <= 1)
		  __privtrans->__inc_cmask_k = 0; else
		 __privtrans->__inc_cmask_k = __privtrans->pdls[5]->dimincs[1];if(__privtrans->pdls[6]->ndims <= 0 || __privtrans->pdls[6]->dims[0] <= 1)
		  __privtrans->__inc_clusterids_nr = 0; else
		 __privtrans->__inc_clusterids_nr = PDL_REPRINC(__privtrans->pdls[6],0);if(__privtrans->pdls[7]->ndims <= 0 || __privtrans->pdls[7]->dims[0] <= 1)
		  __privtrans->__inc_cdist_nr = 0; else
		 __privtrans->__inc_cdist_nr = PDL_REPRINC(__privtrans->pdls[7],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_attachtonearest_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_attachtonearest_struct *__privtrans = (pdl_attachtonearest_struct *) __tr;
	
	{
	    pdl_attachtonearest_struct *__copy = malloc(sizeof(pdl_attachtonearest_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->distFlag) = malloc(strlen(__privtrans->distFlag)+1); strcpy(__copy->distFlag,__privtrans->distFlag);;(__copy->methodFlag) = malloc(strlen(__privtrans->methodFlag)+1); strcpy(__copy->methodFlag,__privtrans->methodFlag);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_data_d=__copy->__inc_data_d;__privtrans->__inc_data_n=__copy->__inc_data_n;__privtrans->__inc_mask_d=__copy->__inc_mask_d;__privtrans->__inc_mask_n=__copy->__inc_mask_n;__privtrans->__inc_weight_d=__copy->__inc_weight_d;__privtrans->__inc_rowids_nr=__copy->__inc_rowids_nr;__privtrans->__inc_cdata_d=__copy->__inc_cdata_d;__privtrans->__inc_cdata_k=__copy->__inc_cdata_k;__privtrans->__inc_cmask_d=__copy->__inc_cmask_d;__privtrans->__inc_cmask_k=__copy->__inc_cmask_k;__privtrans->__inc_clusterids_nr=__copy->__inc_clusterids_nr;__privtrans->__inc_cdist_nr=__copy->__inc_cdist_nr;__copy->__n_size=__privtrans->__n_size;__copy->__nr_size=__privtrans->__nr_size;__copy->__k_size=__privtrans->__k_size;__copy->__d_size=__privtrans->__d_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_attachtonearest_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_attachtonearest_struct *__privtrans = (pdl_attachtonearest_struct *) __tr;
	
	{
	    {register PDL_Indx __nr_size = __privtrans->__nr_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_S: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_US: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_L: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_IND: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_LL: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_F: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	} break; case PDL_D: {
	PDL_Double * data_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Double * data_physdatap = ((PDL_Double *)((__privtrans->pdls[0])->data));

	PDL_Long * mask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * mask_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Double * weight_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Double * weight_physdatap = ((PDL_Double *)((__privtrans->pdls[2])->data));

	PDL_Long * rowids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[3]),(__privtrans->vtable->per_pdl_flags[3]))));
	PDL_Long * rowids_physdatap = ((PDL_Long *)((__privtrans->pdls[3])->data));

	PDL_Double * cdata_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[4]),(__privtrans->vtable->per_pdl_flags[4]))));
	PDL_Double * cdata_physdatap = ((PDL_Double *)((__privtrans->pdls[4])->data));

	PDL_Long * cmask_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[5]),(__privtrans->vtable->per_pdl_flags[5]))));
	PDL_Long * cmask_physdatap = ((PDL_Long *)((__privtrans->pdls[5])->data));

	PDL_Long * clusterids_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[6]),(__privtrans->vtable->per_pdl_flags[6]))));
	PDL_Long * clusterids_physdatap = ((PDL_Long *)((__privtrans->pdls[6])->data));

	PDL_Double * cdist_datap = ((PDL_Double *)(PDL_REPRP_TRANS((__privtrans->pdls[7]),(__privtrans->vtable->per_pdl_flags[7]))));
	PDL_Double * cdist_physdatap = ((PDL_Double *)((__privtrans->pdls[7])->data));

{register PDL_Indx __inc_rowids_nr = __privtrans->__inc_rowids_nr;
register PDL_Indx __inc_cdata_d = __privtrans->__inc_cdata_d;
register PDL_Indx __inc_cdata_k = __privtrans->__inc_cdata_k;
register PDL_Indx __inc_cdist_nr = __privtrans->__inc_cdist_nr;
register PDL_Indx __inc_cmask_d = __privtrans->__inc_cmask_d;
register PDL_Indx __inc_cmask_k = __privtrans->__inc_cmask_k;
register PDL_Indx __inc_mask_d = __privtrans->__inc_mask_d;
register PDL_Indx __inc_mask_n = __privtrans->__inc_mask_n;
register PDL_Indx __inc_weight_d = __privtrans->__inc_weight_d;
register PDL_Indx __inc_data_d = __privtrans->__inc_data_d;
register PDL_Indx __inc_data_n = __privtrans->__inc_data_n;
register PDL_Indx __inc_clusterids_nr = __privtrans->__inc_clusterids_nr;


  double **datapp  = (double **)pp_alloc(__privtrans->__n_size);
  int    **maskpp  = (int    **)pp_alloc(__privtrans->__n_size);
  double **cdatapp = (double **)pp_alloc(__privtrans->__k_size);
  int    **cmaskpp = (int    **)pp_alloc(__privtrans->__k_size);
  double *tmpdatapp[2];
  int    *tmpmaskpp[2];
  int    transpose=0;
    
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc0_3 = __privtrans->__pdlthread.incs[3];
	register PDL_Indx __tinc0_4 = __privtrans->__pdlthread.incs[4];
	register PDL_Indx __tinc0_5 = __privtrans->__pdlthread.incs[5];
	register PDL_Indx __tinc0_6 = __privtrans->__pdlthread.incs[6];
	register PDL_Indx __tinc0_7 = __privtrans->__pdlthread.incs[7];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	register PDL_Indx __tinc1_3 = __privtrans->__pdlthread.incs[__tnpdls+3];
	register PDL_Indx __tinc1_4 = __privtrans->__pdlthread.incs[__tnpdls+4];
	register PDL_Indx __tinc1_5 = __privtrans->__pdlthread.incs[__tnpdls+5];
	register PDL_Indx __tinc1_6 = __privtrans->__pdlthread.incs[__tnpdls+6];
	register PDL_Indx __tinc1_7 = __privtrans->__pdlthread.incs[__tnpdls+7];
	data_datap += __offsp[0];
	mask_datap += __offsp[1];
	weight_datap += __offsp[2];
	rowids_datap += __offsp[3];
	cdata_datap += __offsp[4];
	cmask_datap += __offsp[5];
	clusterids_datap += __offsp[6];
	cdist_datap += __offsp[7];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,data_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,mask_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,weight_datap += __tinc1_2 - __tinc0_2 * __tdims0
			,rowids_datap += __tinc1_3 - __tinc0_3 * __tdims0
			,cdata_datap += __tinc1_4 - __tinc0_4 * __tdims0
			,cmask_datap += __tinc1_5 - __tinc0_5 * __tdims0
			,clusterids_datap += __tinc1_6 - __tinc0_6 * __tdims0
			,cdist_datap += __tinc1_7 - __tinc0_7 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,data_datap += __tinc0_0
			,mask_datap += __tinc0_1
			,weight_datap += __tinc0_2
			,rowids_datap += __tinc0_3
			,cdata_datap += __tinc0_4
			,cmask_datap += __tinc0_5
			,clusterids_datap += __tinc0_6
			,cdist_datap += __tinc0_7
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
    int    tmprowid = 0;
    int    tmpctrid = 1;
    int    ni;
    int    ki, kbest;
    double dist, dbest;
        p2pp_dbl(__privtrans->__n_size, __privtrans->__d_size, data_datap, datapp);
    p2pp_int(__privtrans->__n_size, __privtrans->__d_size, mask_datap, maskpp);
    p2pp_dbl(__privtrans->__k_size, __privtrans->__d_size, cdata_datap, cdatapp);
    p2pp_int(__privtrans->__k_size, __privtrans->__d_size, cmask_datap, cmaskpp);
        /*-- loop over all target rows --*/
    {PDL_COMMENT("Open nr") register PDL_Indx nr;
			for(nr=0; nr<(__nr_size); nr++) {
      ni = (rowids_datap)[0+(__inc_rowids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()") ;
      tmpdatapp[tmprowid] = datapp[ni];
      tmpmaskpp[tmprowid] = maskpp[ni];
            /*-- initialize --*/
      tmpdatapp[tmpctrid] = cdatapp[0];
      tmpmaskpp[tmpctrid] = cmaskpp[0];
      kbest = 0;
      dbest = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                              1, 1, &tmprowid, &tmpctrid,
                              *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
            /*-- loop over all centroids --*/
      for (ki=1; ki < __privtrans->__k_size; ki++) {
        tmpdatapp[tmpctrid] = cdatapp[ki];
        tmpmaskpp[tmpctrid] = cmaskpp[ki];
                dist = clusterdistance(2, __privtrans->__d_size, tmpdatapp, tmpmaskpp, weight_datap,
                               1, 1, &tmprowid, &tmpctrid,
                               *__privtrans->distFlag, *__privtrans->methodFlag, transpose);
        if (dist < dbest) {
          kbest = ki;
          dbest = dist;
        }
      }
            /*-- save best data --*/
      (clusterids_datap)[0+(__inc_clusterids_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")  = kbest;
      (cdist_datap)[0+(__inc_cdist_nr*PP_INDTERM(__privtrans->__nr_size, nr))] PDL_COMMENT("ACCESS()")       = dbest;
    }} PDL_COMMENT("Close nr")
  
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	data_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	mask_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	weight_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	rowids_datap -= __tinc1_3 * __tdims1 + __offsp[3];
	cdata_datap -= __tinc1_4 * __tdims1 + __offsp[4];
	cmask_datap -= __tinc1_5 * __tdims1 + __offsp[5];
	clusterids_datap -= __tinc1_6 * __tdims1 + __offsp[6];
	cdist_datap -= __tinc1_7 * __tdims1 + __offsp[7];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));
    /*-- cleanup --*/
  if (datapp) free(datapp);
  if (maskpp) free(maskpp);
  if (cdatapp) free(cdatapp);
  if (cmaskpp) free(cmaskpp);

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_attachtonearest_free(pdl_trans *__tr ) {
	int __dim;
	pdl_attachtonearest_struct *__privtrans = (pdl_attachtonearest_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			free(__privtrans->distFlag);;free(__privtrans->methodFlag);;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;;;;;;;;;;;;
			}
			
	}
    }
    



static char pdl_attachtonearest_vtable_flags[] =
	 	{ 0,0,0,PDL_TPDL_VAFFINE_OK,0,0,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_attachtonearest_vtable = {
		0,0, 6, 8, pdl_attachtonearest_vtable_flags,
		pdl_attachtonearest_redodims, pdl_attachtonearest_readdata, NULL,
		pdl_attachtonearest_free,NULL,NULL,pdl_attachtonearest_copy,
		sizeof(pdl_attachtonearest_struct),"pdl_attachtonearest_vtable"
	 };

typedef struct pdl_checkprototypes_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Indx  __inc_protos_k;PDL_Indx  __inc_cprotos_k;PDL_Indx  __inc_otmp_n;PDL_Indx  __n_size;PDL_Indx  __k_size;
		int  nsize;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_checkprototypes_struct;

void pdl_checkprototypes_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_checkprototypes_struct *__privtrans = (pdl_checkprototypes_struct *) __tr;
	
	{
	    PDL_Indx __creating[3];
__privtrans->__n_size = __privtrans->nsize;
__privtrans->__k_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Byte * protos_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * protos_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * cprotos_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * cprotos_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Short * protos_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * protos_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * cprotos_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * cprotos_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Ushort * protos_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * protos_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * cprotos_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * cprotos_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * protos_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * protos_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * cprotos_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * cprotos_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"protos","cprotos","otmp"};
		static PDL_Indx __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Cluster::checkprototypes";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in checkprototypes:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in checkprototypes:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in checkprototypes:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,1);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_protos_k = 0; else
		 __privtrans->__inc_protos_k = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_cprotos_k = 0; else
		 __privtrans->__inc_cprotos_k = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_otmp_n = 0; else
		 __privtrans->__inc_otmp_n = PDL_REPRINC(__privtrans->pdls[2],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_checkprototypes_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_checkprototypes_struct *__privtrans = (pdl_checkprototypes_struct *) __tr;
	
	{
	    pdl_checkprototypes_struct *__copy = malloc(sizeof(pdl_checkprototypes_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->nsize) = (__privtrans->nsize);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_protos_k=__copy->__inc_protos_k;__privtrans->__inc_cprotos_k=__copy->__inc_cprotos_k;__privtrans->__inc_otmp_n=__copy->__inc_otmp_n;__copy->__n_size=__privtrans->__n_size;__copy->__k_size=__privtrans->__k_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_checkprototypes_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_checkprototypes_struct *__privtrans = (pdl_checkprototypes_struct *) __tr;
	
	{
	    {register PDL_Indx __k_size = __privtrans->__k_size;
register PDL_Indx __n_size = __privtrans->__n_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Byte * protos_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * protos_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * cprotos_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * cprotos_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkprototypes(): number of prototypes \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	protos_datap += __offsp[0];
	cprotos_datap += __offsp[1];
	otmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,protos_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cprotos_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,otmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,protos_datap += __tinc0_0
			,cprotos_datap += __tinc0_1
			,otmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) { (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close n")
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     int protoi = (protos_datap)[0+(__inc_protos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ;
     for (; (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()") ; protoi = (protoi+1)%__privtrans->__n_size) { ; }
     (cprotos_datap)[0+(__inc_cprotos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = protoi;
     (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()")  = 1;
   }} PDL_COMMENT("Close k")
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	protos_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cprotos_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	otmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	} break; case PDL_S: {
	PDL_Short * protos_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * protos_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * cprotos_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * cprotos_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkprototypes(): number of prototypes \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	protos_datap += __offsp[0];
	cprotos_datap += __offsp[1];
	otmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,protos_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cprotos_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,otmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,protos_datap += __tinc0_0
			,cprotos_datap += __tinc0_1
			,otmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) { (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close n")
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     int protoi = (protos_datap)[0+(__inc_protos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ;
     for (; (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()") ; protoi = (protoi+1)%__privtrans->__n_size) { ; }
     (cprotos_datap)[0+(__inc_cprotos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = protoi;
     (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()")  = 1;
   }} PDL_COMMENT("Close k")
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	protos_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cprotos_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	otmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	} break; case PDL_US: {
	PDL_Ushort * protos_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * protos_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * cprotos_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * cprotos_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkprototypes(): number of prototypes \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	protos_datap += __offsp[0];
	cprotos_datap += __offsp[1];
	otmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,protos_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cprotos_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,otmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,protos_datap += __tinc0_0
			,cprotos_datap += __tinc0_1
			,otmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) { (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close n")
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     int protoi = (protos_datap)[0+(__inc_protos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ;
     for (; (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()") ; protoi = (protoi+1)%__privtrans->__n_size) { ; }
     (cprotos_datap)[0+(__inc_cprotos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = protoi;
     (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()")  = 1;
   }} PDL_COMMENT("Close k")
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	protos_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cprotos_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	otmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	} break; case PDL_L: {
	PDL_Long * protos_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * protos_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * cprotos_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * cprotos_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Byte * otmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * otmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cprotos_k = __privtrans->__inc_cprotos_k;
register PDL_Indx __inc_otmp_n = __privtrans->__inc_otmp_n;
register PDL_Indx __inc_protos_k = __privtrans->__inc_protos_k;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkprototypes(): number of prototypes \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	protos_datap += __offsp[0];
	cprotos_datap += __offsp[1];
	otmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,protos_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cprotos_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,otmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,protos_datap += __tinc0_0
			,cprotos_datap += __tinc0_1
			,otmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) { (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close n")
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) {
     int protoi = (protos_datap)[0+(__inc_protos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()") ;
     for (; (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()") ; protoi = (protoi+1)%__privtrans->__n_size) { ; }
     (cprotos_datap)[0+(__inc_cprotos_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = protoi;
     (otmp_datap)[0+(__inc_otmp_n*PP_INDTERM(__privtrans->__n_size, protoi))] PDL_COMMENT("ACCESS()")  = 1;
   }} PDL_COMMENT("Close k")
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	protos_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cprotos_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	otmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_checkprototypes_free(pdl_trans *__tr ) {
	int __dim;
	pdl_checkprototypes_struct *__privtrans = (pdl_checkprototypes_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_checkprototypes_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_checkprototypes_vtable = {
		0,0, 1, 3, pdl_checkprototypes_vtable_flags,
		pdl_checkprototypes_redodims, pdl_checkprototypes_readdata, NULL,
		pdl_checkprototypes_free,NULL,NULL,pdl_checkprototypes_copy,
		sizeof(pdl_checkprototypes_struct),"pdl_checkprototypes_vtable"
	 };

typedef struct pdl_checkpartitions_struct {
		PDL_TRANS_START(3);
		pdl_thread  __pdlthread;PDL_Indx  __inc_part_n;PDL_Indx  __inc_cpart_n;PDL_Indx  __inc_ptmp_k;PDL_Indx  __k_size;PDL_Indx  __n_size;
		int  ksize;
		char __ddone; PDL_COMMENT("Dims done")
		} pdl_checkpartitions_struct;

void pdl_checkpartitions_redodims(pdl_trans *__tr ) {
	int __dim;
	pdl_checkpartitions_struct *__privtrans = (pdl_checkpartitions_struct *) __tr;
	
	{
	    PDL_Indx __creating[3];
__privtrans->__k_size = __privtrans->ksize;
__privtrans->__n_size = -1;
__creating[0] = 0;
__creating[1] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[1]);
__creating[2] = PDL_CR_SETDIMSCOND(__privtrans,__privtrans->pdls[2]);
 {
{PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Byte * part_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * part_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * cpart_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * cpart_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * ptmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * ptmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;

PDL_COMMENT("none")
}	} break; case PDL_S: {
	PDL_Short * part_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * part_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * cpart_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * cpart_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Short * ptmp_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * ptmp_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;

PDL_COMMENT("none")
}	} break; case PDL_US: {
	PDL_Ushort * part_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * part_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * cpart_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * cpart_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Ushort * ptmp_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * ptmp_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;

PDL_COMMENT("none")
}	} break; case PDL_L: {
	PDL_Long * part_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * part_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * cpart_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * cpart_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * ptmp_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * ptmp_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;

PDL_COMMENT("none")
}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
}
 {
 static char *__parnames[] = {"part","cpart","ptmp"};
		static PDL_Indx __realdims[] = {1,1,1};
		static char __funcname[] = "PDL::Cluster::checkpartitions";
		static pdl_errorinfo __einfo = {
			__funcname, __parnames, 3
		};
		
		 PDL->initthreadstruct(2,__privtrans->pdls,
			__realdims,__creating,3,
                      &__einfo,&(__privtrans->__pdlthread),
                        __privtrans->vtable->per_pdl_flags,
			0 );
		}
   if(((__privtrans->pdls[0]))->ndims < 1) {
      if (((__privtrans->pdls[0]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[0]))->dims[0];
   } else if(((__privtrans->pdls[0]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[0]))->dims[0]) {
      if(((__privtrans->pdls[0]))->dims[0] != 1) {
         PDL->pdl_barf("Error in checkpartitions:" "Wrong dims\n");
      }
   }
if(!__creating[1]) {
   if(((__privtrans->pdls[1]))->ndims < 1) {
      if (((__privtrans->pdls[1]))->ndims < 1 && __privtrans->__n_size <= 1) __privtrans->__n_size = 1;
   }
   if(__privtrans->__n_size == -1 || (((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size == 1)) {
      __privtrans->__n_size = ((__privtrans->pdls[1]))->dims[0];
   } else if(((__privtrans->pdls[1]))->ndims > 0 && __privtrans->__n_size != ((__privtrans->pdls[1]))->dims[0]) {
      if(((__privtrans->pdls[1]))->dims[0] != 1) {
         PDL->pdl_barf("Error in checkpartitions:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__n_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,1,dims,0);
}if(!__creating[2]) {
   if(((__privtrans->pdls[2]))->ndims < 1) {
      if (((__privtrans->pdls[2]))->ndims < 1 && __privtrans->__k_size <= 1) __privtrans->__k_size = 1;
   }
   if(__privtrans->__k_size == -1 || (((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__k_size == 1)) {
      __privtrans->__k_size = ((__privtrans->pdls[2]))->dims[0];
   } else if(((__privtrans->pdls[2]))->ndims > 0 && __privtrans->__k_size != ((__privtrans->pdls[2]))->dims[0]) {
      if(((__privtrans->pdls[2]))->dims[0] != 1) {
         PDL->pdl_barf("Error in checkpartitions:" "Wrong dims\n");
      }
   }
} else {
 PDL_Indx dims[2]; PDL_COMMENT("Use ninds+1 to avoid smart (stupid) compilers")dims[0] = __privtrans->__k_size;
 PDL->thread_create_parameter(&__privtrans->__pdlthread,2,dims,1);
}
{ PDL_COMMENT("convenience block")
  void *hdrp = NULL;
  char propagate_hdrcpy = 0;
  SV *hdr_copy = NULL;
      if(!hdrp &&
	      __privtrans->pdls[0]->hdrsv &&
	 (__privtrans->pdls[0]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[0]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[0]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[1] && 
     __privtrans->pdls[1]->hdrsv &&
	 (__privtrans->pdls[1]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[1]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[1]->state & PDL_HDRCPY) != 0);
      }
      if(!hdrp &&
	 !__creating[2] && 
     __privtrans->pdls[2]->hdrsv &&
	 (__privtrans->pdls[2]->state & PDL_HDRCPY)
	 ) {
	hdrp = __privtrans->pdls[2]->hdrsv;
	propagate_hdrcpy = ((__privtrans->pdls[2]->state & PDL_HDRCPY) != 0);
      }
if (hdrp) {
  if(hdrp == &PL_sv_undef)
    hdr_copy = &PL_sv_undef;
  else  {  PDL_COMMENT("Call the perl routine _hdr_copy...")
    int count;
    PDL_COMMENT("Call the perl routine PDL::_hdr_copy(hdrp)")
    dSP;
    ENTER ;
    SAVETMPS ;
    PUSHMARK(SP) ;
    XPUSHs( hdrp );
    PUTBACK ;
    count = call_pv("PDL::_hdr_copy",G_SCALAR);
    SPAGAIN ;
    if(count != 1)
	croak("PDL::_hdr_copy didn't return a single value - please report this bug (A).");

    hdr_copy = (SV *)POPs;

    if(hdr_copy && hdr_copy != &PL_sv_undef) {
       (void)SvREFCNT_inc(hdr_copy); PDL_COMMENT("Keep hdr_copy from vanishing during FREETMPS")
    }

    FREETMPS ;
    LEAVE ;


  } PDL_COMMENT("end of callback  block")

       if ( __privtrans->pdls[1]->hdrsv != hdrp ){
	 if( __privtrans->pdls[1]->hdrsv && __privtrans->pdls[1]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[1]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[1]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[1]->state |= PDL_HDRCPY;
       if ( __privtrans->pdls[2]->hdrsv != hdrp ){
	 if( __privtrans->pdls[2]->hdrsv && __privtrans->pdls[2]->hdrsv != &PL_sv_undef)
             (void)SvREFCNT_dec( __privtrans->pdls[2]->hdrsv );
	 if( hdr_copy != &PL_sv_undef )
             (void)SvREFCNT_inc(hdr_copy);
	 __privtrans->pdls[2]->hdrsv = hdr_copy;
       }
     if(propagate_hdrcpy)
       __privtrans->pdls[2]->state |= PDL_HDRCPY;

         if(hdr_copy != &PL_sv_undef)
            SvREFCNT_dec(hdr_copy); PDL_COMMENT("make hdr_copy mortal again")
      } PDL_COMMENT("end of if(hdrp) block")
   } PDL_COMMENT("end of conv. block")
if(__privtrans->pdls[0]->ndims <= 0 || __privtrans->pdls[0]->dims[0] <= 1)
		  __privtrans->__inc_part_n = 0; else
		 __privtrans->__inc_part_n = PDL_REPRINC(__privtrans->pdls[0],0);if(__privtrans->pdls[1]->ndims <= 0 || __privtrans->pdls[1]->dims[0] <= 1)
		  __privtrans->__inc_cpart_n = 0; else
		 __privtrans->__inc_cpart_n = PDL_REPRINC(__privtrans->pdls[1],0);if(__privtrans->pdls[2]->ndims <= 0 || __privtrans->pdls[2]->dims[0] <= 1)
		  __privtrans->__inc_ptmp_k = 0; else
		 __privtrans->__inc_ptmp_k = PDL_REPRINC(__privtrans->pdls[2],0); __privtrans->__ddone = 1;
	}
    }
    

pdl_trans * pdl_checkpartitions_copy(pdl_trans *__tr ) {
	int __dim;
	pdl_checkpartitions_struct *__privtrans = (pdl_checkpartitions_struct *) __tr;
	
	{
	    pdl_checkpartitions_struct *__copy = malloc(sizeof(pdl_checkpartitions_struct));
PDL_THR_CLRMAGIC(&__copy->__pdlthread);			PDL_TR_CLRMAGIC(__copy);
                        __copy->has_badvalue = __privtrans->has_badvalue;
                        __copy->badvalue = __privtrans->badvalue;
			__copy->flags = __privtrans->flags;
			__copy->vtable = __privtrans->vtable;
			__copy->__datatype = __privtrans->__datatype;
			__copy->freeproc = NULL;
			__copy->__ddone = __privtrans->__ddone;
			{int i;
			 for(i=0; i<__copy->vtable->npdls; i++)
				__copy->pdls[i] = __privtrans->pdls[i];
			}
			(__copy->ksize) = (__privtrans->ksize);;
			if(__copy->__ddone) {
				PDL->thread_copy(&(__privtrans->__pdlthread),&(__copy->__pdlthread));__privtrans->__inc_part_n=__copy->__inc_part_n;__privtrans->__inc_cpart_n=__copy->__inc_cpart_n;__privtrans->__inc_ptmp_k=__copy->__inc_ptmp_k;__copy->__k_size=__privtrans->__k_size;__copy->__n_size=__privtrans->__n_size;
			}
			return (pdl_trans*)__copy;
	}
    }
    

void pdl_checkpartitions_readdata(pdl_trans *__tr ) {
	int __dim;
	pdl_checkpartitions_struct *__privtrans = (pdl_checkpartitions_struct *) __tr;
	
	{
	    {register PDL_Indx __k_size = __privtrans->__k_size;
register PDL_Indx __n_size = __privtrans->__n_size;
PDL_COMMENT("Start generic loop")

	switch(__privtrans->__datatype) { case -42: PDL_COMMENT("Warning eater") {(void)1;
	} break; case PDL_B: {
	PDL_Byte * part_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Byte * part_physdatap = ((PDL_Byte *)((__privtrans->pdls[0])->data));

	PDL_Byte * cpart_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Byte * cpart_physdatap = ((PDL_Byte *)((__privtrans->pdls[1])->data));

	PDL_Byte * ptmp_datap = ((PDL_Byte *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Byte * ptmp_physdatap = ((PDL_Byte *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkpartitions(): number of partitions \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	part_datap += __offsp[0];
	cpart_datap += __offsp[1];
	ptmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,part_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cpart_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,ptmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,part_datap += __tinc0_0
			,cpart_datap += __tinc0_1
			,ptmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   int ni, ki, kj;
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
     ki = (part_datap)[0+(__inc_part_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
     (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = ki;
     (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
   }} PDL_COMMENT("Close n")
   ni = 0;
   for (ki=0; ki < __privtrans->__k_size; ki++) {
     if (!(ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()") ) {
       for (; 1; ni = (ni+1)%__privtrans->__n_size) {
	 kj = (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()") ;
	 if ((ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  > 1) break;
       }
       (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()")    = ki;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  -= 1;
     }
   }
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	part_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cpart_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	ptmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	} break; case PDL_S: {
	PDL_Short * part_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Short * part_physdatap = ((PDL_Short *)((__privtrans->pdls[0])->data));

	PDL_Short * cpart_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Short * cpart_physdatap = ((PDL_Short *)((__privtrans->pdls[1])->data));

	PDL_Short * ptmp_datap = ((PDL_Short *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Short * ptmp_physdatap = ((PDL_Short *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkpartitions(): number of partitions \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	part_datap += __offsp[0];
	cpart_datap += __offsp[1];
	ptmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,part_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cpart_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,ptmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,part_datap += __tinc0_0
			,cpart_datap += __tinc0_1
			,ptmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   int ni, ki, kj;
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
     ki = (part_datap)[0+(__inc_part_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
     (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = ki;
     (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
   }} PDL_COMMENT("Close n")
   ni = 0;
   for (ki=0; ki < __privtrans->__k_size; ki++) {
     if (!(ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()") ) {
       for (; 1; ni = (ni+1)%__privtrans->__n_size) {
	 kj = (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()") ;
	 if ((ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  > 1) break;
       }
       (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()")    = ki;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  -= 1;
     }
   }
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	part_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cpart_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	ptmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	} break; case PDL_US: {
	PDL_Ushort * part_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Ushort * part_physdatap = ((PDL_Ushort *)((__privtrans->pdls[0])->data));

	PDL_Ushort * cpart_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Ushort * cpart_physdatap = ((PDL_Ushort *)((__privtrans->pdls[1])->data));

	PDL_Ushort * ptmp_datap = ((PDL_Ushort *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Ushort * ptmp_physdatap = ((PDL_Ushort *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkpartitions(): number of partitions \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	part_datap += __offsp[0];
	cpart_datap += __offsp[1];
	ptmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,part_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cpart_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,ptmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,part_datap += __tinc0_0
			,cpart_datap += __tinc0_1
			,ptmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   int ni, ki, kj;
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
     ki = (part_datap)[0+(__inc_part_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
     (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = ki;
     (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
   }} PDL_COMMENT("Close n")
   ni = 0;
   for (ki=0; ki < __privtrans->__k_size; ki++) {
     if (!(ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()") ) {
       for (; 1; ni = (ni+1)%__privtrans->__n_size) {
	 kj = (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()") ;
	 if ((ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  > 1) break;
       }
       (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()")    = ki;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  -= 1;
     }
   }
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	part_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cpart_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	ptmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	} break; case PDL_L: {
	PDL_Long * part_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[0]),(__privtrans->vtable->per_pdl_flags[0]))));
	PDL_Long * part_physdatap = ((PDL_Long *)((__privtrans->pdls[0])->data));

	PDL_Long * cpart_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[1]),(__privtrans->vtable->per_pdl_flags[1]))));
	PDL_Long * cpart_physdatap = ((PDL_Long *)((__privtrans->pdls[1])->data));

	PDL_Long * ptmp_datap = ((PDL_Long *)(PDL_REPRP_TRANS((__privtrans->pdls[2]),(__privtrans->vtable->per_pdl_flags[2]))));
	PDL_Long * ptmp_physdatap = ((PDL_Long *)((__privtrans->pdls[2])->data));

{register PDL_Indx __inc_cpart_n = __privtrans->__inc_cpart_n;
register PDL_Indx __inc_ptmp_k = __privtrans->__inc_ptmp_k;
register PDL_Indx __inc_part_n = __privtrans->__inc_part_n;


 /*-- sanity check --*/
 if (__privtrans->__k_size > __privtrans->__n_size) {
   barf("checkpartitions(): number of partitions \"k\" (=%d) must be <= number of objects \"n\" (=%d)!\n",
        __privtrans->__k_size, __privtrans->__n_size);
 }
 
	PDL_COMMENT("THREADLOOPBEGIN")
	if ( PDL->startthreadloop(&(__privtrans->__pdlthread),__privtrans->vtable->readdata, __tr) ) return;
           do { register PDL_Indx __tind1=0,__tind2=0;
                register PDL_Indx __tnpdls = __privtrans->__pdlthread.npdls;
                register PDL_Indx __tdims1 = __privtrans->__pdlthread.dims[1];
                register PDL_Indx __tdims0 = __privtrans->__pdlthread.dims[0];
                register PDL_Indx *__offsp = PDL->get_threadoffsp(&__privtrans->__pdlthread);
	register PDL_Indx __tinc0_0 = __privtrans->__pdlthread.incs[0];
	register PDL_Indx __tinc0_1 = __privtrans->__pdlthread.incs[1];
	register PDL_Indx __tinc0_2 = __privtrans->__pdlthread.incs[2];
	register PDL_Indx __tinc1_0 = __privtrans->__pdlthread.incs[__tnpdls+0];
	register PDL_Indx __tinc1_1 = __privtrans->__pdlthread.incs[__tnpdls+1];
	register PDL_Indx __tinc1_2 = __privtrans->__pdlthread.incs[__tnpdls+2];
	part_datap += __offsp[0];
	cpart_datap += __offsp[1];
	ptmp_datap += __offsp[2];
	for( __tind2 = 0 ;
                __tind2 < __tdims1 ;
                __tind2++
			,part_datap += __tinc1_0 - __tinc0_0 * __tdims0
			,cpart_datap += __tinc1_1 - __tinc0_1 * __tdims0
			,ptmp_datap += __tinc1_2 - __tinc0_2 * __tdims0
	)
	{
	     for( __tind1 = 0 ;
                  __tind1 < __tdims0 ;
                  __tind1++
			,part_datap += __tinc0_0
			,cpart_datap += __tinc0_1
			,ptmp_datap += __tinc0_2
	)
	{  PDL_COMMENT("This is the tightest threadloop. Make sure inside is optimal.")
   int ni, ki, kj;
   {PDL_COMMENT("Open k") register PDL_Indx k;
			for(k=0; k<(__k_size); k++) { (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, k))] PDL_COMMENT("ACCESS()")  = 0; }} PDL_COMMENT("Close k")
   {PDL_COMMENT("Open n") register PDL_Indx n;
			for(n=0; n<(__n_size); n++) {
     ki = (part_datap)[0+(__inc_part_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()") ;
     (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, n))] PDL_COMMENT("ACCESS()")  = ki;
     (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
   }} PDL_COMMENT("Close n")
   ni = 0;
   for (ki=0; ki < __privtrans->__k_size; ki++) {
     if (!(ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()") ) {
       for (; 1; ni = (ni+1)%__privtrans->__n_size) {
	 kj = (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()") ;
	 if ((ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  > 1) break;
       }
       (cpart_datap)[0+(__inc_cpart_n*PP_INDTERM(__privtrans->__n_size, ni))] PDL_COMMENT("ACCESS()")    = ki;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, ki))] PDL_COMMENT("ACCESS()")  += 1;
       (ptmp_datap)[0+(__inc_ptmp_k*PP_INDTERM(__privtrans->__k_size, kj))] PDL_COMMENT("ACCESS()")  -= 1;
     }
   }
 
	PDL_COMMENT("THREADLOOPEND")
	}
	}
	part_datap -= __tinc1_0 * __tdims1 + __offsp[0];
	cpart_datap -= __tinc1_1 * __tdims1 + __offsp[1];
	ptmp_datap -= __tinc1_2 * __tdims1 + __offsp[2];
	} while(PDL->iterthreadloop(&__privtrans->__pdlthread,2));

}	break;}
	default:barf("PP INTERNAL ERROR! PLEASE MAKE A BUG REPORT\n");}
}
	}
    }
    



void pdl_checkpartitions_free(pdl_trans *__tr ) {
	int __dim;
	pdl_checkpartitions_struct *__privtrans = (pdl_checkpartitions_struct *) __tr;
	
	{
	    
			PDL_TR_CLRMAGIC(__privtrans);
			;
			if(__privtrans->__ddone) {
				PDL->freethreadloop(&(__privtrans->__pdlthread));
				;;;;;;
			}
			
	}
    }
    



static char pdl_checkpartitions_vtable_flags[] =
	 	{ PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK,PDL_TPDL_VAFFINE_OK};
	 pdl_transvtable pdl_checkpartitions_vtable = {
		0,0, 1, 3, pdl_checkpartitions_vtable_flags,
		pdl_checkpartitions_redodims, pdl_checkpartitions_readdata, NULL,
		pdl_checkpartitions_free,NULL,NULL,pdl_checkpartitions_copy,
		sizeof(pdl_checkpartitions_struct),"pdl_checkpartitions_vtable"
	 };



#line 31063 "Cluster.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 31207 "Cluster.c"

XS_EUPXS(XS_PDL__Cluster_set_debugging); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__Cluster_set_debugging)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 31061 "Cluster.xs"
	RETVAL = __pdl_debugging;
	__pdl_debugging = i;
#line 31223 "Cluster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PDL__Cluster_set_boundscheck); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__Cluster_set_boundscheck)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "i");
    {
	int	i = (int)SvIV(ST(0))
;
	int	RETVAL;
	dXSTARG;
#line 31070 "Cluster.xs"
       if (! 1)
         warn("Bounds checking is disabled for PDL::Cluster");
       RETVAL = __pdl_boundscheck;
       __pdl_boundscheck = i;
#line 31246 "Cluster.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PDL__Cluster_library_version); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL__Cluster_library_version)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	char *	RETVAL;
	dXSTARG;
#line 31087 "Cluster.xs"
   RETVAL = CLUSTERVERSION;
#line 31264 "Cluster.c"
	sv_setpv(TARG, RETVAL); XSprePUSH; PUSHTARG;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_PDL_cmean); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_cmean)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31098 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *b_SV;
  pdl  *a;
  pdl  *b;
#line 31288 "Cluster.c"
#line 31107 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    a = PDL->SvPDLV(ST(0));
    b = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    a = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       b_SV = sv_newmortal();
       b = PDL->null();
       PDL->SetSV_PDL(b_SV,b);
       if (bless_stash) b_SV = sv_bless(b_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       b_SV = POPs;
       PUTBACK;
       b = PDL->SvPDLV(b_SV);
    }
  }
  else {
    croak ("Usage:  PDL::cmean(a,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_cmean_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_cmean_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((a->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = PDL_D;
	  } else if(PDL_D != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = a;
__privtrans->pdls[1] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  b->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = b_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 31365 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_cmedian); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_cmedian)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31186 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *b_SV;
  pdl  *a;
  pdl  *b;
#line 31389 "Cluster.c"
#line 31195 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    a = PDL->SvPDLV(ST(0));
    b = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    a = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       b_SV = sv_newmortal();
       b = PDL->null();
       PDL->SetSV_PDL(b_SV,b);
       if (bless_stash) b_SV = sv_bless(b_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       b_SV = POPs;
       PUTBACK;
       b = PDL->SvPDLV(b_SV);
    }
  }
  else {
    croak ("Usage:  PDL::cmedian(a,b) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_cmedian_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_cmedian_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((a->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != a->datatype) {
	     a = PDL->get_convertedpdl(a,PDL_D);
	  }if( (b->state & PDL_NOMYDIMS) && b->trans == NULL ) {
	     b->datatype = PDL_D;
	  } else if(PDL_D != b->datatype) {
	     b = PDL->get_convertedpdl(b,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = a;
__privtrans->pdls[1] = b;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  b->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = b_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 31466 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_calculate_weights); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_calculate_weights)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31274 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *oweights_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *cutoff;
  pdl  *exponent;
  pdl  *oweights;
  char  *distFlag;
#line 31495 "Cluster.c"
#line 31288 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 7) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    cutoff = PDL->SvPDLV(ST(3));
    exponent = PDL->SvPDLV(ST(4));
    oweights = PDL->SvPDLV(ST(5));
    distFlag = (char *)SvPV_nolen(ST(6))
;
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    cutoff = PDL->SvPDLV(ST(3));
    exponent = PDL->SvPDLV(ST(4));
    distFlag = (char *)SvPV_nolen(ST(5))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       oweights_SV = sv_newmortal();
       oweights = PDL->null();
       PDL->SetSV_PDL(oweights_SV,oweights);
       if (bless_stash) oweights_SV = sv_bless(oweights_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       oweights_SV = POPs;
       PUTBACK;
       oweights = PDL->SvPDLV(oweights_SV);
    }
  }
  else {
    croak ("Usage:  PDL::calculate_weights(data,mask,weight,cutoff,exponent,oweights,distFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_calculate_weights_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_calculate_weights_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((cutoff->state & PDL_BADVAL) > 0) || ((exponent->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_D != cutoff->datatype) {
	     cutoff = PDL->get_convertedpdl(cutoff,PDL_D);
	  }if(PDL_D != exponent->datatype) {
	     exponent = PDL->get_convertedpdl(exponent,PDL_D);
	  }if( (oweights->state & PDL_NOMYDIMS) && oweights->trans == NULL ) {
	     oweights->datatype = PDL_D;
	  } else if(PDL_D != oweights->datatype) {
	     oweights = PDL->get_convertedpdl(oweights,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = cutoff;
__privtrans->pdls[4] = exponent;
__privtrans->pdls[5] = oweights;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  oweights->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = oweights_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 31603 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clusterdistance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clusterdistance)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31398 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *dist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *n1;
  pdl  *n2;
  pdl  *index1;
  pdl  *index2;
  pdl  *dist;
  char  *distFlag;
  char  *methodFlag;
#line 31635 "Cluster.c"
#line 31415 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 10) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    n1 = PDL->SvPDLV(ST(3));
    n2 = PDL->SvPDLV(ST(4));
    index1 = PDL->SvPDLV(ST(5));
    index2 = PDL->SvPDLV(ST(6));
    dist = PDL->SvPDLV(ST(7));
    distFlag = (char *)SvPV_nolen(ST(8))
;
    methodFlag = (char *)SvPV_nolen(ST(9))
;
  }
  else if (items == 9) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    n1 = PDL->SvPDLV(ST(3));
    n2 = PDL->SvPDLV(ST(4));
    index1 = PDL->SvPDLV(ST(5));
    index2 = PDL->SvPDLV(ST(6));
    distFlag = (char *)SvPV_nolen(ST(7))
;
    methodFlag = (char *)SvPV_nolen(ST(8))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       dist_SV = sv_newmortal();
       dist = PDL->null();
       PDL->SetSV_PDL(dist_SV,dist);
       if (bless_stash) dist_SV = sv_bless(dist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       dist_SV = POPs;
       PUTBACK;
       dist = PDL->SvPDLV(dist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clusterdistance(data,mask,weight,n1,n2,index1,index2,dist,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clusterdistance_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clusterdistance_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((n1->state & PDL_BADVAL) > 0) || ((n2->state & PDL_BADVAL) > 0) || ((index1->state & PDL_BADVAL) > 0) || ((index2->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != n1->datatype) {
	     n1 = PDL->get_convertedpdl(n1,PDL_L);
	  }if(PDL_L != n2->datatype) {
	     n2 = PDL->get_convertedpdl(n2,PDL_L);
	  }if(PDL_L != index1->datatype) {
	     index1 = PDL->get_convertedpdl(index1,PDL_L);
	  }if(PDL_L != index2->datatype) {
	     index2 = PDL->get_convertedpdl(index2,PDL_L);
	  }if( (dist->state & PDL_NOMYDIMS) && dist->trans == NULL ) {
	     dist->datatype = PDL_D;
	  } else if(PDL_D != dist->datatype) {
	     dist = PDL->get_convertedpdl(dist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = n1;
__privtrans->pdls[4] = n2;
__privtrans->pdls[5] = index1;
__privtrans->pdls[6] = index2;
__privtrans->pdls[7] = dist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  dist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = dist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 31757 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_distancematrix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_distancematrix)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31539 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *dists_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *dists;
  char  *distFlag;
#line 31784 "Cluster.c"
#line 31551 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    dists = PDL->SvPDLV(ST(3));
    distFlag = (char *)SvPV_nolen(ST(4))
;
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    distFlag = (char *)SvPV_nolen(ST(3))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       dists_SV = sv_newmortal();
       dists = PDL->null();
       PDL->SetSV_PDL(dists_SV,dists);
       if (bless_stash) dists_SV = sv_bless(dists_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       dists_SV = POPs;
       PUTBACK;
       dists = PDL->SvPDLV(dists_SV);
    }
  }
  else {
    croak ("Usage:  PDL::distancematrix(data,mask,weight,dists,distFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_distancematrix_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_distancematrix_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if( (dists->state & PDL_NOMYDIMS) && dists->trans == NULL ) {
	     dists->datatype = PDL_D;
	  } else if(PDL_D != dists->datatype) {
	     dists = PDL->get_convertedpdl(dists,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = dists;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  dists->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = dists_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 31882 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_getclustercentroids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_getclustercentroids)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31651 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *cdata_SV;
  SV *cmask_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *clusterids;
  pdl  *cdata;
  pdl  *cmask;
  char  *ctrMethodFlag;
#line 31911 "Cluster.c"
#line 31665 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    clusterids = PDL->SvPDLV(ST(2));
    cdata = PDL->SvPDLV(ST(3));
    cmask = PDL->SvPDLV(ST(4));
    ctrMethodFlag = (char *)SvPV_nolen(ST(5))
;
  }
  else if (items == 4) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    clusterids = PDL->SvPDLV(ST(2));
    ctrMethodFlag = (char *)SvPV_nolen(ST(3))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       cdata_SV = sv_newmortal();
       cdata = PDL->null();
       PDL->SetSV_PDL(cdata_SV,cdata);
       if (bless_stash) cdata_SV = sv_bless(cdata_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       cdata_SV = POPs;
       PUTBACK;
       cdata = PDL->SvPDLV(cdata_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       cmask_SV = sv_newmortal();
       cmask = PDL->null();
       PDL->SetSV_PDL(cmask_SV,cmask);
       if (bless_stash) cmask_SV = sv_bless(cmask_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       cmask_SV = POPs;
       PUTBACK;
       cmask = PDL->SvPDLV(cmask_SV);
    }
  }
  else {
    croak ("Usage:  PDL::getclustercentroids(data,mask,clusterids,cdata,cmask,ctrMethodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_getclustercentroids_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_getclustercentroids_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((clusterids->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (cdata->state & PDL_NOMYDIMS) && cdata->trans == NULL ) {
	     cdata->datatype = PDL_D;
	  } else if(PDL_D != cdata->datatype) {
	     cdata = PDL->get_convertedpdl(cdata,PDL_D);
	  }if( (cmask->state & PDL_NOMYDIMS) && cmask->trans == NULL ) {
	     cmask->datatype = PDL_L;
	  } else if(PDL_L != cmask->datatype) {
	     cmask = PDL->get_convertedpdl(cmask,PDL_L);
	  }{(__privtrans->ctrMethodFlag) = malloc(strlen(ctrMethodFlag)+1); strcpy(__privtrans->ctrMethodFlag,ctrMethodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = clusterids;
__privtrans->pdls[3] = cdata;
__privtrans->pdls[4] = cmask;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  cdata->state |= PDL_BADVAL;
  cmask->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = cdata_SV;
  ST(1) = cmask_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 32032 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_getclustermedoids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_getclustermedoids)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31788 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *centroids_SV;
  SV *errors_SV;
  pdl  *distance;
  pdl  *clusterids;
  pdl  *centroids;
  pdl  *errors;
#line 32059 "Cluster.c"
#line 31800 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    distance = PDL->SvPDLV(ST(0));
    clusterids = PDL->SvPDLV(ST(1));
    centroids = PDL->SvPDLV(ST(2));
    errors = PDL->SvPDLV(ST(3));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    distance = PDL->SvPDLV(ST(0));
    clusterids = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       centroids_SV = sv_newmortal();
       centroids = PDL->null();
       PDL->SetSV_PDL(centroids_SV,centroids);
       if (bless_stash) centroids_SV = sv_bless(centroids_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       centroids_SV = POPs;
       PUTBACK;
       centroids = PDL->SvPDLV(centroids_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       errors_SV = sv_newmortal();
       errors = PDL->null();
       PDL->SetSV_PDL(errors_SV,errors);
       if (bless_stash) errors_SV = sv_bless(errors_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       errors_SV = POPs;
       PUTBACK;
       errors = PDL->SvPDLV(errors_SV);
    }
  }
  else {
    croak ("Usage:  PDL::getclustermedoids(distance,clusterids,centroids,errors) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_getclustermedoids_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_getclustermedoids_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((distance->state & PDL_BADVAL) > 0) || ((clusterids->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != distance->datatype) {
	     distance = PDL->get_convertedpdl(distance,PDL_D);
	  }if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (centroids->state & PDL_NOMYDIMS) && centroids->trans == NULL ) {
	     centroids->datatype = PDL_L;
	  } else if(PDL_L != centroids->datatype) {
	     centroids = PDL->get_convertedpdl(centroids,PDL_L);
	  }if( (errors->state & PDL_NOMYDIMS) && errors->trans == NULL ) {
	     errors->datatype = PDL_D;
	  } else if(PDL_D != errors->datatype) {
	     errors = PDL->get_convertedpdl(errors,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = distance;
__privtrans->pdls[1] = clusterids;
__privtrans->pdls[2] = centroids;
__privtrans->pdls[3] = errors;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  centroids->state |= PDL_BADVAL;
  errors->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = centroids_SV;
  ST(1) = errors_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 32171 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_kcluster); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_kcluster)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 31914 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *clusterids_SV;
  SV *error_SV;
  SV *nfound_SV;
  pdl  *nclusters;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *npass;
  pdl  *clusterids;
  pdl  *error;
  pdl  *nfound;
  char  *distFlag;
  char  *ctrMethodFlag;
#line 32205 "Cluster.c"
#line 31933 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 10) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    nclusters = PDL->SvPDLV(ST(0));
    data = PDL->SvPDLV(ST(1));
    mask = PDL->SvPDLV(ST(2));
    weight = PDL->SvPDLV(ST(3));
    npass = PDL->SvPDLV(ST(4));
    clusterids = PDL->SvPDLV(ST(5));
    error = PDL->SvPDLV(ST(6));
    nfound = PDL->SvPDLV(ST(7));
    distFlag = (char *)SvPV_nolen(ST(8))
;
    ctrMethodFlag = (char *)SvPV_nolen(ST(9))
;
  }
  else if (items == 7) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    nclusters = PDL->SvPDLV(ST(0));
    data = PDL->SvPDLV(ST(1));
    mask = PDL->SvPDLV(ST(2));
    weight = PDL->SvPDLV(ST(3));
    npass = PDL->SvPDLV(ST(4));
    distFlag = (char *)SvPV_nolen(ST(5))
;
    ctrMethodFlag = (char *)SvPV_nolen(ST(6))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       clusterids_SV = sv_newmortal();
       clusterids = PDL->null();
       PDL->SetSV_PDL(clusterids_SV,clusterids);
       if (bless_stash) clusterids_SV = sv_bless(clusterids_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       clusterids_SV = POPs;
       PUTBACK;
       clusterids = PDL->SvPDLV(clusterids_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       error_SV = sv_newmortal();
       error = PDL->null();
       PDL->SetSV_PDL(error_SV,error);
       if (bless_stash) error_SV = sv_bless(error_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       error_SV = POPs;
       PUTBACK;
       error = PDL->SvPDLV(error_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       nfound_SV = sv_newmortal();
       nfound = PDL->null();
       PDL->SetSV_PDL(nfound_SV,nfound);
       if (bless_stash) nfound_SV = sv_bless(nfound_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       nfound_SV = POPs;
       PUTBACK;
       nfound = PDL->SvPDLV(nfound_SV);
    }
  }
  else {
    croak ("Usage:  PDL::kcluster(nclusters,data,mask,weight,npass,clusterids,error,nfound,distFlag,ctrMethodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_kcluster_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_kcluster_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((nclusters->state & PDL_BADVAL) > 0) || ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((npass->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != nclusters->datatype) {
	     nclusters = PDL->get_convertedpdl(nclusters,PDL_L);
	  }if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != npass->datatype) {
	     npass = PDL->get_convertedpdl(npass,PDL_L);
	  }if( (clusterids->state & PDL_NOMYDIMS) && clusterids->trans == NULL ) {
	     clusterids->datatype = PDL_L;
	  } else if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (error->state & PDL_NOMYDIMS) && error->trans == NULL ) {
	     error->datatype = PDL_D;
	  } else if(PDL_D != error->datatype) {
	     error = PDL->get_convertedpdl(error,PDL_D);
	  }if( (nfound->state & PDL_NOMYDIMS) && nfound->trans == NULL ) {
	     nfound->datatype = PDL_L;
	  } else if(PDL_L != nfound->datatype) {
	     nfound = PDL->get_convertedpdl(nfound,PDL_L);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->ctrMethodFlag) = malloc(strlen(ctrMethodFlag)+1); strcpy(__privtrans->ctrMethodFlag,ctrMethodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = nclusters;
__privtrans->pdls[1] = data;
__privtrans->pdls[2] = mask;
__privtrans->pdls[3] = weight;
__privtrans->pdls[4] = npass;
__privtrans->pdls[5] = clusterids;
__privtrans->pdls[6] = error;
__privtrans->pdls[7] = nfound;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  clusterids->state |= PDL_BADVAL;
  error->state |= PDL_BADVAL;
  nfound->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = clusterids_SV;
  ST(1) = error_SV;
  ST(2) = nfound_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 32363 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_kmedoids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_kmedoids)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 32093 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *clusterids_SV;
  SV *error_SV;
  SV *nfound_SV;
  pdl  *nclusters;
  pdl  *distance;
  pdl  *npass;
  pdl  *clusterids;
  pdl  *error;
  pdl  *nfound;
#line 32393 "Cluster.c"
#line 32108 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 6) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    nclusters = PDL->SvPDLV(ST(0));
    distance = PDL->SvPDLV(ST(1));
    npass = PDL->SvPDLV(ST(2));
    clusterids = PDL->SvPDLV(ST(3));
    error = PDL->SvPDLV(ST(4));
    nfound = PDL->SvPDLV(ST(5));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    nclusters = PDL->SvPDLV(ST(0));
    distance = PDL->SvPDLV(ST(1));
    npass = PDL->SvPDLV(ST(2));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       clusterids_SV = sv_newmortal();
       clusterids = PDL->null();
       PDL->SetSV_PDL(clusterids_SV,clusterids);
       if (bless_stash) clusterids_SV = sv_bless(clusterids_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       clusterids_SV = POPs;
       PUTBACK;
       clusterids = PDL->SvPDLV(clusterids_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       error_SV = sv_newmortal();
       error = PDL->null();
       PDL->SetSV_PDL(error_SV,error);
       if (bless_stash) error_SV = sv_bless(error_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       error_SV = POPs;
       PUTBACK;
       error = PDL->SvPDLV(error_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       nfound_SV = sv_newmortal();
       nfound = PDL->null();
       PDL->SetSV_PDL(nfound_SV,nfound);
       if (bless_stash) nfound_SV = sv_bless(nfound_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       nfound_SV = POPs;
       PUTBACK;
       nfound = PDL->SvPDLV(nfound_SV);
    }
  }
  else {
    croak ("Usage:  PDL::kmedoids(nclusters,distance,npass,clusterids,error,nfound) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_kmedoids_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_kmedoids_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((nclusters->state & PDL_BADVAL) > 0) || ((distance->state & PDL_BADVAL) > 0) || ((npass->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != nclusters->datatype) {
	     nclusters = PDL->get_convertedpdl(nclusters,PDL_L);
	  }if(PDL_D != distance->datatype) {
	     distance = PDL->get_convertedpdl(distance,PDL_D);
	  }if(PDL_L != npass->datatype) {
	     npass = PDL->get_convertedpdl(npass,PDL_L);
	  }if( (clusterids->state & PDL_NOMYDIMS) && clusterids->trans == NULL ) {
	     clusterids->datatype = PDL_L;
	  } else if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (error->state & PDL_NOMYDIMS) && error->trans == NULL ) {
	     error->datatype = PDL_D;
	  } else if(PDL_D != error->datatype) {
	     error = PDL->get_convertedpdl(error,PDL_D);
	  }if( (nfound->state & PDL_NOMYDIMS) && nfound->trans == NULL ) {
	     nfound->datatype = PDL_L;
	  } else if(PDL_L != nfound->datatype) {
	     nfound = PDL->get_convertedpdl(nfound,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = nclusters;
__privtrans->pdls[1] = distance;
__privtrans->pdls[2] = npass;
__privtrans->pdls[3] = clusterids;
__privtrans->pdls[4] = error;
__privtrans->pdls[5] = nfound;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  clusterids->state |= PDL_BADVAL;
  error->state |= PDL_BADVAL;
  nfound->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = clusterids_SV;
  ST(1) = error_SV;
  ST(2) = nfound_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 32533 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_treecluster); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_treecluster)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 32250 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *tree_SV;
  SV *lnkdist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *tree;
  pdl  *lnkdist;
  char  *distFlag;
  char  *methodFlag;
#line 32563 "Cluster.c"
#line 32265 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 7) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    tree = PDL->SvPDLV(ST(3));
    lnkdist = PDL->SvPDLV(ST(4));
    distFlag = (char *)SvPV_nolen(ST(5))
;
    methodFlag = (char *)SvPV_nolen(ST(6))
;
  }
  else if (items == 5) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    distFlag = (char *)SvPV_nolen(ST(3))
;
    methodFlag = (char *)SvPV_nolen(ST(4))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       tree_SV = sv_newmortal();
       tree = PDL->null();
       PDL->SetSV_PDL(tree_SV,tree);
       if (bless_stash) tree_SV = sv_bless(tree_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       tree_SV = POPs;
       PUTBACK;
       tree = PDL->SvPDLV(tree_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       lnkdist_SV = sv_newmortal();
       lnkdist = PDL->null();
       PDL->SetSV_PDL(lnkdist_SV,lnkdist);
       if (bless_stash) lnkdist_SV = sv_bless(lnkdist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       lnkdist_SV = POPs;
       PUTBACK;
       lnkdist = PDL->SvPDLV(lnkdist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::treecluster(data,mask,weight,tree,lnkdist,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_treecluster_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_treecluster_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if( (tree->state & PDL_NOMYDIMS) && tree->trans == NULL ) {
	     tree->datatype = PDL_L;
	  } else if(PDL_L != tree->datatype) {
	     tree = PDL->get_convertedpdl(tree,PDL_L);
	  }if( (lnkdist->state & PDL_NOMYDIMS) && lnkdist->trans == NULL ) {
	     lnkdist->datatype = PDL_D;
	  } else if(PDL_D != lnkdist->datatype) {
	     lnkdist = PDL->get_convertedpdl(lnkdist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = tree;
__privtrans->pdls[4] = lnkdist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  tree->state |= PDL_BADVAL;
  lnkdist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = tree_SV;
  ST(1) = lnkdist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 32688 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_treeclusterd); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_treeclusterd)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 32392 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *tree_SV;
  SV *lnkdist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *distances;
  pdl  *tree;
  pdl  *lnkdist;
  char  *distFlag;
  char  *methodFlag;
#line 32719 "Cluster.c"
#line 32408 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 8) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    distances = PDL->SvPDLV(ST(3));
    tree = PDL->SvPDLV(ST(4));
    lnkdist = PDL->SvPDLV(ST(5));
    distFlag = (char *)SvPV_nolen(ST(6))
;
    methodFlag = (char *)SvPV_nolen(ST(7))
;
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    distances = PDL->SvPDLV(ST(3));
    distFlag = (char *)SvPV_nolen(ST(4))
;
    methodFlag = (char *)SvPV_nolen(ST(5))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       tree_SV = sv_newmortal();
       tree = PDL->null();
       PDL->SetSV_PDL(tree_SV,tree);
       if (bless_stash) tree_SV = sv_bless(tree_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       tree_SV = POPs;
       PUTBACK;
       tree = PDL->SvPDLV(tree_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       lnkdist_SV = sv_newmortal();
       lnkdist = PDL->null();
       PDL->SetSV_PDL(lnkdist_SV,lnkdist);
       if (bless_stash) lnkdist_SV = sv_bless(lnkdist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       lnkdist_SV = POPs;
       PUTBACK;
       lnkdist = PDL->SvPDLV(lnkdist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::treeclusterd(data,mask,weight,distances,tree,lnkdist,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_treeclusterd_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_treeclusterd_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((distances->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_D != distances->datatype) {
	     distances = PDL->get_convertedpdl(distances,PDL_D);
	  }if( (tree->state & PDL_NOMYDIMS) && tree->trans == NULL ) {
	     tree->datatype = PDL_L;
	  } else if(PDL_L != tree->datatype) {
	     tree = PDL->get_convertedpdl(tree,PDL_L);
	  }if( (lnkdist->state & PDL_NOMYDIMS) && lnkdist->trans == NULL ) {
	     lnkdist->datatype = PDL_D;
	  } else if(PDL_D != lnkdist->datatype) {
	     lnkdist = PDL->get_convertedpdl(lnkdist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = distances;
__privtrans->pdls[4] = tree;
__privtrans->pdls[5] = lnkdist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  tree->state |= PDL_BADVAL;
  lnkdist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = tree_SV;
  ST(1) = lnkdist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 32849 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_cuttree); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_cuttree)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 32540 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *clusterids_SV;
  pdl  *tree;
  pdl  *nclusters;
  pdl  *clusterids;
#line 32874 "Cluster.c"
#line 32550 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    tree = PDL->SvPDLV(ST(0));
    nclusters = PDL->SvPDLV(ST(1));
    clusterids = PDL->SvPDLV(ST(2));
  }
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    tree = PDL->SvPDLV(ST(0));
    nclusters = PDL->SvPDLV(ST(1));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       clusterids_SV = sv_newmortal();
       clusterids = PDL->null();
       PDL->SetSV_PDL(clusterids_SV,clusterids);
       if (bless_stash) clusterids_SV = sv_bless(clusterids_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       clusterids_SV = POPs;
       PUTBACK;
       clusterids = PDL->SvPDLV(clusterids_SV);
    }
  }
  else {
    croak ("Usage:  PDL::cuttree(tree,nclusters,clusterids) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_cuttree_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_cuttree_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((tree->state & PDL_BADVAL) > 0) || ((nclusters->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != tree->datatype) {
	     tree = PDL->get_convertedpdl(tree,PDL_L);
	  }if(PDL_L != nclusters->datatype) {
	     nclusters = PDL->get_convertedpdl(nclusters,PDL_L);
	  }if( (clusterids->state & PDL_NOMYDIMS) && clusterids->trans == NULL ) {
	     clusterids->datatype = PDL_L;
	  } else if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = tree;
__privtrans->pdls[1] = nclusters;
__privtrans->pdls[2] = clusterids;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  clusterids->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = clusterids_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 32963 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_somcluster); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_somcluster)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 32641 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *clusterids_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *nxnodes;
  pdl  *nynodes;
  pdl  *inittau;
  pdl  *niter;
  pdl  *clusterids;
  char  *distFlag;
#line 32994 "Cluster.c"
#line 32657 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 9) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    nxnodes = PDL->SvPDLV(ST(3));
    nynodes = PDL->SvPDLV(ST(4));
    inittau = PDL->SvPDLV(ST(5));
    niter = PDL->SvPDLV(ST(6));
    clusterids = PDL->SvPDLV(ST(7));
    distFlag = (char *)SvPV_nolen(ST(8))
;
  }
  else if (items == 8) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    nxnodes = PDL->SvPDLV(ST(3));
    nynodes = PDL->SvPDLV(ST(4));
    inittau = PDL->SvPDLV(ST(5));
    niter = PDL->SvPDLV(ST(6));
    distFlag = (char *)SvPV_nolen(ST(7))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       clusterids_SV = sv_newmortal();
       clusterids = PDL->null();
       PDL->SetSV_PDL(clusterids_SV,clusterids);
       if (bless_stash) clusterids_SV = sv_bless(clusterids_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       clusterids_SV = POPs;
       PUTBACK;
       clusterids = PDL->SvPDLV(clusterids_SV);
    }
  }
  else {
    croak ("Usage:  PDL::somcluster(data,mask,weight,nxnodes,nynodes,inittau,niter,clusterids,distFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_somcluster_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_somcluster_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((nxnodes->state & PDL_BADVAL) > 0) || ((nynodes->state & PDL_BADVAL) > 0) || ((inittau->state & PDL_BADVAL) > 0) || ((niter->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != nxnodes->datatype) {
	     nxnodes = PDL->get_convertedpdl(nxnodes,PDL_L);
	  }if(PDL_L != nynodes->datatype) {
	     nynodes = PDL->get_convertedpdl(nynodes,PDL_L);
	  }if(PDL_D != inittau->datatype) {
	     inittau = PDL->get_convertedpdl(inittau,PDL_D);
	  }if(PDL_L != niter->datatype) {
	     niter = PDL->get_convertedpdl(niter,PDL_L);
	  }if( (clusterids->state & PDL_NOMYDIMS) && clusterids->trans == NULL ) {
	     clusterids->datatype = PDL_L;
	  } else if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = nxnodes;
__privtrans->pdls[4] = nynodes;
__privtrans->pdls[5] = inittau;
__privtrans->pdls[6] = niter;
__privtrans->pdls[7] = clusterids;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  clusterids->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = clusterids_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 33112 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_pca); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_pca)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 32777 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *U_SV;
  SV *S_SV;
  SV *V_SV;
  pdl  *U;
  pdl  *S;
  pdl  *V;
#line 33139 "Cluster.c"
#line 32789 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    U = PDL->SvPDLV(ST(0));
    S = PDL->SvPDLV(ST(1));
    V = PDL->SvPDLV(ST(2));
  }
  else if (items == 0) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 3;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       U_SV = sv_newmortal();
       U = PDL->null();
       PDL->SetSV_PDL(U_SV,U);
       if (bless_stash) U_SV = sv_bless(U_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       U_SV = POPs;
       PUTBACK;
       U = PDL->SvPDLV(U_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       S_SV = sv_newmortal();
       S = PDL->null();
       PDL->SetSV_PDL(S_SV,S);
       if (bless_stash) S_SV = sv_bless(S_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       S_SV = POPs;
       PUTBACK;
       S = PDL->SvPDLV(S_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       V_SV = sv_newmortal();
       V = PDL->null();
       PDL->SetSV_PDL(V_SV,V);
       if (bless_stash) V_SV = sv_bless(V_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       V_SV = POPs;
       PUTBACK;
       V = PDL->SvPDLV(V_SV);
    }
  }
  else {
    croak ("Usage:  PDL::pca(U,S,V) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_pca_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_pca_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if( (U->state & PDL_NOMYDIMS) && U->trans == NULL ) {
	     U->datatype = PDL_D;
	  } else if(PDL_D != U->datatype) {
	     U = PDL->get_convertedpdl(U,PDL_D);
	  }if( (S->state & PDL_NOMYDIMS) && S->trans == NULL ) {
	     S->datatype = PDL_D;
	  } else if(PDL_D != S->datatype) {
	     S = PDL->get_convertedpdl(S,PDL_D);
	  }if( (V->state & PDL_NOMYDIMS) && V->trans == NULL ) {
	     V->datatype = PDL_D;
	  } else if(PDL_D != V->datatype) {
	     V = PDL->get_convertedpdl(V,PDL_D);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = U;
__privtrans->pdls[1] = S;
__privtrans->pdls[2] = V;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  U->state |= PDL_BADVAL;
  S->state |= PDL_BADVAL;
  V->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = U_SV;
  ST(1) = S_SV;
  ST(2) = V_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 33262 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_rowdistances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_rowdistances)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 32914 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *dist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *rowids1;
  pdl  *rowids2;
  pdl  *dist;
  char  *distFlag;
#line 33291 "Cluster.c"
#line 32928 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 7) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids1 = PDL->SvPDLV(ST(3));
    rowids2 = PDL->SvPDLV(ST(4));
    dist = PDL->SvPDLV(ST(5));
    distFlag = (char *)SvPV_nolen(ST(6))
;
  }
  else if (items == 6) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids1 = PDL->SvPDLV(ST(3));
    rowids2 = PDL->SvPDLV(ST(4));
    distFlag = (char *)SvPV_nolen(ST(5))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       dist_SV = sv_newmortal();
       dist = PDL->null();
       PDL->SetSV_PDL(dist_SV,dist);
       if (bless_stash) dist_SV = sv_bless(dist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       dist_SV = POPs;
       PUTBACK;
       dist = PDL->SvPDLV(dist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::rowdistances(data,mask,weight,rowids1,rowids2,dist,distFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_rowdistances_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_rowdistances_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((rowids1->state & PDL_BADVAL) > 0) || ((rowids2->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != rowids1->datatype) {
	     rowids1 = PDL->get_convertedpdl(rowids1,PDL_L);
	  }if(PDL_L != rowids2->datatype) {
	     rowids2 = PDL->get_convertedpdl(rowids2,PDL_L);
	  }if( (dist->state & PDL_NOMYDIMS) && dist->trans == NULL ) {
	     dist->datatype = PDL_D;
	  } else if(PDL_D != dist->datatype) {
	     dist = PDL->get_convertedpdl(dist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = rowids1;
__privtrans->pdls[4] = rowids2;
__privtrans->pdls[5] = dist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  dist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = dist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 33399 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clusterdistances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clusterdistances)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33038 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *dist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *rowids;
  pdl  *index2;
  pdl  *dist;
  char  *distFlag;
  char  *methodFlag;
#line 33429 "Cluster.c"
#line 33053 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 8) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids = PDL->SvPDLV(ST(3));
    index2 = PDL->SvPDLV(ST(4));
    dist = PDL->SvPDLV(ST(5));
    distFlag = (char *)SvPV_nolen(ST(6))
;
    methodFlag = (char *)SvPV_nolen(ST(7))
;
  }
  else if (items == 7) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids = PDL->SvPDLV(ST(3));
    index2 = PDL->SvPDLV(ST(4));
    distFlag = (char *)SvPV_nolen(ST(5))
;
    methodFlag = (char *)SvPV_nolen(ST(6))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       dist_SV = sv_newmortal();
       dist = PDL->null();
       PDL->SetSV_PDL(dist_SV,dist);
       if (bless_stash) dist_SV = sv_bless(dist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       dist_SV = POPs;
       PUTBACK;
       dist = PDL->SvPDLV(dist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clusterdistances(data,mask,weight,rowids,index2,dist,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clusterdistances_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clusterdistances_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((rowids->state & PDL_BADVAL) > 0) || ((index2->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != rowids->datatype) {
	     rowids = PDL->get_convertedpdl(rowids,PDL_L);
	  }if(PDL_L != index2->datatype) {
	     index2 = PDL->get_convertedpdl(index2,PDL_L);
	  }if( (dist->state & PDL_NOMYDIMS) && dist->trans == NULL ) {
	     dist->datatype = PDL_D;
	  } else if(PDL_D != dist->datatype) {
	     dist = PDL->get_convertedpdl(dist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = rowids;
__privtrans->pdls[4] = index2;
__privtrans->pdls[5] = dist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  dist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = dist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 33541 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clustersizes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clustersizes)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33167 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *clustersizes_SV;
  pdl  *clusterids;
  pdl  *clustersizes;
#line 33565 "Cluster.c"
#line 33176 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    clusterids = PDL->SvPDLV(ST(0));
    clustersizes = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    clusterids = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       clustersizes_SV = sv_newmortal();
       clustersizes = PDL->null();
       PDL->SetSV_PDL(clustersizes_SV,clustersizes);
       if (bless_stash) clustersizes_SV = sv_bless(clustersizes_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       clustersizes_SV = POPs;
       PUTBACK;
       clustersizes = PDL->SvPDLV(clustersizes_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clustersizes(clusterids,clustersizes) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clustersizes_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clustersizes_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((clusterids->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (clustersizes->state & PDL_NOMYDIMS) && clustersizes->trans == NULL ) {
	     clustersizes->datatype = PDL_L;
	  } else if(PDL_L != clustersizes->datatype) {
	     clustersizes = PDL->get_convertedpdl(clustersizes,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = clusterids;
__privtrans->pdls[1] = clustersizes;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
clustersizes->state &= ~PDL_BADVAL; /* always make sure the output is "good" */if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = clustersizes_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 33646 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clusterelements); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clusterelements)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33259 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *clustersizes_SV;
  SV *eltids_SV;
  pdl  *clusterids;
  pdl  *clustersizes;
  pdl  *eltids;
#line 33672 "Cluster.c"
#line 33270 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 3) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    clusterids = PDL->SvPDLV(ST(0));
    clustersizes = PDL->SvPDLV(ST(1));
    eltids = PDL->SvPDLV(ST(2));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    clusterids = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       clustersizes_SV = sv_newmortal();
       clustersizes = PDL->null();
       PDL->SetSV_PDL(clustersizes_SV,clustersizes);
       if (bless_stash) clustersizes_SV = sv_bless(clustersizes_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       clustersizes_SV = POPs;
       PUTBACK;
       clustersizes = PDL->SvPDLV(clustersizes_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       eltids_SV = sv_newmortal();
       eltids = PDL->null();
       PDL->SetSV_PDL(eltids_SV,eltids);
       if (bless_stash) eltids_SV = sv_bless(eltids_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       eltids_SV = POPs;
       PUTBACK;
       eltids = PDL->SvPDLV(eltids_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clusterelements(clusterids,clustersizes,eltids) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clusterelements_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clusterelements_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((clusterids->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (clustersizes->state & PDL_NOMYDIMS) && clustersizes->trans == NULL ) {
	     clustersizes->datatype = PDL_L;
	  } else if(PDL_L != clustersizes->datatype) {
	     clustersizes = PDL->get_convertedpdl(clustersizes,PDL_L);
	  }if( (eltids->state & PDL_NOMYDIMS) && eltids->trans == NULL ) {
	     eltids->datatype = PDL_L;
	  } else if(PDL_L != eltids->datatype) {
	     eltids = PDL->get_convertedpdl(eltids,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = clusterids;
__privtrans->pdls[1] = clustersizes;
__privtrans->pdls[2] = eltids;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  clustersizes->state |= PDL_BADVAL;
  eltids->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = clustersizes_SV;
  ST(1) = eltids_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 33779 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clusterelementmask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clusterelementmask)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33379 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *eltmask_SV;
  pdl  *clusterids;
  pdl  *eltmask;
#line 33803 "Cluster.c"
#line 33388 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 2) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    clusterids = PDL->SvPDLV(ST(0));
    eltmask = PDL->SvPDLV(ST(1));
  }
  else if (items == 1) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    clusterids = PDL->SvPDLV(ST(0));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       eltmask_SV = sv_newmortal();
       eltmask = PDL->null();
       PDL->SetSV_PDL(eltmask_SV,eltmask);
       if (bless_stash) eltmask_SV = sv_bless(eltmask_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       eltmask_SV = POPs;
       PUTBACK;
       eltmask = PDL->SvPDLV(eltmask_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clusterelementmask(clusterids,eltmask) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clusterelementmask_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clusterelementmask_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((clusterids->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (eltmask->state & PDL_NOMYDIMS) && eltmask->trans == NULL ) {
	     eltmask->datatype = PDL_B;
	  } else if(PDL_B != eltmask->datatype) {
	     eltmask = PDL->get_convertedpdl(eltmask,PDL_B);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = clusterids;
__privtrans->pdls[1] = eltmask;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  eltmask->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = eltmask_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 33887 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clusterdistancematrix); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clusterdistancematrix)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33474 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *dist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *rowids;
  pdl  *clustersizes;
  pdl  *eltids;
  pdl  *dist;
  char  *distFlag;
  char  *methodFlag;
#line 33918 "Cluster.c"
#line 33490 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 9) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids = PDL->SvPDLV(ST(3));
    clustersizes = PDL->SvPDLV(ST(4));
    eltids = PDL->SvPDLV(ST(5));
    dist = PDL->SvPDLV(ST(6));
    distFlag = (char *)SvPV_nolen(ST(7))
;
    methodFlag = (char *)SvPV_nolen(ST(8))
;
  }
  else if (items == 8) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids = PDL->SvPDLV(ST(3));
    clustersizes = PDL->SvPDLV(ST(4));
    eltids = PDL->SvPDLV(ST(5));
    distFlag = (char *)SvPV_nolen(ST(6))
;
    methodFlag = (char *)SvPV_nolen(ST(7))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       dist_SV = sv_newmortal();
       dist = PDL->null();
       PDL->SetSV_PDL(dist_SV,dist);
       if (bless_stash) dist_SV = sv_bless(dist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       dist_SV = POPs;
       PUTBACK;
       dist = PDL->SvPDLV(dist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clusterdistancematrix(data,mask,weight,rowids,clustersizes,eltids,dist,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clusterdistancematrix_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clusterdistancematrix_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((rowids->state & PDL_BADVAL) > 0) || ((clustersizes->state & PDL_BADVAL) > 0) || ((eltids->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != rowids->datatype) {
	     rowids = PDL->get_convertedpdl(rowids,PDL_L);
	  }if(PDL_L != clustersizes->datatype) {
	     clustersizes = PDL->get_convertedpdl(clustersizes,PDL_L);
	  }if(PDL_L != eltids->datatype) {
	     eltids = PDL->get_convertedpdl(eltids,PDL_L);
	  }if( (dist->state & PDL_NOMYDIMS) && dist->trans == NULL ) {
	     dist->datatype = PDL_D;
	  } else if(PDL_D != dist->datatype) {
	     dist = PDL->get_convertedpdl(dist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = rowids;
__privtrans->pdls[4] = clustersizes;
__privtrans->pdls[5] = eltids;
__privtrans->pdls[6] = dist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  dist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = dist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 34035 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clusterdistancematrixenc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clusterdistancematrixenc)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33609 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *dist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *clens1;
  pdl  *crowids1;
  pdl  *clens2;
  pdl  *crowids2;
  pdl  *dist;
  char  *distFlag;
  char  *methodFlag;
#line 34067 "Cluster.c"
#line 33626 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 10) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    clens1 = PDL->SvPDLV(ST(3));
    crowids1 = PDL->SvPDLV(ST(4));
    clens2 = PDL->SvPDLV(ST(5));
    crowids2 = PDL->SvPDLV(ST(6));
    dist = PDL->SvPDLV(ST(7));
    distFlag = (char *)SvPV_nolen(ST(8))
;
    methodFlag = (char *)SvPV_nolen(ST(9))
;
  }
  else if (items == 9) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    clens1 = PDL->SvPDLV(ST(3));
    crowids1 = PDL->SvPDLV(ST(4));
    clens2 = PDL->SvPDLV(ST(5));
    crowids2 = PDL->SvPDLV(ST(6));
    distFlag = (char *)SvPV_nolen(ST(7))
;
    methodFlag = (char *)SvPV_nolen(ST(8))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       dist_SV = sv_newmortal();
       dist = PDL->null();
       PDL->SetSV_PDL(dist_SV,dist);
       if (bless_stash) dist_SV = sv_bless(dist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       dist_SV = POPs;
       PUTBACK;
       dist = PDL->SvPDLV(dist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clusterdistancematrixenc(data,mask,weight,clens1,crowids1,clens2,crowids2,dist,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clusterdistancematrixenc_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clusterdistancematrixenc_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((clens1->state & PDL_BADVAL) > 0) || ((crowids1->state & PDL_BADVAL) > 0) || ((clens2->state & PDL_BADVAL) > 0) || ((crowids2->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != clens1->datatype) {
	     clens1 = PDL->get_convertedpdl(clens1,PDL_L);
	  }if(PDL_L != crowids1->datatype) {
	     crowids1 = PDL->get_convertedpdl(crowids1,PDL_L);
	  }if(PDL_L != clens2->datatype) {
	     clens2 = PDL->get_convertedpdl(clens2,PDL_L);
	  }if(PDL_L != crowids2->datatype) {
	     crowids2 = PDL->get_convertedpdl(crowids2,PDL_L);
	  }if( (dist->state & PDL_NOMYDIMS) && dist->trans == NULL ) {
	     dist->datatype = PDL_D;
	  } else if(PDL_D != dist->datatype) {
	     dist = PDL->get_convertedpdl(dist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = clens1;
__privtrans->pdls[4] = crowids1;
__privtrans->pdls[5] = clens2;
__privtrans->pdls[6] = crowids2;
__privtrans->pdls[7] = dist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  dist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = dist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 34189 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_clusterdistancesenc); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_clusterdistancesenc)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33750 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *dists_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *coffsets1;
  pdl  *crowids1;
  pdl  *cwhich1;
  pdl  *coffsets2;
  pdl  *crowids2;
  pdl  *cwhich2;
  pdl  *dists;
  char  *distFlag;
  char  *methodFlag;
#line 34223 "Cluster.c"
#line 33769 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 12) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    coffsets1 = PDL->SvPDLV(ST(3));
    crowids1 = PDL->SvPDLV(ST(4));
    cwhich1 = PDL->SvPDLV(ST(5));
    coffsets2 = PDL->SvPDLV(ST(6));
    crowids2 = PDL->SvPDLV(ST(7));
    cwhich2 = PDL->SvPDLV(ST(8));
    dists = PDL->SvPDLV(ST(9));
    distFlag = (char *)SvPV_nolen(ST(10))
;
    methodFlag = (char *)SvPV_nolen(ST(11))
;
  }
  else if (items == 11) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    coffsets1 = PDL->SvPDLV(ST(3));
    crowids1 = PDL->SvPDLV(ST(4));
    cwhich1 = PDL->SvPDLV(ST(5));
    coffsets2 = PDL->SvPDLV(ST(6));
    crowids2 = PDL->SvPDLV(ST(7));
    cwhich2 = PDL->SvPDLV(ST(8));
    distFlag = (char *)SvPV_nolen(ST(9))
;
    methodFlag = (char *)SvPV_nolen(ST(10))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       dists_SV = sv_newmortal();
       dists = PDL->null();
       PDL->SetSV_PDL(dists_SV,dists);
       if (bless_stash) dists_SV = sv_bless(dists_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       dists_SV = POPs;
       PUTBACK;
       dists = PDL->SvPDLV(dists_SV);
    }
  }
  else {
    croak ("Usage:  PDL::clusterdistancesenc(data,mask,weight,coffsets1,crowids1,cwhich1,coffsets2,crowids2,cwhich2,dists,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_clusterdistancesenc_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_clusterdistancesenc_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((coffsets1->state & PDL_BADVAL) > 0) || ((crowids1->state & PDL_BADVAL) > 0) || ((cwhich1->state & PDL_BADVAL) > 0) || ((coffsets2->state & PDL_BADVAL) > 0) || ((crowids2->state & PDL_BADVAL) > 0) || ((cwhich2->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != coffsets1->datatype) {
	     coffsets1 = PDL->get_convertedpdl(coffsets1,PDL_L);
	  }if(PDL_L != crowids1->datatype) {
	     crowids1 = PDL->get_convertedpdl(crowids1,PDL_L);
	  }if(PDL_L != cwhich1->datatype) {
	     cwhich1 = PDL->get_convertedpdl(cwhich1,PDL_L);
	  }if(PDL_L != coffsets2->datatype) {
	     coffsets2 = PDL->get_convertedpdl(coffsets2,PDL_L);
	  }if(PDL_L != crowids2->datatype) {
	     crowids2 = PDL->get_convertedpdl(crowids2,PDL_L);
	  }if(PDL_L != cwhich2->datatype) {
	     cwhich2 = PDL->get_convertedpdl(cwhich2,PDL_L);
	  }if( (dists->state & PDL_NOMYDIMS) && dists->trans == NULL ) {
	     dists->datatype = PDL_D;
	  } else if(PDL_D != dists->datatype) {
	     dists = PDL->get_convertedpdl(dists,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = coffsets1;
__privtrans->pdls[4] = crowids1;
__privtrans->pdls[5] = cwhich1;
__privtrans->pdls[6] = coffsets2;
__privtrans->pdls[7] = crowids2;
__privtrans->pdls[8] = cwhich2;
__privtrans->pdls[9] = dists;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  dists->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = dists_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 34355 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_getclusterwsum); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_getclusterwsum)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 33903 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *cdata_SV;
  SV *cmask_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *clusterwts;
  pdl  *cdata;
  pdl  *cmask;
#line 34383 "Cluster.c"
#line 33916 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 5) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    clusterwts = PDL->SvPDLV(ST(2));
    cdata = PDL->SvPDLV(ST(3));
    cmask = PDL->SvPDLV(ST(4));
  }
  else if (items == 3) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    clusterwts = PDL->SvPDLV(ST(2));
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       cdata_SV = sv_newmortal();
       cdata = PDL->null();
       PDL->SetSV_PDL(cdata_SV,cdata);
       if (bless_stash) cdata_SV = sv_bless(cdata_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       cdata_SV = POPs;
       PUTBACK;
       cdata = PDL->SvPDLV(cdata_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       cmask_SV = sv_newmortal();
       cmask = PDL->null();
       PDL->SetSV_PDL(cmask_SV,cmask);
       if (bless_stash) cmask_SV = sv_bless(cmask_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       cmask_SV = POPs;
       PUTBACK;
       cmask = PDL->SvPDLV(cmask_SV);
    }
  }
  else {
    croak ("Usage:  PDL::getclusterwsum(data,mask,clusterwts,cdata,cmask) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_getclusterwsum_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_getclusterwsum_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((clusterwts->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != clusterwts->datatype) {
	     clusterwts = PDL->get_convertedpdl(clusterwts,PDL_D);
	  }if( (cdata->state & PDL_NOMYDIMS) && cdata->trans == NULL ) {
	     cdata->datatype = PDL_D;
	  } else if(PDL_D != cdata->datatype) {
	     cdata = PDL->get_convertedpdl(cdata,PDL_D);
	  }if( (cmask->state & PDL_NOMYDIMS) && cmask->trans == NULL ) {
	     cmask->datatype = PDL_L;
	  } else if(PDL_L != cmask->datatype) {
	     cmask = PDL->get_convertedpdl(cmask,PDL_L);
	  }{}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = clusterwts;
__privtrans->pdls[3] = cdata;
__privtrans->pdls[4] = cmask;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  cdata->state |= PDL_BADVAL;
  cmask->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = cdata_SV;
  ST(1) = cmask_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 34500 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_attachtonearest); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_attachtonearest)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 34035 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *clusterids_SV;
  SV *cdist_SV;
  pdl  *data;
  pdl  *mask;
  pdl  *weight;
  pdl  *rowids;
  pdl  *cdata;
  pdl  *cmask;
  pdl  *clusterids;
  pdl  *cdist;
  char  *distFlag;
  char  *methodFlag;
#line 34533 "Cluster.c"
#line 34053 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 10) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids = PDL->SvPDLV(ST(3));
    cdata = PDL->SvPDLV(ST(4));
    cmask = PDL->SvPDLV(ST(5));
    clusterids = PDL->SvPDLV(ST(6));
    cdist = PDL->SvPDLV(ST(7));
    distFlag = (char *)SvPV_nolen(ST(8))
;
    methodFlag = (char *)SvPV_nolen(ST(9))
;
  }
  else if (items == 8) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 2;
    data = PDL->SvPDLV(ST(0));
    mask = PDL->SvPDLV(ST(1));
    weight = PDL->SvPDLV(ST(2));
    rowids = PDL->SvPDLV(ST(3));
    cdata = PDL->SvPDLV(ST(4));
    cmask = PDL->SvPDLV(ST(5));
    distFlag = (char *)SvPV_nolen(ST(6))
;
    methodFlag = (char *)SvPV_nolen(ST(7))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       clusterids_SV = sv_newmortal();
       clusterids = PDL->null();
       PDL->SetSV_PDL(clusterids_SV,clusterids);
       if (bless_stash) clusterids_SV = sv_bless(clusterids_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       clusterids_SV = POPs;
       PUTBACK;
       clusterids = PDL->SvPDLV(clusterids_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       cdist_SV = sv_newmortal();
       cdist = PDL->null();
       PDL->SetSV_PDL(cdist_SV,cdist);
       if (bless_stash) cdist_SV = sv_bless(cdist_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       cdist_SV = POPs;
       PUTBACK;
       cdist = PDL->SvPDLV(cdist_SV);
    }
  }
  else {
    croak ("Usage:  PDL::attachtonearest(data,mask,weight,rowids,cdata,cmask,clusterids,cdist,distFlag,methodFlag) (you may leave temporaries or output variables out of list)");
  }
}
{
}
 { pdl_attachtonearest_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_attachtonearest_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((data->state & PDL_BADVAL) > 0) || ((mask->state & PDL_BADVAL) > 0) || ((weight->state & PDL_BADVAL) > 0) || ((rowids->state & PDL_BADVAL) > 0) || ((cdata->state & PDL_BADVAL) > 0) || ((cmask->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else if(__privtrans->__datatype == PDL_N) {}
else if(__privtrans->__datatype == PDL_Q) {}
else if(__privtrans->__datatype == PDL_F) {}
else if(__privtrans->__datatype == PDL_D) {}
else __privtrans->__datatype = PDL_D;
if(PDL_D != data->datatype) {
	     data = PDL->get_convertedpdl(data,PDL_D);
	  }if(PDL_L != mask->datatype) {
	     mask = PDL->get_convertedpdl(mask,PDL_L);
	  }if(PDL_D != weight->datatype) {
	     weight = PDL->get_convertedpdl(weight,PDL_D);
	  }if(PDL_L != rowids->datatype) {
	     rowids = PDL->get_convertedpdl(rowids,PDL_L);
	  }if(PDL_D != cdata->datatype) {
	     cdata = PDL->get_convertedpdl(cdata,PDL_D);
	  }if(PDL_L != cmask->datatype) {
	     cmask = PDL->get_convertedpdl(cmask,PDL_L);
	  }if( (clusterids->state & PDL_NOMYDIMS) && clusterids->trans == NULL ) {
	     clusterids->datatype = PDL_L;
	  } else if(PDL_L != clusterids->datatype) {
	     clusterids = PDL->get_convertedpdl(clusterids,PDL_L);
	  }if( (cdist->state & PDL_NOMYDIMS) && cdist->trans == NULL ) {
	     cdist->datatype = PDL_D;
	  } else if(PDL_D != cdist->datatype) {
	     cdist = PDL->get_convertedpdl(cdist,PDL_D);
	  }{(__privtrans->distFlag) = malloc(strlen(distFlag)+1); strcpy(__privtrans->distFlag,distFlag);(__privtrans->methodFlag) = malloc(strlen(methodFlag)+1); strcpy(__privtrans->methodFlag,methodFlag);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = data;
__privtrans->pdls[1] = mask;
__privtrans->pdls[2] = weight;
__privtrans->pdls[3] = rowids;
__privtrans->pdls[4] = cdata;
__privtrans->pdls[5] = cmask;
__privtrans->pdls[6] = clusterids;
__privtrans->pdls[7] = cdist;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  clusterids->state |= PDL_BADVAL;
  cdist->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = clusterids_SV;
  ST(1) = cdist_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 34673 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_checkprototypes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_checkprototypes)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 34195 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *cprotos_SV;
  SV *otmp_SV;
  pdl  *protos;
  pdl  *cprotos;
  pdl  *otmp;
  int  nsize;
#line 34700 "Cluster.c"
#line 34207 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    protos = PDL->SvPDLV(ST(0));
    cprotos = PDL->SvPDLV(ST(1));
    otmp = PDL->SvPDLV(ST(2));
    nsize = (int)SvIV(ST(3))
;
  }
  else if (items == 3) { PDL_COMMENT("all but temps on stack, read in output, create temps")    nreturn = 0;
    protos = PDL->SvPDLV(ST(0));
    cprotos = PDL->SvPDLV(ST(1));
    nsize = (int)SvIV(ST(2))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       otmp_SV = sv_newmortal();
       otmp = PDL->null();
       PDL->SetSV_PDL(otmp_SV,otmp);
       if (bless_stash) otmp_SV = sv_bless(otmp_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       otmp_SV = POPs;
       PUTBACK;
       otmp = PDL->SvPDLV(otmp_SV);
    }
}
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    protos = PDL->SvPDLV(ST(0));
    nsize = (int)SvIV(ST(1))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       cprotos_SV = sv_newmortal();
       cprotos = PDL->null();
       PDL->SetSV_PDL(cprotos_SV,cprotos);
       if (bless_stash) cprotos_SV = sv_bless(cprotos_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       cprotos_SV = POPs;
       PUTBACK;
       cprotos = PDL->SvPDLV(cprotos_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       otmp_SV = sv_newmortal();
       otmp = PDL->null();
       PDL->SetSV_PDL(otmp_SV,otmp);
       if (bless_stash) otmp_SV = sv_bless(otmp_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       otmp_SV = POPs;
       PUTBACK;
       otmp = PDL->SvPDLV(otmp_SV);
    }
  }
  else {
    croak ("Usage:  PDL::checkprototypes(protos,cprotos,otmp,nsize) (you may leave temporaries or output variables out of list)");
  }
}
{
	if ( protos->state & PDL_INPLACE && (cprotos != protos)) {
              protos->state &= ~PDL_INPLACE; PDL_COMMENT("unset")
              cprotos = protos;             PDL_COMMENT("discard output value, leak ?")
              PDL->SetSV_PDL(cprotos_SV,cprotos);
          }
}
 { pdl_checkprototypes_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_checkprototypes_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((protos->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < protos->datatype) {
		 	__privtrans->__datatype = protos->datatype;
		    }
if(!((cprotos->state & PDL_NOMYDIMS) &&
		       cprotos->trans == NULL) && __privtrans->__datatype < cprotos->datatype) {
		 	__privtrans->__datatype = cprotos->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else __privtrans->__datatype = PDL_L;
if(__privtrans->__datatype != protos->datatype) {
	     protos = PDL->get_convertedpdl(protos,__privtrans->__datatype);
	  }if( (cprotos->state & PDL_NOMYDIMS) && cprotos->trans == NULL ) {
	     cprotos->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != cprotos->datatype) {
	     cprotos = PDL->get_convertedpdl(cprotos,__privtrans->__datatype);
	  }if( (otmp->state & PDL_NOMYDIMS) && otmp->trans == NULL ) {
	     otmp->datatype = PDL_B;
	  } else if(PDL_B != otmp->datatype) {
	     otmp = PDL->get_convertedpdl(otmp,PDL_B);
	  }{(__privtrans->nsize) = (nsize);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = protos;
__privtrans->pdls[1] = cprotos;
__privtrans->pdls[2] = otmp;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  cprotos->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = cprotos_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 34838 "Cluster.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_PDL_checkpartitions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_PDL_checkpartitions)
{
    dVAR; dXSARGS;
    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 34347 "Cluster.xs"
  char *objname = "PDL"; /* XXX maybe that class should actually depend on the value set
                            by pp_bless ? (CS) */
  HV *bless_stash = 0;
  SV *parent = 0;
  int   nreturn;
  SV *cpart_SV;
  SV *ptmp_SV;
  pdl  *part;
  pdl  *cpart;
  pdl  *ptmp;
  int  ksize;
#line 34865 "Cluster.c"
#line 34359 "Cluster.xs"
{
  PDL_COMMENT("Check if you can get a package name for this input value.  ")
  PDL_COMMENT("It can be either a PDL (SVt_PVMG) or a hash which is a     ")
  PDL_COMMENT("derived PDL subclass (SVt_PVHV)                            ")
  if (SvROK(ST(0)) && ((SvTYPE(SvRV(ST(0))) == SVt_PVMG) || (SvTYPE(SvRV(ST(0))) == SVt_PVHV))) {
    parent = ST(0);
    if (sv_isobject(parent)){
	bless_stash = SvSTASH(SvRV(ST(0)));
	objname = HvNAME((bless_stash));  PDL_COMMENT("The package to bless output vars into is taken from the first input var")
    }
  }
  if (items == 4) { PDL_COMMENT("all variables on stack, read in output and temp vars")
    nreturn = 0;
    part = PDL->SvPDLV(ST(0));
    cpart = PDL->SvPDLV(ST(1));
    ptmp = PDL->SvPDLV(ST(2));
    ksize = (int)SvIV(ST(3))
;
  }
  else if (items == 3) { PDL_COMMENT("all but temps on stack, read in output, create temps")    nreturn = 0;
    part = PDL->SvPDLV(ST(0));
    cpart = PDL->SvPDLV(ST(1));
    ksize = (int)SvIV(ST(2))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       ptmp_SV = sv_newmortal();
       ptmp = PDL->null();
       PDL->SetSV_PDL(ptmp_SV,ptmp);
       if (bless_stash) ptmp_SV = sv_bless(ptmp_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       ptmp_SV = POPs;
       PUTBACK;
       ptmp = PDL->SvPDLV(ptmp_SV);
    }
}
  else if (items == 2) { PDL_COMMENT("only input variables on stack, create outputs and temps")
    nreturn = 1;
    part = PDL->SvPDLV(ST(0));
    ksize = (int)SvIV(ST(1))
;
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       cpart_SV = sv_newmortal();
       cpart = PDL->null();
       PDL->SetSV_PDL(cpart_SV,cpart);
       if (bless_stash) cpart_SV = sv_bless(cpart_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       cpart_SV = POPs;
       PUTBACK;
       cpart = PDL->SvPDLV(cpart_SV);
    }
    if (strcmp(objname,"PDL") == 0) { PDL_COMMENT("shortcut if just PDL")
       ptmp_SV = sv_newmortal();
       ptmp = PDL->null();
       PDL->SetSV_PDL(ptmp_SV,ptmp);
       if (bless_stash) ptmp_SV = sv_bless(ptmp_SV, bless_stash);
    } else {
       PUSHMARK(SP);
       XPUSHs(sv_2mortal(newSVpv(objname, 0)));
       PUTBACK;
       perl_call_method("initialize", G_SCALAR);
       SPAGAIN;
       ptmp_SV = POPs;
       PUTBACK;
       ptmp = PDL->SvPDLV(ptmp_SV);
    }
  }
  else {
    croak ("Usage:  PDL::checkpartitions(part,cpart,ptmp,ksize) (you may leave temporaries or output variables out of list)");
  }
}
{
	if ( part->state & PDL_INPLACE && (cpart != part)) {
              part->state &= ~PDL_INPLACE; PDL_COMMENT("unset")
              cpart = part;             PDL_COMMENT("discard output value, leak ?")
              PDL->SetSV_PDL(cpart_SV,cpart);
          }
}
 { pdl_checkpartitions_struct  *__privtrans;
  int badflag_cache = 0;
   __privtrans = malloc(sizeof(*__privtrans));
   PDL_THR_CLRMAGIC(&__privtrans->__pdlthread);
   PDL_TR_SETMAGIC(__privtrans);
   __privtrans->flags = 0;
   __privtrans->__ddone = 0;
   __privtrans->vtable = &pdl_checkpartitions_vtable;
   __privtrans->freeproc = PDL->trans_mallocfreeproc;
__privtrans->bvalflag = 0;
  badflag_cache = ((part->state & PDL_BADVAL) > 0);
  if (badflag_cache) __privtrans->bvalflag = 1;
__privtrans->__datatype = 0;if(__privtrans->__datatype < part->datatype) {
		 	__privtrans->__datatype = part->datatype;
		    }
if(!((cpart->state & PDL_NOMYDIMS) &&
		       cpart->trans == NULL) && __privtrans->__datatype < cpart->datatype) {
		 	__privtrans->__datatype = cpart->datatype;
		    }
if(!((ptmp->state & PDL_NOMYDIMS) &&
		       ptmp->trans == NULL) && __privtrans->__datatype < ptmp->datatype) {
		 	__privtrans->__datatype = ptmp->datatype;
		    }
if(__privtrans->__datatype == PDL_B) {}
else if(__privtrans->__datatype == PDL_S) {}
else if(__privtrans->__datatype == PDL_U) {}
else if(__privtrans->__datatype == PDL_L) {}
else __privtrans->__datatype = PDL_L;
if(__privtrans->__datatype != part->datatype) {
	     part = PDL->get_convertedpdl(part,__privtrans->__datatype);
	  }if( (cpart->state & PDL_NOMYDIMS) && cpart->trans == NULL ) {
	     cpart->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != cpart->datatype) {
	     cpart = PDL->get_convertedpdl(cpart,__privtrans->__datatype);
	  }if( (ptmp->state & PDL_NOMYDIMS) && ptmp->trans == NULL ) {
	     ptmp->datatype = __privtrans->__datatype;
	  } else if(__privtrans->__datatype != ptmp->datatype) {
	     ptmp = PDL->get_convertedpdl(ptmp,__privtrans->__datatype);
	  }{(__privtrans->ksize) = (ksize);}PDL_COMMENT("No flow")__privtrans->__pdlthread.inds = 0;__privtrans->pdls[0] = part;
__privtrans->pdls[1] = cpart;
__privtrans->pdls[2] = ptmp;
PDL->make_trans_mutual((pdl_trans *)__privtrans);
if (badflag_cache) {
  cpart->state |= PDL_BADVAL;
}
if (nreturn) {
  if (nreturn - items > 0) EXTEND (SP, nreturn - items);
  ST(0) = cpart_SV;
  XSRETURN(nreturn);
} else {
  XSRETURN(0);
}
}
#line 35007 "Cluster.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_PDL__Cluster); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_PDL__Cluster)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        (void)newXSproto_portable("PDL::Cluster::set_debugging", XS_PDL__Cluster_set_debugging, file, "$");
        (void)newXSproto_portable("PDL::Cluster::set_boundscheck", XS_PDL__Cluster_set_boundscheck, file, "$");
        (void)newXSproto_portable("PDL::Cluster::library_version", XS_PDL__Cluster_library_version, file, "");
        (void)newXSproto_portable("PDL::cmean", XS_PDL_cmean, file, ";@");
        (void)newXSproto_portable("PDL::cmedian", XS_PDL_cmedian, file, ";@");
        (void)newXSproto_portable("PDL::calculate_weights", XS_PDL_calculate_weights, file, ";@");
        (void)newXSproto_portable("PDL::clusterdistance", XS_PDL_clusterdistance, file, ";@");
        (void)newXSproto_portable("PDL::distancematrix", XS_PDL_distancematrix, file, ";@");
        (void)newXSproto_portable("PDL::getclustercentroids", XS_PDL_getclustercentroids, file, ";@");
        (void)newXSproto_portable("PDL::getclustermedoids", XS_PDL_getclustermedoids, file, ";@");
        (void)newXSproto_portable("PDL::kcluster", XS_PDL_kcluster, file, ";@");
        (void)newXSproto_portable("PDL::kmedoids", XS_PDL_kmedoids, file, ";@");
        (void)newXSproto_portable("PDL::treecluster", XS_PDL_treecluster, file, ";@");
        (void)newXSproto_portable("PDL::treeclusterd", XS_PDL_treeclusterd, file, ";@");
        (void)newXSproto_portable("PDL::cuttree", XS_PDL_cuttree, file, ";@");
        (void)newXSproto_portable("PDL::somcluster", XS_PDL_somcluster, file, ";@");
        (void)newXSproto_portable("PDL::pca", XS_PDL_pca, file, ";@");
        (void)newXSproto_portable("PDL::rowdistances", XS_PDL_rowdistances, file, ";@");
        (void)newXSproto_portable("PDL::clusterdistances", XS_PDL_clusterdistances, file, ";@");
        (void)newXSproto_portable("PDL::clustersizes", XS_PDL_clustersizes, file, ";@");
        (void)newXSproto_portable("PDL::clusterelements", XS_PDL_clusterelements, file, ";@");
        (void)newXSproto_portable("PDL::clusterelementmask", XS_PDL_clusterelementmask, file, ";@");
        (void)newXSproto_portable("PDL::clusterdistancematrix", XS_PDL_clusterdistancematrix, file, ";@");
        (void)newXSproto_portable("PDL::clusterdistancematrixenc", XS_PDL_clusterdistancematrixenc, file, ";@");
        (void)newXSproto_portable("PDL::clusterdistancesenc", XS_PDL_clusterdistancesenc, file, ";@");
        (void)newXSproto_portable("PDL::getclusterwsum", XS_PDL_getclusterwsum, file, ";@");
        (void)newXSproto_portable("PDL::attachtonearest", XS_PDL_attachtonearest, file, ";@");
        (void)newXSproto_portable("PDL::checkprototypes", XS_PDL_checkprototypes, file, ";@");
        (void)newXSproto_portable("PDL::checkpartitions", XS_PDL_checkpartitions, file, ";@");

    /* Initialisation Section */

#line 34502 "Cluster.xs"

   PDL_COMMENT("Get pointer to structure of core shared C routines")
   PDL_COMMENT("make sure PDL::Core is loaded")

   perl_require_pv ("PDL/Core.pm"); /* make sure PDL::Core is loaded */
#ifndef aTHX_
#define aTHX_
#endif
   if (SvTRUE (ERRSV)) Perl_croak(aTHX_ "%s",SvPV_nolen (ERRSV));
   CoreSV = perl_get_sv("PDL::SHARE",FALSE);  /* SV* value */
   if (CoreSV==NULL)
     Perl_croak(aTHX_ "We require the PDL::Core module, which was not found");
   PDL = INT2PTR(Core*,SvIV( CoreSV ));  /* Core* value */
   if (PDL->Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ "[PDL->Version: %d PDL_CORE_VERSION: %d XS_VERSION: %s] PDL::Cluster needs to be recompiled against the newly installed PDL", PDL->Version, PDL_CORE_VERSION, XS_VERSION);

#line 35090 "Cluster.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

