=pod

=head1 NAME

POSIX::2008 - Perl interface to POSIX.1-2008

=head1 SYNOPSIS

  use POSIX::2008 qw(:fcntl openat pwrite);

  sysopen my $dh, '/tmp', O_RDONLY|O_DIRECTORY|O_NOFOLLOW or die 'Dafuq?';
  my $fh = openat($dh, 'foobar', O_RDWR|O_CREAT);
  pwrite($fh, 'fuckyounsa', 10, 0);

=head1 DESCRIPTION

POSIX::2008 contains many of the interfaces specified by
L<POSIX.1-2008|https://pubs.opengroup.org/onlinepubs/9699919799/> that the
core POSIX module withholds, implements in Perl or fucked up.

It also contains a few nonstandard interfaces present in Linux, BSD and Solaris
that are extensions of the POSIX interfaces.

This module is provided "as is" unless someone volunteers to maintain it.

=head1 FILE DESCRIPTORS AND HANDLES

Since version 0.05, all I/O functions that take numeric file descriptors also
accept Perl file or directory handles.

=head1 SYSTEM CALL RETURN VALUES

A system call return value of -1 meaning "error" is mapped to undef.

A system call return value of 0 meaning "success" is mapped to "0 but true".

For system calls where 0 does not just mean "success", 0 is returned
unchanged. These are L<C<open()>|"open">, L<C<read()>|"read">,
L<C<write()>|"write">, L<C<readv()>|"readv">, L<C<writev()>|"writev">,
L<C<pread()>|"pread">, L<C<pwrite()>|"pwrite">, L<C<preadv()>|"preadv">,
L<C<pwritev()>|"pwritev">, L<C<preadv2()>|"preadv2">,
L<C<pwritev2()>|"pwritev2">, L<C<getpriority()>|"getpriority">.
L<C<openat()>|"openat"> gets a special treatment in this regard, see below.

=head1 FUNCTIONS

=over 4

=item C<a64l>

l = a64l(s);

=item C<abort>

abort();

=item C<abs>

ui = abs(i);

Calls C<llabs()>, C<labs()>, or C<abs()>, whichever is the maximum supported
by your system.

Note that the library functions use signed integers, so C<abs(~0)> is 1.
If you don't want that, use C<CORE::abs()>.

=item C<access>

ret = access(path, mode);

=item C<acos>

y = acos(x);

=item C<acosh>

y = acosh(x);

=item C<alarm>

remaining_sec = alarm(sec);

=item C<asin>

y = asin(x);

=item C<asinh>

y = asinh(x);

=item C<atan2>

z = atan2(y, x);

=item C<atan>

y = atan(x);

=item C<atanh>

y = atanh(x);

=item C<atof>

f = atof(s);

=item C<atoi>

i = atoi(s);

Calls C<atoll()>, C<atol()>, or C<atoi()>, whichever is the maximum supported 
by your system. This is of course silly because you could just use C<int()>.

=item C<basename>

s = basename(path);

=item C<cabs>

r = cabs(re, im);

=item C<cacos>

(re, im) = cacos(re, im);

=item C<cacosh>

(re, im) = cacosh(re, im);

=item C<carg>

phi = carg(re, im);

=item C<casinh>

(re, im) = casinh(re, im);

=item C<catan>

(re, im) = catan(re, im);

=item C<catanh>

(re, im) = catanh(re, im);

=item C<catclose>

ret = catclose(catd);

=item C<catgets>

s = catgets(catd, set_id, msg_id, dflt_string);

=item C<catopen>

catd = catopen(name, flag);

=item C<cbrt>

y = cbrt(x);

=item C<ccos>

(re, im) = ccos(re, im);

=item C<ccosh>

(re, im) = ccosh(re, im);

=item C<ceil>

y = ceil(x);

=item C<cexp>

(re, im) = cexp(re, im);

=item C<chdir>

ret = chdir(dir);

C<dir> can be a path, a Perl file handle or a file descriptor.

=item C<chmod>

ret = chmod(what, mode);

C<what> can be a path, a Perl file handle or a file descriptor.

=item C<chown>

ret = chown(what, uid, gid);

C<what> can be a path, a Perl file handle or a file descriptor.

=item C<cimag>

im = cimag(re, im);

=item C<clock>

t = clock()

=item C<clock_getcpuclockid>

clock_id = clock_getcpuclockid(pid);

pid defaults to C<$$>. Returns undef on error.

=item C<clock_getres>

(sec, nsec) = clock_getres(clock_id);

clock_id defaults to C<CLOCK_REALTIME>. Returns empty list on error.

=item C<clock_gettime>

(sec, nsec) = clock_gettime(clock_id);

clock_id defaults to C<CLOCK_REALTIME>. Returns empty list on error.

=item C<clock_nanosleep>

(rem_sec, rem_nsec) = clock_nanosleep(clock_id, flags, sec, nsec);

In scalar context returns the remaining seconds as a floating point number.

=item C<clock_settime>

ret = clock_settime(clock_id, sec, nsec);

=item C<clog>

(re, im) = clog(re, im);

=item C<close>

ret = close(fd);

=item C<confstr>

s = confstr(name);

I<name> is one of the C<_CS_*> integer constants.

=item C<conj>

(re, im) = conj(re, im);

=item C<copysign>

xs = copysign(x, y);

=item C<cos>

y = cos(x);

=item C<cosh>

y = cosh(x);

=item C<cpow>

(re, im) = cpow(re_x, im_x, re_y, im_y);

=item C<cproj>

(re, im) = cproj(re, im);

=item C<creal>

re = creal(re, im);

=item C<csin>

(re, im) = csin(re, im);

=item C<csinh>

(re, im) = csinh(re, im);

=item C<csqrt>

(re, im) = csqrt(re, im);

=item C<ctan>

(re, im) = ctan(re, im);

=item C<ctanh>

(re, im) = ctanh(re, im);

=item C<dirname>

name = dirname(path);

=item C<div>

(quot, rem) = div(numer, denom);

Calls C<lldiv()>, C<ldiv()>, or C<div()>, whichever is the maximum supported
by your system.

Note that the library functions use signed integers, so C<div(~0, 1)> is
C<(-1, 0)>. If you don't want that, use Perls C<int()>, C</> and C<%>.

=item C<dlclose>

dlclose(dlhandle);

=item C<dlerror>

dlerror();

=item C<dlopen>

dlhandle = dlopen(file, mode);

=item C<dlsym>

addr = dlsym(dlhandle, name);

=item C<drand48>

r = drand48();

=item C<endutxent>

endutxent();

=item C<erand48>

(r, X0, X1, X2) = erand48(X0, X1, X2);

=item C<erf>

y = erf(x);

=item C<erfc>

y = erfc(x);

=item C<exp>

y = exp(x);

=item C<exp2>

y = exp2(x);

=item C<expm1>

y = expm1(x);

=item C<faccessat>

ret = faccessat(dirfd, path, amode, flags=0);

I<flags> is the bitwise OR of zero or more of C<AT_EACCESS>,
C<AT_SYMLINK_NOFOLLOW>.

=item C<fchmodat>

ret = fchmodat(dirfd, path, mode, flags=0);

I<flags> can be 0 or C<AT_SYMLINK_NOFOLLOW>.

=item C<fchownat>

ret = fchownat(dirfd, path, uid, gid, flags=0);

I<flags> can be 0 or C<AT_SYMLINK_NOFOLLOW>.

=item C<fdatasync>

ret = fdatasync(fd);

=item C<fdopen>

ret = fdopen(fd, mode);

Returns a file handle associated with the file descriptor I<fd> or undef on
error. I<mode> is one of the values C<"r">, C<"w">, C<"a"> with an optional
C<"+"> and/or C<"b">.

It's similar to C<IO::Handle::new_from_fd()> with the following improvements:

=over

=item *
It I<really> calls C<fdopen(3)>.

=item *
It expects POSIX mode strings (e.g. C<"r">, not C<"<">).

=item *
It fails if I<mode> is not compatible with the flags of I<fd>.

=back

=item C<fdopendir>

ret = fdopendir(fd);

Returns a directory handle associated with the file descriptor I<fd> or undef
on error. Usage example:

  my $dh = do {
    sysopen my $fh, '/tmp', O_RDONLY|O_DIRECTORY|O_NOFOLLOW;
    fdopendir($fh); # or fdopendir(fileno $fh) but the former also works
                    # with handles from opendir() for which fileno does
                    # not work before Perl 5.22
  };
  my @files = readdir $dh;  # this would fail with $fh from sysopen

=item C<fdim>

d = fdim(double x, double y);

=item C<feclearexcept>

ret = feclearexcept(excepts);

Returns C<0 but true> on success, undef on error.

=item C<fegetround>

rounding_mode = fegetround();

=item C<feraiseexcept>

ret = feraiseexcept(excepts);

Returns C<0 but true> on success, undef on error.

=item C<fesetround>

ret = fesetround(round);

Returns C<0 but true> on success, undef on error.

=item C<fetestexcept>

excepts_currently_set = fetestexcept(excepts);

=item C<ffs>

pos = ffs(i);

Calls C<ffsll()>, C<ffsl()>, or C<ffs()>, whichever is the maximum available
on your system.

=item C<floor>

y = floor(x);

=item C<fma>

r = fma(x, y, z);

=item C<fmax>

m = fmax(x, y);

=item C<fmin>

m = fmin(x, y);

=item C<fmod>

m = fmod(x, y);

=item C<fnmatch>

ret = fnmatch(pattern, string, flags);

Returns 0 if I<string> matches I<pattern>, C<FNM_NOMATCH> if there is no
match, undef if there is an error.

I<flags> is the bitwise OR of zero or more of C<FNM_NOESCAPE>,
C<FNM_PATHNAME>, C<FNM_PERIOD>, C<FNM_FILE_NAME>, C<FNM_LEADING_DIR>,
C<FNM_CASEFOLD>.

=item C<fpclassify>

fpclassify(x);

Returns one of C<FP_NAN>, C<FP_INFINITE>, C<FP_ZERO>, C<FP_SUBNORMAL>,
C<FP_NORMAL>.

=item C<fstatat>

(dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec,
blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = fstatat(dirfd, path,
flags = 0);

I<flags> is the bitwise OR of zero or more of C<AT_SYMLINK_NOFOLLOW>,
C<AT_NO_AUTOMOUNT>.

See L<C<stat()>|"stat"> for notes on the return values and bugs in C<CORE::stat()>.

Returns an empty list on error.

=item C<fsync>

ret = fsync(fd);

=item C<futimens>

ret = futimens(fd, atime_sec, atime_nsec, mtime_sec, mtime_nsec);

atime_sec and mtime_sec default to 0, atime_nsec and mtime_nsec default to
C<UTIME_NOW>.

=item C<getdate>

(sec, min, hour, mday, mon, year, wday, yday, isdst) = getdate(string);

=item C<getdate_err>

getdate_err() returns the value of the getdate_err variable.

=item C<getegid>

egid = getegid();

=item C<geteuid>

euid = geteuid();

=item C<getgid>

gid = getgid();

=item C<gethostid>

hostid = gethostid();

=item C<gethostname>

hostname = gethostname();

=item C<getitimer>

(int_sec, int_usec, val_sec, val_usec) = getitimer(which);

I<which> is one of C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>.

=item C<getpriority>

prio = getpriority(which=PRIO_PROCESS, who=0);

I<which> can be one of C<PRIO_PROCESS>, C<PRIO_PGRP>, C<PRIO_USER>, defaults
to C<PRIO_PROCESS>. I<who> defaults to 0.

Returns undef on error.

=item C<getsid>

sid = getsid(pid);

I<pid> defaults to 0.

=item C<getuid>

uid = getuid();

=item C<getutxent>

(user, id, line, pid, type, sec, usec) = getutxent();

getutxent() reads a line from the current file position in the utmp file.

=item C<getutxid>

(user, id, line, pid, type, sec, usec) = getutxid(ut_type, ut_id);

getutxid() searches forward from the current file position in the utmp file
based upon I<ut_type> and I<ut_id>. If I<ut_type> is one of C<RUN_LVL>,
C<BOOT_TIME>, C<NEW_TIME>, or C<OLD_TIME>, getutxid() will find the first
entry whose I<ut_type> field matches I<ut_type>. If I<ut_type> is one of
C<INIT_PROCESS>, C<LOGIN_PROCESS>, C<USER_PROCESS>, or C<DEAD_PROCESS>,
getutxid() will find the first entry whose I<ut_id> field matches I<ut_id>.

=item C<getutxline>

(user, id, line, pid, type, sec, usec) = getutxline(ut_line);

getutxline() searches forward from the current file position in the utmp file.
It scans entries whose I<ut_type> is C<USER_PROCESS> or C<LOGIN_PROCESS> and
returns the first one whose I<ut_line> field matches I<ut_line>.

=item C<hypot>

r = hypot(x, y);

=item C<ilogb>

y = ilogb(x);

=item C<isalnum>

ret = isalnum(charstring);

Like POSIX::isalnum() but returns 0 for the empty string.

=item C<isalpha>

ret = isalpha(charstring);

Like POSIX::isalpha() but returns 0 for the empty string.

=item C<isascii>

ret = isascii(charstring);

POSIX.1-2008 marks it as obsolete, but I include it anyway.

=item C<isatty>

ret = isatty(fd);

=item C<isblank>

ret = isblank(charstring);

Like POSIX::isblank() but returns 0 for the empty string.

=item C<iscntrl>

ret = iscntrl(charstring);

Like POSIX::iscntrl() but returns 0 for the empty string.

=item C<isdigit>

ret = isdigit(charstring);

Like POSIX::isdigit() but returns 0 for the empty string.

=item C<isfinite>

ret = isfinite(x);

=item C<isgraph>

ret = isgraph(charstring);

Like POSIX::isgraph() but returns 0 for the empty string.

=item C<isinf>

ret = isinf(x);

=item C<islower>

ret = islower(charstring);

Like POSIX::islower() but returns 0 for the empty string.

=item C<isnan>

ret = isnan(x);

=item C<isnormal>

ret = isnormal(x);

=item C<isprint>

ret = isprint(charstring);

Like POSIX::isprint() but returns 0 for the empty string.

=item C<ispunct>

ret = ispunct(charstring);

Like POSIX::ispunct() but returns 0 for the empty string.

=item C<isspace>

ret = isspace(charstring);

Like POSIX::isspace() but returns 0 for the empty string.

=item C<isupper>

ret = isupper(charstring);

Like POSIX::isupper() but returns 0 for the empty string.

=item C<isxdigit>

ret = isxdigit(charstring);

Like POSIX::isxdigit() but returns 0 for the empty string.

=item C<j0>

y = j0(x);

C<j0()> is the Bessel function of the first kind of order 0.

=item C<j1>

y = j1(x);

C<j1()> is the Bessel function of the first kind of order 1.

=item C<jn>

y = jn(n, x);

C<jn()> is the Bessel function of the first kind of order I<n>.

=item C<jrand48>

(r, X0, X1, X2) = jrand48(X0, X1, X2);

=item C<killpg>

ret = killpg(pgrp, sig);

=item C<l64a>

s = l64a(n);

=item C<lchown>

ret = lchown(path, uid, gid);

=item C<ldexp>

y = ldexp(x, exp);

=item C<lgamma>

y = lgamma(x);

=item C<link>

ret = link(path1, path2);

=item C<linkat>

ret = linkat(fd1, path1, fd2, path2, flags=0);

I<flags> can be 0 or C<AT_SYMLINK_FOLLOW>.

=item C<log1p>

y = log1p(x);

=item C<log2>

y = log2(x);

=item C<logb>

y = logb(x);

=item C<lrand48>

r = lrand48();

=item C<lround>

l = lround(x);

Calls C<llround()> or C<lround()> whichever is the maximum available on your
system. If the rounded value is outside Perl's internal signed integer range,
it is returned as a string. If the rounded value is too large to be stored in
a long long or long, undef is returned.

=item C<lstat>

(dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec,
blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = lstat(path);

C<path> is assumed to be a string (or will be converted to a string).

See L<C<stat()>|"stat"> for notes on the return values and bugs in C<CORE::stat()>.

Returns an empty list on error.

=item C<mkdir>

ret = mkdir(path, [mode = 0777]);

=item C<mkdirat>

ret = mkdirat(fd, path, mode);

=item C<mkdtemp>

name = mkdtemp(template);

=item C<mkfifo>

ret = mkfifo(path, mode);

=item C<mkfifoat>

ret = mkfifoat(fd, path, mode);

=item C<mknod>

ret = mknod(path, mode, dev);

=item C<mknodat>

ret = mknodat(fd, path, mode, dev);

=item C<mkstemp>

(fd, name) = mkstemp(template);

=item C<mrand48>

mrand48();

=item C<nanosleep>

(rem_sec, rem_nsec) = nanosleep(sec, nsec);

In scalar context returns the remaining seconds as a floating point number.

=item C<nearbyint>

y = nearbyint(x);

=item C<nextafter>

z = nextafter(x, y);

=item C<nexttoward>

z = nexttoward(x, y);

=item C<nice>

ret = nice(incr);

Returns undef on error.

=item C<nrand48>

r = nrand48()

=item C<open>

ret = open(path, flags=O_RDONLY, mode=0666);

=item C<openat>

ret = openat(dirfd, path, flags=O_RDONLY, mode=0666);

If I<dirfd> is numeric (i.e. a file descriptor), C<openat()> returns a file
descriptor. If I<dirfd> is a file or directory handle, the return value is
also a handle whose type depends on the file type of I<path>: If I<path> is a
directory, the return value is a directory handle, otherwise it's a file
handle.

To get a handle even for the special numeric I<dirfd> value C<AT_FDCWD>, you
can pass a reference to that value instead, i.e. C<openat(\AT_FDCWD, ...)>.

Returns undef on error.

=item C<openat2>

ret = openat2(dirfd, path, how);

The C<openat2()> system call is a Linux-specific extension of
L<C<openat()>|"openat"> and provides a superset of its functionality.

The I<how> parameter is a hash reference corresponding to the I<struct
open_how>. It currently supports the keys I<flags>, I<mode> and
I<resolve>. Missing keys are treated as having a zero value.

Example:

  my $fh = openat2(
    \AT_FDCWD, '/foobar',
    {flags => O_RDWR|O_CREAT, mode => 0600, resolve => RESOLVE_IN_ROOT}
  );

Note that, unlike L<C<open()>|"open"> or L<C<openat()>|"openat">, C<openat2()>
is very picky about I<flags> and I<mode>. See the manpage for details.

Returns undef on error.

=item C<posix_fadvise>

ret = posix_fadvise(fd, offset, len, advice);

I<advice> is one of the C<POSIX_FADV_> constants.

Returns undef on error

=item C<posix_fallocate>

ret = posix_fallocate(fd, offset, len);

=item C<pread>

bytes_read = pread(fd, buf, count, offset=0, buf_offset=0);

C<pread()> reads I<count> bytes (not characters) of data from the file
descriptor I<fd> at file offset I<offset> into the scalar I<buf> without
changing the file offset. I<buf> will be enlarged automatically if necessary.

I<offset> and I<buf_offset> are set to 0 if omitted or undef.

C<pread()> treats I<buf> just like C<sysread()> does: I<buf_offset> may be
specified to place the read data at that position in I<buf>. If I<buf_offset>
is past the end of I<buf>, I<buf> will be padded with zeros before appending
the data. If I<buf_offset> is negative, it is counted from the end of the
string. I<buf> will be grown or shrunk so that the last byte actually read is
the last byte of I<buf> after the read.

Returns the number of bytes read, 0 at EOF, undef on error.

=item C<preadv>

bytes_read = preadv(fd, buffers, sizes, offset=0);

C<preadv()> behaves like L<C<readv()>|"readv"> but adds an optional I<offset>
argument, which specifies the file position at which the data is to be
read. I<offset> is set to 0 if omitted or undef.

The file offset is not changed by this system call. The file referred to by
I<fd> must be capable of seeking.

This syscall is present in Linux and BSD.

=item C<preadv2>

bytes_read = preadv2(fd, buffers, sizes, offset=0, flags=0);

C<preadv2()> is similar to L<C<preadv()>|"preadv"> but adds an optional I<flags>
argument, which is a bitwise OR of zero or more of the C<RWF_*> flags (see the
manpage for details). I<flags> is set to 0 if omitted or undef.

This syscall is Linux-specific.

=item C<ptsname>

name = ptsname(fd);

=item C<pwrite>

bytes_written = pwrite(fd, buf, count=undef, offset=0, buf_offset=0);

C<pwrite()> writes I<count> bytes of data from the scalar I<buf> to the file
descriptor I<fd> at file offset I<offset> without changing the file
offset. The file referenced by I<fd> must be capable of seeking.

If I<count> is omitted or undef, everything from I<buf_offset> up to the end
of I<buf> is written.

I<buf_offset> may be specified to write data from that position in
I<buf>. If I<buf_offset> is negative it is counted from the end
of the string.

I<offset> and I<buf_offset> are set to 0 if omitted or undef.

Returns the number of bytes written, undef on error.

On Linux, if a file is opened with C<O_APPEND>, C<pwrite()> appends data to
the end of the file, regardless of the value of I<offset> (in violation of
POSIX).

=item C<pwritev>

bytes_written = pwritev(fd, buffers, offset=0);

C<pwritev()> behaves like L<C<writev()>|"writev"> but adds an optional
I<offset> argument, which specifies the file position at which the data is to
be written. I<offset> is set to 0 if omitted or undef.

The file offset is not changed by this system call. The file referred to by
I<fd> must be capable of seeking.

On Linux, if a file is opened with C<O_APPEND>, C<pwritev()> appends data to
the end of the file, regardless of the value of I<offset> (in violation of
POSIX).

This syscall is present in Linux and BSD.

=item C<pwritev2>

bytes_written = pwritev2(fd, buffers, offset=0, flags=0);

C<pwritev2()> is similar to L<C<pwritev()>|"pwritev"> but adds an optional
I<flags> argument, which is a bitwise OR of zero or more of the C<RWF_*>
flags (see the manpage for details). I<flags> is set to 0 if omitted or undef.

This syscall is Linux-specific.

=item C<random>

r = random();

=item C<read>

bytes_read = read(fd, buf, count);

Like C<POSIX::read()> but returns 0 at EOF instead of I<"0 but true">.

=item C<readv>

bytes_read = readv(fd, buffers, sizes);

Example:

  my $fh = openat(\AT_FDCWD, '/tmp/foobar', O_RDWR|O_CREAT|O_TRUNC);
  pwrite($fh, 'foobar', 6, 0);
  readv($fh, my @buf, [4, 0, 4, 4]);
  # -> @buf is ('foob', '', 'ar')

C<readv()> reads from the file descriptor I<fd> into I<buffers> as many
strings as there are elements in I<sizes>.

I<buffers> must be a I<variable> holding either an array or an array
reference, i.e. C<@buf> or C<$buf>.

I<sizes> must be an array reference, i.e. C<\@sizes>, C<$sizes>, or C<[...]>.

I<sizes> is expected to hold unsigned integers that specify how many bytes are
to be read into each buffer. A byte count of 0 or undef creates an empty
string. I<sizes> is processed in array order.

I<buffers> will be extended if necessary, but it will never be shrunk. If
I<buffers> is not empty, any existing elements are replaced as long as
sufficient data was read from I<fd>.

If the total byte count of I<sizes> exceeds the number of bytes actually read
from I<fd>, there may be one partly filled buffer and the rest of I<sizes> is
skipped, so you may end up with less strings in I<buffers> than there are
elements in I<sizes>.

C<readv()> returns the number of bytes read (which may be less than the total
bytes in I<sizes>) or undef on error.

=item C<readlink>

name = readlink(path);

Returns undef on error.

=item C<readlinkat>

name = readlinkat(dirfd, path);

Returns undef on error.

=item C<realpath>

resolved_path = realpath(path);

Calls the actual C library fuction C<realpath()> and relies on it to be able
to allocate memory for the resolved path automatically (as required by
POSIX-2008).

Returns undef on error.

=item C<remainder>

rem = remainder(x, y);

Returns  undef on error.

=item C<remove>

ret = remove(path);

Calls the actual C library function C<remove()>.

Note that core C<POSIX::remove()> fails if I<path> is a symlink to a directory
because someone "couldn't read the plans right and did a piss-poor job of
putting it together" as C<(-d $_[0]) ? CORE::rmdir($_[0]) :
CORE::unlink($_[0])>. Quote from Armageddon.

This could be fixed like this: C<unlink $_[0] or ($!{EISDIR} or $!{EPERM}) and
rmdir $_[0]> (correct errno check depends on OS), or by using the library call
right away.

=item C<remquo>

(rem, quo) = remquo(x, y);

Returns an empty list on error.

=item C<rename>

ret = rename(old, new);

=item C<renameat>

ret = renameat(olddirfd, oldpath, newdirfd, newpath);

=item C<renameat2>

ret = renameat(olddirfd, oldpath, newdirfd, newpath, flags=0);

The C<renameat2()> system call is a Linux-specific extension of
L<C<renameat()>|"renameat"> and provides a superset of its functionality.

I<flags> is the bitwise OR of zero or more of C<RENAME_EXCHANGE>,
C<RENAME_NOREPLACE>, C<RENAME_WHITEOUT>.

=item C<round>

r = round(x);

=item C<scalbn>

y = scalbn(x, n);

Calls C<scalbln()> or C<scalbn()>, whichever is the maximum supported by your
system.

=item C<seed48>

(old_seed1, old_seed2, old_seed3) = seed48(seed1, seed2, seed3);

=item C<setegid>

ret = setegid(gid);

=item C<seteuid>

ret = seteuid(uid);

=item C<setgid>

ret = setgid(gid);

=item C<setitimer>

(old_int_sec, old_int_usec, old_val_sec, old_val_usec) = setitimer(which, int_sec, int_usec, val_sec, val_usec);

I<which> is one of C<ITIMER_REAL>, C<ITIMER_VIRTUAL>, C<ITIMER_PROF>.

=item C<setpriority>

ret = setpriority(prio, which=PRIO_PROCESS, who=0);

I<which> can be one of C<PRIO_PROCESS>, C<PRIO_PGRP>, C<PRIO_USER>, defaults
to C<PRIO_PROCESS>. I<who> defaults to 0.

Note that due to the support of default values for I<which> and I<who>,
I<prio> is the first call parameter, whereas in the actual syscall it is the
last.

Returns true on success, undef on error.

=item C<setregid>

ret = setregid(rgid, egid);

=item C<setreuid>

ret = setreuid(ruid, euid);

=item C<setsid>

sid = setsid();

=item C<setuid>

ret = setuid(uid);

=item C<setutxent>

setutxent();

=item C<sighold>

ret = sighold(sig);

=item C<sigignore>

ret = sigignore(sig);

=item C<signbit>

b = signbit(x);

=item C<sigpause>

sigpause(sig);

=item C<sigrelse>

ret = sigrelse(sig);

=item C<sin>

y = sin(x);

=item C<sinh>

y = sinh(x);

=item C<srand48>

srand48(seedval);

=item C<srandom>

srandom(seed);

=item C<stat>

(dev, ino, mode, nlink, uid, gid, rdev, size, atim_sec, mtim_sec, ctim_sec,
blksize, blocks, atim_nsec, mtim_nsec, ctim_nsec) = stat(what);

C<what> can be a path, a Perl file handle or a file descriptor.

C<ctim_sec>, C<blksize>, C<blocks> and nanoseconds may not be available on
your system. Values outside Perl's internal integer range are returned as
strings, i.e. if you need the exact values you should, for example, use C<eq>
instead of C<==> for comparisons.

Note that C<CORE::stat()> lies to you in some cases: It returns I<rdev> as a
signed integer even if your OS's C<dev_t> is unsigned. It returns I<size> as
a floating point number if your OS's C<off_t> is bigger than Perl's integer
size. It returns the times as floating point numbers if your OS's C<time_t>
is unsigned.

C<POSIX::2008::stat()> doesn't mimic these bugs and uses the correct data types
for all values.

Returns an empty list on error.

=item C<strptime>

(sec, min, hour, mday, mon, year, wday, yday, isdst) = strptime(s, format[,
sec, min, hour, mday, mon, year, wday, yday, isdst]);

C<strptime()> converts the string I<s> into a broken-down time according to
the format string I<format>. The time fields may optionally be initialized in
whole or in part and will be returned as initialized if they are not affected
by the format string. Unprocessed uninitialized or undef fields are returned
as undef.

Returns an empty list on error.

In scalar context returns the index of the first byte in I<s> that was not
processed or the byte length of I<s> if the whole string was consumed or undef
on error.

As C<strptime()> acts on null-terminated strings, strings containing NUL bytes
will only be processed up to the first NUL byte.

=item C<symlink>

ret = symlink(target, linkpath);

=item C<symlinkat>

ret = symlinkat(target, dirfd, linkpath);

=item C<sync>

sync();

=item C<tan>

y = tan(x);

=item C<tanh>

y = tanh(x);

=item C<tgamma>

y = tgamma(x);

=item C<timer_create>

timerid = timer_create(clockid, signal);

Returns undef on error.

=item C<timer_delete>

ret = timer_delete(timerid);

Returns C<0 but true> on success, undef on error.

=item C<timer_getoverrun>

count = timer_getoverrun(timerid);

Returns undef on error.

=item C<timer_gettime>

(interval_sec, interval_nsec, initial_sec, initial_nsec) = timer_gettime(timerid);

Returns an empty list on error.

=item C<timer_settime>

(old_int_sec, old_int_nsec, old_init_sec, old_init_nsec) = timer_settime(timerid, flags, int_sec, int_nsec, [init_sec, init_nsec]);

I<flags> may be 0 or C<TIMER_ABSTIME>. If the I<init> values are omitted, they
are set to the I<int> values.

=item C<truncate>

ret = truncate(path, length);

=item C<trunc>

y = trunc(x);

=item C<ttyname>

name = ttyname(fd);

=item C<unlink>

ret = unlink(path);

Calls the actual C library function C<unlink()>.

Note that core C<POSIX::unlink()> calls C<CORE::unlink()>, which, unless you
start Perl with C<-U>, a) is prone to time-of-check/time-of-use race
conditions due to an additional lstat(), and b) blindly fails with C<EISDIR>
for directories (due to said lstat()), ignoring that some OSes use C<EPERM> in
this case (as required by POSIX).

=item C<unlinkat>

ret = unlinkat(dirfd, path, flags=0);

I<flags> can be 0 or C<AT_REMOVEDIR>.

=item C<utimensat>

ret = utimensat(dirfd, path, flags, atime_sec, atime_nsec, mtime_sec,
mtime_nsec);

I<flags> can be 0 or C<AT_SYMLINK_NOFOLLOW>, defaults to 0.

I<atime_sec> and I<mtime_sec> default to 0. I<atime_nsec> and I<mtime_nsec>
default to C<UTIME_NOW>.

=item C<write>

bytes_written = write(fd, buf, count=undef);

Like C<POSIX::write()> but returns 0 instead of C<0 but true> if 0 bytes were
written, and never writes more bytes than I<buf> contains even if I<count>
exceeds the length of I<buf>.

If I<count> is omitted or undef, it defaults to the length of I<buf>.

=item C<writev>

bytes_written = writev(fd, buffers);

C<writev()> writes multiple I<buffers> of data to the file associated with the
file descriptor I<fd>.

I<buffers> must be an array reference, i.e. C<\@buf>, C<$buf> or C<[...]>. The
buffers are processed in array order. Undefined or empty elements are skipped.

Returns the number of bytes written or undef on error.

=item C<y0>

y = y0(x);

C<y0()> is the Bessel function of the second kind of order 0.

=item C<y1>

y = y1(x);

C<y1()> is the Bessel function of the second kind of order 1.

=item C<yn>

y = yn(n, x);

C<yn()> is the Bessel function of the second kind of order n.

=back

=head1 EXPORTS

This module does not export anything by default. The following export tags are
available:

 :at     All *at() functions like openat() and all AT_/RENAME_/RESOLVE_ constants
 :id     All get/set*id() functions like getuid() etc.
 :is     All is* functions like isdigit() etc.
 :rw     read(), readv(), write(), writev()
 :prw    pread(), preadv(), preadv2(), pwrite(), pwritev(), pwritev2()
 :clock  All clock* functions and CLOCK_ constants
 :fcntl  All F_, FD_, O_, POSIX_FADV_, SEEK_ and _OK constants (for AT_ use :at)
 :fenv_h All FE_ constants and fe* functions
 :fnm    fnmatch() and all FNM_ constants
 :stat_h All S_I* and UTIME_ constants
 :time_h All CLOCK_ and TIMER_ constants
 :timer  All timer_ functions and TIMER_ constants

=head1 CONSTANTS

C<AT_EACCESS> C<AT_EMPTY_PATH> C<AT_FDCWD> C<AT_NO_AUTOMOUNT> C<AT_REMOVEDIR>
C<AT_SYMLINK_FOLLOW> C<AT_SYMLINK_NOFOLLOW> C<RENAME_EXCHANGE>
C<RENAME_NOREPLACE> C<RENAME_WHITEOUT> C<RESOLVE_BENEATH> C<RESOLVE_CACHED>
C<RESOLVE_IN_ROOT> C<RESOLVE_NO_MAGICLINKS> C<RESOLVE_NO_SYMLINKS>
C<RESOLVE_NO_XDEV>

C<BOOT_TIME> C<NEW_TIME> C<OLD_TIME> C<DEAD_PROCESS> C<INIT_PROCESS>
C<LOGIN_PROCESS> C<USER_PROCESS> C<RUN_LVL>

C<CLOCK_BOOTTIME> C<CLOCK_HIGHRES> C<CLOCK_MONOTONIC>
C<CLOCK_MONOTONIC_COARSE> C<CLOCK_MONOTONIC_FAST> C<CLOCK_MONOTONIC_PRECISE>
C<CLOCK_MONOTONIC_RAW> C<CLOCK_PROCESS_CPUTIME_ID> C<CLOCK_REALTIME>
C<CLOCK_REALTIME_COARSE> C<CLOCK_REALTIME_FAST> C<CLOCK_REALTIME_PRECISE>
C<CLOCK_SOFTTIME> C<CLOCK_THREAD_CPUTIME_ID> C<CLOCK_UPTIME>
C<CLOCK_UPTIME_FAST> C<CLOCK_UPTIME_PRECISE>

C<_CS_GNU_LIBC_VERSION> C<_CS_GNU_LIBPTHREAD_VERSION> C<_CS_PATH>

C<F_DUPFD> C<F_DUPFD_CLOEXEC> C<F_GETFD> C<F_SETFD> C<F_GETFL>
C<F_SETFL> C<F_GETLK> C<F_SETLK> C<F_SETLKW> C<F_GETOWN> C<F_SETOWN>
C<F_RDLCK> C<F_UNLCK> C<F_WRLCK>

C<FE_TONEAREST> C<FE_TOWARDZERO> C<FE_UPWARD> C<FE_DOWNWARD>

C<FD_CLOEXEC>

C<FNM_CASEFOLD> C<FNM_FILE_NAME> C<FNM_LEADING_DIR> C<FNM_NOESCAPE>
C<FNM_NOMATCH> C<FNM_PATHNAME> C<FNM_PERIOD>

C<FP_INFINITE> C<FP_NAN> C<FP_NORMAL> C<FP_SUBNORMAL> C<FP_ZERO>

C<TIMER_ABSTIME> C<ITIMER_PROF> C<ITIMER_REAL> C<ITIMER_VIRTUAL>

C<O_ACCMODE> C<O_APPEND> C<O_ASYNC> C<O_CLOEXEC> C<O_CREAT> C<O_DIRECT>
C<O_DIRECTORY> C<O_DSYNC> C<O_EXCL> C<O_EXEC> C<O_LARGEFILE> C<O_NDELAY>
C<O_NOATIME> C<O_NOCTTY> C<O_NOFOLLOW> C<O_NONBLOCK> C<O_PATH> C<O_RDONLY>
C<O_RDWR> C<O_RSYNC> C<O_SEARCH> C<O_SYNC> C<O_TMPFILE> C<O_TRUNC>
C<O_TTY_INIT> C<O_WRONLY> C<FASYNC>

C<POSIX_FADV_NORMAL> C<POSIX_FADV_SEQUENTIAL> C<POSIX_FADV_RANDOM>
C<POSIX_FADV_NOREUSE> C<POSIX_FADV_WILLNEED> C<POSIX_FADV_DONTNEED>

C<PRIO_PROCESS> C<PRIO_PGRP> C<PRIO_USER>

C<RTLD_GLOBAL> C<RTLD_LAZY> C<RTLD_LOCAL> C<RTLD_NOW>

C<RWF_APPEND> C<RWF_DSYNC> C<RWF_HIPRI> C<RWF_NOWAIT> C<RWF_SYNC>

C<SEEK_SET> C<SEEK_CUR> C<SEEK_END> C<SEEK_DATA> C<SEEK_HOLE> C<F_OK> C<R_OK>
C<W_OK> C<X_OK>

C<S_IFMT> C<S_IFBLK> C<S_IFCHR> C<S_IFIFO> C<S_IFREG> C<S_IFDIR> C<S_IFLNK>
C<S_IFSOCK> C<S_ISUID> C<S_ISGID> C<S_IRWXU> C<S_IRUSR> C<S_IWUSR> C<S_IXUSR>
C<S_IRWXG> C<S_IRGRP> C<S_IWGRP> C<S_IXGRP> C<S_IRWXO> C<S_IROTH> C<S_IWOTH>
C<S_IXOTH> C<S_ISVTX> 

C<UTIME_NOW> C<UTIME_OMIT>

=head1 NOTES

C<preadv()> and C<pwritev()> are nonstandard extensions present in Linux and
BSD.

C<openat2()>, C<preadv2()>, C<pwritev2()> and C<renameat2()> are nonstandard
extensions present in Linux.

C<fstatat()>, C<lstat()> and C<stat()> do not set the special underscore
filehandle C<_> (mostly because I have no clue how that works).

C<open()>, C<openat()> and C<openat2()> do not set the C<O_CLOEXEC> flag
automatically. You have to take care of that yourself if needed.

C<isalnum()> and friends were cowardly removed from the POSIX module with Perl
5.24.0. They have found a cozy home here with a fix for a long-standing bug.

C<SEEK_DATA> and C<SEEK_HOLE> are nonstandard extensions present in Linux,
Solaris, FreeBSD, and DragonFly BSD; they are proposed for inclusion in the
next POSIX revision (Issue 8).

=head1 AUTHOR

Initially hacked together by Carsten Gaebler.

=head1 LICENSE

This library is free software. You can redistribute and/or modify it under the
terms of the Do What The Fuck You Want To Public License, Version 2, as
published by Sam Hocevar. See the COPYING file or L<http://www.wtfpl.net/> for
more details.

=cut
