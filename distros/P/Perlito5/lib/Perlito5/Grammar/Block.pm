# Do not edit this file - Generated by Perlito5 9.027

{
    package main;
    package Perlito5::Grammar::Block;
    use Perlito5::Grammar::Expression ;
    use Perlito5::Grammar::Scope ;
    use Perlito5::AST::BeginScratchpad ;
    use Perlito5::AST::Captures ;
    use Perlito5::FoldConstant ;
    use strict ;
    our %Named_block = ("BEGIN", 1, "UNITCHECK", 1, "CHECK", 1, "INIT", 1, "END", 1, "AUTOLOAD", 1, "DESTROY", 1);
    sub Perlito5::Grammar::Block::block {
        my $str = $_[0];
        my $pos = $_[1];
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "{") {;
            return
        }
        $pos++;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        $m = Perlito5::Grammar::exp_stmts($str, $pos);
        if (!$m) {;
            Perlito5::Compiler::error("syntax error")
        }
        $pos = $m->{"to"};
        my $capture = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "}") {;
            Perlito5::Compiler::error("syntax error")
        }
        $m->{"to"} = $pos + 1;
        $m->{"capture"} = Perlito5::AST::Block::->new("stmts", $capture, "sig", undef);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        return $m
    }
    sub Perlito5::Grammar::Block::closure_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "{") {;
            return
        }
        $pos++;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        local $Perlito5::CLOSURE_SCOPE = $#Perlito5::BASE_SCOPE;
        $m = Perlito5::Grammar::exp_stmts($str, $pos);
        if (!$m) {;
            Perlito5::Compiler::error("syntax error")
        }
        $pos = $m->{"to"};
        my $capture = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::Space::opt_ws($str, $pos);
        $pos = $m->{"to"};
        if ($str->[$pos] ne "}") {;
            Perlito5::Compiler::error("syntax error")
        }
        $m->{"to"} = $pos + 1;
        $m->{"capture"} = Perlito5::AST::Block::->new("stmts", $capture, "sig", undef);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        return $m
    }
    sub Perlito5::Grammar::Block::eval_end_block {
        (my $block, my $phase) = @_;
        $block = Perlito5::AST::Block::->new("stmts", [Perlito5::AST::Sub::->new("attributes", [], "block", $block, "name", undef, "namespace", $Perlito5::PKG_NAME, "sig", undef, "pos", Perlito5::Compiler::compiler_pos())]);
        return Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN")
    }
    sub Perlito5::Grammar::Block::eval_begin_block {
        my $block = shift;
        local ${^GLOBAL_PHASE};
        Perlito5::set_global_phase("BEGIN");
        my @captured = $block->get_captures();
        my %dont_capture = map {;
            $_->{"dont"} ? ($_->{"dont"}, 1) : ()
        } @captured;
        my %capture = map {;
            $_->{"dont"} ? () : $dont_capture{$_->{"_id"}} ? () : ($_->{"_decl"} eq "local" || $_->{"_decl"} eq "global" || $_->{"_decl"} eq "our" || $_->{"_decl"} eq '') ? () : ($_->{"_id"}, $_)
        } @captured;
        %Perlito5::BEGIN_SCRATCHPAD = (%Perlito5::BEGIN_SCRATCHPAD, %capture);
        $block = $block->emit_begin_scratchpad();
        $block = $block->emit_compile_time();
        local ${"\@"};
        my $result = Perlito5::Perl5::Runtime::eval_ast($block);
        if (${"\@"}) {;
            Perlito5::Compiler::error("Error in BEGIN block: " . ${"\@"})
        }
        return $result
    }
    sub Perlito5::Grammar::Block::opt_continue_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp119 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("c" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ("n" eq $str->[($MATCH->{"to"}) + 2]) && ("t" eq $str->[($MATCH->{"to"}) + 3]) && ("i" eq $str->[($MATCH->{"to"}) + 4]) && ("n" eq $str->[($MATCH->{"to"}) + 5]) && ("u" eq $str->[($MATCH->{"to"}) + 6]) && ("e" eq $str->[($MATCH->{"to"}) + 7]) && ($MATCH->{"to"} += 8)) && (do {
                my $m2 = Perlito5::Grammar::Block::block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"capture"} = Perlito5::Match::flat($MATCH->{"block"});
                $MATCH->{"capture"}->{"is_continue"} = 1;
                1
            }))) || ($MATCH->{"to"} = $tmp119, (do {
                $MATCH->{"capture"} = Perlito5::AST::Block::->new("stmts", [], "sig", undef);
                1
            }))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::anon_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        local $Perlito5::BLOCK_HAS_SEMICOLON;
        my $m = Perlito5::Grammar::block($str, $p);
        !$m && return;
        $p = $m->{"to"};
        my $block = Perlito5::Match::flat($m);
        $m = Perlito5::Grammar::opt_continue_block($str, $p);
        $p = $m->{"to"};
        my $continue = Perlito5::Match::flat($m);
        my $v = $block;
        !$continue->{"is_continue"} && !$Perlito5::BLOCK_HAS_SEMICOLON && ($v = Perlito5::Grammar::Expression::block_or_hash($v));
        $m->{"capture"} = $v;
        if ($continue->{"is_continue"}) {;
            $m->{"capture"}->{"continue"} = $continue
        }
        return $m
    }
    sub Perlito5::Grammar::Block::ast_nop {;
        Perlito5::AST::Apply::->new("code", "nop", "namespace", "Perlito5", "arguments", [])
    }
    sub Perlito5::Grammar::Block::special_named_block {
        my $str = $_[0];
        my $pos = $_[1];
        my $p = $pos;
        my $block_name;
        my $m_name = Perlito5::Grammar::ident($str, $p);
        !$m_name && return;
        $p = $m_name->{"to"};
        $block_name = Perlito5::Match::flat($m_name);
        my $ws = Perlito5::Grammar::Space::opt_ws($str, $p);
        $p = $ws->{"to"};
        my $block_start = $p;
        my $m = Perlito5::Grammar::Block::closure_block($str, $p);
        !$m && return;
        $p = $m->{"to"};
        my $block = Perlito5::Match::flat($m);
        if ($block_name eq "INIT") {
            push(@Perlito5::INIT_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "INIT"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "END") {
            unshift(@Perlito5::END_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "END"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "CHECK") {
            unshift(@Perlito5::CHECK_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "CHECK"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "UNITCHECK") {
            unshift(@Perlito5::UNITCHECK_BLOCK, Perlito5::Grammar::Block::eval_end_block($block, "UNITCHECK"));
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "BEGIN") {
            local $Perlito5::PHASE = "BEGIN";
            Perlito5::Grammar::Block::eval_begin_block($block);
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        elsif ($block_name eq "AUTOLOAD" || $block_name eq "DESTROY") {
            my $sub = Perlito5::AST::Sub::->new("attributes", [], "block", $block, "name", $block_name, "namespace", $Perlito5::PKG_NAME, "sig", undef, "pos", Perlito5::Compiler::compiler_pos());
            my $full_name = ($sub->{"namespace"}) . "::" . ($sub->{"name"});
            $Perlito5::PROTO->{$full_name} = undef;
            $Perlito5::GLOBAL->{$full_name} = $sub;
            $block = Perlito5::AST::Block::->new("stmts", [$sub]);
            Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN");
            $m->{"capture"} = Perlito5::Grammar::Block::ast_nop()
        }
        else {
            $m->{"capture"} = $block;
            $m->{"capture"}->{"name"} = $block_name
        }
        return $m
    }
    sub Perlito5::Grammar::Block::named_sub_def {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::optional_namespace_before_ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::optional_namespace_before_ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::ident($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::ident"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::prototype_"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp147 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Block::closure_block($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"Perlito5::Grammar::Block::closure_block"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                $MATCH->{"_tmp"} = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::closure_block"});
                1
            }))) || ($MATCH->{"to"} = $tmp147, ((do {
                my $m2 = Perlito5::Grammar::Statement::statement_parse($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                Perlito5::Compiler::error("Illegal declaration of subroutine '", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"}), "'");
                1
            }))) || ($MATCH->{"to"} = $tmp147, (do {
                $MATCH->{"_tmp"} = undef;
                1
            }))
        }) && (do {
            my $name = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::ident"});
            my $sig = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::prototype_"});
            $sig eq "*undef*" && ($sig = undef);
            my $attributes = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"});
            (my $proto) = grep {;
                $_->[0] eq "prototype"
            } @{$attributes};
            if ($proto) {
                $attributes = [grep {;
                    $_->[0] ne "prototype"
                } @{$attributes}];
                $sig = $proto->[1]
            }
            my $namespace = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::optional_namespace_before_ident"});
            if ($name) {
                if (!$namespace) {;
                    $namespace = $name eq "_" ? "main" : $Perlito5::PKG_NAME
                }
                my $full_name = $namespace . "::" . $name;
                $Perlito5::PROTO->{$full_name} = $sig
            }
            my $sub = Perlito5::AST::Sub::->new("name", $name, "namespace", $namespace, "sig", $sig, "block", $MATCH->{"_tmp"}, "attributes", $attributes, "pos", Perlito5::Compiler::compiler_pos());
            if ($name && defined($sig) && $sig eq '' && $sub->{"block"} && @{$sub->{"block"}->{"stmts"}} == 1) {
                my $expr = $sub->{"block"}->{"stmts"}->[0];
                $expr = Perlito5::FoldConstant::fold_constant($expr);
                my $ref = ref($expr);
                if ($ref eq "Perlito5::AST::Int" || $ref eq "Perlito5::AST::Num" || $ref eq "Perlito5::AST::Buf") {;
                    $Perlito5::CONSTANT{$namespace . "::" . $name} = $expr
                }
            }
            if ($Perlito5::EXPAND_USE && $name) {
                my $full_name = $namespace . "::" . $name;
                my $block = Perlito5::AST::Block::->new("stmts", [$sub]);
                Perlito5::Grammar::Block::eval_begin_block($block, "BEGIN");
                $Perlito5::GLOBAL->{$full_name} = $sub;
                $sub = Perlito5::Grammar::Block::ast_nop();
                $MATCH->{"capture"} = $sub
            }
            else {;
                $MATCH->{"capture"} = $sub
            }
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::named_sub {
        my $str = $_[0];
        my $pos = $_[1];
        $str->[$pos] eq "s" && $str->[$pos + 1] eq "u" && $str->[$pos + 2] eq "b" || return;
        my $ws = Perlito5::Grammar::Space::ws($str, $pos + 3);
        $ws || return;
        my $p = $ws->{"to"};
        my $m_name = Perlito5::Grammar::ident($str, $p);
        $m_name || return;
        my $block_name = Perlito5::Match::flat($m_name);
        if (exists($Named_block{$block_name})) {;
            return Perlito5::Grammar::Block::special_named_block($str, $p)
        }
        return Perlito5::Grammar::Block::named_sub_def($str, $p)
    }
    sub Perlito5::Grammar::Block::term_anon_sub {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("s" eq $str->[($MATCH->{"to"}) + 0]) && ("u" eq $str->[($MATCH->{"to"}) + 1]) && ("b" eq $str->[($MATCH->{"to"}) + 2]) && ($MATCH->{"to"} += 3)) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::anon_sub_def($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::anon_sub_def"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::anon_sub_def"})];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::term_do {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((("d" eq $str->[($MATCH->{"to"}) + 0]) && ("o" eq $str->[($MATCH->{"to"}) + 1]) && ($MATCH->{"to"} += 2)) && (do {
            my $m2 = Perlito5::Grammar::block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            $MATCH->{"capture"} = ["term", Perlito5::AST::Apply::->new("code", "do", "arguments", [Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::block"})])];
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::args_sig {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $m = $MATCH;
            my $to = $MATCH->{"to"};
            while ((do {
                my $tmp189 = $MATCH->{"to"};
                (((";" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("\\" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("[" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("]" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("*" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("+" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("\@" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("%" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("\$" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1))) || ($MATCH->{"to"} = $tmp189, (("&" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)))
            })) {
                $m = $MATCH;
                $to = $MATCH->{"to"}
            }
            $MATCH = $m;
            $MATCH->{"to"} = $to;
            1
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::prototype_ {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = ((do {
            my $tmp197 = $MATCH->{"to"};
            (((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("_" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = "_";
                1
            }))) || ($MATCH->{"to"} = $tmp197, ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (("(" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Block::args_sig($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    $MATCH->{"args_sig"} = $m2;
                    1
                }
                else {;
                    0
                }
            }) && (do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
                if ($m2) {
                    $MATCH->{"to"} = $m2->{"to"};
                    1
                }
                else {;
                    0
                }
            }) && ((")" eq $str->[($MATCH->{"to"}) + 0]) && ($MATCH->{"to"} += 1)) && (do {
                $MATCH->{"capture"} = '' . Perlito5::Match::flat($MATCH->{"args_sig"});
                1
            }))) || ($MATCH->{"to"} = $tmp197, (do {
                $MATCH->{"capture"} = "*undef*";
                1
            }))
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Block::anon_sub_def {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {"str" => $str, "from" => $pos, "to" => $pos, };
        my $tmp = (((do {
            my $m2 = Perlito5::Grammar::Block::prototype_($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"prototype_"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Attribute::opt_attribute($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Block::closure_block($str, $MATCH->{"to"});
            if ($m2) {
                $MATCH->{"to"} = $m2->{"to"};
                $MATCH->{"Perlito5::Grammar::Block::closure_block"} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $sig = Perlito5::Match::flat($MATCH->{"prototype_"});
            $sig eq "*undef*" && ($sig = undef);
            my $attributes = Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Attribute::opt_attribute"});
            (my $proto) = grep {;
                $_->[0] eq "prototype"
            } @{$attributes};
            if ($proto) {
                $attributes = [grep {;
                    $_->[0] ne "prototype"
                } @{$attributes}];
                $sig = $proto->[1]
            }
            $MATCH->{"capture"} = Perlito5::AST::Sub::->new("name", undef, "namespace", undef, "sig", $sig, "block", Perlito5::Match::flat($MATCH->{"Perlito5::Grammar::Block::closure_block"}), "attributes", $attributes, "pos", Perlito5::Compiler::compiler_pos());
            1
        })));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term("do", \&term_do);
    Perlito5::Grammar::Precedence::add_term("sub", \&term_anon_sub);
    Perlito5::Grammar::Statement::add_statement("{", \&anon_block);
    Perlito5::Grammar::Statement::add_statement("sub", \&named_sub);
    Perlito5::Grammar::Statement::add_statement($_, \&special_named_block)
        for keys(%Named_block);
    1
}
;1
