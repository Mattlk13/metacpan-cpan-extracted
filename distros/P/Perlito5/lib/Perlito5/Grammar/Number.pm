# Do not edit this file - Generated by Perlito5 9.022

{
    package main;
    package Perlito5::Grammar::Number;
    use strict ;
    use Perlito5::Grammar::Precedence ;
    sub Perlito5::Grammar::Number::term_digit {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_octal($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::val_octal'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_octal'})];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_vstring($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::val_vstring'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_vstring'})];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_num($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::val_num'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_num'})];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_int($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::val_int'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = ['term', Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Number::val_int'})];
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    Perlito5::Grammar::Precedence::add_term($_ => \&term_digit)
        for '.', 0 .. 9;
    sub Perlito5::Grammar::Number::digit {
        my $str = $_[0];
        my $pos = $_[1];
        $str->[$pos] ge 0 && $str->[$pos] le 9 ? {'str' => $str, 'from' => $pos, 'to' => $pos + 1} : 0
    }
    sub Perlito5::Grammar::Number::exponent {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                (('e' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('E' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
            })
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                (('+' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('-' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                1
            })
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{'to'};
            my $count = 0;
            while ((do {
                my $pos1 = $MATCH->{'to'};
                (do {;
                    (('_' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        my $m2 = digit($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {;
                            0
                        }
                    })
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{'to'}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{'to'};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{'to'} = $to;
            $count > 0
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_num {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                ((('.' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)) && (do {
                    my $m2 = digit($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    while ((do {
                        my $pos1 = $MATCH->{'to'};
                        (do {;
                            (('_' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            (do {
                                my $m2 = digit($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {;
                                    0
                                }
                            })
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!(do {
                        my $m2 = exponent($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {;
                            0
                        }
                    })) {;
                        $MATCH = $m
                    }
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = digit($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    while ((do {
                        my $pos1 = $MATCH->{'to'};
                        (do {;
                            (('_' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            (do {
                                my $m2 = digit($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {;
                                    0
                                }
                            })
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'}
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    1
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {;
                        (do {
                            my $m2 = exponent($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {;
                                0
                            }
                        })
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        ((('.' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)) && (do {
                            my $tmp = $MATCH;
                            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                            my $res = (('.' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1));
                            $MATCH = $tmp;
                            $res ? 0 : 1
                        }) && (do {
                            my $last_match_null = 0;
                            my $m = $MATCH;
                            my $to = $MATCH->{'to'};
                            while ((do {
                                my $pos1 = $MATCH->{'to'};
                                (do {;
                                    (('_' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                                }) || (do {
                                    $MATCH->{'to'} = $pos1;
                                    (do {
                                        my $m2 = digit($str, $MATCH->{'to'});
                                        if ($m2) {
                                            $MATCH->{'to'} = $m2->{'to'};
                                            1
                                        }
                                        else {;
                                            0
                                        }
                                    })
                                })
                            }) && ($last_match_null < 2)) {
                                if ($to == $MATCH->{'to'}) {;
                                    $last_match_null = $last_match_null + 1
                                }
                                else {;
                                    $last_match_null = 0
                                }
                                $m = $MATCH;
                                $to = $MATCH->{'to'}
                            }
                            $MATCH = $m;
                            $MATCH->{'to'} = $to;
                            1
                        }) && (do {
                            my $m = $MATCH;
                            if (!(do {
                                my $m2 = exponent($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {;
                                    0
                                }
                            })) {;
                                $MATCH = $m
                            }
                            1
                        }))
                    })
                }))
            })
        }) && (do {
            my $s = Perlito5::Match::flat($MATCH);
            $s =~ s/_//g;
            $MATCH->{'capture'} = Perlito5::AST::Num::->new('num' => $s);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::digits {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{'to'};
            my $count = 0;
            while ((do {
                my $m2 = digit($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {;
                    0
                }
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{'to'}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{'to'};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{'to'} = $to;
            $count > 0
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::digits_underscore {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = digit($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{'to'};
            while ((do {
                my $pos1 = $MATCH->{'to'};
                (do {;
                    (('_' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                }) || (do {
                    $MATCH->{'to'} = $pos1;
                    (do {
                        my $m2 = digit($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {;
                            0
                        }
                    })
                })
            }) && ($last_match_null < 2)) {
                if ($to == $MATCH->{'to'}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{'to'}
            }
            $MATCH = $m;
            $MATCH->{'to'} = $to;
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_octal {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((((0 eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {;
                        (('x' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('X' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                    })
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    while ((do {
                        my $m2 = Perlito5::Grammar::word($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {;
                            0
                        }
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    $count > 0
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $pos1 = $MATCH->{'to'};
                    (do {;
                        (('b' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (('B' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                    })
                }) && (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    while ((do {
                        my $pos1 = $MATCH->{'to'};
                        (do {;
                            (('_' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ((0 eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            ((1 eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    $count > 0
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    my $last_match_null = 0;
                    my $m = $MATCH;
                    my $to = $MATCH->{'to'};
                    my $count = 0;
                    while ((do {
                        my $pos1 = $MATCH->{'to'};
                        (do {;
                            (('_' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1))
                        }) || (do {
                            $MATCH->{'to'} = $pos1;
                            (do {
                                my $m2 = digit($str, $MATCH->{'to'});
                                if ($m2) {
                                    $MATCH->{'to'} = $m2->{'to'};
                                    1
                                }
                                else {;
                                    0
                                }
                            })
                        })
                    }) && ($last_match_null < 2)) {
                        if ($to == $MATCH->{'to'}) {;
                            $last_match_null = $last_match_null + 1
                        }
                        else {;
                            $last_match_null = 0
                        }
                        $m = $MATCH;
                        $to = $MATCH->{'to'};
                        $count = $count + 1
                    }
                    $MATCH = $m;
                    $MATCH->{'to'} = $to;
                    $count > 0
                })
            })
        }) && (do {
            $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => oct(lc(Perlito5::Match::flat($MATCH))));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_int {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = digits_underscore($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $s = Perlito5::Match::flat($MATCH);
            $s =~ s/_//g;
            $MATCH->{'capture'} = Perlito5::AST::Int::->new('int' => $s);
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_vstring {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = val_int($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'val_int'} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{'to'};
            my $count = 0;
            while (((('.' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)) && (do {
                my $m2 = digits_underscore($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    if (exists($MATCH->{'digits_underscore'})) {;
                        push(@{$MATCH->{'digits_underscore'}}, $m2)
                    }
                    else {;
                        $MATCH->{'digits_underscore'} = [$m2]
                    }
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{'to'}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{'to'};
                $count = $count + 1
            }
            $MATCH = $m;
            $MATCH->{'to'} = $to;
            $count > 0
        }) && (do {
            my @parts = map {;
                Perlito5::Match::flat($_)
            } @{$MATCH->{'digits_underscore'}};
            @parts < 2 && return;
            $MATCH->{'capture'} = Perlito5::AST::Buf::->new('is_vstring' => 1, 'buf' => join('', map {;
                chr($_)
            } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
            1
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Number::val_version {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((('v' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)) && (do {
            my $m2 = val_int($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'val_int'} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $tmp = $MATCH;
            $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
            my $res = ((do {
                my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    1
                }
                else {;
                    0
                }
            }) && (('(' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)));
            $MATCH = $tmp;
            $res ? 0 : 1
        }) && (do {
            my $last_match_null = 0;
            my $m = $MATCH;
            my $to = $MATCH->{'to'};
            while (((('.' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)) && (do {
                my $m2 = digits_underscore($str, $MATCH->{'to'});
                if ($m2) {
                    $MATCH->{'to'} = $m2->{'to'};
                    if (exists($MATCH->{'digits_underscore'})) {;
                        push(@{$MATCH->{'digits_underscore'}}, $m2)
                    }
                    else {;
                        $MATCH->{'digits_underscore'} = [$m2]
                    }
                    1
                }
                else {;
                    0
                }
            })) && ($last_match_null < 2)) {
                if ($to == $MATCH->{'to'}) {;
                    $last_match_null = $last_match_null + 1
                }
                else {;
                    $last_match_null = 0
                }
                $m = $MATCH;
                $to = $MATCH->{'to'}
            }
            $MATCH = $m;
            $MATCH->{'to'} = $to;
            1
        }) && (do {
            my @parts = map {;
                Perlito5::Match::flat($_)
            } @{$MATCH->{'digits_underscore'}};
            $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => join('', map {;
                chr($_)
            } $MATCH->{'val_int'}->{'capture'}->{'int'}, @parts));
            1
        })));
        $tmp ? $MATCH : undef
    }
    1
}
;1
