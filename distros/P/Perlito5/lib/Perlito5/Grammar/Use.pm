# Do not edit this file - Generated by Perlito5 9.022

{
    package main;
    package Perlito5::Grammar::Use;
    use Perlito5::Grammar::Precedence ;
    use Perlito5::Grammar ;
    use strict ;
    my %Perlito_internal_module = ('strict' => 'Perlito5X::strict', 'warnings' => 'Perlito5X::warnings', 'feature' => 'Perlito5X::feature', 'utf8' => 'Perlito5X::utf8', 'bytes' => 'Perlito5X::bytes', 're' => 'Perlito5X::re', 'encoding' => 'Perlito5X::encoding', 'Carp' => 'Perlito5X::Carp', 'Config' => 'Perlito5X::Config', 'Exporter' => 'Perlito5X::Exporter', 'Data::Dumper' => 'Perlito5X::Dumper', 'UNIVERSAL' => 'Perlito5X::UNIVERSAL', 'JSON' => 'Perlito5X::JSON');
    sub Perlito5::Grammar::Use::register_internal_module {
        (my($module), my($real_name)) = @_;
        $Perlito_internal_module{$module} = $real_name
    }
    sub Perlito5::Grammar::Use::use_decl {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                (('u' eq $str->[$MATCH->{'to'} + 0]) && ('s' eq $str->[$MATCH->{'to'} + 1]) && ('e' eq $str->[$MATCH->{'to'} + 2]) && ($MATCH->{'to'} += 3))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (('n' eq $str->[$MATCH->{'to'} + 0]) && ('o' eq $str->[$MATCH->{'to'} + 1]) && ($MATCH->{'to'} += 2))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::version_string {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = ((do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::val_version($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::val_version'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    $MATCH->{'capture'} = $MATCH->{'Perlito5::Grammar::Number::val_version'}->{'capture'};
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::Number::term_digit($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::Number::term_digit'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $version = $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'buf'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'int'} || $MATCH->{'Perlito5::Grammar::Number::term_digit'}->{'capture'}->[1]->{'num'};
                    $MATCH->{'capture'} = Perlito5::AST::Buf::->new('buf' => $version);
                    1
                }))
            })
        }));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::term_require {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((('r' eq $str->[$MATCH->{'to'} + 0]) && ('e' eq $str->[$MATCH->{'to'} + 1]) && ('q' eq $str->[$MATCH->{'to'} + 2]) && ('u' eq $str->[$MATCH->{'to'} + 3]) && ('i' eq $str->[$MATCH->{'to'} + 4]) && ('r' eq $str->[$MATCH->{'to'} + 5]) && ('e' eq $str->[$MATCH->{'to'} + 6]) && ($MATCH->{'to'} += 7)) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                ((do {
                    my $m2 = version_string($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'version_string'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $version = $MATCH->{'version_string'}->{'capture'};
                    $version->{'is_version_string'} = 1;
                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [$version])];
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $module_name = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                    my $filename = modulename_to_filename($module_name);
                    $MATCH->{'capture'} = ['term', Perlito5::AST::Apply::->new('code' => 'require', 'namespace' => '', 'arguments' => [Perlito5::AST::Buf::->new('buf' => $filename)])];
                    1
                }))
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::stmt_use {
        my $str = $_[0];
        my $pos = $_[1];
        my $MATCH = {'str' => $str, 'from' => $pos, 'to' => $pos};
        my $tmp = (((do {
            my $m2 = use_decl($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                $MATCH->{'use_decl'} = $m2;
                1
            }
            else {;
                0
            }
        }) && (do {
            my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
            if ($m2) {
                $MATCH->{'to'} = $m2->{'to'};
                1
            }
            else {;
                0
            }
        }) && (do {
            my $pos1 = $MATCH->{'to'};
            (do {;
                ((do {
                    my $m2 = version_string($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'version_string'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $version = $MATCH->{'version_string'}->{'capture'}->{'buf'};
                    Perlito5::test_perl_version($version);
                    $MATCH->{'capture'} = Perlito5::Grammar::Block::ast_nop();
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                ((do {
                    my $m2 = Perlito5::Grammar::full_ident($str, $MATCH->{'to'});
                    if ($m2) {
                        $MATCH->{'to'} = $m2->{'to'};
                        $MATCH->{'Perlito5::Grammar::full_ident'} = $m2;
                        1
                    }
                    else {;
                        0
                    }
                }) && (do {
                    my $m = $MATCH;
                    if (!((('-' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1)) && (do {
                        my $m2 = Perlito5::Grammar::ident($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            if (exists($MATCH->{'Perlito5::Grammar::ident'})) {;
                                push(@{$MATCH->{'Perlito5::Grammar::ident'}}, $m2)
                            }
                            else {;
                                $MATCH->{'Perlito5::Grammar::ident'} = [$m2]
                            }
                            1
                        }
                        else {;
                            0
                        }
                    }))) {;
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $m = $MATCH;
                    if (!((do {
                        my $m2 = Perlito5::Grammar::Space::ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {;
                            0
                        }
                    }) && (do {
                        my $m2 = version_string($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            if (exists($MATCH->{'version_string'})) {;
                                push(@{$MATCH->{'version_string'}}, $m2)
                            }
                            else {;
                                $MATCH->{'version_string'} = [$m2]
                            }
                            1
                        }
                        else {;
                            0
                        }
                    }) && (do {
                        my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                        if ($m2) {
                            $MATCH->{'to'} = $m2->{'to'};
                            1
                        }
                        else {;
                            0
                        }
                    }) && (do {
                        my $tmp = $MATCH;
                        $MATCH = {'from' => $tmp->{'to'}, 'to' => $tmp->{'to'}};
                        my $res = ((',' eq $str->[$MATCH->{'to'} + 0]) && ($MATCH->{'to'} += 1));
                        $MATCH = $tmp;
                        $res ? 0 : 1
                    }))) {;
                        $MATCH = $m
                    }
                    1
                }) && (do {
                    my $pos1 = $MATCH->{'to'};
                    (do {;
                        (do {
                            my $m2 = Perlito5::Grammar::Expression::exp_parse($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                $MATCH->{'Perlito5::Grammar::Expression::exp_parse'} = $m2;
                                1
                            }
                            else {;
                                0
                            }
                        })
                    }) || (do {
                        $MATCH->{'to'} = $pos1;
                        (do {
                            my $m2 = Perlito5::Grammar::Space::opt_ws($str, $MATCH->{'to'});
                            if ($m2) {
                                $MATCH->{'to'} = $m2->{'to'};
                                1
                            }
                            else {;
                                0
                            }
                        })
                    })
                }) && (do {
                    my $version = $MATCH->{'version_string'}->[0]->{'capture'}->{'buf'};
                    my $list = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::Expression::exp_parse'});
                    if (ref($list) eq 'Perlito5::AST::Buf') {;
                        $list = $list->{'buf'}
                    }
                    elsif ($list) {
                        Perlito5::Grammar::Scope::check_variable_declarations();
                        my $ast = Perlito5::AST::Block::->new('stmts' => [Perlito5::AST::Apply::->new('code' => 'circumfix:<[ ]>', 'arguments' => [$list])]);
                        $list = Perlito5::Grammar::Block::eval_begin_block($ast)
                    }
                    else {;
                        $list = undef
                    }
                    my $full_ident = Perlito5::Match::flat($MATCH->{'Perlito5::Grammar::full_ident'});
                    $Perlito5::PACKAGES->{$full_ident} = 1;
                    my $use_decl = Perlito5::Match::flat($MATCH->{'use_decl'});
                    if ($full_ident eq 'strict') {;
                        $Perlito5::STRICT = ($use_decl eq 'no' ? 0 : 1)
                    }
                    if ($use_decl eq 'use' && $full_ident eq 'vars' && $list) {
                        my $code = 'our (' . join(', ', @{$list}) . ')';
                        my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                        !$m && Perlito5::Compiler::error('not a valid variable name: ' . join(${'"'}, @{$list}));
                        $MATCH->{'capture'} = $m->{'capture'}
                    }
                    elsif ($use_decl eq 'use' && $full_ident eq 'constant') {
                        my @ast;
                        if ($list) {
                            my $name = shift(@{$list});
                            if (ref($name) eq 'HASH') {;
                                for my $key (sort {;
                                    $a cmp $b
                                } keys(%{$name})) {
                                    my $code = 'sub ' . $key . ' () { ' . Perlito5::Dumper::_dumper($name->{$key}) . ' }';
                                    my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                                    !$m && Perlito5::Compiler::error('not a valid constant: ' . join(${'"'}, @{$list}));
                                    push(@ast, $m->{'capture'})
                                }
                            }
                            else {
                                my $code = 'sub ' . $name . ' () { (' . join(', ', map {;
                                    Perlito5::Dumper::_dumper($_)
                                } @{$list}) . ') }';
                                my $m = Perlito5::Grammar::Statement::statement_parse([split('', $code)], 0);
                                !$m && Perlito5::Compiler::error('not a valid constant: ' . join(${'"'}, @{$list}));
                                push(@ast, $m->{'capture'})
                            }
                        }
                        $MATCH->{'capture'} = Perlito5::AST::Block::->new('stmts' => \@ast)
                    }
                    elsif ($Perlito5::EMIT_USE) {;
                        $MATCH->{'capture'} = Perlito5::AST::Apply::->new('code' => 'use', 'special_arg' => Perlito5::AST::Apply::->new('code' => $full_ident, 'bareword' => 1, 'arguments' => []), 'arguments' => $list)
                    }
                    else {;
                        $MATCH->{'capture'} = parse_time_eval({'mod' => $full_ident, 'code' => $use_decl, 'arguments' => $list})
                    }
                    1
                }))
            }) || (do {
                $MATCH->{'to'} = $pos1;
                (do {
                    Perlito5::Compiler::error('Syntax error');
                    1
                })
            })
        })));
        $tmp ? $MATCH : undef
    }
    sub Perlito5::Grammar::Use::parse_time_eval {
        my $ast = shift;
        my $module_name = $ast->{'mod'};
        my $use_or_not = $ast->{'code'};
        my $arguments = $ast->{'arguments'};
        my $skip_import = defined($arguments) && @{$arguments} == 0;
        defined($arguments) || ($arguments = []);
        local $Perlito5::STRICT = 0;
        if ($Perlito5::EXPAND_USE) {
            my $current_module_name = $Perlito5::PKG_NAME;
            my $filename = modulename_to_filename($module_name);
            Perlito5::Grammar::Use::require($filename);
            if (!$skip_import) {
                if ($use_or_not eq 'use') {
                    my $code = $module_name->can('import');
                    if (defined($code)) {
                        unshift(@Perlito5::CALLER, [$current_module_name]);
                        eval {
                            $module_name->import(@{$arguments});
                            1
                        } or ${'@'}->Perlito5::Compiler::error();
                        shift(@Perlito5::CALLER)
                    }
                }
                elsif ($use_or_not eq 'no') {
                    my $code = $module_name->can('unimport');
                    if (defined($code)) {
                        unshift(@Perlito5::CALLER, [$current_module_name]);
                        eval {
                            $module_name->unimport(@{$arguments});
                            1
                        } or ${'@'}->Perlito5::Compiler::error();
                        shift(@Perlito5::CALLER)
                    }
                }
            }
        }
        else {;
            bootstrapping_use($ast)
        }
        return Perlito5::Grammar::Block::ast_nop()
    }
    sub Perlito5::Grammar::Use::emit_time_eval {
        my $ast = shift;
        if ($ast->{'mod'} eq 'strict') {
            if ($ast->{'code'} eq 'use') {;
                strict::->import()
            }
            elsif ($ast->{'code'} eq 'no') {;
                strict::->unimport()
            }
        }
    }
    sub Perlito5::Grammar::Use::modulename_to_filename {
        my $s = shift;
        exists($Perlito_internal_module{$s}) && ($s = $Perlito_internal_module{$s});
        $s =~ s!::!/!g;
        return $s . '.pm'
    }
    sub Perlito5::Grammar::Use::filename_lookup {
        my $filename = shift;
        if (exists($INC{$filename})) {
            $INC{$filename} && return 'done';
            Perlito5::Compiler::error('Compilation failed in require')
        }
        for my $prefix (@INC, '.') {
            my $realfilename = $prefix . '/' . $filename;
            if (-f $realfilename) {
                $INC{$filename} = $realfilename;
                return 'todo'
            }
        }
        Perlito5::Compiler::error('Can' . chr(39) . 't locate ' . $filename . ' in @INC ' . '(@INC contains ' . join(' ', @INC) . ').')
    }
    sub Perlito5::Grammar::Use::bootstrapping_use {
        my $stmt = shift;
        my $module_name = $stmt->{'mod'};
        my $filename = modulename_to_filename($module_name);
        filename_lookup($filename) eq 'done' && return;
        local $Perlito5::FILE_NAME = $filename;
        local $Perlito5::LINE_NUMBER = 1;
        my $realfilename = $INC{$filename};
        open(FILE, '<', $realfilename) or Perlito5::Compiler::error('Cannot read ' . $realfilename . ': ' . ${'!'} . '
');
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        my $m = Perlito5::Grammar::exp_stmts($source, 0);
        $m->{'to'} != length($source) && Perlito5::Compiler::error('Syntax Error near ', $m->{'to'});
        if ($m->{'to'} != length($source)) {
            my $pos = $m->{'to'} - 10;
            $pos < 0 && ($pos = 0);
            print('* near: ', substr($source, $pos, 20), '
');
            print('* filename: ' . $realfilename . '
');
            Perlito5::Compiler::error('Syntax Error')
        }
        push(@Perlito5::COMP_UNIT, Perlito5::AST::CompUnit::->new('name' => 'main', 'body' => Perlito5::Match::flat($m)));
        return
    }
    sub Perlito5::Grammar::Use::require {
        my $filename = shift;
        my $m2 = version_string([split('', $filename)], 0);
        if ($m2) {
            my $version = $m2->{'version_string'}->{'capture'}->{'buf'};
            Perlito5::test_perl_version($version);
            return 1
        }
        filename_lookup($filename) eq 'done' && return;
        my $source = do_file($filename);
        local $Perlito5::FILE_NAME = $filename;
        local $Perlito5::STRICT = 0;
        Perlito5::Grammar::Scope::check_variable_declarations();
        Perlito5::Grammar::Scope::create_new_compile_time_scope();
        my $m = Perlito5::Grammar::exp_stmts($source, 0);
        my $ast = Perlito5::AST::Block::->new('stmts' => Perlito5::Match::flat($m));
        my $result = Perlito5::Grammar::Block::eval_begin_block($ast);
        Perlito5::Grammar::Scope::end_compile_time_scope();
        if (${'@'}) {
            $INC{$filename} = undef;
            ${'@'}->Perlito5::Compiler::error()
        }
        elsif (!$result) {
            delete($INC{$filename});
            ${'@'} && warn(${'@'});
            Perlito5::Compiler::error($filename . ' did not return true value')
        }
        else {;
            return $result
        }
    }
    sub Perlito5::Grammar::Use::do_file {
        my $filename = shift;
        eval {
            filename_lookup($filename);
            1
        } or do {
            $INC{$filename} = undef;
            ${'@'} = '';
            ${'!'} = 'No such file or directory';
            return 'undef'
        };
        my $realfilename = $INC{$filename};
        open(FILE, '<', $realfilename) or Perlito5::Compiler::error('Cannot read ' . $realfilename . ': ' . ${'!'} . '
');
        local $/ = undef;
        my $source = <FILE>;
        close(FILE);
        return $source
    }
    Perlito5::Grammar::Statement::add_statement('no' => \&stmt_use);
    Perlito5::Grammar::Statement::add_statement('use' => \&stmt_use);
    Perlito5::Grammar::Precedence::add_term('require' => \&term_require);
    1
}
;1
