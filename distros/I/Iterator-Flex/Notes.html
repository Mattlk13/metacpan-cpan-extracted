<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Notes.html</title>

</head>

<body>

<h1>Solving the Hidden Class Problem</h1>

<p>Iterator functions are typically not called as a class method, even
though they are essentially constructors.  For example,</p>

<p><code>
use Iterator::Flex -all;
my $iter = imap { CODE } [0..10];
</code></p>

<p>creates an iteration object.  What is that object's class?  There's a
default base Iterator class (in this case <code>Iterator::Flex::Iterator</code>,
but if the caller wants to use a specialized subclass, there's no
obvious way of instructing <code>imap</code> to use it.  Adding extra arguments
to <code>imap</code> destroys the fluid interface.  Adding a companion subroutine, e.g.
<code>imap_with_class</code>, forces the caller to be explicit with every call, and
requires the module to double the size of the interface.</p>

<p>An alternative is to indicate on a global or per-package basis which
class to use when importing <code>Iterator::Flex</code>:</p>

<p>```
use Iterator::Flex { default_class => 'My::Iterator::One'}, '-all';
ref( imap { CODE } [0..10]; ) == 'My::Iterator::One';</p>

<p>package Foo{
  use Iterator::Flex { class => 'My::Iterator::Two'}, '-all';</p>

<p>ref( imap { CODE } [0..10]; ) == 'My::Iterator::Two';
}</p>

<p>package Bar {
  use Iterator::Flex -all;</p>

<p>ref( imap { CODE } [0..10]; ) == 'My::Iterator::One';
}</p>

<p>```</p>

<p><code>Iterator::Flex</code> would keep track of a package's requested class via a private hash, and
the iterator subroutines would call <code>Iterator::Flex::_instance_class</code> to determine which class to use:</p>

<p>```
   sub imap {</p>

<pre><code> my $class = Iterator::Flex::_instance_class( caller );
 [...]
</code></pre>

<p>}
```</p>

</body>
</html>
