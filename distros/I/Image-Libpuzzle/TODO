The PHP extension provides bindings for the following tuning functions, so I would like to do the same

Use as setter/getter - to return value or set it; setting any of these values causes the signature to recomputed the ntext time that puzzle_fill_cvec_from_file is called.

Sensitivity of each sample  - puzzle_set_p_ratio()
Number of samples per image - puzzle_set_lambdas()
- puzzle_set_max_width()
- puzzle_set_max_height()
- puzzle_set_noise_cutoff()
- puzzle_set_contrast_barrier_for_cropping()
- puzzle_set_max_cropping_ratio()
- puzzle_set_autocrop()

Additionally, functions related to dealing with signatures

Generate signature - puzzle_fill_cvec_from_file($filename)
Compress signature - $compressed_signature = puzzle_compress_cvec($signature);
Decompress sig     - $signature = puzzle_uncompress_cvec($compressed_signature);

- $d = puzzle_vector_normalized_distance($signature1, $signature2);
The PUZZLE_CVEC_SIMILARITY_THRESHOLD, PUZZLE_CVEC_SIMILARITY_HIGH_THRESHOLD,
PUZZLE_CVEC_SIMILARITY_LOW_THRESHOLD and PUZZLE_CVEC_SIMILARITY_LOWER_THRESHOLD

Module properties:

1. constructor ('new') will initialize the PuzzleContext that will get reused for nearly all calls
2. constructor ('new') will initialize the PuzzleCVec, which is used to hold the sig generated by puzzle_fill_cvec_from_file
3. constructor will compute signature if a filename or scalar containing image data is passed to it

  my $puz = Puzzle->new('/path/to/file');   # generates signature
  my $sig = $puz->puzzle_fill_cvec_from_file(); # returns signature

4. puzzle_fill_cvec_from_file act as a set/get
4.a. if passed a filename/scalar, it will compute the signature based on available tuning parameters

  my $sig = $puz->puzzle_fill_cvec_from_file('/path/to/newfile'); # returns signature of "/path/to/newfile"

4.b. if called without param, it will return sig if previously computed, else it will throw an exception

  my $puz = Puzzle->new('/path/to/file');   # generates signature
  my $sig = $puz->puzzle_fill_cvec_from_file(); # returns last computed sig;

  my $puz = Puzzle->new();
  my $sig = $puz->puzzle_fill_cvec_from_file(); # throws exception 

5. using any of the tuning functions will clear any cached signature and cause puzzle_fill_cvec_from_file to compute it anew, using the update tunables

  my $puz = Puzzle->new('/path/to/file');   # generates signature
  $puz->puzzle_set_p_ratio(1.9);  # sets P, also deletes pre-computed signature

  my $sig = $puz->puzzle_fill_cvec_from_file(); # computes new sig with new P 
  $puz->puzzle_set_lambdas(11);  # sets Lambdas (sample regions), also deletes pre-computed signature
  $sig = $puz->puzzle_fill_cvec_from_file(); # computes new sig with current P, updated Lambda 
  
6. puzzle_compress_cvec returns compressed version of precomuted signature via puzzle_fill_cvec_from_file

  my $puz = Puzzle->new('/path/to/file');   # generates signature
  my $sig = $puz->puzzle_fill_cvec_from_file(); # returns last computed sig;
  my $compressed = $puz->puzzle_compress_cvec(); # returns compressed signature (for storing, not comparing) 

  my $orig_sig = $puz->puzzle_uncompress_cvec($compressed); # just a util function to decomp $compressed, has no affect on internal state of $puz

7. comparing sigs, puzzle_vector_normalized_distance takes in 2 uncompressed sigs and returns distance;

  my $puz1 = Puzzle->new('/path/to/file');   # generates signature
  my $sig1 = $puz1->puzzle_fill_cvec_from_file(); # returns last computed sig;

  my $puz2 = Puzzle->new('/path/to/otherfile');   # generates signature
  my $sig2 = $puz2->puzzle_fill_cvec_from_file(); # returns last computed sig;

  my $distance1 = $puz1->puzzle_vector_normalized_distance($sig1, $sig2);
  my $distance2 = $puz2->puzzle_vector_normalized_distance($sig1, $sig2); # equivalent to $distance1

8. Access to constants: The PUZZLE_CVEC_SIMILARITY_THRESHOLD, PUZZLE_CVEC_SIMILARITY_HIGH_THRESHOLD, PUZZLE_CVEC_SIMILARITY_LOW_THRESHOLD and PUZZLE_CVEC_SIMILARITY_LOWER_THRESHOLD should be provided; (potentially allow to override these by setting envar?) 
