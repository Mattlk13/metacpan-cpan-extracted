<html><head><title>IO::HyCon</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" type="text/css" title="pod_stylesheet" href="http://search.cpan.org/s/style.css">

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.28,
  using Pod::Simple::PullParser v3.28,
  under Perl v5.020000 at Sat Sep 21 21:01:47 2019 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#Functions_and_methods'>Functions and methods</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new(%24filename)'>new($filename)</a>
    <li class='indexItem indexItem2'><a href='#get_response()'>get_response()</a>
    <li class='indexItem indexItem2'><a href='#ic()'>ic()</a>
    <li class='indexItem indexItem2'><a href='#op()'>op()</a>
    <li class='indexItem indexItem2'><a href='#halt()'>halt()</a>
    <li class='indexItem indexItem2'><a href='#enable_ovl_halt()'>enable_ovl_halt()</a>
    <li class='indexItem indexItem2'><a href='#disable_ovl_halt()'>disable_ovl_halt()</a>
    <li class='indexItem indexItem2'><a href='#enable_ext_halt()'>enable_ext_halt()</a>
    <li class='indexItem indexItem2'><a href='#disable_ext_halt()'>disable_ext_halt()</a>
    <li class='indexItem indexItem2'><a href='#single_run()'>single_run()</a>
    <li class='indexItem indexItem2'><a href='#single_run_sync()'>single_run_sync()</a>
    <li class='indexItem indexItem2'><a href='#repetitive_run()'>repetitive_run()</a>
    <li class='indexItem indexItem2'><a href='#pot_set()'>pot_set()</a>
    <li class='indexItem indexItem2'><a href='#set_ic_time(%24milliseconds)'>set_ic_time($milliseconds)</a>
    <li class='indexItem indexItem2'><a href='#set_op_time(%24milliseconds)'>set_op_time($milliseconds)</a>
    <li class='indexItem indexItem2'><a href='#read_element(%24name)'>read_element($name)</a>
    <li class='indexItem indexItem2'><a href='#read_element_by_address(%24address)'>read_element_by_address($address)</a>
    <li class='indexItem indexItem2'><a href='#read_all_elements()'>read_all_elements()</a>
    <li class='indexItem indexItem2'><a href='#set_ro_group()'>set_ro_group()</a>
    <li class='indexItem indexItem2'><a href='#read_ro_group()'>read_ro_group()</a>
    <li class='indexItem indexItem2'><a href='#read_digital()'>read_digital()</a>
    <li class='indexItem indexItem2'><a href='#digital_output(%24port%2C_%24value)'>digital_output($port, $value)</a>
    <li class='indexItem indexItem2'><a href='#read_mpts()'>read_mpts()</a>
    <li class='indexItem indexItem2'><a href='#set_pt(%24address%2C_%24value)'>set_pt($address, $value)</a>
    <li class='indexItem indexItem2'><a href='#get_status()'>get_status()</a>
    <li class='indexItem indexItem2'><a href='#get_op_time()'>get_op_time()</a>
    <li class='indexItem indexItem2'><a href='#reset()'>reset()</a>
    <li class='indexItem indexItem2'><a href='#set_address(address)'>set_address(address)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Examples'>Examples</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>IO::HyCon - Perl interface to the Analog Paradigm hybrid controller.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This document refers to version 0.1 of HyCon</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use strict;
    use warnings;

    use File::Basename;
    use HyCon;

    (my $config_filename = basename($0)) =~ s/\.pl$//;
    print &#34;Create object...\n&#34;;
    my $ac = HyCon-&#62;new(&#34;$config_filename.yml&#34;);

    $ac-&#62;set_ic_time(500);  # Set IC-time to 500 ms
    $ac-&#62;set_op_time(1000); # Set OP-Time to 1000 ms
    $ac-&#62;single_run();      # Perform a single computation run

    # Read a value from a specific computing element:
    my $element_name = &#39;SUM8-0&#39;;
    my $value = $ac-&#62;read_element($element_name);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module implements a simple object oriented interface to the Arduino based Analog Paradigm hybrid controller which interfaces an analog computer to a digital computer and thus allows true hybrid computation.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Functions_and_methods"
>Functions and methods</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new($filename)"
>new($filename)</a></h2>

<p>This function generates a HyCon-object. Currently there is only one hybrid controller supported, so this is, in fact, a singleton and every subsequent invocation will cause a fatal error. This function expects a path to a YAML configuration file of the following structure:</p>

<pre>    config.yml:
        serial:
            port: /dev/tty.usbmodem621
            bits: 8
            baud: 250000
            parity: none
            stopbits: 1
            poll_interval: 1000
            poll_attempts: 200
    builtin_dpt:
        values: .1, .2, .3, .4, .5, .6, .7, .8
    types:
        0: PS
        1: SUM8
        2: INT4
        3: PT8
        4: CU
        5: MLT8
        6: MDS2
        7: CMP4
        8: HC
    elements: 
        Y_DDOT: 0x0100
        Y_DOT:  0x0101
        PT_8-0: 0x0220
        PT_8-1: 0x0221
        PT_8-2: 0x0222
        PT_8-3: 0x0223
        PT_8-4: 0x0224
        PT_8-5: 0x0225
        PT_8-6: 0x0226
        PT_8-7: 0x0227
    manual_potentiometers:
        PT_8-0,rT_8-1,PT_8-2,PT_8-3,PT_8-4,PT_8-5,PT_8-6,PT_8-7</pre>

<p>The setup shown above will not fit your particular analog computer configuration; it just serves as an example. The remaining parameters nevertheless apply in general and are mostly self-explanatory. &#39;poll_interval&#39; and &#39;poll_attempts&#39; control how often this interface will poll the hybrid controller to get a response to a command issued before. The values shown above are overly pessimistic but this won&#39;t matter during normal operation.</p>

<p>The section labeled &#39;builtin_dpt&#39; contains data to setup and control the built-in digital potentiometers of the hybrid controller (currently only eight such potentiometers are supported by the hardware). The initial values of these potentiometers can be specified by a list containing eight entries following the key &#39;values&#39;. If this part is missing, initial values of 0 are assumed. The new() function will set all digitally controlled potentiometers of the hybrid computer according to these values upon invocation.</p>

<p>If the number of values specified in the array &#39;values&#39; does not match the number of configured potentiometers, the function will abort.</p>

<p>The &#39;types&#39; section contains the mapping of the devices types as returned by the analog computer&#39;s readout system to their module names. This should not be changed but will be expanded when new analog computer modules will be developed.</p>

<p>The &#39;elements&#39; section contains a list of computing elements defined by an arbitrary name and their respective address in the computer system. Calling read_all_elements() will switch the computer into HALT-mode, read the values of all elements in this list and return a reference to a hash containing all values and IDs of the elements read. (If jitter during readout is to be minimized, a readout-group should be defined instead, see below.)</p>

<p>Ideally, all manual potentiometers are listed under &#39;manual_potentiometers&#39; which is used for automatic readout of the settings of these potentiometers by calling read_mpts(). This is useful if a simulation has been parameterized manually and these parameters are required for documentation purposes or the like. Caution: All potentiometers to be read out by read_mpts() must be defined in the elements-section.</p>

<p>The new() function will clear the communication buffer of the hybrid controller by reading and discarding and data until a timeout will be reached. This currently equals the product of &#39;poll_interval&#39; and &#39;poll_attempts&#39; and may take a few seconds during startup.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_response()"
>get_response()</a></h2>

<p>In some cases, e.g. external HALT conditions, it is necessary to query the hybrid controller for any messages which may have occured since the last command. This can be done with this method - it will poll the controller for a period of &#39;poll_interval&#39; times &#39;poll_attemps&#39; microseconds. If this timeout value is not suitable, a different value (in milliseconds) can be supplied as first argument of this method. If this argument is zero or negative, get_response will wait indefinitely for a response from the hybrid controller.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ic()"
>ic()</a></h2>

<p>This method switches the analog computer to IC (initial condition) mode during which the integrators are (re)set to their respective initial value. Since this involves charging a capacitor to a given value, this mode should be activated for the a minimum duration as required by the time scale factors involved.</p>

<p>ic() and the two following methods should not be used when timing is critical. Instead, IC- and OP-times should be setup explicitly (see below) and then a single-run should be initiated which will be under control of the hybrid controller. This avoids latencies involved with the communication to and from the hybrid controller and allows sub-millisecond resolution.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="op()"
>op()</a></h2>

<p>This method switches the analog computer to operating-mode.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="halt()"
>halt()</a></h2>

<p>Calling this method causes the analog computer to switch to HALT-mode. In this mode the integrators are halted and store their last value. After calling halt() it is possible to return to OP-mode by calling op() again. Depending on the analog computer being controlled, there will be a more or less substantial drift of the integrators in HALT-mode, so it is advisable to keep the HALT-periods as short as possible to minimize errors.</p>

<p>A typical operation cycle may look like this: IC-OP-HALT-OP-HALT-OP-HALT. This would start a single computation with the possibility of reading values from the analog computer during the HALT-intervals.</p>

<p>Another typical cycle is called &#39;repetitive operation&#39; and looks like this: IC-OP-IC-OP-IC-OP... This is normally used with the integrators set to time-constants of 100 or 1000 and allows to display a solution as a more or less flicker free curve on an oscilloscope for example.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="enable_ovl_halt()"
>enable_ovl_halt()</a></h2>

<p>During a normal computation on an analog computation there should be no overloads of summers or integrators. Such overload conditions are typically the result of an erroneous computer setup (normally caused by wrong scaling of the underlying equations). To catch such problems it is usually a good idea to switch the analog computer automatically to HALT-mode when an overload occurs. The computing element(s) causing the overload condition can the easily identified on the analog computer&#39;s console and the variables of the computation run can be read out to identify the cause of the problem.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="disable_ovl_halt()"
>disable_ovl_halt()</a></h2>

<p>Calling this method will disable the automatic halt-on-overload functionality of the hybrid controller.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="enable_ext_halt()"
>enable_ext_halt()</a></h2>

<p>Sometimes it is necessary to halt a computation when some condition is satisfied (some value reached etc.). This is normally detected by a comparator used in the analog computer setup. The hybrid controller features an EXT-HALT input jack that can be connected to such a comparator. After calling this method, the hybrid controller will switch the analog computer from OP-mode to HALT as soon as the input signal patched to this input jack goes high.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="disable_ext_halt()"
>disable_ext_halt()</a></h2>

<p>This method disables the HALT-on-overflow feature of the hybrid controller.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="single_run()"
>single_run()</a></h2>

<p>Calling this method will initiate a so-called &#39;single-run&#39; on the analog computer which automatically performs the sequence IC-OP-HALT. The times spent in IC- and OP-mode are specified with the methods set_ic_time() and set_op_time() (see below).</p>

<p>It should be noted that the hybrid controller will not be blocked during such a single-run - it is still possible to issue other commands to read or set ports etc.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="single_run_sync()"
>single_run_sync()</a></h2>

<p>This function behaves quite like single_run() but waits for the termination of the single run, thus blocking any further program execution. This method returns true if the single-run mode was terminated by an external halt condition. undef is returned otherwise.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="repetitive_run()"
>repetitive_run()</a></h2>

<p>This initiates repetitive operation, i.e. the analog computer is commanded to perform an IC-OP-IC-OP-... sequence. The hybrid controller will not block during this sequence. To terminate a repetitive run, either ic() or halt() may be called. Note that these methods act immediately and will interrupt any ongoing IC- or OP-period of the analog computer.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pot_set()"
>pot_set()</a></h2>

<p>This function switches the analog computer to POTSET-mode i.e. the integrators are set implicitly to HALT, while all (manual) potentiometers are connected to +1 on their respective input side. This mode can be used to read the current settings of the potentiometers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_ic_time($milliseconds)"
>set_ic_time($milliseconds)</a></h2>

<p>It is normally advisable to let the hybrid controller take care of the overall timing of OP and IC operations since the communication with the digital host introduces quite some jitter. This method sets the time the analog computer will spend in IC-mode during a single- or repetitive run. The time is specified in milliseconds and must be positive and can not exceed 999999 milliseconds due to limitations of the hybrid controller firmware.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_op_time($milliseconds)"
>set_op_time($milliseconds)</a></h2>

<p>This method specifies the duration of the OP-cycle(s) during a single- or repetitive analog computer run. The same limitations hold with respect to the value specified as for the set_ic_time() method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_element($name)"
>read_element($name)</a></h2>

<p>This function expects the name of a computing element specified in the configuation YML-file and applies the corresponding 16 bit value $address to the address lines of the analog computer&#39;s bus system, asserts the active-low /READ-line, reads one value from the READOUT-line, and de-asserts /READ again. read_element(...) returns a reference to a hash containing the keys &#39;value&#39; and &#39;id&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_element_by_address($address)"
>read_element_by_address($address)</a></h2>

<p>This function expects the 16 bit address address of a computing element as parameter and returns a data structure identically to that returned by read_element. This routine should not be used in general as computing elements are better addressed by their name. It is mainly provided for completeness.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_all_elements()"
>read_all_elements()</a></h2>

<p>The routine read_all_elements() reads the current values from all elements listed in the &#39;elements&#39; section of the configuration file. It returns a reference to a hash containing all elements read with their associated values and IDs. It may be advisable to switch the analog computer to HALT mode before calling read_all_elements() to minimize the effect of jitter. After calling this routine the computer has to be switched back to OP mode again. A better way to readout groups of elements is by means of a readout-group (see below).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_ro_group()"
>set_ro_group()</a></h2>

<p>This function defines a readout group, i.e. a group of computing elements specified by their respective names as defined in the configuration file. All elements of such a readout group can be read by issuing a single call to read_ro_group() thus reducing the communications overhead between the HC and digital computer substantially. A typical call would look like this (provided the names are defined in the configuration file):</p>

<pre>    $ac-&#62;set_ro_group(&#39;INT0_1&#39;, &#39;SUM2_3&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_ro_group()"
>read_ro_group()</a></h2>

<p>read_ro_group() reads all elements defined in a readout group. This minimizes the communications overhead between digital and analog computer and reduces the effect of jitter during readout as well as the risk of a serial line buffer overflow on the side of the hybrid controller. The function returns a reference to a hash containing the names of the elements forming the readout group with their associated values.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_digital()"
>read_digital()</a></h2>

<p>In addition to these analog readout capabilities, the hybrid controller also features eight digital inputs which can be used to read the state of comparators or other logic elements of the analog computer being controlled. This method returns an array-reference containing values of 0 or 1 for each of the digital input ports.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="digital_output($port,_$value)"
>digital_output($port, $value)</a></h2>

<p>The hybrid controller also features eight digital outputs which can be used to control the electronic switches which are part of the comparator unit. Calling digital_output(0, 1) will set the first (0) digital output to 1 etc.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_mpts()"
>read_mpts()</a></h2>

<p>Calling read_mpts() returns a reference to a hash containing the current settings of all manual potentiometers listed in the &#39;manual_potentiometers&#39; section in the configuration file. To accomplish this, the analog computer is switched to POTSET-mode (implying HALT for the integrators). In this mode, all inputs of potentiometers are connected to the positive machine unit +1, so that their current setting can be read out. (&#34;Free&#34; potentiometers will behave erroneously unless their second input is connected to ground, refer to the analog computer manual for more information on that topic.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_pt($address,_$value)"
>set_pt($address, $value)</a></h2>

<p>To set a digital potentiometer, set_pt() is called. The first argument is the address of the potentiometer to be set (0 &#60;= number &#60; number-of-potentiometers as specified in the potentiometers section in the configuration YML-file), the second argument is a floatingpoint value 0 &#60;= v &#60;= 1. If either the address or the value is out of bounds, the function will die.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_status()"
>get_status()</a></h2>

<p>Calling get_status() yields a reference to a hash containing all current status information of the hybrid controller. A typical hash structure returned may look like this:</p>

<pre>    $VAR1 = {
          &#39;IC-time&#39; =&#62; &#39;500&#39;,
          &#39;MODE&#39; =&#62; &#39;HALT&#39;,
          &#39;OP-time&#39; =&#62; &#39;1000&#39;,
          &#39;STATE&#39; =&#62; &#39;NORM&#39;,
          &#39;OVLH&#39; =&#62; &#39;DIS&#39;,
          &#39;EXTH&#39; =&#62; &#39;DIS&#39;,
          &#39;RO_GROUP&#39; =&#62; [..., ..., ...]
        };</pre>

<p>In this case the IC-time has been set to 500 ms while the OP-time is set to one second. The analog computer is currently in HALT-mode, and the hybrid controller is in its normal state, i.e. it is not currently performing a single- or repetitive-run. HALT on overload and external HALT are both disabled. A readout-group has been defined, too.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_op_time()"
>get_op_time()</a></h2>

<p>In some applications it is useful to be able to determine how long the analog computer has been in OP-mode. As time as such is the only free variable of integration in an analog-electronic analog computer, it is a central parameter to know. Imagine that some integration is being performed by the analog computer and the time which it took to reach some threshold value is of interest. In this case, the hybrid controller would be configured so that external-HALT is enabled. Then the analog computer would be placed to IC-mode and then to OP-mode. After an external HALT has been triggered by some comparator of the analog commputer, the hybrid controller will switch the analog computer to HALT-mode immediately. Afterwards, the time the analog computer spent in OP-mode can be determined by calling this method. The time will be returned in microseconds (the resolution is about +/- 3 to 4 microseconds).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="reset()"
>reset()</a></h2>

<p>The reset() method resets the hybrid controller to its initial setup. This will also reset all digital potentiometer settings including their number! During normal operations it should not be necessary to call this method which was included primarily to aid debugging.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_address(address)"
>set_address(address)</a></h2>

<p>set_address() is used to set the hybrid controller to a different address than its default address of 0x0090. The hybrid controller requires its own address on the backplane in order to set the builtin digital potentiometers. If the controller is placed into another slot than the last one of the main backplane (something which is not recommended), then this method has to be called before any changes to the builtin digitally controlled potentiometer setting are made. If the hybrid controller&#39;s address is not set correctly setting the digital potentiometers will fail silently! The address has to be specified in hexadecimal notation with four digits (padded on the left with zeros if necessary).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Examples"
>Examples</a></h1>

<p>The following example initates a repetitive run of the analog computer with 20 ms of operating time and 10 ms IC time:</p>

<pre>    use strict;
    use warnings;

    use File::Basename;
    use HyCon;

    (my $config_filename = basename($0)) =~ s/\.pl$//;
    my $ac = HyCon-&#62;new(&#34;$config_filename.yml&#34;);

    $ac-&#62;set_op_time(20);
    $ac-&#62;set_ic_time(10);

    $ac-&#62;repetitive_run();</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Dr. Bernd Ulmann, ulmann@analogparadigm.com</p>

<!-- end doc -->

</body></html>
