TYPEMAP
HV *	T_HvRV
AV *	T_AvRV
std::string	T_STD_STRING
std::string*	T_STD_STRING_PTR
std::vector<double>*	T_STD_VECTOR_DOUBLE_PTR
std::vector<double>	T_STD_VECTOR_DOUBLE
std::vector<int>*	T_STD_VECTOR_INT_PTR
std::vector<int>	T_STD_VECTOR_INT
std::vector<unsigned int>*	T_STD_VECTOR_UINT_PTR
std::vector<unsigned int>	T_STD_VECTOR_UINT
std::vector<std::string>	T_STD_VECTOR_STD_STRING
std::vector<std::string>*	T_STD_VECTOR_STD_STRING_PTR
std::vector<char*>	T_STD_VECTOR_CSTRING
std::vector<char*>*	T_STD_VECTOR_CSTRING_PTR
std::list<double>*	T_STD_LIST_DOUBLE_PTR
std::list<double>	T_STD_LIST_DOUBLE
std::list<int>*	T_STD_LIST_INT_PTR
std::list<int>	T_STD_LIST_INT
std::list<unsigned int>*	T_STD_LIST_UINT_PTR
std::list<unsigned int>	T_STD_LIST_UINT
std::list<std::string>	T_STD_LIST_STD_STRING
std::list<std::string>*	T_STD_LIST_STD_STRING_PTR
std::list<string>	T_STD_LIST_STD_STRING
std::list<string>*	T_STD_LIST_STD_STRING_PTR
std::list<char*>	T_STD_LIST_CSTRING
std::list<char*>*	T_STD_LIST_CSTRING_PTR
list<double>*	T_STD_LIST_DOUBLE_PTR
list<double>	T_STD_LIST_DOUBLE
list<int>*	T_STD_LIST_INT_PTR
list<int>	T_STD_LIST_INT
list<unsigned int>*	T_STD_LIST_UINT_PTR
list<unsigned int>	T_STD_LIST_UINT
list<std::string>	T_STD_LIST_STD_STRING
list<std::string>*	T_STD_LIST_STD_STRING_PTR
list<string>	T_STD_LIST_STD_STRING
list<string>*	T_STD_LIST_STD_STRING_PTR
list<char*>	T_STD_LIST_CSTRING
list<char*>*	T_STD_LIST_CSTRING_PTR
Status	T_ENUM
mesos::perl::CommandChannel*	O_COMMAND_CHANNEL
mesos::perl::MesosCommand	O_MESOS_COMMAND
mesos::perl::CommandDispatcher*	O_COMMAND_DISPATCHER
mesos::perl::PipeDispatcher*	O_COMMAND_DISPATCHER
mesos::perl::InterruptDispatcher*	O_COMMAND_DISPATCHER
mesos::perl::ExecutorDriver*	O_EXECUTOR_DRIVER
mesos::perl::SchedulerDriver*	O_SCHEDULER_DRIVER
mesos::Credential	O_MESOS_CREDENTIAL
mesos::ExecutorID	O_MESOS_EXECUTORID
mesos::Filters	O_MESOS_FILTERS
mesos::FrameworkInfo	O_MESOS_FRAMEWORKINFO
mesos::OfferID	O_MESOS_OFFERID
mesos::SlaveID	O_MESOS_SLAVEID
mesos::TaskID	O_MESOS_TASKID
mesos::TaskStatus	O_MESOS_TASKSTATUS
std::vector<mesos::OfferID>	O_MESOS_OFFERID_VEC
std::vector<mesos::Request>	O_MESOS_REQUEST_VEC
std::vector<mesos::TaskInfo>	O_MESOS_TASKINFO_VEC
std::vector<mesos::TaskStatus>	O_MESOS_TASKSTATUS_VEC

INPUT
O_OBJECT
	if( sv_isobject($arg) && (SvTYPE(SvRV($arg)) == SVt_PVMG) )
		$var = ($type)SvIV((SV*)SvRV( $arg ));
	else{
		warn( \"${Package}::$func_name() -- $var is not a blessed SV reference\" );
		XSRETURN_UNDEF;
	}
T_OBJECT
	if( SvROK($arg) )
		$var = ($type)SvIV((SV*)SvRV( $arg ));
	else{
		warn( \"${Package}::$func_name() -- $var is not an SV reference\" );
		XSRETURN_UNDEF;
	}
O_HvRV
	if( sv_isobject($arg) && (SvTYPE(SvRV($arg)) == SVt_PVHV) )
		$var = (HV*)SvRV( $arg );
	else {
		warn( \"${Package}::$func_name() -- $var is not a blessed HV reference\" );
		XSRETURN_UNDEF;
	}
T_HvRV
	if( SvROK($arg) && (SvTYPE(SvRV($arg)) == SVt_PVHV) )
		$var = (HV*)SvRV( $arg );
	else {
		warn( \"${Package}::$func_name() -- $var is not an HV reference\" );
		XSRETURN_UNDEF;
	}
O_AvRV
	if( sv_isobject($arg) && (SvTYPE(SvRV($arg)) == SVt_PVAV) )
		$var = (AV*)SvRV( $arg );
	else {
		warn( \"${Package}::$func_name() -- $var is not a blessed AV reference\" );
		XSRETURN_UNDEF;
	}
T_AvRV
	if( SvROK($arg) && (SvTYPE(SvRV($arg)) == SVt_PVAV) )
		$var = (AV*)SvRV( $arg );
	else {
		warn( \"${Package}::$func_name() -- $var is not an AV reference\" );
		XSRETURN_UNDEF;
	}
T_STD_STRING
    $var = std::string( SvPV_nolen( $arg ), SvCUR( $arg ) );
T_STD_STRING_PTR
    $var = new std::string( SvPV_nolen( $arg ), SvCUR( $arg ) );
T_STD_VECTOR_DOUBLE
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      ${var}[i] = SvNV(*elem);
	    else
	      ${var}[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_DOUBLE_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      (*$var)[i] = SvNV(*elem);
	    else
	      (*$var)[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_INT
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::vector<int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      ${var}[i] = SvIV(*elem);
	    else
	      ${var}[i] = 0;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_INT_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::vector<int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      (*$var)[i] = SvIV(*elem);
	    else
	      (*$var)[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_UINT
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::vector<unsigned int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      ${var}[i] = SvUV(*elem);
	    else
	      ${var}[i] = 0;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_UINT_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::vector<unsigned int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      (*$var)[i] = SvUV(*elem);
	    else
	      (*$var)[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_STD_STRING
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int alen = av_len(av)+1;
	  $var = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPV(*elem, len);
	      ${var}[i] = std::string(tmp, len);
	    }
	    else
	      ${var}[i] = std::string(\"\");
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_STD_STRING_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int alen = av_len(av)+1;
	  $var = new std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	      tmp = SvPV(*elem, len);
	      (*$var)[i] = std::string(tmp, len);
	    }
	    else
	      (*$var)[i] = std::string(\"\");
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_CSTRING
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::vector<char*>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	      ${var}[i] = SvPV_nolen(*elem);
	    else
	      ${var}[i] = NULL;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_VECTOR_CSTRING_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::vector<char*>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	      (*$var)[i] = SvPV_nolen(*elem);
	    else
	      (*$var)[i] = NULL;
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_DOUBLE
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::list<double>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      ${var}.push_back(SvNV(*elem));
	    else
	      ${var}[i].push_back(0.);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_DOUBLE_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::list<double>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      (*$var).push_back(SvNV(*elem));
	    else
	      (*$var).push_back(0.);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_INT
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::list<int>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      ${var}.push_back(SvIV(*elem));
	    else
	      ${var}[i].push_back(0);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_INT_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::list<int>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      (*$var).push_back(SvIV(*elem));
	    else
	      (*$var).push_back(0);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_UINT
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::list<unsigned int>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      ${var}.push_back(SvUV(*elem));
	    else
	      ${var}[i].push_back(0);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_UINT_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::list<unsigned int>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      (*$var).push_back(SvUV(*elem));
	    else
	      (*$var).push_back(0);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_STD_STRING
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int alen = av_len(av)+1;
	  $var = std::list<std::string>();
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	      tmp = SvPV(*elem, len);
	      ${var}.push_back(std::string(tmp, len));
	    }
	    else
	      ${var}.push_back(std::string(\"\"));
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_STD_STRING_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int alen = av_len(av)+1;
	  $var = new std::list<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	      tmp = SvPV(*elem, len);
	      (*$var).push_back(std::string(tmp, len));
	    }
	    else
	      (*$var).push_back(std::string(\"\"));
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_CSTRING
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = std::list<char*>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	      ${var}.push_back(SvPV_nolen(*elem));
	    else
	      ${var}.push_back(NULL);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
T_STD_LIST_CSTRING_PTR
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV) {
	  AV* av = (AV*)SvRV($arg);
	  const unsigned int len = av_len(av)+1;
	  $var = new std::list<char*>();
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	      (*$var).push_back(SvPV_nolen(*elem));
	    else
	      (*$var).push_back(NULL);
	  }
	}
	else
	  Perl_croak(aTHX_ \"%s: %s is not an array reference\",
	             ${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
	             \"$var\");
O_COMMAND_CHANNEL
    $var = ($type) tied_object_to_ptr(aTHX_ $arg, \"$var\", \"Mesos::Channel\");
O_MESOS_COMMAND
        if (!SvROK($arg) || !(SvTYPE(SvRV($arg)) == SVt_PVAV))
            Perl_croak(aTHX_ \"$var must be an array ref\");
        AV* command_av = (AV*) SvRV($arg);
        SV* name_sv = *(av_fetch(command_av, 0, 0));
        if (SvTYPE(name_sv) != SVt_PV)
            Perl_croak(aTHX_ \"Command name must be a string\");
        mesos::perl::CommandArgs args;
        int length = AvFILL(command_av) + 1;
        for (int i = 1; i < length; i++) {
            SV* arg = *(av_fetch(command_av, i, 0));
            args.push_back(sv_to_CommandArg(arg));
        }
        $var = ($type) mesos::perl::MesosCommand(sv_to_string(name_sv), args);
O_COMMAND_DISPATCHER
    $var = ($type) tied_object_to_ptr(aTHX_ $arg, \"$var\", \"Mesos::Dispatcher\");
O_EXECUTOR_DRIVER
    $var = ($type) tied_object_to_ptr(aTHX_ $arg, \"$var\", \"Mesos::ExecutorDriver\");
O_SCHEDULER_DRIVER
    $var = ($type) tied_object_to_ptr(aTHX_ $arg, \"$var\", \"Mesos::SchedulerDriver\");
O_MESOS_CREDENTIAL
    $var = ($type) toMsg<mesos::Credential>($arg);
O_MESOS_EXECUTORID
    $var = ($type) toMsg<mesos::ExecutorID>($arg);
O_MESOS_FILTERS
    $var = ($type) toMsg<mesos::Filters>($arg);
O_MESOS_FRAMEWORKINFO
    $var = ($type) toMsg<mesos::FrameworkInfo>($arg);
O_MESOS_OFFERID
    $var = ($type) toMsg<mesos::OfferID>($arg);
O_MESOS_SLAVEID
    $var = ($type) toMsg<mesos::SlaveID>($arg);
O_MESOS_TASKID
    $var = ($type) toMsg<mesos::TaskID>($arg);
O_MESOS_TASKSTATUS
    $var = ($type) toMsg<mesos::TaskStatus>($arg);
O_MESOS_OFFERID_VEC
    $var = ($type) toMsgVec<mesos::OfferID>($arg);
O_MESOS_REQUEST_VEC
    $var = ($type) toMsgVec<mesos::Request>($arg);
O_MESOS_TASKINFO_VEC
    $var = ($type) toMsgVec<mesos::TaskInfo>($arg);
O_MESOS_TASKSTATUS_VEC
    $var = ($type) toMsgVec<mesos::TaskStatus>($arg);

OUTPUT
O_OBJECT
	sv_setref_pv( $arg, CLASS, (void*)$var );
T_OBJECT
	sv_setref_pv( $arg, Nullch, (void*)$var );
O_HvRV
	$arg = sv_bless( newRV((SV*)$var), gv_stashpv(CLASS,1) );
T_HvRV
	$arg = newRV((SV*)$var);
O_AvRV
	$arg = sv_bless( newRV((SV*)$var), gv_stashpv(CLASS,1) );
T_AvRV
	$arg = newRV((SV*)$var);
T_STD_STRING
    $arg = newSVpvn( $var.c_str(), $var.length() );
T_STD_STRING_PTR
    $arg = newSVpvn( $var->c_str(), $var->length() );
T_STD_VECTOR_DOUBLE
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  av_store(av, i, newSVnv(${var}[i]));
	}
T_STD_VECTOR_DOUBLE_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  av_store(av, i, newSVnv((*$var)[i]));
	}
T_STD_VECTOR_INT
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  av_store(av, i, newSViv(${var}[i]));
	}
T_STD_VECTOR_INT_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  av_store(av, i, newSViv((*$var)[i]));
	}
T_STD_VECTOR_UINT
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  av_store(av, i, newSVuv(${var}[i]));
	}
T_STD_VECTOR_UINT_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  av_store(av, i, newSVuv((*$var)[i]));
	}
T_STD_VECTOR_STD_STRING
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  const std::string& str = ${var}[i];
	  STRLEN len = str.length();
	  av_store(av, i, newSVpv(str.c_str(), len));
	}
T_STD_VECTOR_STD_STRING_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  const std::string& str = (*$var)[i];
	  STRLEN len = str.length();
	  av_store(av, i, newSVpv(str.c_str(), len));
	}
T_STD_VECTOR_CSTRING
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  STRLEN len = strlen(${var}[i]);
	  av_store(av, i, newSVpv(${var}[i], len));
	}
T_STD_VECTOR_CSTRING_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
        if (len)
          av_extend(av, len-1);
	for (unsigned int i = 0; i < len; i++) {
	  STRLEN len = strlen((*$var)[i]);
	  av_store(av, i, newSVpv((*$var)[i], len));
	}
T_STD_LIST_DOUBLE
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<double>::const_iterator lend = $var.cend();
	std::list<double>::const_iterator lit  = $var.cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i++, newSVnv(*lit));
	}
T_STD_LIST_DOUBLE_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<double>::const_iterator lend = (*$var).cend();
	std::list<double>::const_iterator lit  = (*$var).cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i++, newSVnv(*lit));
	}
T_STD_LIST_INT
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<int>::const_iterator lend = $var.cend();
	std::list<int>::const_iterator lit  = $var.cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i++, newSViv(*lit));
	}
T_STD_LIST_INT_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<int>::const_iterator lend = (*$var).cend();
	std::list<int>::const_iterator lit  = (*$var).cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i++, newSViv(*lit));
	}
T_STD_LIST_UINT
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<unsigned int>::const_iterator lend = $var.cend();
	std::list<unsigned int>::const_iterator lit  = $var.cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i++, newSVuv(*lit));
	}
T_STD_LIST_UINT_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<unsigned int>::const_iterator lend = (*$var).cend();
	std::list<unsigned int>::const_iterator lit  = (*$var).cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i++, newSVuv(*lit));
	}
T_STD_LIST_STD_STRING
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<std::string>::const_iterator lend = $var.cend();
	std::list<std::string>::const_iterator lit  = $var.cbegin();
	for (; lit != lend; ++lit) {
	  const std::string& str = *lit;
	  STRLEN len = str.length();
	  av_store(av, i++, newSVpv(str.c_str(), len));
	}
T_STD_LIST_STD_STRING_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size(); // Technically may be linear...
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<std::string>::const_iterator lend = (*$var).cend();
	std::list<std::string>::const_iterator lit  = (*$var).cbegin();
	for (; lit != lend; ++lit) {
	  const std::string& str = *lit;
	  STRLEN len = str.length();
	  av_store(av, i++, newSVpv(str.c_str(), len));
	}
T_STD_LIST_CSTRING
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var.size();
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<char *>::const_iterator lend = $var.cend();
	std::list<char *>::const_iterator lit  = $var.cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i, newSVpv(*lit, (STRLEN)strlen(*lit)));
	}
T_STD_LIST_CSTRING_PTR
	AV* av = newAV();
	$arg = newRV_noinc((SV*)av);
	const unsigned int len = $var->size();
	av_extend(av, len-1);
	unsigned int i = 0;
	std::list<char *>::const_iterator lend = (*$var).cend();
	std::list<char *>::const_iterator lit  = (*$var).cbegin();
	for (; lit != lend; ++lit) {
	  av_store(av, i, newSVpv(*lit, (STRLEN)strlen(*lit)));
	}
O_COMMAND_CHANNEL
    $arg = ptr_to_tied_object(aTHX_ (void*) $var, \"Mesos::Channel\");
O_MESOS_COMMAND
        mesos::perl::MesosCommand command((mesos::perl::MesosCommand) $var);
        AV* retval  newAV();
        av_store(retval, 0, newSVpvn(command.name_.c_str(), command.name_.length()));
        for (int i=0; i < command.args_.size(); i++) {
            av_store(retval, i + 1, CommandArg_to_sv( command.args_.at(i) ));
        }
        $arg = sv_2mortal(newRV_noinc((SV*) retval));
O_COMMAND_DISPATCHER
    $arg = ptr_to_tied_object(aTHX_ (void*) $var, \"Mesos::Dispatcher\");
O_EXECUTOR_DRIVER
    $arg = ptr_to_tied_object(aTHX_ (void*) $var, \"Mesos::ExecutorDriver\");
O_SCHEDULER_DRIVER
    $arg = ptr_to_tied_object(aTHX_ (void*) $var, \"Mesos::SchedulerDriver\");
