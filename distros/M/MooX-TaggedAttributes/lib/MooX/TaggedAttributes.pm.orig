package MooX::TaggedAttributes;

# ABSTRACT: Add a tag with an arbitrary value to a an attribute

use v5.10.1;

use strict;
use warnings;

our $VERSION = '0.13';

use Carp;
use MRO::Compat;

use Class::Method::Modifiers qw[ install_modifier ];

use MooX::TaggedAttributes::Cache;
use constant Role => 'MooX::TaggedAttributes::Role';

our %TAGSTORE;
our %TAGCACHE;

my %ARGS = ( -tags => [] );

our $_role_import = sub {
    my $class = shift;
    return unless Moo::Role->is_role( $class );
    my $target = caller;
    Moo::Role->apply_roles_to_package( $target, Role );
    _install_tags( $target, $TAGSTORE{$class} );
};

sub import {

    my ( $class, @args ) = @_;
    my $target = caller;

    Moo::Role->apply_roles_to_package( $target, Role );

    return unless @args;

    my %args = %ARGS;

    while ( @args ) {
        my $arg = shift @args;

        croak( "unknown argument to ", __PACKAGE__, ": $arg" )
          unless exists $ARGS{$arg};

        $args{$arg} = defined $ARGS{$arg} ? shift @args : 1;
    }

    $args{-tags} = [ $args{-tags} ]
      unless 'ARRAY' eq ref $args{-tags};

    _install_tags( $target, $args{-tags} )
      if @{ $args{-tags} };

    say STDERR "TARGET $target";

    no strict 'refs';    ## no critic
    *${ \"${target}::import" } = $_role_import;
}


sub _install_tags {
    my ( $target, $tags ) = @_;

    if ( $TAGSTORE{$target} ) {
        push @{ $TAGSTORE{$target} }, @$tags;
    }

    else {
        $TAGSTORE{$target} = [@$tags];
        _install_tag_handler( $target );
    }
}

sub _install_tag_handler {
    my $target = shift;

    # we need to
    #  1) use the target package's around() function, and
    #  2) call it in that package's context.

    # create a closure which knows about the target's around
    # so that if namespace::clean is called on the target class
    # we don't lose access to it.

    my $around = \&${ \"${target}::around" };

    install_modifier(
        $target,
        after => has => sub {
            my ( $attrs, %attr ) = @_;

            $attrs = ref $attrs ? $attrs : [$attrs];

            my @tags = @{ $TAGSTORE{$target} };

            $around->(
                "_tag_list" => sub {
                    my $orig = shift;

                    ## no critic (ProhibitAccessOfPrivateData)
                    return [
                        @{&$orig},
                        map    { [ $_, $attrs, $attr{$_} ] }
                          grep { exists $attr{$_} } @tags,
                    ];

                } );

        } );
}


1;

# COPYRIGHT

__END__

=for stopwords instantiation use'ing

=head1 SYNOPSIS

# EXAMPLE: ./examples/synopsis/T1.pm

# EXAMPLE: ./examples/synopsis/C1.pm

# EXAMPLE: ./examples/synopsis/R1.pm

# EXAMPLE: ./examples/synopsis/C2.pm

# EXAMPLE: ./examples/synopsis/script.pl

=head1 DESCRIPTION

This module attaches a tag-value pair to an attribute in a B<Moo>
class or role, and provides a interface to query which attributes have
which tags, and what the values are.

=head2 Tagging Attributes

To define a set of tags, create a special I<tag role>:

# EXAMPLE: ./examples/description/T1.pm

If there's only one tag, it can be passed directly without being
wrapped in an array:

# EXAMPLE: ./examples/description/T2.pm

A tag role is a standard B<Moo::Role> with added machinery to track
attribute tags.  As shown, attributes may be tagged in the tag role
as well as in modules which consume it.

Tag roles may be consumed just as ordinary roles, but in order for
role consumers to have the ability to assign tags to attributes, they
need to be consumed with the Perl B<use> statement, not with the B<with> statement.

Consuming with the B<with> statement I<will> propagate attributes with
existing tags, but won't provide the ability to tag new attributes.

This is correct:

# EXAMPLE: ./examples/description/R2.pm

# EXAMPLE: ./examples/description/R3.pm

The same goes for classes:

# EXAMPLE: ./examples/description/C1.pm

Combining tag roles is as simple as B<use>'ing them in the new role:

# EXAMPLE: ./examples/description/T12.pm

# EXAMPLE: ./examples/description/C2.pm

=head2 Accessing tags

Classes and objects are provided a B<_tags> method which returns a
L<MooX::TaggedAttributes::Cache> object.  For backwards compatibility,
it can be dereferenced as a hash, providing a hash of hashes keyed
off of the tags and attribute names.  For example, for the following
code:

# EXAMPLE: ./examples/accessing/T.pm

# EXAMPLE: ./examples/accessing/C.pm

The tag structure returned by  C<< C->_tags >>

# COMMAND: perl -Iexamples/accessing -MC -MData::Dump -e 'dd( C->_tags)'

and C<< C->new->_tags >>

# COMMAND: perl -Iexamples/accessing -MC -MData::Dump -E 'dd( C->new->_tags)'

are identical.

=head1 BUGS AND LIMITATIONS

=head2 Changes to an object after instantiation are not tracked.

If a role with tagged attributes is applied to an object, the
tags for those attributes are not visible.
