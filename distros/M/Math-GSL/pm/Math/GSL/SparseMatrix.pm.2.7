# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package Math::GSL::SparseMatrix;
use base qw(Exporter);
use base qw(DynaLoader);
package Math::GSL::SparseMatrixc;
bootstrap Math::GSL::SparseMatrix;
package Math::GSL::SparseMatrix;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package Math::GSL::SparseMatrix;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package Math::GSL::SparseMatrix;

*gsl_error = *Math::GSL::SparseMatrixc::gsl_error;
*gsl_stream_printf = *Math::GSL::SparseMatrixc::gsl_stream_printf;
*gsl_strerror = *Math::GSL::SparseMatrixc::gsl_strerror;
*gsl_set_error_handler = *Math::GSL::SparseMatrixc::gsl_set_error_handler;
*gsl_set_error_handler_off = *Math::GSL::SparseMatrixc::gsl_set_error_handler_off;
*gsl_set_stream_handler = *Math::GSL::SparseMatrixc::gsl_set_stream_handler;
*gsl_set_stream = *Math::GSL::SparseMatrixc::gsl_set_stream;
*gsl_spmatrix_cumsum = *Math::GSL::SparseMatrixc::gsl_spmatrix_cumsum;
*gsl_spmatrix_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_alloc;
*gsl_spmatrix_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_alloc_nzmax;
*gsl_spmatrix_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_free;
*gsl_spmatrix_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_realloc;
*gsl_spmatrix_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_nnz;
*gsl_spmatrix_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_type;
*gsl_spmatrix_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_set_zero;
*gsl_spmatrix_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_tree_rebuild;
*gsl_spmatrix_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_csc;
*gsl_spmatrix_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_csr;
*gsl_spmatrix_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_compress;
*gsl_spmatrix_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_compcol;
*gsl_spmatrix_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_ccs;
*gsl_spmatrix_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_crs;
*gsl_spmatrix_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_memcpy;
*gsl_spmatrix_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_fprintf;
*gsl_spmatrix_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_fscanf;
*gsl_spmatrix_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_fwrite;
*gsl_spmatrix_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_fread;
*gsl_spmatrix_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_get;
*gsl_spmatrix_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_set;
*gsl_spmatrix_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_ptr;
*gsl_spmatrix_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_minmax;
*gsl_spmatrix_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_min_index;
*gsl_spmatrix_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_scale;
*gsl_spmatrix_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_scale_columns;
*gsl_spmatrix_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_scale_rows;
*gsl_spmatrix_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_add;
*gsl_spmatrix_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_dense_add;
*gsl_spmatrix_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_dense_sub;
*gsl_spmatrix_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_d2sp;
*gsl_spmatrix_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_sp2d;
*gsl_spmatrix_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_add_to_dense;
*gsl_spmatrix_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_equal;
*gsl_spmatrix_norm1 = *Math::GSL::SparseMatrixc::gsl_spmatrix_norm1;
*gsl_spmatrix_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_transpose;
*gsl_spmatrix_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_transpose2;
*gsl_spmatrix_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_transpose_memcpy;
*gsl_spmatrix_complex_long_double_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_alloc;
*gsl_spmatrix_complex_long_double_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_alloc_nzmax;
*gsl_spmatrix_complex_long_double_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_free;
*gsl_spmatrix_complex_long_double_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_realloc;
*gsl_spmatrix_complex_long_double_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_nnz;
*gsl_spmatrix_complex_long_double_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_type;
*gsl_spmatrix_complex_long_double_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_set_zero;
*gsl_spmatrix_complex_long_double_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_tree_rebuild;
*gsl_spmatrix_complex_long_double_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_csc;
*gsl_spmatrix_complex_long_double_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_csr;
*gsl_spmatrix_complex_long_double_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_compress;
*gsl_spmatrix_complex_long_double_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_compcol;
*gsl_spmatrix_complex_long_double_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_ccs;
*gsl_spmatrix_complex_long_double_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_crs;
*gsl_spmatrix_complex_long_double_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_memcpy;
*gsl_spmatrix_complex_long_double_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_fprintf;
*gsl_spmatrix_complex_long_double_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_fscanf;
*gsl_spmatrix_complex_long_double_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_fwrite;
*gsl_spmatrix_complex_long_double_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_fread;
*gsl_spmatrix_complex_long_double_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_get;
*gsl_spmatrix_complex_long_double_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_set;
*gsl_spmatrix_complex_long_double_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_ptr;
*gsl_spmatrix_complex_long_double_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_scale;
*gsl_spmatrix_complex_long_double_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_scale_columns;
*gsl_spmatrix_complex_long_double_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_scale_rows;
*gsl_spmatrix_complex_long_double_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_add;
*gsl_spmatrix_complex_long_double_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_dense_add;
*gsl_spmatrix_complex_long_double_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_dense_sub;
*gsl_spmatrix_complex_long_double_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_d2sp;
*gsl_spmatrix_complex_long_double_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_sp2d;
*gsl_spmatrix_complex_long_double_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_add_to_dense;
*gsl_spmatrix_complex_long_double_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_equal;
*gsl_spmatrix_complex_long_double_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_transpose;
*gsl_spmatrix_complex_long_double_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_transpose2;
*gsl_spmatrix_complex_long_double_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_transpose_memcpy;
*gsl_spmatrix_complex_float_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_alloc;
*gsl_spmatrix_complex_float_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_alloc_nzmax;
*gsl_spmatrix_complex_float_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_free;
*gsl_spmatrix_complex_float_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_realloc;
*gsl_spmatrix_complex_float_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_nnz;
*gsl_spmatrix_complex_float_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_type;
*gsl_spmatrix_complex_float_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_set_zero;
*gsl_spmatrix_complex_float_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_tree_rebuild;
*gsl_spmatrix_complex_float_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_csc;
*gsl_spmatrix_complex_float_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_csr;
*gsl_spmatrix_complex_float_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_compress;
*gsl_spmatrix_complex_float_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_compcol;
*gsl_spmatrix_complex_float_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_ccs;
*gsl_spmatrix_complex_float_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_crs;
*gsl_spmatrix_complex_float_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_memcpy;
*gsl_spmatrix_complex_float_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_fprintf;
*gsl_spmatrix_complex_float_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_fscanf;
*gsl_spmatrix_complex_float_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_fwrite;
*gsl_spmatrix_complex_float_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_fread;
*gsl_spmatrix_complex_float_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_get;
*gsl_spmatrix_complex_float_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_set;
*gsl_spmatrix_complex_float_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_ptr;
*gsl_spmatrix_complex_float_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_scale;
*gsl_spmatrix_complex_float_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_scale_columns;
*gsl_spmatrix_complex_float_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_scale_rows;
*gsl_spmatrix_complex_float_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_add;
*gsl_spmatrix_complex_float_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_dense_add;
*gsl_spmatrix_complex_float_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_dense_sub;
*gsl_spmatrix_complex_float_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_d2sp;
*gsl_spmatrix_complex_float_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_sp2d;
*gsl_spmatrix_complex_float_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_add_to_dense;
*gsl_spmatrix_complex_float_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_equal;
*gsl_spmatrix_complex_float_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_transpose;
*gsl_spmatrix_complex_float_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_transpose2;
*gsl_spmatrix_complex_float_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_transpose_memcpy;
*gsl_spmatrix_long_double_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_alloc;
*gsl_spmatrix_long_double_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_alloc_nzmax;
*gsl_spmatrix_long_double_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_free;
*gsl_spmatrix_long_double_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_realloc;
*gsl_spmatrix_long_double_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_nnz;
*gsl_spmatrix_long_double_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_type;
*gsl_spmatrix_long_double_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_set_zero;
*gsl_spmatrix_long_double_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_tree_rebuild;
*gsl_spmatrix_long_double_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_csc;
*gsl_spmatrix_long_double_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_csr;
*gsl_spmatrix_long_double_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_compress;
*gsl_spmatrix_long_double_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_compcol;
*gsl_spmatrix_long_double_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_ccs;
*gsl_spmatrix_long_double_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_crs;
*gsl_spmatrix_long_double_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_memcpy;
*gsl_spmatrix_long_double_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_fprintf;
*gsl_spmatrix_long_double_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_fscanf;
*gsl_spmatrix_long_double_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_fwrite;
*gsl_spmatrix_long_double_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_fread;
*gsl_spmatrix_long_double_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_get;
*gsl_spmatrix_long_double_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_set;
*gsl_spmatrix_long_double_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_ptr;
*gsl_spmatrix_long_double_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_minmax;
*gsl_spmatrix_long_double_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_min_index;
*gsl_spmatrix_long_double_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_scale;
*gsl_spmatrix_long_double_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_scale_columns;
*gsl_spmatrix_long_double_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_scale_rows;
*gsl_spmatrix_long_double_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_add;
*gsl_spmatrix_long_double_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_dense_add;
*gsl_spmatrix_long_double_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_dense_sub;
*gsl_spmatrix_long_double_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_d2sp;
*gsl_spmatrix_long_double_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_sp2d;
*gsl_spmatrix_long_double_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_add_to_dense;
*gsl_spmatrix_long_double_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_equal;
*gsl_spmatrix_long_double_norm1 = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_norm1;
*gsl_spmatrix_long_double_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_transpose;
*gsl_spmatrix_long_double_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_transpose2;
*gsl_spmatrix_long_double_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_transpose_memcpy;
*gsl_spmatrix_uint_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_alloc;
*gsl_spmatrix_uint_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_alloc_nzmax;
*gsl_spmatrix_uint_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_free;
*gsl_spmatrix_uint_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_realloc;
*gsl_spmatrix_uint_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_nnz;
*gsl_spmatrix_uint_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_type;
*gsl_spmatrix_uint_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_set_zero;
*gsl_spmatrix_uint_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_tree_rebuild;
*gsl_spmatrix_uint_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_csc;
*gsl_spmatrix_uint_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_csr;
*gsl_spmatrix_uint_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_compress;
*gsl_spmatrix_uint_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_compcol;
*gsl_spmatrix_uint_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_ccs;
*gsl_spmatrix_uint_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_crs;
*gsl_spmatrix_uint_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_memcpy;
*gsl_spmatrix_uint_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_fprintf;
*gsl_spmatrix_uint_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_fscanf;
*gsl_spmatrix_uint_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_fwrite;
*gsl_spmatrix_uint_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_fread;
*gsl_spmatrix_uint_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_get;
*gsl_spmatrix_uint_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_set;
*gsl_spmatrix_uint_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_ptr;
*gsl_spmatrix_uint_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_minmax;
*gsl_spmatrix_uint_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_min_index;
*gsl_spmatrix_uint_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_scale;
*gsl_spmatrix_uint_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_scale_columns;
*gsl_spmatrix_uint_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_scale_rows;
*gsl_spmatrix_uint_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_add;
*gsl_spmatrix_uint_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_dense_add;
*gsl_spmatrix_uint_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_dense_sub;
*gsl_spmatrix_uint_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_d2sp;
*gsl_spmatrix_uint_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_sp2d;
*gsl_spmatrix_uint_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_add_to_dense;
*gsl_spmatrix_uint_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_equal;
*gsl_spmatrix_uint_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_transpose;
*gsl_spmatrix_uint_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_transpose2;
*gsl_spmatrix_uint_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_transpose_memcpy;
*gsl_spmatrix_complex_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_alloc;
*gsl_spmatrix_complex_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_alloc_nzmax;
*gsl_spmatrix_complex_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_free;
*gsl_spmatrix_complex_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_realloc;
*gsl_spmatrix_complex_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_nnz;
*gsl_spmatrix_complex_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_type;
*gsl_spmatrix_complex_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_set_zero;
*gsl_spmatrix_complex_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_tree_rebuild;
*gsl_spmatrix_complex_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_csc;
*gsl_spmatrix_complex_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_csr;
*gsl_spmatrix_complex_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_compress;
*gsl_spmatrix_complex_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_compcol;
*gsl_spmatrix_complex_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_ccs;
*gsl_spmatrix_complex_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_crs;
*gsl_spmatrix_complex_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_memcpy;
*gsl_spmatrix_complex_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_fprintf;
*gsl_spmatrix_complex_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_fscanf;
*gsl_spmatrix_complex_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_fwrite;
*gsl_spmatrix_complex_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_fread;
*gsl_spmatrix_complex_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_get;
*gsl_spmatrix_complex_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_set;
*gsl_spmatrix_complex_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_ptr;
*gsl_spmatrix_complex_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_scale;
*gsl_spmatrix_complex_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_scale_columns;
*gsl_spmatrix_complex_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_scale_rows;
*gsl_spmatrix_complex_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_add;
*gsl_spmatrix_complex_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_dense_add;
*gsl_spmatrix_complex_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_dense_sub;
*gsl_spmatrix_complex_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_d2sp;
*gsl_spmatrix_complex_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_sp2d;
*gsl_spmatrix_complex_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_add_to_dense;
*gsl_spmatrix_complex_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_equal;
*gsl_spmatrix_complex_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_transpose;
*gsl_spmatrix_complex_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_transpose2;
*gsl_spmatrix_complex_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_transpose_memcpy;
*gsl_spmatrix_char_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_alloc;
*gsl_spmatrix_char_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_alloc_nzmax;
*gsl_spmatrix_char_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_free;
*gsl_spmatrix_char_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_realloc;
*gsl_spmatrix_char_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_nnz;
*gsl_spmatrix_char_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_type;
*gsl_spmatrix_char_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_set_zero;
*gsl_spmatrix_char_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_tree_rebuild;
*gsl_spmatrix_char_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_csc;
*gsl_spmatrix_char_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_csr;
*gsl_spmatrix_char_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_compress;
*gsl_spmatrix_char_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_compcol;
*gsl_spmatrix_char_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_ccs;
*gsl_spmatrix_char_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_crs;
*gsl_spmatrix_char_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_memcpy;
*gsl_spmatrix_char_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_fprintf;
*gsl_spmatrix_char_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_fscanf;
*gsl_spmatrix_char_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_fwrite;
*gsl_spmatrix_char_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_fread;
*gsl_spmatrix_char_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_get;
*gsl_spmatrix_char_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_set;
*gsl_spmatrix_char_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_ptr;
*gsl_spmatrix_char_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_minmax;
*gsl_spmatrix_char_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_min_index;
*gsl_spmatrix_char_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_scale;
*gsl_spmatrix_char_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_scale_columns;
*gsl_spmatrix_char_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_scale_rows;
*gsl_spmatrix_char_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_add;
*gsl_spmatrix_char_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_dense_add;
*gsl_spmatrix_char_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_dense_sub;
*gsl_spmatrix_char_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_d2sp;
*gsl_spmatrix_char_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_sp2d;
*gsl_spmatrix_char_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_add_to_dense;
*gsl_spmatrix_char_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_equal;
*gsl_spmatrix_char_norm1 = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_norm1;
*gsl_spmatrix_char_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_transpose;
*gsl_spmatrix_char_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_transpose2;
*gsl_spmatrix_char_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_transpose_memcpy;
*gsl_spmatrix_uchar_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_alloc;
*gsl_spmatrix_uchar_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_alloc_nzmax;
*gsl_spmatrix_uchar_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_free;
*gsl_spmatrix_uchar_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_realloc;
*gsl_spmatrix_uchar_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_nnz;
*gsl_spmatrix_uchar_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_type;
*gsl_spmatrix_uchar_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_set_zero;
*gsl_spmatrix_uchar_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_tree_rebuild;
*gsl_spmatrix_uchar_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_csc;
*gsl_spmatrix_uchar_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_csr;
*gsl_spmatrix_uchar_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_compress;
*gsl_spmatrix_uchar_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_compcol;
*gsl_spmatrix_uchar_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_ccs;
*gsl_spmatrix_uchar_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_crs;
*gsl_spmatrix_uchar_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_memcpy;
*gsl_spmatrix_uchar_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_fprintf;
*gsl_spmatrix_uchar_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_fscanf;
*gsl_spmatrix_uchar_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_fwrite;
*gsl_spmatrix_uchar_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_fread;
*gsl_spmatrix_uchar_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_get;
*gsl_spmatrix_uchar_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_set;
*gsl_spmatrix_uchar_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_ptr;
*gsl_spmatrix_uchar_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_minmax;
*gsl_spmatrix_uchar_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_min_index;
*gsl_spmatrix_uchar_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_scale;
*gsl_spmatrix_uchar_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_scale_columns;
*gsl_spmatrix_uchar_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_scale_rows;
*gsl_spmatrix_uchar_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_add;
*gsl_spmatrix_uchar_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_dense_add;
*gsl_spmatrix_uchar_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_dense_sub;
*gsl_spmatrix_uchar_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_d2sp;
*gsl_spmatrix_uchar_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_sp2d;
*gsl_spmatrix_uchar_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_add_to_dense;
*gsl_spmatrix_uchar_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_equal;
*gsl_spmatrix_uchar_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_transpose;
*gsl_spmatrix_uchar_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_transpose2;
*gsl_spmatrix_uchar_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_transpose_memcpy;
*gsl_spmatrix_int_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_alloc;
*gsl_spmatrix_int_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_alloc_nzmax;
*gsl_spmatrix_int_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_free;
*gsl_spmatrix_int_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_realloc;
*gsl_spmatrix_int_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_nnz;
*gsl_spmatrix_int_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_type;
*gsl_spmatrix_int_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_set_zero;
*gsl_spmatrix_int_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_tree_rebuild;
*gsl_spmatrix_int_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_csc;
*gsl_spmatrix_int_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_csr;
*gsl_spmatrix_int_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_compress;
*gsl_spmatrix_int_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_compcol;
*gsl_spmatrix_int_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_ccs;
*gsl_spmatrix_int_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_crs;
*gsl_spmatrix_int_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_memcpy;
*gsl_spmatrix_int_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_fprintf;
*gsl_spmatrix_int_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_fscanf;
*gsl_spmatrix_int_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_fwrite;
*gsl_spmatrix_int_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_fread;
*gsl_spmatrix_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_get;
*gsl_spmatrix_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_set;
*gsl_spmatrix_int_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_ptr;
*gsl_spmatrix_int_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_minmax;
*gsl_spmatrix_int_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_min_index;
*gsl_spmatrix_int_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_scale;
*gsl_spmatrix_int_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_scale_columns;
*gsl_spmatrix_int_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_scale_rows;
*gsl_spmatrix_int_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_add;
*gsl_spmatrix_int_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_dense_add;
*gsl_spmatrix_int_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_dense_sub;
*gsl_spmatrix_int_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_d2sp;
*gsl_spmatrix_int_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_sp2d;
*gsl_spmatrix_int_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_add_to_dense;
*gsl_spmatrix_int_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_equal;
*gsl_spmatrix_int_norm1 = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_norm1;
*gsl_spmatrix_int_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_transpose;
*gsl_spmatrix_int_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_transpose2;
*gsl_spmatrix_int_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_transpose_memcpy;
*gsl_spmatrix_short_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_alloc;
*gsl_spmatrix_short_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_alloc_nzmax;
*gsl_spmatrix_short_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_free;
*gsl_spmatrix_short_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_realloc;
*gsl_spmatrix_short_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_nnz;
*gsl_spmatrix_short_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_type;
*gsl_spmatrix_short_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_set_zero;
*gsl_spmatrix_short_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_tree_rebuild;
*gsl_spmatrix_short_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_csc;
*gsl_spmatrix_short_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_csr;
*gsl_spmatrix_short_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_compress;
*gsl_spmatrix_short_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_compcol;
*gsl_spmatrix_short_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_ccs;
*gsl_spmatrix_short_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_crs;
*gsl_spmatrix_short_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_memcpy;
*gsl_spmatrix_short_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_fprintf;
*gsl_spmatrix_short_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_fscanf;
*gsl_spmatrix_short_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_fwrite;
*gsl_spmatrix_short_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_fread;
*gsl_spmatrix_short_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_get;
*gsl_spmatrix_short_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_set;
*gsl_spmatrix_short_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_ptr;
*gsl_spmatrix_short_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_minmax;
*gsl_spmatrix_short_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_min_index;
*gsl_spmatrix_short_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_scale;
*gsl_spmatrix_short_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_scale_columns;
*gsl_spmatrix_short_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_scale_rows;
*gsl_spmatrix_short_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_add;
*gsl_spmatrix_short_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_dense_add;
*gsl_spmatrix_short_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_dense_sub;
*gsl_spmatrix_short_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_d2sp;
*gsl_spmatrix_short_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_sp2d;
*gsl_spmatrix_short_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_add_to_dense;
*gsl_spmatrix_short_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_equal;
*gsl_spmatrix_short_norm1 = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_norm1;
*gsl_spmatrix_short_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_transpose;
*gsl_spmatrix_short_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_transpose2;
*gsl_spmatrix_short_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_transpose_memcpy;
*gsl_spmatrix_float_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_alloc;
*gsl_spmatrix_float_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_alloc_nzmax;
*gsl_spmatrix_float_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_free;
*gsl_spmatrix_float_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_realloc;
*gsl_spmatrix_float_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_nnz;
*gsl_spmatrix_float_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_type;
*gsl_spmatrix_float_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_set_zero;
*gsl_spmatrix_float_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_tree_rebuild;
*gsl_spmatrix_float_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_csc;
*gsl_spmatrix_float_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_csr;
*gsl_spmatrix_float_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_compress;
*gsl_spmatrix_float_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_compcol;
*gsl_spmatrix_float_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_ccs;
*gsl_spmatrix_float_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_crs;
*gsl_spmatrix_float_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_memcpy;
*gsl_spmatrix_float_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_fprintf;
*gsl_spmatrix_float_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_fscanf;
*gsl_spmatrix_float_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_fwrite;
*gsl_spmatrix_float_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_fread;
*gsl_spmatrix_float_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_get;
*gsl_spmatrix_float_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_set;
*gsl_spmatrix_float_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_ptr;
*gsl_spmatrix_float_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_minmax;
*gsl_spmatrix_float_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_min_index;
*gsl_spmatrix_float_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_scale;
*gsl_spmatrix_float_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_scale_columns;
*gsl_spmatrix_float_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_scale_rows;
*gsl_spmatrix_float_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_add;
*gsl_spmatrix_float_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_dense_add;
*gsl_spmatrix_float_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_dense_sub;
*gsl_spmatrix_float_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_d2sp;
*gsl_spmatrix_float_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_sp2d;
*gsl_spmatrix_float_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_add_to_dense;
*gsl_spmatrix_float_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_equal;
*gsl_spmatrix_float_norm1 = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_norm1;
*gsl_spmatrix_float_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_transpose;
*gsl_spmatrix_float_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_transpose2;
*gsl_spmatrix_float_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_transpose_memcpy;
*gsl_spmatrix_ushort_alloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_alloc;
*gsl_spmatrix_ushort_alloc_nzmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_alloc_nzmax;
*gsl_spmatrix_ushort_free = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_free;
*gsl_spmatrix_ushort_realloc = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_realloc;
*gsl_spmatrix_ushort_nnz = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_nnz;
*gsl_spmatrix_ushort_type = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_type;
*gsl_spmatrix_ushort_set_zero = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_set_zero;
*gsl_spmatrix_ushort_tree_rebuild = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_tree_rebuild;
*gsl_spmatrix_ushort_csc = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_csc;
*gsl_spmatrix_ushort_csr = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_csr;
*gsl_spmatrix_ushort_compress = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_compress;
*gsl_spmatrix_ushort_compcol = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_compcol;
*gsl_spmatrix_ushort_ccs = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_ccs;
*gsl_spmatrix_ushort_crs = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_crs;
*gsl_spmatrix_ushort_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_memcpy;
*gsl_spmatrix_ushort_fprintf = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_fprintf;
*gsl_spmatrix_ushort_fscanf = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_fscanf;
*gsl_spmatrix_ushort_fwrite = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_fwrite;
*gsl_spmatrix_ushort_fread = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_fread;
*gsl_spmatrix_ushort_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_get;
*gsl_spmatrix_ushort_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_set;
*gsl_spmatrix_ushort_ptr = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_ptr;
*gsl_spmatrix_ushort_minmax = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_minmax;
*gsl_spmatrix_ushort_min_index = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_min_index;
*gsl_spmatrix_ushort_scale = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_scale;
*gsl_spmatrix_ushort_scale_columns = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_scale_columns;
*gsl_spmatrix_ushort_scale_rows = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_scale_rows;
*gsl_spmatrix_ushort_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_add;
*gsl_spmatrix_ushort_dense_add = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_dense_add;
*gsl_spmatrix_ushort_dense_sub = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_dense_sub;
*gsl_spmatrix_ushort_d2sp = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_d2sp;
*gsl_spmatrix_ushort_sp2d = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_sp2d;
*gsl_spmatrix_ushort_add_to_dense = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_add_to_dense;
*gsl_spmatrix_ushort_equal = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_equal;
*gsl_spmatrix_ushort_transpose = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_transpose;
*gsl_spmatrix_ushort_transpose2 = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_transpose2;
*gsl_spmatrix_ushort_transpose_memcpy = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_transpose_memcpy;

############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_pool_node ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_pool_node;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_next_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_node_next_get;
*swig_next_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_node_next_set;
*swig_block_ptr_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_node_block_ptr_get;
*swig_block_ptr_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_node_block_ptr_set;
*swig_free_slot_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_node_free_slot_get;
*swig_free_slot_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_node_free_slot_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_pool_node(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_pool_node($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix ##############

package Math::GSL::SparseMatrix::gsl_spmatrix;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_complex_long_double ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_complex_long_double;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_complex_long_double(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_complex_long_double($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_complex_long_double_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_complex_long_double_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_long_double_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_complex_long_double_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_complex_long_double_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_complex_float ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_complex_float;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_complex_float(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_complex_float($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_complex_float_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_complex_float_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_float_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_complex_float_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_complex_float_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_long_double ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_long_double;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_long_double(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_long_double($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_long_double_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_long_double_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_long_double_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_long_double_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_long_double_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_uint ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_uint;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_uint(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_uint($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_uint_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_uint_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uint_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_uint_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_uint_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_complex ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_complex;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_complex(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_complex($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_complex_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_complex_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_complex_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_complex_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_complex_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_char ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_char;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_char(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_char($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_char_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_char_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_char_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_char_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_char_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_uchar ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_uchar;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_uchar(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_uchar($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_uchar_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_uchar_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_uchar_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_uchar_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_uchar_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_int ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_int;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_int(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_int($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_int_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_int_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_int_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_int_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_int_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_short ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_short;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_short(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_short($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_short_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_short_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_short_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_short_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_short_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_float ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_float;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_float(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_float($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_float_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_float_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_float_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_float_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_float_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_ushort ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_ushort;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_size1_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_size1_get;
*swig_size1_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_size1_set;
*swig_size2_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_size2_get;
*swig_size2_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_size2_set;
*swig_i_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_i_get;
*swig_i_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_i_set;
*swig_data_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_data_get;
*swig_data_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_data_set;
*swig_p_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_p_get;
*swig_p_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_p_set;
*swig_nzmax_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_nzmax_get;
*swig_nzmax_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_nzmax_set;
*swig_nz_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_nz_get;
*swig_nz_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_nz_set;
*swig_tree_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_tree_get;
*swig_tree_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_tree_set;
*swig_pool_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_pool_get;
*swig_pool_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_pool_set;
*swig_node_size_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_node_size_get;
*swig_node_size_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_node_size_set;
*swig_work_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_get;
*swig_work_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_set;
*swig_sptype_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_sptype_get;
*swig_sptype_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_sptype_set;
*swig_spflags_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_spflags_get;
*swig_spflags_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_spflags_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_ushort(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_ushort($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


############# Class : Math::GSL::SparseMatrix::gsl_spmatrix_ushort_work ##############

package Math::GSL::SparseMatrix::gsl_spmatrix_ushort_work;
use vars qw(@ISA %OWNER %ITERATORS %BLESSEDMEMBERS);
@ISA = qw( Math::GSL::SparseMatrix );
%OWNER = ();
%ITERATORS = ();
*swig_work_void_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_work_void_get;
*swig_work_void_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_work_void_set;
*swig_work_int_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_work_int_get;
*swig_work_int_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_work_int_set;
*swig_work_atomic_get = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_work_atomic_get;
*swig_work_atomic_set = *Math::GSL::SparseMatrixc::gsl_spmatrix_ushort_work_work_atomic_set;
sub new {
    my $pkg = shift;
    my $self = Math::GSL::SparseMatrixc::new_gsl_spmatrix_ushort_work(@_);
    bless $self, $pkg if defined($self);
}

sub DESTROY {
    return unless $_[0]->isa('HASH');
    my $self = tied(%{$_[0]});
    return unless defined $self;
    delete $ITERATORS{$self};
    if (exists $OWNER{$self}) {
        Math::GSL::SparseMatrixc::delete_gsl_spmatrix_ushort_work($self);
        delete $OWNER{$self};
    }
}

sub DISOWN {
    my $self = shift;
    my $ptr = tied(%$self);
    delete $OWNER{$ptr};
}

sub ACQUIRE {
    my $self = shift;
    my $ptr = tied(%$self);
    $OWNER{$ptr} = 1;
}


# ------- VARIABLE STUBS --------

package Math::GSL::SparseMatrix;

*GSL_VERSION = *Math::GSL::SparseMatrixc::GSL_VERSION;
*GSL_MAJOR_VERSION = *Math::GSL::SparseMatrixc::GSL_MAJOR_VERSION;
*GSL_MINOR_VERSION = *Math::GSL::SparseMatrixc::GSL_MINOR_VERSION;
*GSL_POSZERO = *Math::GSL::SparseMatrixc::GSL_POSZERO;
*GSL_NEGZERO = *Math::GSL::SparseMatrixc::GSL_NEGZERO;
*GSL_SUCCESS = *Math::GSL::SparseMatrixc::GSL_SUCCESS;
*GSL_FAILURE = *Math::GSL::SparseMatrixc::GSL_FAILURE;
*GSL_CONTINUE = *Math::GSL::SparseMatrixc::GSL_CONTINUE;
*GSL_EDOM = *Math::GSL::SparseMatrixc::GSL_EDOM;
*GSL_ERANGE = *Math::GSL::SparseMatrixc::GSL_ERANGE;
*GSL_EFAULT = *Math::GSL::SparseMatrixc::GSL_EFAULT;
*GSL_EINVAL = *Math::GSL::SparseMatrixc::GSL_EINVAL;
*GSL_EFAILED = *Math::GSL::SparseMatrixc::GSL_EFAILED;
*GSL_EFACTOR = *Math::GSL::SparseMatrixc::GSL_EFACTOR;
*GSL_ESANITY = *Math::GSL::SparseMatrixc::GSL_ESANITY;
*GSL_ENOMEM = *Math::GSL::SparseMatrixc::GSL_ENOMEM;
*GSL_EBADFUNC = *Math::GSL::SparseMatrixc::GSL_EBADFUNC;
*GSL_ERUNAWAY = *Math::GSL::SparseMatrixc::GSL_ERUNAWAY;
*GSL_EMAXITER = *Math::GSL::SparseMatrixc::GSL_EMAXITER;
*GSL_EZERODIV = *Math::GSL::SparseMatrixc::GSL_EZERODIV;
*GSL_EBADTOL = *Math::GSL::SparseMatrixc::GSL_EBADTOL;
*GSL_ETOL = *Math::GSL::SparseMatrixc::GSL_ETOL;
*GSL_EUNDRFLW = *Math::GSL::SparseMatrixc::GSL_EUNDRFLW;
*GSL_EOVRFLW = *Math::GSL::SparseMatrixc::GSL_EOVRFLW;
*GSL_ELOSS = *Math::GSL::SparseMatrixc::GSL_ELOSS;
*GSL_EROUND = *Math::GSL::SparseMatrixc::GSL_EROUND;
*GSL_EBADLEN = *Math::GSL::SparseMatrixc::GSL_EBADLEN;
*GSL_ENOTSQR = *Math::GSL::SparseMatrixc::GSL_ENOTSQR;
*GSL_ESING = *Math::GSL::SparseMatrixc::GSL_ESING;
*GSL_EDIVERGE = *Math::GSL::SparseMatrixc::GSL_EDIVERGE;
*GSL_EUNSUP = *Math::GSL::SparseMatrixc::GSL_EUNSUP;
*GSL_EUNIMPL = *Math::GSL::SparseMatrixc::GSL_EUNIMPL;
*GSL_ECACHE = *Math::GSL::SparseMatrixc::GSL_ECACHE;
*GSL_ETABLE = *Math::GSL::SparseMatrixc::GSL_ETABLE;
*GSL_ENOPROG = *Math::GSL::SparseMatrixc::GSL_ENOPROG;
*GSL_ENOPROGJ = *Math::GSL::SparseMatrixc::GSL_ENOPROGJ;
*GSL_ETOLF = *Math::GSL::SparseMatrixc::GSL_ETOLF;
*GSL_ETOLX = *Math::GSL::SparseMatrixc::GSL_ETOLX;
*GSL_ETOLG = *Math::GSL::SparseMatrixc::GSL_ETOLG;
*GSL_EOF = *Math::GSL::SparseMatrixc::GSL_EOF;
*GSL_SPMATRIX_COO = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_COO;
*GSL_SPMATRIX_CSC = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_CSC;
*GSL_SPMATRIX_CSR = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_CSR;
*GSL_SPMATRIX_TRIPLET = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_TRIPLET;
*GSL_SPMATRIX_CCS = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_CCS;
*GSL_SPMATRIX_CRS = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_CRS;
*GSL_SPMATRIX_FLG_GROW = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_FLG_GROW;
*GSL_SPMATRIX_FLG_FIXED = *Math::GSL::SparseMatrixc::GSL_SPMATRIX_FLG_FIXED;

@EXPORT_OK = qw/
               gsl_spmatrix_alloc
               gsl_spmatrix_get
               gsl_spmatrix_set
               gsl_spmatrix_free
               gsl_spmatrix_transpose
               gsl_spmatrix_transpose2
               gsl_spmatrix_transpose_memcpy
               gsl_spmatrix_set_zero
               gsl_spmatrix_add
               gsl_spmatrix_nnz
               gsl_spmatrix_scale
               gsl_spmatrix_d2sp
               gsl_spmatrix_sp2d
               gsl_spmatrix_minmax
               gsl_spmatrix_ccs
               gsl_spmatrix_crs
               gsl_spmatrix_memcpy
               gsl_spmatrix_ptr
               gsl_spmatrix_fwrite
               gsl_spmatrix_fread
               gsl_spmatrix_fprintf
               gsl_spmatrix_fscanf
             /;
%EXPORT_TAGS = ( all => [ @EXPORT_OK ] );

__END__

=encoding utf8

=head1 NAME

Math::GSL::SparseMatrix - Sparse Matrices

=head1 SYNOPSIS

    use Math::GSL::SparseMatrix qw/:all/;
    use Math::GSL::Matrix qw/gsl_matrix_alloc/;
    my $sparse = gsl_spmatrix_alloc(100,100);
    my $status = gsl_spmatrix_set($sparse,50,50,42.42);
    my $value  = gsl_spmatrix_get($sparse,50,50);

    # multiply every element by 5
    $status = gsl_spmatrix_scale($sparse, 5);

    # get the number of non-zero elements
    my $nnz = gsl_spmatrix_nnz($sparse);

    # fine min and max values, other than zero elements
    ($status, $min, $max) = gsl_spmatrix_minmax($sparse);

    # set all elements to zero
    $status = gsl_spmatrix_set_zero($sparse);

    my $dense  = gsl_matrix_alloc(100,100);
    # convert a sparse matrix to a dense matrix
    $status = gsl_spmatrix_sp2d($dense, $sparse);

    # convert a dense matrix to a sparse matrix
    $status = gsl_spmatrix_d2sp($sparse, $dense);

=head1 DESCRIPTION

NOTE: This module requires GSL 2.0 or higher.

For more informations on the functions, we refer you to the GSL official
documentation: L<http://www.gnu.org/software/gsl/manual/html_node/>

=head1 AUTHORS

Jonathan "Duke" Leto <jonathan@leto.net> and Thierry Moisan <thierry.moisan@gmail.com>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2008-2021 Jonathan "Duke" Leto and Thierry Moisan

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut


1;
