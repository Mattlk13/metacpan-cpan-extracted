NAME
    Acme::CPANModules::Import::CPANRatings::User::perlancar - Modules
    mentioned by CPANRatings user perlancar

VERSION
    This document describes version 0.001 of
    Acme::CPANModules::Import::CPANRatings::User::perlancar (from Perl
    distribution Acme-CPANModules-Import-CPANRatings-User-perlancar),
    released on 2018-06-07.

DESCRIPTION
    This list is generated by scraping CPANRatings (cpanratings.perl.org)
    user page.

    Modules mentioned by CPANRatings user perlancar.

    This list is generated by scraping CPANRatings (cpanratings.perl.org)
    user page.

INCLUDED MODULES
    *   LWP::JSON::Tiny

        I'm not sure this really &quot;befits a ::Tiny distribution&quot;
        just because it's a thin wrapper of something. Please read: <a
        href="http://blogs.perl.org/users/dan_muey/2014/08/please-dont-use-t
        iny-unless-it-meets-the-tiny-criteria-thanks.html"
        rel="nofollow">blogs.perl.org/users/dan_muey/2014/08...</a> or the
        Tiny mandate e.g. in <a
        href="https://metacpan.org/pod/Time::Tiny#The-Tiny-Mandate"
        rel="nofollow">metacpan.org/pod/Time::Tiny#The-Tiny-...</a>

    *   Acme::CPANRatings

        After the last template change of the website which is one year ago,
        &quot;Was this review helpful&quot; links no longer works. <a
        href="https://github.com/perlorg/perlweb/issues/232"
        rel="nofollow">github.com/perlorg/perlweb/issues/232</a> <br>

        Rating: 2/10

    *   Finance::Currency::Convert::WebserviceX

        No longer works. Sigh, looks like there is currently NO working
        generic currency converter module on CPAN anymore. Every converter
        module is either: 1) dead; 2) specific for some currencies only.
        <br>

        Rating: 2/10

    *   Finance::Currency::Convert

        Uses hard-coded rates in the source code. Does not seem to work
        anymore: convert() returns zero even after updateRates().

        Rating: 2/10

    *   Finance::Currency::Convert::XE

        Of limited use because of the site's restrictive license. UPDATE:
        And it no longer works.

        Rating: 2/10

    *   Finance::Currency::Convert::Yahoo

        No longer works (not a surprise since this module has not been
        updated since almost 13 years ago).

        Rating: 2/10

    *   App::used

        Uses simple regex instead of properly parses Perl source code (PPI,
        Compiler::Lexer) so potentially lots of false positives. Better use
        existing solutions like Perl::PrereqScanner or
        Perl::PrereqScanner::Lite, which already come with their own CLI's.

    *   Net::FTPServer

        Currently the only &quot;real&quot; module to create FTP servers in
        Perl. My suggestion would be to separate the Perl API documentation
        vs using the ftpd*.pl script, as the Net::FTPServer documentation
        currently mixes the two.

    *   Games::Sudoku::CLI

        Early release, so not polished yet, but... cool! Thanks, Gabor. We
        need more CLI games! <br>

    *   PPR

        The coolest thing since PPI. Now every time someone still says that
        one can't parse HTML or balanced parentheses using regex, you can
        just point him to this module to shut him up (although, if he had
        said that one *shouldn't*...). <br><br>Also now you can say that
        Perl is a simple language that is easy to learn. Why? Well, it's so
        simple you can parse the whole syntax with a single regex. <br><br>

    *   DBIx::Compare

        Use MySQL-specific SQL dialect &quot;SHOW TABLES&quot; so comparing
        e.g. two SQLite database is an instant fail, even though there is
        DBIx::Compare::SQLite. Instead of the common convention like
        DBIx::Compare-&gt;new(...), uses db_comparison-&gt;new(...),
        sqlite_comparison-&gt;new(...), etc.

        Rating: 4/10

    *   Perl::Critic

        Hey, Perl::Critic has not been reviewed for quite a while...
        <br><br>Finally take the plunge (again) to include Perl::Critic in
        my development work, this time adding critic test in the Dist::Zilla
        release process. Already caught a couple of stupid bugs otherwise
        uncaught by perl's -w. Aside from that, will help you become more
        consistent and a better (Perl) programmer. Invaluable!

    *   Config::Perl

        Rating Data::Undump::PPI, which currently lives inside Config-Perl:
        <br><br>Of course this is a nice proof of concept, but for
        &quot;real world&quot; usage, look at Data::Undump which is about
        2000x faster :)

    *   Array::Contains

        Requires perl 5.20 for no particular reason. Claims to be
        replacement of smart match but only covers string comparison. Just
        use List::Util's first() which is more flexible and part of the core
        Perl distribution, or match::smart which covers more cases.

        Rating: 2/10

    *   Array::Unique

        Mostly unnecessary because this is just a glorified form of a widely
        known Perl idiom. Requires perl 5.20 for no particular reason.
        Re-sorts the list which is 99% not what user wants. Just use
        List::Util's uniq() which is faster and part of core distribution.

        Rating: 2/10

    *   Dist::Zilla::Plugin::ReadmeFromPod

        Has some problems, e.g. it uses InstallTool phase so it conflicts
        with DZP:StaticInstall when wanting to produce a static install
        distro. Use alternatives like the simpler DZP:Pod2Readme or the more
        complex DZP:ReadmeAnyFromPod. <br>

        Rating: 2/10

    *   Dist::Zilla::Plugin::Hook

        Great for debugging. Just whip up some code in dist.ini to e.g. dump
        &amp; print some stuffs, etc.

    *   File::Tail::Dir

        Interesting features, but mooseware.

        Rating: 6/10

    *   Algorithm::Dependency

        Happily returns result when graph is cyclic (and thus proper
        topological sorting cannot be done). See also Data::Graph::Util for
        a simpler alternative. <br>

        Rating: 6/10

    *   Data::Match

        (Reviewing Sort::Topological, which is included in Data-Match
        distribution at the time of this review). <br><br>Hangs when given a
        dependency like: a =&gt; [&quot;a&quot;]. Happily returns result
        when graph is cyclic (and thus proper topological sorting cannot be
        done). See also Data::Graph::Util for alternative. <br>

        Rating: 4/10

    *   File::Find::Wanted

        File::Find lacks the &quot;making easy things easy&quot; part, so
        modules like this are great. A further step would be an option to
        omit $wanted for even simpler cases, but that would probably break
        the interface. Another alternative is File::Finder, but it forces OO
        style. <br>

        Rating: 8/10

    *   Hash::MD5

        Since this is essentially md5(dump($data)), why restrict yourself to
        hash? This works also for any kind of Perl data structure.

    *   DateTime::Format::Docker

        Isn't this basically ISO8601 (see DateTime::Format::ISO8601)?

    *   WWW::CPANRatings

        To get the ratings for a single distribution, this client library
        needs to download /csv/all_ratings.csv (~80KB at the time of this
        writing) first. This is not the fault of the client because the
        website indeed does not provide the necessary ratings data on the
        /dist/:DISTNAME page. The client library should perhaps cache the
        CSV response though. The implementation could also be simplified by
        using slimmer libraries for this simple scraping task. But other
        than that, does what it says on the tin.

        Rating: 8/10

    *   Parse::CPAN::Ratings

        Not as useful as the name implies. It requires you to download the
        CSV of all ratings first, which BTW does not seem to be advertised
        on the CPAN Ratings website. The CSV file only contains numeric
        ratings and does not include any reviews. So basically what this
        module does is just filter the CSV rows for a distribution's rating.
        <br><br>One might want to look at WWW::CPANRatings instead.

        Rating: 6/10

    *   Acme::Curse

        This pure-perl module creates a shallow copy of the object instead
        of directly removing blessing from the same object (which requires
        XS). Acme::Damn is the more direct counterpart of bless(). <br>

    *   Digest::SHA1

        Use Digest::SHA instead. In general, there is no reason in using
        Digest::SHA1 over Digest::SHA. The latter is a core Perl module,
        more updated, and implements the other algorithms while the former
        only implements SHA-1 which is now deprecated. <br><br>

    *   File::Checksum

        The &quot;checksum&quot; (basically just adding 16-bit words) is too
        simplistic to be a real checksum or to be practically useful. Even
        MD5 or CRC32 is infinitely better. <br>

    *   WordPress::XMLRPC

        Still works, partially, but in general out of date. For example, to
        get post the deprecated metaWeblog.getPost API method is still used
        instead of the newer wp.getPost call (which understandably is only
        introduced in WordPress 3.4, while this module is last updated with
        WordPress 2.8.4). And apparently wordpress.com doesn't return
        post_content anymore when you use metaWeblog.getPost.
        <br><br>Luckily, performing XMLRPC request directly is easy enough.
        Just use XMLRPC::Lite and peruse the Wordpress documentation here:
        <a href="https://codex.wordpress.org/XML-RPC_WordPress_API"
        rel="nofollow">codex.wordpress.org/XML-RPC_WordPress...</a>

    *   Text::Levenshtein::Flexible

        My new favorite Levenshtein distance module. It's as fast (if not
        faster) than Text::Levenshtein::XS and can provide a speed boost if
        you don't care about distances above a certain limit. Which I think
        in many cases is true.

    *   CPAN::Changes

        Great and all, but one drawback is that it currently destroys
        original file's formatting in serialize().

    *   Module::Changes::ADAMK

        Any module from ADAMK should be interesting, including this one. But
        please take a look at CPAN::Changes for the de facto standard
        nowadays.

    *   Module::Metadata::Changes

        Like Module::Changes, this module also tries to use a more defined
        format for Changes. Sadly, it has not caught on. Please also take a
        look at CPAN::Changes which seems to be the de facto standard
        nowadays.

    *   Module::Changes

        In general I'm not opposed to the idea of this module. The included
        'changes' script is also pretty cool (which I'm trying to recreate,
        for CPAN::Changes). <br><br>Just pointing out that I believe this
        module has not really &quot;caught on&quot; among the CPAN
        community. What has, is, CPAN::Changes which is followed by many
        authors and even employed on MetaCPAN. <br>

    *   Archive::Tar::Wrapper

        Sadly there is not a single perfect Archive::Tar::* module out
        there. Either a module offers incomplete API, (was) buggy, or it is
        crippled/limited in some way. Plus, the modules are mostly
        incompatible with one another. And that's why TIMTOWTDI. <br><br>For
        the task of just listing files in an archive, for example, it seems
        only Archive::Tar and Archive::Tar::Wrapper are usable.
        Archive::Tar::Wrapper is fast (because it utilizes external C-based
        tar utility) and does not load all contents of an archive into
        memory, but requires writing to temporary files and of course
        requires a tar utility so portability to non-Unix systems might be
        an issue.

    *   Archive::Tar

        Sadly there is not a single perfect Archive::Tar::* module out
        there. Either a module offers incomplete API, (was) buggy, or it is
        crippled/limited in some way. Plus, the modules are mostly
        incompatible with one another. And that's why TIMTOWTDI. <br><br>For
        the task of just listing files in an archive, for example, it seems
        only Archive::Tar and Archive::Tar::Wrapper are usable. Archive::Tar
        is a core module, but relatively slow, and extracts all contents of
        an archive in memory so it's not workable for huge archives. <br>

    *   Hash::Util::Pick

        One can easily use this idiom instead: <br><br>$picked = { map
        {(exists $hash{$*} ? ($*=&gt;$hash{$*}):())} @keys }; <br><br>or:
        <br><br>$picked = { map {$*=&gt;$hash{$*}} grep {exists $hash{$*}}
        @keys }; <br><br>or (if you want non-existing picked keys to be
        created instead): <br><br>$picked = { map {$_ =&gt; $hash{$_}} @keys
        }; <br><br>but Hash::Util::Pick is implemented in XS and can be a
        few times faster than the above when the number of keys has reached
        thousands. So I guess this module has its uses.

    *   NetObj::IPv4Address

        Cons: more heavyweight (requires Moo), limited operations/methods,
        can only handle IPv4 and not IPv6. Pros: some operations are faster
        than competing modules, e.g. validation. See also: NetAddr::IP,
        Net::CIDR. <br>

    *   NetObj::MacAddress

        Aside from being Moo-based (which, makes it a bit more heavyweight
        and with more dependencies), doesn't yet offer anything extra or
        more methods compared to previously existing modules like
        NetAddr::MAC.

        Rating: 4/10

    *   Acme::AsciiArtinator

        Cool. Now you can create your own Camel Code with ease!

    *   Object::Simple

        I'd say in terms of footprint and runtime performance, this module
        is average (it's not the most lightweight nor the fastest pure-perl
        object system, not to mention against XS ones). See my
        Bencher::Scenarios::Accessors for a comparison, e.g. <a
        href="https://metacpan.org/pod/Bencher::Scenario::Accessors::Get"
        rel="nofollow">metacpan.org/pod/Bencher::Scenario::A...</a> and <a
        href="https://metacpan.org/pod/Bencher::Scenario::Accessors::Set"
        rel="nofollow">metacpan.org/pod/Bencher::Scenario::A...</a> .
        <br><br>One drawback of using Mojo::Base and Object::Simple is its
        similar but slightly different and incompatible syntax with the Moo*
        family, so your code is not &quot;upgradable&quot; to Moo or Moose
        once you need more features. And often you'll end up wanting them,
        e.g. one day you'll probably read about the wonders of method
        modifiers (before, after, around), or roles, or wanting to have a
        lazy constructor, or triggers, and so on. <br><br>I'd recommend
        instead Mo. It's more lightweight than Object::Simple and you can do
        default value, builder, ro/rw, required, even coercion. But the
        features are modular and you only pay for what you use. And once you
        need more features later, you normally should be able to just
        replace 'use Mo' in your code with 'use Moo' or 'use Moose'.
        <br><br>Of course, this point is moot if you don't care about
        compatibility/upgradability to Moo*.

        Rating: 6/10

    *   Test::Needs

        Nice. API is more convenient to use than Test::Requires, especially
        if you use subtests. <br>

    *   HTTP::Command::Wrapper

        There are a few use-cases where this would be useful (mostly, to
        access https websites in the absence of required perl library like
        LWP::Protocol::https), but it would be more useful to provide an API
        that is already familiar to Perl programmers. That's why MIYAGAWA
        created HTTP::Tinyish.

    *   File::Util

        Point for documentation (lots of examples and cookbook). But the
        recipes in the cookbook currently don't really entice me to use the
        module. Let's see: <br><br>1) batch file rename: it's much simpler
        to use 'rename' or 'perlmv' utility. Or, it's much shorter to just
        use plain perl like 'for (grep {-f} &lt;*&gt;) { rename $*,
        s/.log$/.txt/r }'. <br><br>2) recursively remove a directory tree:
        it's much shorter to just use 'File::Path::remove*tree()'.
        <br><br>3) increment a counter file: no locking (it's classic 1990's
        counter.cgi race condition all over again). Take a look at, for
        example, The Perl Cookbook chapter 7.11. Or I think one of Randal
        Schwartz's articles. <br><br>As an alternative, one can also take a
        look at Path::Tiny.

    *   Common::Routine

        A couple of comments: <br><br>* Some functions like min(), max(),
        etc need not be reinvented because they are already in core module
        List::Util. But I guess the author wants to be able to say
        min([1,2,3]) in addition to min(1,2,3). <br><br>* round() uses
        Number::Format, note that rounding number using this module is
        hundreds of times slower than using sprintf(). <br><br>

    *   Submodules

        A couple of prior arts: <br><br>* all, <a
        href="https://metacpan.org/pod/all"
        rel="nofollow">metacpan.org/pod/all</a> (since 2003), nicer
        interface and offers &quot;use&quot;/compile-time interface, so it's
        more equivalent to the statements it wants to replace. The
        Submodules equivalent would be: BEGIN { for my $i
        (Submodules-&gt;find(&quot;Blah&quot;)) { $i-&gt;require } }.
        <br><br>* Module::Require, <a
        href="https://metacpan.org/pod/Module::Require"
        rel="nofollow">metacpan.org/pod/Module::Require</a> (since 2001),
        also nicer interface, more flexible, and more lightweight
        implementation. <br><br>I don't like Submodules' interface, it's too
        verbose and clunky. IMO, the interface should be a one-liner and
        without manual looping.

    *   Regexp::Assemble

        I guess it depends on your data, but for random shortish strings
        (hundreds to thousands of them), I find that using raw joining is
        much faster to assemble the regex. And the resulting regex is also
        (much) faster to match. Please see Bencher::Scenario::RegexpAssemble
        if you're interested in the benchmark script.

    *   Tie::Scalar::Callback

        There is a prior art Tie::Simple (created in 2004) which works for
        scalar as well as the other types of ties that perl supports (array,
        hash, handle). <br>

    *   JSON::Create

        Review for 0.02: Performance-wise, still has some catching up to do
        against JSON::XS &amp; Cpanel::JSON::XS with regards to encoding
        arrays &amp; hashes. <br><br>UPDATE review for 0.19: Giving it 4
        stars now. Speed has been improving and on-par/slightly better than
        the other JSON XS modules in some areas, while a bit worse in some
        other areas. Faster modules are always welcome.

        Rating: 8/10

    *   Set::Scalar

        Confirming previous reviewer, the module is a lot slower (~ 20-40x)
        than other alternatives like Array::Utils or List::MoreUtils when
        you want to perform basic set operations like
        union/intersect/diff/symmetric diff.

    *   Exporter::Easy

        I can see the value of Exporter::Easy (although these days the
        saving in typing is not as big, with plain Exporter one can just
        say: use Exporter 'import'; our @EXPORT = qw(a b c)).
        <br><br>However I fail to see the value of Exporter::Easiest. I'd
        rather use plain Perl than some DDL which cannot be checked
        statically or cannot be syntax-highlighted, just to save some []'s
        and ()'s (which I can get my editor to help me type them).
        <br><br>In short, I'd rather use plain Exporter than save a few
        keystrokes but add a non-core dependency.

        Rating: 6/10

    *   App::cpm

        Due to parallel processes and defaulting on no_test, can be several
        times faster than cpanminus (tried installing a module on a vanilla
        perlbrew instance with local CPAN mirror, which pulled +- 200
        distributions, &quot;cpanm -n&quot; took 2m9s, while cpm took 38s.)
        I hope this gets developed further. Great job. <br>

    *   Zodiac::Chinese

        From the doc: &quot;This module generates one's Chinese zodiac.
        However, for those born in late January to early February, it may be
        wrong.&quot; Well, a module that might return wrong results is not
        very useful. <br>

        Rating: 2/10

    *   JSON::MultiValueOrdered

        I guess if you want to switch JSON implementation more easily with
        JSON, JSON::PP, and JSON::XS, it's better to use
        JSON::Tiny::Subclassable instead of JSON::Tiny, because the
        interface is more similar to JSON{::XS,::PP}, although it's not
        exactly the same. JT:Subclassable also supports pretty() which is
        often used when debugging. In short, I found
        JSON::Tiny::Subclassable is a better &quot;Tiny JSON&quot; module
        than JSON::Tiny.

    *   JSON::Tiny

        Ah, the many JSON implementation modules out there... <br><br>I
        guess if you want to switch JSON implementation more easily with
        JSON, JSON::PP, and JSON::XS, it's better to use
        JSON::Tiny::Subclassable instead of JSON::Tiny, because the
        interface is more similar to JSON{::XS,::PP}, although it's not
        exactly the same. <br><br>

    *   Devel::Confess

        Provides some more features compared to Carp::Always, like producing
        stack trace even when exception is ref/object, color &amp; dump
        function arguments (so you don't need a separate Carp::Always::Dump
        and Carp::Always::Color). Recommended. <br>

    *   Carp::Always

        This module works well for string exceptions (e.g. die &quot;some
        message&quot;), but for ref/object exceptions (e.g. die
        [404,&quot;Not found&quot;] or die $some_object) it will simply
        print/return the ref/object and thus no stack trace information is
        produced. <br><br>See also Devel::Confess, which can handle
        ref/object. <br><br>References: <br> <a
        href="http://blogs.perl.org/users/graham_knop/2013/09/carp-always-ev
        enobjects.html"
        rel="nofollow">blogs.perl.org/users/graham_knop/2013...</a>

    *   experimental

        Our prayer has been answered. experimental was added to perl core in
        5.19.11

    *   Exporter::Lite

        Mostly unnecessary. The main premise of this module is that you
        don't need to inherit to use it. But you also can use Exporter (a
        core module, BTW) without inherinting it: <br><br>use Exporter
        qw(import); <br>

    *   Date::Holidays

        The idea is good, but a couple of things prevents me from using this
        interface. <br><br>First, the use of TryCatch (which brings the
        Moose ecosystem) makes the startup overhead too high for my taste
        (about 0.5s on my PC). Which is rather unfortunate because
        Date::Holidays itself does not use Moose. <br><br>Second, the
        interface assumes that a country has a single set of holidays, which
        is too restrictive in some cases. A more flexible/general interface
        would allow adding more calendars based not only on country but also
        religion, special community, organization, etc. And allow adding
        custom calendars. <br>

    *   Furl

        @Kira S (I wish cpanratings adds a feature to comment on a review):
        <br><br>Comparing WWW::Mechanize with Furl is not really
        apples-to-apples, since Furl does not support parsing/following
        links or form processing. As the Furl POD itself suggests, Furl is
        positioned as a faster alternative to LWP, not WWW::Mechanize.

    *   Lingua::EN::Inflect

        Just add this review to link to Ben Bullock's
        Lingua::EN::PluralToSingular if you need to go the other way
        (converting English noun from plural to singular). <br><br>BTW, I
        don't like the interface either, and wonder why the Env module needs
        to be involved. <br>

    *   Lingua::EN::PluralToSingular

        Not perfect or exhaustive, but good enough and lightweight. With a
        dead-simple interface. Just the sort of libraries that are reusable
        almost everywhere. Thanks for this. <br><br>Also, this might not be
        immediately obvious since there's no mention on the See Also
        section: to go the other way (converting English noun from singular
        to plural) you can use Lingua::EN::Inflect.

    *   Log::Declare

        I haven't used or evaluated this module in detail, but if there is
        one advantage to using procedural/command syntax: <br><br>info blah;
        <br><br>as opposed to object syntax: <br><br>$log-&gt;info(blah);
        <br><br>then this module clearly demonstrates it. Using
        Devel::Declare (or the Perl 5.14+ keyword API), the former can be
        easily rewritten as something like: <br><br>info &amp;&amp; blah;
        <br><br>or: <br><br>if (CONST_LOG_INFO) { info blah } <br><br>and
        during compilation, Perl can optimize the line away and we get zero
        run-time penalty when logging (level) is disabled.
        <br><br>(Actually, it's also possible for the object syntax to get
        rewritten, e.g. using source filter, but it's more cumbersome).

    *   Benchmark::Timer

        Nice alternative module for benchmarking with a different interface
        than Benchmark (marking portion of code to be benchmarked with start
        and stop). <br><br>For most Perl programmers familiar to the core
        module Benchmark, I recommend looking at Benchmark::Dumb first
        though. It has an interface like Benchmark (cmpthese() et all) but
        with some statistical confidence.

    *   Getargs::Long

        Nice idea, but some performance concerns. If you want to use
        cgetargs (the compiled, faster version), you are restricted to the
        getargs() interface, which only features checking for required
        arguments and supplying default value. In which case you might as
        well use Params::Validate directly as it's several times (e.g. 3-4x)
        faster. <br><br>If you want to use the more featured xgetargs, there
        is currently no compiled version. <br><br>All in all, I think users
        should take a look at Params::Validate first.

    *   Debug::Easy

        Not as easy as the name might claim. First of all, why do users need
        to pass LINE explicitly for every call??? Other logging modules will
        get this information automatically via caller(). <br><br>Levels are
        a bit confusing: why is debug split to 2 (or 3)? <br><br>Not as
        flexible as it should be because the design conflates some things
        together. For example, most levels output to STDERR but some level
        (VERBOSE) outputs to STDOUT instead. The output concern and levels
        should've been separated. Another example would be the DEBUGWAIT
        level, where level is DEBUG *and* execution is halted (wait on a
        keypress) on log. What if users want a lower level setting *but*
        want execution to be halted on log? The halt/keypress setting
        should've been separated from the level.

        Rating: 4/10

    *   File::Slurper

        Who'da thought that something as seemingly simple as &quot;slurping
        a file into a string&quot; would need several modules and false
        starts? Well, if you add encodings, Perl I/O layers, scalar/list
        context, DWIM-ness, ... it can get complex and buggy. I'm glad there
        are people taking care of this and making sure that a simple task
        stays simple and correct.

    *   File::Slurp

        Use the newer File::Slurper instead, which has a clearer API (e.g.
        text vs binary, array/lines vs string) and encoding default. It's
        arguably &quot;saner&quot; than File::Slurp and File::Slurp::Tiny.
        <br>

    *   File::Slurp::Tiny

        Use the newer File::Slurper instead, which has a clearer API (e.g.
        text vs binary, array/lines vs string) and encoding default. It's
        arguably &quot;saner&quot; than File::Slurp and File::Slurp::Tiny.
        <br>

    *   Perl::PrereqScanner::Lite

        A significantly faster alternative to Perl::PrereqScanner. It's
        *almost* a drop-in replacement, there might still be some bugs in
        missing detecting some modules, and you still have to do several
        add_extra_scanner() calls like
        $scanner-&gt;add_extra_scanner('Moose') to match the behavior of
        Perl::PrereqScanner. <br><br>

    *   Logfile::Rotate

        First file rotating module I found and tried. Works, but needs to be
        modernized a bit. Indirect object notation in doc should be
        replaced. Bool option takes &quot;yes&quot; or &quot;no&quot;,
        should perhaps be 1 or 0. Capitalization adjustment, perhaps.
        <br><br>

        Rating: 6/10

    *   File::ReadBackwards

        At the time of this review, I find two modules for reading a file
        backwards: File::Bidirectional (FBidi) and File::ReadBackwards
        (FRB). <br><br>Both modules have roughly the same footprint and
        minimal dependencies. Both provide OO as well as tie interface. Both
        respect the $/ setting. <br><br>FRB pro's: <br> - FRB is 15-20%
        faster than FBidi when reading backwards; <br><br>FRB con's: <br> -
        does not offer the feature of reading forward as well, but of course
        this is not the goal of the module. <br><br>FBidi's POD contains
        information on benchmarks (it's roughly an order of magnitude slower
        than raw Perl's open+read/diamond operator, still the case in 2014).
        While FRB's POD contains information on how the thing works behind
        the scenes. <br><br>In summary, both modules are roughly the same.
        I'd prefer FRB unless in the rarer cases where I need bidirectional
        reading. <br>

        Rating: 8/10

    *   File::Bidirectional

        At the time of this review, I find two modules for reading a file
        backwards: File::Bidirectional (FBidi) and File::ReadBackwards
        (FRB). <br><br>Both modules have roughly the same footprint and
        minimal dependencies. Both provide OO as well as tie interface. Both
        respect the $/ setting. <br><br>FBidi pro's: <br> - has the unique
        feature of reading backward/forward and switch direction in the
        middle; <br><br>FBidi con's: <br> - FBidi is 15-20% slower than
        FBidi when reading backwards; <br> - reading forward is just as slow
        as backward, so if you only need to read forward, obviously there's
        no need to use this module; <br><br>FBidi's POD contains information
        on benchmarks (it's roughly an order of magnitude slower than raw
        Perl's open+read/diamond operator, still the case in 2014). While
        FRB's POD contains information on how the thing works behind the
        scenes. <br><br>In summary, both modules are roughly the same. I'd
        prefer FRB unless in the rarer cases where I need bidirectional
        reading. <br>

        Rating: 8/10

    *   Signal::StackTrace::CarpLike

        Nice, but Signal::StackTrace should've output something carp-like in
        the first place.

    *   Devel::Messenger

        I think this is basically logging under a fancy name and with a more
        cumbersome interface. Look at Log::Any instead.

    *   Term::Twiddle

        Cute! I didn't know SIGALRM still works even though you're doing
        blocking I/O or calling other programs. But unfortunately it doesn't
        work if you sleep(), making this approach not as attractive. <br>

    *   CHI

        The move to Moo is very welcome, but I wish there were an
        alternative of CHI which is even more lightweight (starts in under
        0.01s). CHI::Tiny, anyone?

    *   App::YTDL

        Bit of a shame that we currently don't have a working YouTube
        download script/module (WWW::YouTube::Download is last updated 2013
        and has been broken for a long while). This module actually requires
        another *Python* script to do its job. I might as well skip this and
        go straight to the Python script. <br><br>UPDATE 2016-03-04: I guess
        it's been so for a few years, but this still needs to be said: For
        downloading YouTube videos, use youtube-dl (a far more popular
        Python project) and just forget the rest. Keeping up with YouTube
        changes is many times a full time job. Nothing else comes remotely
        close.

    *   XXX

        The part that makes this module convenient is that the functions
        return their original arguments. So when debugging (peppering dump
        statements), you don't have to change this: <br><br>return
        [&quot;some&quot;, $expr]; <br><br>to this (taking an example from
        another dumping module, Data::Dump): <br><br>my $tmp =
        [&quot;some&quot;, $expr]; dd $tmp; return $tmp; <br><br>but just
        this: <br><br>return YYY [&quot;some&quot;, $expr]; <br><br>This
        should be imitated by the other dumper functions.

HOMEPAGE
    Please visit the project's homepage at
    <https://metacpan.org/release/Acme-CPANModules-Import-CPANRatings-User-p
    erlancar>.

SOURCE
    Source repository is at
    <https://github.com/perlancar/perl-Acme-CPANModules-Import-CPANRatings-U
    ser-perlancar>.

BUGS
    Please report any bugs or feature requests on the bugtracker website
    <https://rt.cpan.org/Public/Dist/Display.html?Name=Acme-CPANModules-Impo
    rt-CPANRatings-User-perlancar>

    When submitting a bug or request, please include a test-file or a patch
    to an existing test-file that illustrates the bug or desired feature.

SEE ALSO
    Acme::CPANModules - about the Acme::CPANModules namespace

    cpanmodules - CLI tool to let you browse/view the lists

AUTHOR
    perlancar <perlancar@cpan.org>

COPYRIGHT AND LICENSE
    This software is copyright (c) 2018 by perlancar@cpan.org.

    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.

