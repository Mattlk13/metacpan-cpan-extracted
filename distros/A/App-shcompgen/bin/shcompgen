#!perl

our $DATE = '2016-12-03'; # DATE
our $VERSION = '0.30'; # VERSION
# FRAGMENT id=shcompgen-nohint

use 5.010;
use strict;
use warnings;
use experimental 'smartmatch';

use App::shcompgen;
use Perinci::CmdLine::Any;

my $urlprefix = '/App/shcompgen/';
Perinci::CmdLine::Any->new(
    url => $urlprefix,
    log => $ENV{LOG} // 1,
    subcommands => {
        init     => {url=>"${urlprefix}init"},
        generate => {url=>"${urlprefix}generate"},
        list     => {url=>"${urlprefix}list"},
        remove   => {url=>"${urlprefix}remove"},

        'guess-shell' => {url=>"${urlprefix}guess_shell", summary => "(Utility) detect a program", tags=>["category:utility"]},
        'detect-prog' => {url=>"${urlprefix}detect_prog", summary => "(Utility) Guess running shell", tags=>["category:utility"]},
    },
)->run;

# ABSTRACT: Generate shell completion scripts
# PODNAME: shcompgen

__END__

=pod

=encoding UTF-8

=head1 NAME

shcompgen - Generate shell completion scripts

=head1 VERSION

This document describes version 0.30 of shcompgen (from Perl distribution App-shcompgen), released on 2016-12-03.

=head1 SYNOPSIS

Initialize (this will create completion scripts directory, create shell script
to initialize completion system):

 % shcompgen init

Generate shell completion scripts for all detectable programs in PATH:

 % shcompgen generate

Note that this distribution automatically runs 'init' and 'generate' the first
time it is installed, or when you upgrade from an older version. So normally you
don't have to do this manually.

Generate some programs only, replace if previously already exists, be verbose:

 % shcompgen generate --verbose --replace prog1 prog2 ./bin/prog3

List all shell completion scripts generated by us:

 % shcompgen list
 % shcompgen list --detail

Remove some shell completion scripts:

 % shcompgen remove prog1 prog2

Remove all generated shell completion scripts:

 % shcompgen remove

=head1 DESCRIPTION

Some shells, like bash/fish/zsh/tcsh, supports tab completion for programs. They
are usually activated by issuing one or more C<complete> (zsh uses C<compctl>)
internal shell commands. The completion scripts which contain these commands are
usually put in (e.g., for fish) C</etc/fish/completion/PROGNAME.fish> (if one
wants to install globally) or C<~/.config/fish/completions/PROGNAME.fish> (if
one wants to install per-user).

This utility, B<shcompgen>, can detect how to generate shell completion scripts
for some programs and then install the completion scripts into the
abovementioned location (the default is to per-user directory, but if running as
root or with C<--global> switch will install to the global directory).

It can also list all completion scripts generated by it, and be instructed to
uninstall them again.

It supports several shells, currently: bash, fish, zsh, and tcsh. Shell-specific
information can be found below.

=head2 Shell-specific information

=head3 bash

This script can work with the C<bash-completion> package (and uses the same
global completion directory: C</etc/bash_completion.d>). At the time of this
writing, bash-completion (at version 2.1) does not yet look at per-user
completion scripts directory. This script picks
C<~/.config/bash/completions/PROGNAME> as location for per-user completion
scripts. If later on C<bash-completion> package decides on a different per-user
location, this script will probably be adjusted too.

=head3 fish

Known issues include proper escaping of completion answer (e.g. when an answer
contains a whitespace). To demonstrate this problem, try
L<peri-eg-complete-fruits-any> and type:

 % peri-eg-complete-fruits-any --fruit <tab>

The answer C<butternut squash> is returned as C<butternut\\\ squash>.

=head3 tcsh

So far I couldn't get fallback (a.k.a catch-all) completion mechanism to work in
tcsh. For example if I do:

 complete '*' 'p/*/`helper`/'

then it will eclipse the other existing completion definitions.

So in tcsh, activating (or deactivating) completion is currently less convenient
compared to the other shells. Instead of the C<complete> definitions being put
on a per-command basis in C<~/.config/tcsh/completions/> directory, the init
script C<~/.config/shcompgen.tcsh> will directly contain all the C<complete>
definitions. This script must be sourced to update the definitions. So after you

 % shcompgen generate foo

you will need to re-source the init script (or logout from + login back to the
shell). And after you remove a completion script, you will need to C<uncomplete>
+ re-source the init script (or logout from + login back to the shell).

Known issues include proper escaping of completion answer (e.g. when an answer
contains a whitespace). To demonstrate this problem, try
L<peri-eg-complete-fruits-any> and type:

 % peri-eg-complete-fruits-any --fruit <tab>

The answer C<butternut squash> is only returned as C<butternut\\ >.

=head3 zsh

Known issues include proper escaping of completion answer (e.g. when an answer
contains a whitespace). To demonstrate this problem, try
L<peri-eg-complete-fruits-any> and type:

 % peri-eg-complete-fruits-any --fruit <tab>

The answer C<butternut squash> is only returned as C<butternut\\ >.

Another known issue is still having to C<compinit> after C<shcompgen generate>
or C<shcompgen remove>.

And yet another known issue is having to C<compinit> in the init script
(C<~/.config/shcompgen.zsh>) which is slowing down the shell startup.

=head2 Program detection

Below are the types/kinds of programs that can be detected. Expect the list to
expand as more methods are added.

=over

=item * Scripts which are tagged with hints of what completion program to use

You can put this line in a script, e.g. in a script called C<foo>:

 # FRAGMENT id=shcompgen-hint command=bar

The above line tells C<shcompgen> that the script should be completed using an
external program called C<bar>. This will construct this completion script, e.g.
for bash:

 complete -C bar foo

=item * Completion programs which are tagged with hints of what programs they complete

You can create a completion script in Perl (or other language, actually), e.g.
C<_foo> and tag it with hints of what programs they complete, e.g.

 # FRAGMENT id=shcompgen-hint completer=1 for=foo,foo-this-host

This will add completion script for C<foo>:

 complete -C _foo foo

as well as for C<foo-this-host>:

 complete -C _foo foo-this-host

=item * Getopt::Long::Complete-based CLI scripts

If a script C<foo> is detected as a Perl script using L<Getopt::Long::Complete>,
we know that it can complete itself. Thus, C<shcompgen> will generate this
completion script (e.g. for bash):

 complete -C foo foo

=item * Getopt::Long::Subcommand-based CLI scripts

If a script C<foo> is detected as a Perl script using
L<Getopt::Long::Subcommand>, we know that it can complete itself. Thus,
C<shcompgen> will generate this completion script (e.g. for bash):

 complete -C foo foo

=item * Perinci::CmdLine-based CLI scripts

If a script like C<foo> is detected as a Perl script using L<Perinci::CmdLine>
(or its variant like L<Perinci::CmdLine::Lite> or L<Perinci::CmdLine::Any>) we
know that it can complete itself. Thus, C<shcompgen> will add this completion
script e.g. for bash:

 complete -C foo foo

=item * Other methods

Other methods will be added in the future, e.g. by parsing manpage or POD, and
so on.

=back

=head1 SUBCOMMANDS

=head2 B<detect-prog>

(Utility) Guess running shell.

=head2 B<generate>

Generate shell completion scripts for detectable programs.

=head2 B<guess-shell>

(Utility) detect a program.

=head2 B<init>

Initialize shcompgen.

This subcommand creates the completion directories and initialization shell
script, as well as run C<generate>.


=head2 B<list>

List all shell completion scripts generated by this script.

=head2 B<remove>

Remove shell completion scripts generated by this script.

=head1 OPTIONS

C<*> marks required options.

=head2 Common options

=over

=item B<--config-path>=I<filename>

Set path to configuration file.

Can be specified multiple times.

=item B<--config-profile>=I<s>

Set configuration profile to use.

=item B<--debug>

Set log level to debug (note: you also need to set LOG=1 to enable logging, or use DEBUG=1).

=item B<--fish>

Shortcut for --shell=fish.

See C<--shell>.

=item B<--format>=I<s>

Choose output format, e.g. json, text.

Default value:

 undef

=item B<--help>, B<-h>, B<-?>

Display help message and exit.

=item B<--json>

Set output format to json.

=item B<--log-level>=I<s>

Set log level (note: you also need to set LOG=1 to enable logging).

=item B<--naked-res>

When outputing as JSON, strip result envelope.

Default value:

 0

By default, when outputing as JSON, the full enveloped result is returned, e.g.:

    [200,"OK",[1,2,3],{"func.extra"=>4}]

The reason is so you can get the status (1st element), status message (2nd
element) as well as result metadata/extra result (4th element) instead of just
the result (3rd element). However, sometimes you want just the result, e.g. when
you want to pipe the result for more post-processing. In this case you can use
`--naked-res` so you just get:

    [1,2,3]


=item B<--no-config>

Do not use any configuration file.

=item B<--no-env>

Do not read environment for default options.

=item B<--quiet>

Set log level to quiet (note: you also need to set LOG=1 to enable logging, or use QUIET=1).

=item B<--shell>=I<s>

Override guessing and select shell manually.

Valid values:

 ["bash","fish","zsh","tcsh"]

=item B<--subcommands>

List available subcommands.

=item B<--tcsh>

Shortcut for --shell=tcsh.

See C<--shell>.

=item B<--trace>

Set log level to trace (note: you also need to set LOG=1 to enable logging, or use TRACE=1).

=item B<--verbose>

Set log level to info (note: you also need to set LOG=1 to enable logging, or use VERBOSE=1).

=item B<--version>, B<-v>

Display program's version and exit.

=item B<--zsh>

Shortcut for --shell=zsh.

See C<--shell>.

=back

=head2 Options for subcommand detect-prog

=over

=item B<--prog>=I<s>*

=back

=head2 Options for subcommand generate

=over

=item B<--per-option>

Create per-option completion script if possible.

If set to true, then attempt to create completion script that register each
option. This creates nicer completion in some shells, e.g. fish and zsh. For
example, option description can be shown.

This is possible for only some types of scripts, e.g. <pm:Perinci::CmdLine>-
(that does not have subcommands) or <pm:Getopt::Long::Descriptive>-based ones.


=item B<--prog-json>=I<s>

Program(s) to generate completion for (JSON-encoded).

See C<--prog>.

=item B<--prog>=I<s@>

Program(s) to generate completion for.

Can contain path (e.g. `../foo`) or a plain word (`foo`) in which case will be
searched from PATH.


Can be specified multiple times.

=item B<--remove>

Remove completion for script that (now) is not detected to have completion.

The default behavior is to simply ignore existing completion script if the
program is not detected to have completion. When the `remove` setting is
enabled, however, such existing completion script will be removed.


=item B<--replace>

Replace existing script.

The default behavior is to skip if an existing completion script exists.


=item B<--stdout>

Output completion script to STDOUT.

=back

=head2 Options for subcommand init

=over

=item B<--per-option>

Create per-option completion script if possible.

If set to true, then attempt to create completion script that register each
option. This creates nicer completion in some shells, e.g. fish and zsh. For
example, option description can be shown.

This is possible for only some types of scripts, e.g. <pm:Perinci::CmdLine>-
(that does not have subcommands) or <pm:Getopt::Long::Descriptive>-based ones.


=back

=head2 Options for subcommand list

=over

=item B<--detail>, B<-l>

=item B<--per-option>

Create per-option completion script if possible.

If set to true, then attempt to create completion script that register each
option. This creates nicer completion in some shells, e.g. fish and zsh. For
example, option description can be shown.

This is possible for only some types of scripts, e.g. <pm:Perinci::CmdLine>-
(that does not have subcommands) or <pm:Getopt::Long::Descriptive>-based ones.


=back

=head2 Options for subcommand remove

=over

=item B<--per-option>

Create per-option completion script if possible.

If set to true, then attempt to create completion script that register each
option. This creates nicer completion in some shells, e.g. fish and zsh. For
example, option description can be shown.

This is possible for only some types of scripts, e.g. <pm:Perinci::CmdLine>-
(that does not have subcommands) or <pm:Getopt::Long::Descriptive>-based ones.


=item B<--prog-json>=I<s>

Program(s) to remove completion script of (JSON-encoded).

See C<--prog>.

=item B<--prog>=I<s@>

Program(s) to remove completion script of.

Can contain path (e.g. `../foo`) or a plain word (`foo`) in which case will be
searched from PATH.


Can be specified multiple times.

=back

=head1 COMPLETION

This script has shell tab completion capability with support for several
shells.

=head2 bash

To activate bash completion for this script, put:

 complete -C shcompgen shcompgen

in your bash startup (e.g. C<~/.bashrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is recommended, however, that you install L<shcompgen> which allows you to
activate completion scripts for several kinds of scripts on multiple shells.
Some CPAN distributions (those that are built with
L<Dist::Zilla::Plugin::GenShellCompletion>) will even automatically enable shell
completion for their included scripts (using C<shcompgen>) at installation time,
so you can immadiately have tab completion.

=head2 tcsh

To activate tcsh completion for this script, put:

 complete shcompgen 'p/*/`shcompgen`/'

in your tcsh startup (e.g. C<~/.tcshrc>). Your next shell session will then
recognize tab completion for the command. Or, you can also directly execute the
line above in your shell to activate immediately.

It is also recommended to install C<shcompgen> (see above).

=head2 other shells

For fish and zsh, install C<shcompgen> as described above.

=head1 CONFIGURATION FILE

This script can read configuration files. Configuration files are in the format of L<IOD>, which is basically INI with some extra features.

By default, these names are searched for configuration filenames (can be changed using C<--config-path>): F<~/.config/shcompgen.conf>, F<~/shcompgen.conf>, or F</etc/shcompgen.conf>.

All found files will be read and merged.

To disable searching for configuration files, pass C<--no-config>.

To put configuration for a certain subcommand only, use a section name like C<[subcommand=NAME]> or C<[SOMESECTION subcommand=NAME]>.

You can put multiple profiles in a single file by using section names like C<[profile=SOMENAME]> or C<[SOMESECTION profile=SOMENAME]> or C<[subcommand=SUBCOMMAND_NAME profile=SOMENAME]> or C<[SOMESECTION subcommand=SUBCOMMAND_NAME profile=SOMENAME]>. Those sections will only be read if you specify the matching C<--config-profile SOMENAME>.

You can also put configuration for multiple programs inside a single file, and use filter C<program=NAME> in section names, e.g. C<[program=NAME ...]> or C<[SOMESECTION program=NAME]>. The section will then only be used when the reading program matches.

Finally, you can filter a section by environment variable using the filter C<env=CONDITION> in section names. For example if you only want a section to be read if a certain environment variable is true: C<[env=SOMEVAR ...]> or C<[SOMESECTION env=SOMEVAR ...]>. If you only want a section to be read when the value of an environment variable has value equals something: C<[env=HOSTNAME=blink ...]> or C<[SOMESECTION env=HOSTNAME=blink ...]>. If you only want a section to be read when the value of an environment variable does not equal something: C<[env=HOSTNAME!=blink ...]> or C<[SOMESECTION env=HOSTNAME!=blink ...]>. If you only want a section to be read when an environment variable contains something: C<[env=HOSTNAME*=server ...]> or C<[SOMESECTION env=HOSTNAME*=server ...]>. Note that currently due to simplistic parsing, there must not be any whitespace in the value being compared because it marks the beginning of a new section filter or section name.

List of available configuration parameters:

=head2 Common for all subcommands

 format (see --format)
 log_level (see --log-level)
 naked_res (see --naked-res)
 shell (see --shell)

=head2 Configuration for subcommand 'detect-prog'

 prog (see --prog)

=head2 Configuration for subcommand 'generate'

 per_option (see --per-option)
 prog (see --prog)
 remove (see --remove)
 replace (see --replace)
 stdout (see --stdout)

=head2 Configuration for subcommand 'guess-shell'


=head2 Configuration for subcommand 'init'

 per_option (see --per-option)

=head2 Configuration for subcommand 'list'

 detail (see --detail)
 per_option (see --per-option)

=head2 Configuration for subcommand 'remove'

 per_option (see --per-option)
 prog (see --prog)

=head1 ENVIRONMENT

=head2 SHCOMPGEN_OPT => str

Specify additional command-line options

=head1 FILES

~/.config/shcompgen.conf

~/shcompgen.conf

/etc/shcompgen.conf

=head1 HOMEPAGE

Please visit the project's homepage at L<https://metacpan.org/release/App-shcompgen>.

=head1 SOURCE

Source repository is at L<https://github.com/perlancar/perl-App-shcompgen>.

=head1 BUGS

Please report any bugs or feature requests on the bugtracker website L<https://rt.cpan.org/Public/Dist/Display.html?Name=App-shcompgen>

When submitting a bug or request, please include a test-file or a
patch to an existing test-file that illustrates the bug or desired
feature.

=head1 SEE ALSO

L<Dist::Zilla::Plugin::GenShellCompletion>

=head1 AUTHOR

perlancar <perlancar@cpan.org>

=head1 COPYRIGHT AND LICENSE

This software is copyright (c) 2016 by perlancar@cpan.org.

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

=cut
