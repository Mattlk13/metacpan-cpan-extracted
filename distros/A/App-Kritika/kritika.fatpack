#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"App/Kritika.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_KRITIKA';
  package App::Kritika;use strict;use warnings;our$VERSION='0.05';use JSON ();use Cwd qw(abs_path);use HTTP::Tiny;sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{base_url}=$params{base_url}|| 'https://kritika.io';$self->{token}=$params{token}or die 'token required';$self->{root}=$params{root};$self->{ua}=$params{ua}|| HTTP::Tiny->new;$self->{diff_ref}=$params{diff_ref};$self->{diff_snapshot}=$params{diff_snapshot};$self->{diff_branch}=$params{diff_branch};$self->{branch}=$params{branch}// $self->_detect_branch;$self->{revision}=$params{revision}// $self->_detect_revision;return$self}sub validate {my$self=shift;my (@paths)=@_;my$files=[];for my$path (@paths){$path=abs_path($path);my$content=do {local $/;open my$fh,'<',$path or die "Can't open file '$path': $!";<$fh>};if (my$root=$self->{root}){$root=abs_path($root);$path =~ s{^$root}{};$path =~ s{^/}{}}push @$files,{path=>$path,content=>$content }}my$ua=$self->{ua};my$response=$ua->post("$self->{base_url}/validate",{headers=>{Authorization=>'Token ' .$self->{token},Accept=>'application/json','X-Version'=>$VERSION,},content=>JSON->new->canonical(1)->encode({branch=>$self->{branch},revision=>$self->{revision},files=>$files,$self->{diff_ref}? (diff_ref=>$self->_detect_revision($self->{diff_ref})): (),$self->{diff_snapshot}? (diff_snapshot=>$self->{diff_snapshot}): (),$self->{diff_branch}? (diff_branch=>$self->{diff_branch}): (),})});if ($response->{status}eq '599'){my$content=$response->{content};$content=substr($content,0,64).'[...]' if length$content > 64;die "Internal error: $response->{status} $content"}unless ($response->{success}){my$message=eval {JSON::decode_json($response->{content})->{message}}// 'Unknown Error';die "Remote error: $response->{status} $response->{reason}: $message\n"}return JSON::decode_json($response->{content})}sub _detect_branch {my$self=shift;die "Doesn't look like a git repository\n" unless -d "$self->{root}/.git";my ($branch)=`cd $self->{root}; git branch` =~ m/^\*\s+(.*)$/m;die "Can't detect current branch\n" unless$branch;return$branch}sub _detect_revision {my$self=shift;my ($ref)=@_;$ref //= 'HEAD';die "Doesn't look like a git repository\n" unless -d "$self->{root}/.git";my ($revision)=`cd $self->{root}; git rev-parse '$ref'` =~ m/([a-f0-9]+)/i;die "Can't detect current revision\n" unless$revision;return$revision}1;
APP_KRITIKA

$fatpacked{"App/Kritika/Settings.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'APP_KRITIKA_SETTINGS';
  package App::Kritika::Settings;use strict;use warnings;use Cwd qw(getcwd);use File::Basename qw(dirname);use File::Spec;use File::HomeDir ();sub new {my$class=shift;my (%params)=@_;my$self={};bless$self,$class;$self->{file}=$params{file};return$self}sub settings {my$self=shift;my$rc_file=$self->_detect;die "Error: Can't find rc file\n" unless defined$rc_file;my$config=do {local $/;open my$fh,'<',$rc_file or die $!;<$fh>};my$settings=$self->_parse($config);if (!$settings->{root}){$settings->{root}=dirname$rc_file}return$settings}sub _detect {my$self=shift;my$dirname=dirname($self->{file});if (!File::Spec->file_name_is_absolute($dirname)){$dirname=File::Spec->catdir(getcwd(),$dirname)}my ($volume,$dirs,$file)=File::Spec->splitpath($dirname);$dirs=File::Spec->catdir($dirs,$file)if$file ne '';my@dir=File::Spec->splitdir($dirs);unshift@dir,$volume if$volume;while (@dir){for ($self->_rc_names){my$location=File::Spec->catfile(@dir,$_);return$location if -f $location}pop@dir}for ($self->_rc_names){my$location=File::Spec->catfile(File::HomeDir->my_home,$_);return$location if -f $location}return}sub _parse {my$self=shift;my ($input)=@_;my@lines=split /\r?\n/,$input;my$options={};for my$line (@lines){next if$line =~ m/^\s*#/;next if$line eq '';my ($key,$value)=split /=/,$line,2;$key =~ s{^\s+}{};$key =~ s{\s+$}{};$value =~ s{^\s+}{};$value =~ s{\s+$}{};$options->{$key}=$value}return$options}sub _rc_names {return ('.kritikarc','_kritikarc')}1;
APP_KRITIKA_SETTINGS

$fatpacked{"ExtUtils/Config.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_CONFIG';
  package ExtUtils::Config;$ExtUtils::Config::VERSION='0.05';use strict;use warnings;use Config;use Data::Dumper ();sub new {my ($pack,$args)=@_;return bless {values=>($args ? {%$args }: {}),},$pack}sub get {my ($self,$key)=@_;return exists$self->{values}{$key}? $self->{values}{$key}: $Config{$key}}sub exists {my ($self,$key)=@_;return exists$self->{values}{$key}|| exists$Config{$key}}sub values_set {my$self=shift;return {%{$self->{values}}}}sub all_config {my$self=shift;return {%Config,%{$self->{values}}}}sub serialize {my$self=shift;return$self->{serialized}||= Data::Dumper->new([$self->values_set])->Terse(1)->Sortkeys(1)->Dump}1;
EXTUTILS_CONFIG

$fatpacked{"ExtUtils/Helpers.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS';
  package ExtUtils::Helpers;$ExtUtils::Helpers::VERSION='0.05';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';use Config;use File::Basename qw/basename/;use File::Spec::Functions qw/splitpath canonpath abs2rel splitdir/;use Text::ParseWords 3.24 ();our@EXPORT_OK=qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;BEGIN {my%impl_for=(MSWin32=>'Windows',VMS=>'VMS');my$package='ExtUtils::Helpers::' .($impl_for{$^O}|| 'Unix');my$impl=$impl_for{$^O}|| 'Unix';require "ExtUtils/Helpers/$impl.pm";"ExtUtils::Helpers::$impl"->import()}sub split_like_shell {my ($string)=@_;return if not defined$string;$string =~ s/^\s+|\s+$//g;return if not length$string;return Text::ParseWords::shellwords($string)}sub man1_pagename {my$filename=shift;return basename($filename).".$Config{man1ext}"}my%separator=(MSWin32=>'.',VMS=>'__',os2=>'.',cygwin=>'.',);my$separator=$separator{$^O}|| '::';sub man3_pagename {my ($filename,$base)=@_;$base ||= 'lib';my ($vols,$dirs,$file)=splitpath(canonpath(abs2rel($filename,$base)));$file=basename($file,qw/.pm .pod/);my@dirs=grep {length}splitdir($dirs);return join$separator,@dirs,"$file.$Config{man3ext}"}1;
EXTUTILS_HELPERS

$fatpacked{"ExtUtils/Helpers/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_UNIX';
  package ExtUtils::Helpers::Unix;$ExtUtils::Helpers::Unix::VERSION='0.05';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Carp qw/croak/;use Config;my$layer=$] >= 5.008001 ? ":raw" : "";sub make_executable {my$filename=shift;my$current_mode=(stat$filename)[2]+ 0;if (-T $filename){open my$fh,"<$layer",$filename;my@lines=<$fh>;if (@lines and $lines[0]=~ s{ \A \#! \s* (?:/\S+/)? perl \b (.*) \z }{$Config{startperl}$1}xms){open my$out,">$layer","$filename.new" or croak "Couldn't open $filename.new: $!";print$out @lines;close$out;rename$filename,"$filename.bak" or croak "Couldn't rename $filename to $filename.bak";rename "$filename.new",$filename or croak "Couldn't rename $filename.new to $filename";unlink "$filename.bak"}}chmod$current_mode | oct(111),$filename;return}sub detildefy {my$value=shift;for ($value){s{ ^ ~ (?= /|$)}          [ $ENV{HOME} || (getpwuid $>)[7] ]ex or s{ ^ ~ ([^/]+) (?= /|$) } { (getpwnam $1)[7] || "~$1" }ex}return$value}1;
EXTUTILS_HELPERS_UNIX

$fatpacked{"ExtUtils/Helpers/VMS.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_VMS';
  package ExtUtils::Helpers::VMS;$ExtUtils::Helpers::VMS::VERSION='0.05';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use File::Copy qw/copy/;sub make_executable {my$filename=shift;my$batchname="$filename.com";copy($filename,$batchname);ExtUtils::Helpers::Unix::make_executable($batchname);return}sub detildefy {my$arg=shift;return$arg if ($arg =~ /^~~/);return$arg if ($arg =~ /^~ /);if ($arg =~ /^~/){my$spec=$arg;$spec =~ s/^~//;$spec =~ s#^/##;my$home=VMS::Filespec::unixify($ENV{HOME});$home .= '/' unless$home =~ m#/$#;if ($spec eq ''){$home =~ s#/$##;return$home}my ($hvol,$hdir,$hfile)=File::Spec::Unix->splitpath($home);if ($hdir eq ''){$hdir=$hfile}my ($vol,$dir,$file)=File::Spec::Unix->splitpath($spec);my@hdirs=File::Spec::Unix->splitdir($hdir);my@dirs=File::Spec::Unix->splitdir($dir);unless ($arg =~ m#^~/#){shift@dirs}my$newdirs=File::Spec::Unix->catdir(@hdirs,@dirs);$arg=File::Spec::Unix->catpath($hvol,$newdirs,$file)}return$arg}
EXTUTILS_HELPERS_VMS

$fatpacked{"ExtUtils/Helpers/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_HELPERS_WINDOWS';
  package ExtUtils::Helpers::Windows;$ExtUtils::Helpers::Windows::VERSION='0.05';use strict;use warnings FATAL=>'all';use Exporter 5.57 'import';our@EXPORT=qw/make_executable detildefy/;use Config;use Carp qw/carp croak/;use ExtUtils::PL2Bat 'pl2bat';sub make_executable {my$script=shift;if (-T $script && $script !~ / \. (?:bat|cmd) $ /x){pl2bat(in=>$script,update=>1)}return}sub detildefy {my$value=shift;$value =~ s{ ^ ~ (?= [/\\] | $ ) }[$ENV{USERPROFILE}]x if$ENV{USERPROFILE};return$value}1;
EXTUTILS_HELPERS_WINDOWS

$fatpacked{"ExtUtils/InstallPaths.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'EXTUTILS_INSTALLPATHS';
  package ExtUtils::InstallPaths;$ExtUtils::InstallPaths::VERSION='0.05';use 5.006;use strict;use warnings;use File::Spec ();use Carp ();use ExtUtils::Config 0.002;my%complex_accessors=map {$_=>1}qw/prefix_relpaths install_sets/;my%hash_accessors=map {$_=>1}qw/install_path install_base_relpaths original_prefix/;my%defaults=(installdirs=>'site',install_base=>undef,prefix=>undef,verbose=>0,blib=>'blib',create_packlist=>1,dist_name=>undef,module_name=>undef,destdir=>undef,install_path=>sub {{}},install_sets=>\&_default_install_sets,original_prefix=>\&_default_original_prefix,install_base_relpaths=>\&_default_base_relpaths,prefix_relpaths=>\&_default_prefix_relpaths,);sub _merge_shallow {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);$filter->($_)for grep$filter,values %$override;return {%$defaults,%$override }}}sub _merge_deep {my ($name,$filter)=@_;return sub {my ($override,$config)=@_;my$defaults=$defaults{$name}->($config);my$pair_for=sub {my$key=shift;my%override=%{$override->{$key}|| {}};$filter && $filter->($_)for values%override;return$key=>{%{$defaults->{$key}},%override }};return {map {$pair_for->($_)}keys %$defaults }}}my%allowed_installdir=map {$_=>1}qw/core site vendor/;my$must_be_relative=sub {Carp::croak('Value must be a relative path')if File::Spec->file_name_is_absolute($_[0])};my%deep_filter=map {$_=>$must_be_relative}qw/install_base_relpaths prefix_relpaths/;my%filter=(installdirs=>sub {my$value=shift;$value='core',Carp::carp('Perhaps you meant installdirs to be "core" rather than "perl"?')if$value eq 'perl';Carp::croak('installdirs must be one of "core", "site", or "vendor"')if not $allowed_installdir{$value};return$value},(map {$_=>_merge_shallow($_,$deep_filter{$_})}qw/original_prefix install_base_relpaths/),(map {$_=>_merge_deep($_,$deep_filter{$_})}qw/install_sets prefix_relpaths/),);sub new {my ($class,%args)=@_;my$config=$args{config}|| ExtUtils::Config->new;my%self=(config=>$config,map {$_=>exists$args{$_}? $filter{$_}? $filter{$_}->($args{$_},$config): $args{$_}: ref$defaults{$_}? $defaults{$_}->($config): $defaults{$_}}keys%defaults,);$self{module_name}||= do {my$module_name=$self{dist_name};$module_name =~ s/-/::/g;$module_name}if defined$self{dist_name};return bless \%self,$class}for my$attribute (keys%defaults){no strict qw/refs/;*{$attribute}=$hash_accessors{$attribute}? sub {my ($self,$key)=@_;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$key}}: $complex_accessors{$attribute}? sub {my ($self,$installdirs,$key)=@_;Carp::confess("$attribute needs installdir")if not defined$installdirs;Carp::confess("$attribute needs key")if not defined$key;return$self->{$attribute}{$installdirs}{$key}}: sub {my$self=shift;return$self->{$attribute}}}my$script=$] > 5.008000 ? 'script' : 'bin';my@install_sets_keys=qw/lib arch bin script bindoc libdoc binhtml libhtml/;my@install_sets_tail=('bin',$script,qw/man1dir man3dir html1dir html3dir/);my%install_sets_values=(core=>[qw/privlib archlib/,@install_sets_tail ],site=>[map {"site$_"}qw/lib arch/,@install_sets_tail ],vendor=>[map {"vendor$_"}qw/lib arch/,@install_sets_tail ],);sub _default_install_sets {my$c=shift;my%ret;for my$installdir (qw/core site vendor/){@{$ret{$installdir}}{@install_sets_keys}=map {$c->get("install$_")}@{$install_sets_values{$installdir}}}return \%ret}sub _default_base_relpaths {my$config=shift;return {lib=>['lib','perl5'],arch=>['lib','perl5',$config->get('archname')],bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],}}my%common_prefix_relpaths=(bin=>['bin'],script=>['bin'],bindoc=>['man','man1'],libdoc=>['man','man3'],binhtml=>['html'],libhtml=>['html'],);sub _default_prefix_relpaths {my$c=shift;my@libstyle=$c->get('installstyle')? File::Spec->splitdir($c->get('installstyle')): qw(lib perl5);my$arch=$c->get('archname');my$version=$c->get('version');return {core=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},vendor=>{lib=>[@libstyle],arch=>[@libstyle,$version,$arch],%common_prefix_relpaths,},site=>{lib=>[@libstyle,'site_perl'],arch=>[@libstyle,'site_perl',$version,$arch],%common_prefix_relpaths,},}}sub _default_original_prefix {my$c=shift;my%ret=(core=>$c->get('installprefixexp'),site=>$c->get('siteprefixexp'),vendor=>$c->get('usevendorprefix')? $c->get('vendorprefixexp'): '',);return \%ret}sub _log_verbose {my$self=shift;print @_ if$self->verbose;return}sub is_default_installable {my$self=shift;my$type=shift;my$installable=$self->install_destination($type)&& ($self->install_path($type)|| $self->install_sets($self->installdirs,$type));return$installable ? 1 : 0}sub _prefixify_default {my$self=shift;my$type=shift;my$rprefix=shift;my$default=$self->prefix_relpaths($self->installdirs,$type);if(!$default){$self->_log_verbose("    no default install location for type '$type', using prefix '$rprefix'.\n");return$rprefix}else {return File::Spec->catdir(@{$default})}}sub _prefixify_novms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;$rprefix .= '/' if$sprefix =~ m{/$};$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n")if defined$path && length$path;if (not defined$path or length$path==0){$self->_log_verbose("  no path to prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}elsif(!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("    path is relative, not prefixifying.\n")}elsif($path !~ s{^\Q$sprefix\E\b}{}s){$self->_log_verbose("    cannot prefixify, falling back to default.\n");return$self->_prefixify_default($type,$rprefix)}$self->_log_verbose("    now $path in $rprefix\n");return$path}sub _catprefix_vms {my ($self,$rprefix,$default)=@_;my ($rvol,$rdirs)=File::Spec->splitpath($rprefix);if ($rvol){return File::Spec->catpath($rvol,File::Spec->catdir($rdirs,$default),'')}else {return File::Spec->catdir($rdirs,$default)}}sub _prefixify_vms {my($self,$path,$sprefix,$type)=@_;my$rprefix=$self->prefix;return '' unless defined$path;$self->_log_verbose("  prefixify $path from $sprefix to $rprefix\n");require VMS::Filespec;$rprefix=VMS::Filespec::vmspath($rprefix)if$rprefix;$sprefix=VMS::Filespec::vmspath($sprefix)if$sprefix;$self->_log_verbose("  rprefix translated to $rprefix\n  sprefix translated to $sprefix\n");if (length($path)==0){$self->_log_verbose("  no path to prefixify.\n")}elsif (!File::Spec->file_name_is_absolute($path)){$self->_log_verbose("	path is relative, not prefixifying.\n")}elsif ($sprefix eq $rprefix){$self->_log_verbose("  no new prefix.\n")}else {my ($path_vol,$path_dirs)=File::Spec->splitpath($path);my$vms_prefix=$self->config->get('vms_prefix');if ($path_vol eq $vms_prefix.':'){$self->_log_verbose("  $vms_prefix: seen\n");$path_dirs =~ s{^\[}{\[.} unless$path_dirs =~ m{^\[\.};$path=$self->_catprefix_vms($rprefix,$path_dirs)}else {$self->_log_verbose("	cannot prefixify.\n");return File::Spec->catdir($self->prefix_relpaths($self->installdirs,$type))}}$self->_log_verbose("	now $path\n");return$path}BEGIN {*_prefixify=$^O eq 'VMS' ? \&_prefixify_vms : \&_prefixify_novms}sub prefix_relative {my ($self,$installdirs,$type)=@_;my$relpath=$self->install_sets($installdirs,$type);return$self->_prefixify($relpath,$self->original_prefix($installdirs),$type)}sub install_destination {my ($self,$type)=@_;return$self->install_path($type)if$self->install_path($type);if ($self->install_base){my$relpath=$self->install_base_relpaths($type);return$relpath ? File::Spec->catdir($self->install_base,@{$relpath}): undef}if ($self->prefix){my$relpath=$self->prefix_relative($self->installdirs,$type);return$relpath ? File::Spec->catdir($self->prefix,$relpath): undef}return$self->install_sets($self->installdirs,$type)}sub install_types {my$self=shift;my%types=(%{$self->{install_path}},$self->install_base ? %{$self->{install_base_relpaths}}: $self->prefix ? %{$self->{prefix_relpaths}{$self->installdirs }}: %{$self->{install_sets}{$self->installdirs }});return sort keys%types}sub install_map {my ($self,$blib)=@_;$blib ||= $self->blib;my (%map,@skipping);for my$type ($self->install_types){my$localdir=File::Spec->catdir($blib,$type);next unless -e $localdir;if (my$dest=$self->install_destination($type)){$map{$localdir}=$dest}else {push@skipping,$type}}warn "WARNING: Can't figure out install path for types: @skipping\nFiles will not be installed.\n" if@skipping;if ($self->create_packlist and my$module_name=$self->module_name){my$archdir=$self->install_destination('arch');my@ext=split /::/,$module_name;$map{write}=File::Spec->catfile($archdir,'auto',@ext,'.packlist')}if (length(my$destdir=$self->destdir || '')){for (keys%map){my ($volume,$path,$file)=File::Spec->splitpath($map{$_},0);my@dirs=File::Spec->splitdir($path);$path=File::Spec->catdir($destdir,@dirs);if ($file ne ''){$map{$_}=File::Spec->catfile($path,$file)}else {$map{$_}=$path}}}$map{read}='';return \%map}1;
EXTUTILS_INSTALLPATHS

$fatpacked{"File/HomeDir.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR';
  package File::HomeDir;use 5.00503;use strict;use Carp ();use Config ();use File::Spec ();use File::Which ();use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};BEGIN {$VERSION='0.05';require Exporter;@ISA=qw{Exporter};@EXPORT=qw{home};@EXPORT_OK=qw{home my_home my_desktop my_documents my_music my_pictures my_videos my_data my_dist_config my_dist_data users_home users_desktop users_documents users_music users_pictures users_videos users_data}}sub _CLASS ($) {(defined $_[0]and!ref $_[0]and $_[0]=~ m/^[^\W\d]\w*(?:::\w+)*\z/s)? $_[0]: undef}sub _DRIVER ($$) {(defined _CLASS($_[0])and eval "require $_[0];" and!$@ and $_[0]->isa($_[1])and $_[0]ne $_[1])? $_[0]: undef}if ($IMPLEMENTED_BY){}elsif ($^O eq 'MSWin32'){$IMPLEMENTED_BY='File::HomeDir::Windows'}elsif ($^O eq 'darwin'){if (eval {require Mac::SystemDirectory;1}){$IMPLEMENTED_BY='File::HomeDir::Darwin::Cocoa'}elsif (eval {require Mac::Files;1}){$IMPLEMENTED_BY='File::HomeDir::Darwin::Carbon'}else {$IMPLEMENTED_BY='File::HomeDir::Darwin'}}elsif ($^O eq 'MacOS'){$IMPLEMENTED_BY='File::HomeDir::MacOS9'}elsif (File::Which::which('xdg-user-dir')){$IMPLEMENTED_BY='File::HomeDir::FreeDesktop'}else {$IMPLEMENTED_BY='File::HomeDir::Unix'}unless (_DRIVER($IMPLEMENTED_BY,'File::HomeDir::Driver')){Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY")}sub my_home {$IMPLEMENTED_BY->my_home}sub my_desktop {$IMPLEMENTED_BY->can('my_desktop')? $IMPLEMENTED_BY->my_desktop : Carp::croak("The my_desktop method is not implemented on this platform")}sub my_documents {$IMPLEMENTED_BY->can('my_documents')? $IMPLEMENTED_BY->my_documents : Carp::croak("The my_documents method is not implemented on this platform")}sub my_music {$IMPLEMENTED_BY->can('my_music')? $IMPLEMENTED_BY->my_music : Carp::croak("The my_music method is not implemented on this platform")}sub my_pictures {$IMPLEMENTED_BY->can('my_pictures')? $IMPLEMENTED_BY->my_pictures : Carp::croak("The my_pictures method is not implemented on this platform")}sub my_videos {$IMPLEMENTED_BY->can('my_videos')? $IMPLEMENTED_BY->my_videos : Carp::croak("The my_videos method is not implemented on this platform")}sub my_data {$IMPLEMENTED_BY->can('my_data')? $IMPLEMENTED_BY->my_data : Carp::croak("The my_data method is not implemented on this platform")}sub my_dist_data {my$params=ref $_[-1]eq 'HASH' ? pop : {};my$dist=pop or Carp::croak("The my_dist_data method requires an argument");my$data=my_data();return undef unless defined$data;my$var=$data eq home()? File::Spec->catdir($data,'.perl','dist',$dist): File::Spec->catdir($data,'Perl','dist',$dist);return$var if -d $var;return undef unless$params->{create};require File::Path;File::Path::mkpath($var);return$var}sub my_dist_config {my$params=ref $_[-1]eq 'HASH' ? pop : {};my$dist=pop or Carp::croak("The my_dist_config method requires an argument");my$config=$IMPLEMENTED_BY->can('my_config')? $IMPLEMENTED_BY->my_config : $IMPLEMENTED_BY->my_documents;return undef unless defined$config;my$etc=$config eq home()? File::Spec->catdir($config,'.perl',$dist): File::Spec->catdir($config,'Perl',$dist);return$etc if -d $etc;return undef unless$params->{create};require File::Path;File::Path::mkpath($etc);return$etc}sub users_home {$IMPLEMENTED_BY->can('users_home')? $IMPLEMENTED_BY->users_home($_[-1]): Carp::croak("The users_home method is not implemented on this platform")}sub users_desktop {$IMPLEMENTED_BY->can('users_desktop')? $IMPLEMENTED_BY->users_desktop($_[-1]): Carp::croak("The users_desktop method is not implemented on this platform")}sub users_documents {$IMPLEMENTED_BY->can('users_documents')? $IMPLEMENTED_BY->users_documents($_[-1]): Carp::croak("The users_documents method is not implemented on this platform")}sub users_music {$IMPLEMENTED_BY->can('users_music')? $IMPLEMENTED_BY->users_music($_[-1]): Carp::croak("The users_music method is not implemented on this platform")}sub users_pictures {$IMPLEMENTED_BY->can('users_pictures')? $IMPLEMENTED_BY->users_pictures($_[-1]): Carp::croak("The users_pictures method is not implemented on this platform")}sub users_videos {$IMPLEMENTED_BY->can('users_videos')? $IMPLEMENTED_BY->users_videos($_[-1]): Carp::croak("The users_videos method is not implemented on this platform")}sub users_data {$IMPLEMENTED_BY->can('users_data')? $IMPLEMENTED_BY->users_data($_[-1]): Carp::croak("The users_data method is not implemented on this platform")}sub home (;$) {if ($_[0]and $_[0]eq 'File::HomeDir'){shift()}return my_home()unless @_;my$name=shift;if (!defined$name){Carp::croak("Can't use undef as a username")}if (!length$name){Carp::croak("Can't use empty-string (\"\") as a username")}if ($name eq '.'){return my_home()}$IMPLEMENTED_BY->users_home($name)}CLASS: {package File::HomeDir::TIE;my$SINGLETON=bless {};sub TIEHASH {$SINGLETON}sub FETCH {unless (defined $_[1]){Carp::croak("Can't use undef as a username")}unless (length $_[1]){return File::HomeDir::my_home()}Carp::carp("The tied %~ hash has been deprecated");return File::HomeDir::home($_[1])}sub STORE {_bad('STORE')}sub EXISTS {_bad('EXISTS')}sub DELETE {_bad('DELETE')}sub CLEAR {_bad('CLEAR')}sub FIRSTKEY {_bad('FIRSTKEY')}sub NEXTKEY {_bad('NEXTKEY')}sub _bad ($) {Carp::croak("You can't $_[0] with the %~ hash")}}tie %~,'File::HomeDir::TIE';1;
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Unix ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Unix'}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}my$home=(getpwuid($<))[7];return$home if$home && -d $home;return undef}sub _my_home {my($class,$path)=@_;my$home=$class->my_home;return undef unless defined$home;my$folder="$home/$path";unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}sub my_desktop {my$class=shift;$class->_my_home('Desktop')}sub my_documents {my$class=shift;$class->_my_home('Documents')}sub my_data {my$class=shift;$class->_my_home('Library/Application Support')}sub my_music {my$class=shift;$class->_my_home('Music')}sub my_pictures {my$class=shift;$class->_my_home('Pictures')}sub my_videos {my$class=shift;$class->_my_home('Movies')}sub users_home {my$class=shift;my$home=$class->SUPER::users_home(@_);return defined$home ? Cwd::abs_path($home): undef}sub users_desktop {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_desktop,$name)}sub users_documents {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_documents,$name)}sub users_data {my ($class,$name)=@_;$class->_to_user($class->my_data,$name)|| $class->users_home($name)}sub _to_user {my ($class,$path,$name)=@_;my$my_home=$class->my_home;my$users_home=$class->users_home($name);defined$users_home or return undef;$path =~ s/^\Q$my_home/$users_home/;return$path}1;
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Darwin ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Darwin';local $@;eval "use prefork 'Mac::Files'"}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}require Mac::Files;$class->_find_folder(Mac::Files::kCurrentUserFolderType(),)}sub my_desktop {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kDesktopFolderType(),)}sub my_documents {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kDocumentsFolderType(),)}sub my_data {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kApplicationSupportFolderType(),)}sub my_music {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kMusicDocumentsFolderType(),)}sub my_pictures {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kPictureDocumentsFolderType(),)}sub my_videos {my$class=shift;require Mac::Files;$class->_find_folder(Mac::Files::kMovieDocumentsFolderType(),)}sub _find_folder {my$class=shift;my$name=shift;require Mac::Files;my$folder=Mac::Files::FindFolder(Mac::Files::kUserDomain(),$name,);return undef unless defined$folder;unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}sub users_home {my$class=shift;my$home=$class->SUPER::users_home(@_);return defined$home ? Cwd::abs_path($home): undef}sub users_desktop {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_desktop,$name)}sub users_documents {my ($class,$name)=@_;return undef if$name eq 'root';$class->_to_user($class->my_documents,$name)}sub users_data {my ($class,$name)=@_;$class->_to_user($class->my_data,$name)|| $class->users_home($name)}sub _to_user {my ($class,$path,$name)=@_;my$my_home=$class->my_home;my$users_home=$class->users_home($name);defined$users_home or return undef;$path =~ s/^\Q$my_home/$users_home/;return$path}1;
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;use 5.00503;use strict;use Cwd ();use Carp ();use File::HomeDir::Darwin ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Darwin';local $@;eval "use prefork 'Mac::SystemDirectory'"}sub my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}require Mac::SystemDirectory;return Mac::SystemDirectory::HomeDirectory()}sub my_desktop {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())}|| $class->SUPER::my_desktop}sub my_documents {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())}|| $class->SUPER::my_documents}sub my_data {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())}|| $class->SUPER::my_data}sub my_music {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())}|| $class->SUPER::my_music}sub my_pictures {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())}|| $class->SUPER::my_pictures}sub my_videos {my$class=shift;require Mac::SystemDirectory;eval {$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())}|| $class->SUPER::my_videos}sub _find_folder {my$class=shift;my$name=shift;require Mac::SystemDirectory;my$folder=Mac::SystemDirectory::FindDirectory($name);return undef unless defined$folder;unless (-d $folder){return undef unless -l $folder;my$dir=readlink$folder or return;return undef unless -d $dir}return Cwd::abs_path($folder)}1;
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;use 5.00503;use strict;use Carp ();use vars qw{$VERSION};BEGIN {$VERSION='0.05'}sub my_home {Carp::croak("$_[0] does not implement compulsory method $_[1]")}1;
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;use 5.00503;use strict;use Carp ();use File::Spec ();use File::Which ();use File::HomeDir::Unix ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Unix'}my$xdgprog=File::Which::which('xdg-user-dir');sub _my {my$thingy=qx($xdgprog $_[1]);chomp$thingy;return$thingy}sub my_desktop {shift->_my('DESKTOP')}sub my_documents {shift->_my('DOCUMENTS')}sub my_music {shift->_my('MUSIC')}sub my_pictures {shift->_my('PICTURES')}sub my_videos {shift->_my('VIDEOS')}sub my_data {$ENV{XDG_DATA_HOME}or File::Spec->catdir(shift->my_home,qw{.local share})}sub my_config {$ENV{XDG_CONFIG_HOME}or File::Spec->catdir(shift->my_home,qw{.config})}sub my_download {shift->_my('DOWNLOAD')}sub my_publicshare {shift->_my('PUBLICSHARE')}sub my_templates {shift->_my('TEMPLATES')}sub my_cache {$ENV{XDG_CACHE_HOME}|| File::Spec->catdir(shift->my_home,qw{.cache})}sub users_desktop {Carp::croak('The users_desktop method is not available on an XDG based system.')}sub users_documents {Carp::croak('The users_documents method is not available on an XDG based system.')}sub users_music {Carp::croak('The users_music method is not available on an XDG based system.')}sub users_pictures {Carp::croak('The users_pictures method is not available on an XDG based system.')}sub users_videos {Carp::croak('The users_videos method is not available on an XDG based system.')}sub users_data {Carp::croak('The users_data method is not available on an XDG based system.')}1;
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;use 5.00503;use strict;use Carp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Driver'}SCOPE: {local $@;eval "use prefork 'Mac::Files'"}sub my_home {my$class=shift;if (defined$ENV{HOME}){return$ENV{HOME}}SCOPE: {local $@;eval {my$home=$class->my_desktop;return$home if$home and -d $home}}SCOPE: {local$SIG{'__DIE__'}='';my$home=(getpwuid($<))[7];return$home if$home and -d $home}Carp::croak("Could not locate current user's home directory")}sub my_desktop {my$class=shift;local$SIG{'__DIE__'}='';require Mac::Files;my$home=Mac::Files::FindFolder(Mac::Files::kOnSystemDisk(),Mac::Files::kDesktopFolderType(),);return$home if$home and -d $home;Carp::croak("Could not locate current user's desktop")}sub users_home {my ($class,$name)=@_;SCOPE: {local$SIG{'__DIE__'}='';my$home=(getpwnam($name))[7];return$home if defined$home and -d $home}Carp::croak("Failed to find home directory for user '$name'")}1;
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;use 5.00503;use strict;use Carp ();use File::Spec ();use File::Temp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA %DIR $ENABLED};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Driver';%DIR=();$ENABLED=0}sub import {my$class=shift;die "Attempted to initialise File::HomeDir::Test trice" if%DIR;my$BASE=File::Temp::tempdir(CLEANUP=>1);%DIR=map {$_=>File::Spec->catdir($BASE,$_)}qw{my_home my_desktop my_documents my_data my_music my_pictures my_videos};$ENV{HOME}=$DIR{my_home};$File::HomeDir::IMPLEMENTED_BY=$File::HomeDir::IMPLEMENTED_BY='File::HomeDir::Test';$ENABLED=1}sub my_home {mkdir($DIR{my_home},0755)unless -d $DIR{my_home};return$DIR{my_home}}sub my_desktop {mkdir($DIR{my_desktop},0755)unless -d $DIR{my_desktop};return$DIR{my_desktop}}sub my_documents {mkdir($DIR{my_documents},0755)unless -f $DIR{my_documents};return$DIR{my_documents}}sub my_data {mkdir($DIR{my_data},0755)unless -d $DIR{my_data};return$DIR{my_data}}sub my_music {mkdir($DIR{my_music},0755)unless -d $DIR{my_music};return$DIR{my_music}}sub my_pictures {mkdir($DIR{my_pictures},0755)unless -d $DIR{my_pictures};return$DIR{my_pictures}}sub my_videos {mkdir($DIR{my_videos},0755)unless -d $DIR{my_videos};return$DIR{my_videos}}sub users_home {return undef}1;
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;use 5.00503;use strict;use Carp ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Driver'}sub my_home {my$class=shift;my$home=$class->_my_home(@_);if (defined$home and!-d $home){$home=undef}return$home}sub _my_home {my$class=shift;if (exists$ENV{HOME}and defined$ENV{HOME}){return$ENV{HOME}}if (exists$ENV{LOGDIR}and $ENV{LOGDIR}){return$ENV{LOGDIR}}SCOPE: {my$home=(getpwuid($<))[7];return$home if$home and -d $home}return undef}sub my_desktop {shift->my_home}sub my_documents {shift->my_home}sub my_data {shift->my_home}sub my_music {shift->my_home}sub my_pictures {shift->my_home}sub my_videos {shift->my_home}sub users_home {my ($class,$name)=@_;if ($name eq getpwuid($<)){return$class->my_home}SCOPE: {my$home=(getpwnam($name))[7];return$home if$home and -d $home}return undef}sub users_desktop {shift->users_home(@_)}sub users_documents {shift->users_home(@_)}sub users_data {shift->users_home(@_)}sub users_music {shift->users_home(@_)}sub users_pictures {shift->users_home(@_)}sub users_videos {shift->users_home(@_)}1;
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;use 5.00503;use strict;use Carp ();use File::Spec ();use File::HomeDir::Driver ();use vars qw{$VERSION @ISA};BEGIN {$VERSION='0.05';@ISA='File::HomeDir::Driver'}sub CREATE () {1}sub my_home {my$class=shift;if (exists$ENV{HOME}and $ENV{HOME}){return$ENV{HOME}}if (exists$ENV{USERPROFILE}and $ENV{USERPROFILE}){return$ENV{USERPROFILE}}if (exists$ENV{HOMEDRIVE}and exists$ENV{HOMEPATH}and $ENV{HOMEDRIVE}and $ENV{HOMEPATH}){return File::Spec->catpath($ENV{HOMEDRIVE},$ENV{HOMEPATH},'',)}return undef}sub my_desktop {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_DESKTOP(),CREATE);return$dir if$dir and $class->_d($dir)}for my$e ('USERPROFILE','WINDIR'){next unless$ENV{$e};my$desktop=File::Spec->catdir($ENV{$e},'Desktop');return$desktop if$desktop and $class->_d($desktop)}for my$fixed ("C:\\windows\\desktop","C:\\win95\\desktop","C:/win95/desktop","C:/windows/desktop",){return$fixed if$class->_d($fixed)}return undef}sub my_documents {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_PERSONAL(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_data {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_music {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_pictures {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub my_videos {my$class=shift;SCOPE: {require Win32;my$dir=Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(),CREATE);return$dir if$dir and $class->_d($dir)}return undef}sub _d {my$self=shift;my$path=shift;if ($path =~ /\\\\/){return 1}return -d $path}1;
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'FILE_WHICH';
  package File::Which;use strict;use warnings;use Exporter ();use File::Spec ();our$VERSION='0.05';our@ISA='Exporter';our@EXPORT='which';our@EXPORT_OK='where';use constant IS_VMS=>($^O eq 'VMS');use constant IS_MAC=>($^O eq 'MacOS');use constant IS_DOS=>($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');use constant IS_CYG=>($^O eq 'cygwin' || $^O eq 'msys');my@PATHEXT=('');if (IS_DOS){if ($ENV{PATHEXT}){push@PATHEXT,split ';',$ENV{PATHEXT}}else {push@PATHEXT,qw{.com .exe .bat}}}elsif (IS_VMS){push@PATHEXT,qw{.exe .com}}elsif (IS_CYG){push@PATHEXT,qw{.exe .com}}sub which {my ($exec)=@_;return undef unless defined$exec;return undef if$exec eq '';my$all=wantarray;my@results=();if (IS_VMS){my$symbol=`SHOW SYMBOL $exec`;chomp($symbol);unless ($?){return$symbol unless$all;push@results,$symbol}}if (IS_MAC){my@aliases=split /\,/,$ENV{Aliases};for my$alias (@aliases){if (lc($alias)eq lc($exec)){chomp(my$file=`Alias $alias`);last unless$file;return$file unless$all;push@results,$file;last}}}return$exec if!IS_VMS and!IS_MAC and!IS_DOS and $exec =~ /\// and -f $exec and -x $exec;my@path=File::Spec->path;if (IS_DOS or IS_VMS or IS_MAC){unshift@path,File::Spec->curdir}for my$base (map {File::Spec->catfile($_,$exec)}@path){for my$ext (@PATHEXT){my$file=$base.$ext;next if -d $file;if (-x _ or (IS_MAC || ((IS_DOS or IS_CYG)and grep {$file =~ /$_\z/i}@PATHEXT[1..$#PATHEXT])and -e _)){return$file unless$all;push@results,$file}}}if ($all){return@results}else {return undef}}sub where {my@res=which($_[0]);return@res}1;
FILE_WHICH

$fatpacked{"JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON';
  package JSON;use strict;use Carp ();use Exporter;BEGIN {@JSON::ISA='Exporter'}@JSON::EXPORT=qw(from_json to_json jsonToObj objToJson encode_json decode_json);BEGIN {$JSON::VERSION='0.05';$JSON::DEBUG=0 unless (defined$JSON::DEBUG);$JSON::DEBUG=$ENV{PERL_JSON_DEBUG }if exists$ENV{PERL_JSON_DEBUG }}my%RequiredVersion=('JSON::PP'=>'2.27203','JSON::XS'=>'2.34',);my@PublicMethods=qw/ascii latin1 utf8 pretty indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed filter_json_object filter_json_single_key_object shrink max_depth max_size encode decode decode_prefix allow_unknown/;my@Properties=qw/ascii latin1 utf8 indent space_before space_after relaxed canonical allow_nonref allow_blessed convert_blessed shrink max_depth max_size allow_unknown/;my@XSOnlyMethods=qw/allow_tags/;my@PPOnlyMethods=qw/indent_length sort_by allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed/;my$_INSTALL_DONT_DIE=1;my$_ALLOW_UNSUPPORTED=0;my$_UNIV_CONV_BLESSED=0;unless ($JSON::Backend){$JSON::DEBUG and Carp::carp("Check used worker module...");my$backend=exists$ENV{PERL_JSON_BACKEND}? $ENV{PERL_JSON_BACKEND}: 1;if ($backend eq '1'){$backend='JSON::XS,JSON::PP'}elsif ($backend eq '0'){$backend='JSON::PP'}elsif ($backend eq '2'){$backend='JSON::XS'}$backend =~ s/\s+//g;my@backend_modules=split /,/,$backend;while(my$module=shift@backend_modules){if ($module =~ /JSON::XS/){_load_xs($module,@backend_modules ? $_INSTALL_DONT_DIE : 0)}elsif ($module =~ /JSON::PP/){_load_pp($module)}elsif ($module =~ /JSON::backportPP/){_load_pp($module)}else {Carp::croak "The value of environmental variable 'PERL_JSON_BACKEND' is invalid."}last if$JSON::Backend}}sub import {my$pkg=shift;my@what_to_export;my$no_export;for my$tag (@_){if ($tag eq '-support_by_pp'){if (!$_ALLOW_UNSUPPORTED++){JSON::Backend::XS ->support_by_pp(@PPOnlyMethods)if ($JSON::Backend->is_xs)}next}elsif ($tag eq '-no_export'){$no_export++,next}elsif ($tag eq '-convert_blessed_universally'){my$org_encode=$JSON::Backend->can('encode');eval q|
                  require B;
                  local $^W;
                  no strict 'refs';
                  *{"${JSON::Backend}\::encode"} = sub {
                      # only works with Perl 5.18+
                      local *UNIVERSAL::TO_JSON = sub {
                          my $b_obj = B::svref_2object( $_[0] );
                          return    $b_obj->isa('B::HV') ? { %{ $_[0] } }
                                  : $b_obj->isa('B::AV') ? [ @{ $_[0] } ]
                                  : undef
                                  ;
                      };
                      $org_encode->(@_);
                  };
              | if (!$_UNIV_CONV_BLESSED++);next}push@what_to_export,$tag}return if ($no_export);__PACKAGE__->export_to_level(1,$pkg,@what_to_export)}sub jsonToObj {my$alternative='from_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='decode'}Carp::carp "'jsonToObj' will be obsoleted. Please use '$alternative' instead.";return JSON::from_json(@_)};sub objToJson {my$alternative='to_json';if (defined $_[0]and UNIVERSAL::isa($_[0],'JSON')){shift @_;$alternative='encode'}Carp::carp "'objToJson' will be obsoleted. Please use '$alternative' instead.";JSON::to_json(@_)};sub to_json ($@) {if (ref($_[0])eq 'JSON' or (@_ > 2 and $_[0]eq 'JSON')){Carp::croak "to_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}$json->encode($_[0])}sub from_json ($@) {if (ref($_[0])eq 'JSON' or $_[0]eq 'JSON'){Carp::croak "from_json should not be called as a method."}my$json=JSON->new;if (@_==2 and ref $_[1]eq 'HASH'){my$opt=$_[1];for my$method (keys %$opt){$json->$method($opt->{$method})}}return$json->decode($_[0])}sub true {$JSON::true}sub false {$JSON::false}sub null {undef}sub require_xs_version {$RequiredVersion{'JSON::XS'}}sub backend {my$proto=shift;$JSON::Backend}sub is_xs {return $_[0]->backend->is_xs}sub is_pp {return $_[0]->backend->is_pp}sub pureperl_only_methods {@PPOnlyMethods}sub property {my ($self,$name,$value)=@_;if (@_==1){my%props;for$name (@Properties){my$method='get_' .$name;if ($name eq 'max_size'){my$value=$self->$method();$props{$name}=$value==1 ? 0 : $value;next}$props{$name}=$self->$method()}return \%props}elsif (@_ > 3){Carp::croak('property() can take only the option within 2 arguments.')}elsif (@_==2){if (my$method=$self->can('get_' .$name)){if ($name eq 'max_size'){my$value=$self->$method();return$value==1 ? 0 : $value}$self->$method()}}else {$self->$name($value)}}sub __load_xs {my ($module,$opt)=@_;$JSON::DEBUG and Carp::carp "Load $module.";my$required_version=$RequiredVersion{$module}|| '';eval qq|
          use $module $required_version ();
      |;if ($@){if (defined$opt and $opt & $_INSTALL_DONT_DIE){$JSON::DEBUG and Carp::carp "Can't load $module...($@)";return 0}Carp::croak $@}$JSON::BackendModuleXS=$module;return 1}sub _load_xs {my ($module,$opt)=@_;__load_xs($module,$opt)or return;my$data=join("",<DATA>);close(DATA);eval$data;JSON::Backend::XS->init($module);return 1};sub __load_pp {my ($module,$opt)=@_;$JSON::DEBUG and Carp::carp "Load $module.";my$required_version=$RequiredVersion{$module}|| '';eval qq| use $module $required_version () |;if ($@){if ($module eq 'JSON::PP'){$JSON::DEBUG and Carp::carp "Can't load $module ($@), so try to load JSON::backportPP";$module='JSON::backportPP';local $^W;eval qq| require $module |}Carp::croak $@ if $@}$JSON::BackendModulePP=$module;return 1}sub _load_pp {my ($module,$opt)=@_;__load_pp($module,$opt);JSON::Backend::PP->init($module)};package JSON::Backend::PP;sub init {my ($class,$module)=@_;local $^W;no strict qw(refs);*{"JSON::decode_json"}=\&{"JSON::PP::decode_json"};*{"JSON::encode_json"}=\&{"JSON::PP::encode_json"};*{"JSON::is_bool"}=\&{"JSON::PP::is_bool"};$JSON::true=${"JSON::PP::true"};$JSON::false=${"JSON::PP::false"};push@JSON::Backend::PP::ISA,'JSON::PP';push@JSON::ISA,$class;$JSON::Backend=$class;$JSON::BackendModule=$module;${"$class\::VERSION"}=$module->VERSION;for my$method (@XSOnlyMethods){*{"JSON::$method"}=sub {Carp::carp("$method is not supported in $module.");$_[0]}}return 1}sub is_xs {0};sub is_pp {1};package JSON;1;__DATA__ 
  
  #
  # Helper classes for Backend Module (XS)
  #
  
  package JSON::Backend::XS;
  
  sub init {
      my ($class, $module) = @_;
  
      local $^W;
      no strict qw(refs);
      *{"JSON::decode_json"} = \&{"$module\::decode_json"};
      *{"JSON::encode_json"} = \&{"$module\::encode_json"};
      *{"JSON::is_bool"} = \&{"$module\::is_bool"};
  
      $JSON::true  = ${"$module\::true"};
      $JSON::false = ${"$module\::false"};
  
      push @JSON::Backend::XS::ISA, $module;
      push @JSON::ISA, $class;
      $JSON::Backend = $class;
      $JSON::BackendModule = $module;
      ${"$class\::VERSION"} = $module->VERSION;
  
      if ( $module->VERSION < 3 ) {
          eval 'package JSON::PP::Boolean';
          push @{"$module\::Boolean::ISA"}, qw(JSON::PP::Boolean);
      }
  
      for my $method (@PPOnlyMethods) {
          *{"JSON::$method"} = sub {
              Carp::carp("$method is not supported in $module.");
              $_[0];
          };
      }
  
      return 1;
  }
  
  sub is_xs { 1 };
  sub is_pp { 0 };
  
  sub support_by_pp {
      my ($class, @methods) = @_;
  
      JSON::__load_pp('JSON::PP');
  
      local $^W;
      no strict qw(refs);
  
      for my $method (@methods) {
          my $pp_method = JSON::PP->can($method) or next;
          *{"JSON::$method"} = sub {
              if (!$_[0]->isa('JSON::PP')) {
                  my $xs_self = $_[0];
                  my $pp_self = JSON::PP->new;
                  for (@Properties) {
                       my $getter = "get_$_";
                      $pp_self->$_($xs_self->$getter);
                  }
                  $_[0] = $pp_self;
              }
              $pp_method->(@_);
          };
      }
  
      $JSON::DEBUG and Carp::carp("set -support_by_pp mode.");
  }
  
  1;
  __END__
  
  =head1 NAME
  
  JSON - JSON (JavaScript Object Notation) encoder/decoder
  
  =head1 SYNOPSIS
  
   use JSON; # imports encode_json, decode_json, to_json and from_json.
   
   # simple and fast interfaces (expect/generate UTF-8)
   
   $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
   $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;
   
   # OO-interface
   
   $json = JSON->new->allow_nonref;
   
   $json_text   = $json->encode( $perl_scalar );
   $perl_scalar = $json->decode( $json_text );
   
   $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
  
  =head1 VERSION
  
      2.97001
  
  =head1 DESCRIPTION
  
  This module is a thin wrapper for L<JSON::XS>-compatible modules with a few
  additional features. All the backend modules convert a Perl data structure
  to a JSON text as of RFC4627 (which we know is obsolete but we still stick
  to; see below for an option to support part of RFC7159) and vice versa.
  This module uses L<JSON::XS> by default, and when JSON::XS is not available,
  this module falls back on L<JSON::PP>, which is in the Perl core since 5.14.
  If JSON::PP is not available either, this module then falls back on
  JSON::backportPP (which is actually JSON::PP in a different .pm file)
  bundled in the same distribution as this module. You can also explicitly
  specify to use L<Cpanel::JSON::XS>, a fork of JSON::XS by Reini Urban.
  
  All these backend modules have slight incompatibilities between them,
  including extra features that other modules don't support, but as long as you
  use only common features (most important ones are described below), migration
  from backend to backend should be reasonably easy. For details, see each
  backend module you use.
  
  =head1 CHOOSING BACKEND
  
  This module respects an environmental variable called C<PERL_JSON_BACKEND>
  when it decides a backend module to use. If this environmental variable is
  not set, it tries to load JSON::XS, and if JSON::XS is not available, it
  falls back on JSON::PP, and then JSON::backportPP if JSON::PP is not available
  either.
  
  If you always don't want it to fall back on pure perl modules, set the
  variable like this (C<export> may be C<setenv>, C<set> and the likes,
  depending on your environment):
  
    > export PERL_JSON_BACKEND=JSON::XS
  
  If you prefer Cpanel::JSON::XS to JSON::XS, then:
  
    > export PERL_JSON_BACKEND=Cpanel::JSON::XS,JSON::XS,JSON::PP
  
  You may also want to set this variable at the top of your test files, in order
  not to be bothered with incompatibilities between backends (you need to wrap
  this in C<BEGIN>, and set before actually C<use>-ing JSON module, as it decides
  its backend as soon as it's loaded):
  
    BEGIN { $ENV{PERL_JSON_BACKEND}='JSON::backportPP'; }
    use JSON;
  
  =head1 USING OPTIONAL FEATURES
  
  There are a few options you can set when you C<use> this module:
  
  =over
  
  =item -support_by_pp
  
     BEGIN { $ENV{PERL_JSON_BACKEND} = 'JSON::XS' }
     
     use JSON -support_by_pp;
     
     my $json = JSON->new;
     # escape_slash is for JSON::PP only.
     $json->allow_nonref->escape_slash->encode("/");
  
  With this option, this module loads its pure perl backend along with
  its XS backend (if available), and lets the XS backend to watch if you set
  a flag only JSON::PP supports. When you do, the internal JSON::XS object
  is replaced with a newly created JSON::PP object with the setting copied
  from the XS object, so that you can use JSON::PP flags (and its slower
  C<decode>/C<encode> methods) from then on. In other words, this is not
  something that allows you to hook JSON::XS to change its behavior while
  keeping its speed. JSON::XS and JSON::PP objects are quite different
  (JSON::XS object is a blessed scalar reference, while JSON::PP object is
  a blessed hash reference), and can't share their internals.
  
  To avoid needless overhead (by copying settings), you are advised not
  to use this option and just to use JSON::PP explicitly when you need
  JSON::PP features.
  
  =item -convert_blessed_universally
  
     use JSON -convert_blessed_universally;
  
     my $json = JSON->new->allow_nonref->convert_blessed;
     my $object = bless {foo => 'bar'}, 'Foo';
     $json->encode($object); # => {"foo":"bar"}
  
  JSON::XS-compatible backend modules don't encode blessed objects by
  default (except for their boolean values, which are typically blessed
  JSON::PP::Boolean objects). If you need to encode a data structure
  that may contain objects, you usually need to look into the structure
  and replace objects with alternative non-blessed values, or enable
  C<convert_blessed> and provide a C<TO_JSON> method for each object's
  (base) class that may be found in the structure, in order to let the
  methods replace the objects with whatever scalar values the methods
  return.
  
  If you need to serialise data structures that may contain arbitrary
  objects, it's probably better to use other serialisers (such as
  L<Sereal> or L<Storable> for example), but if you do want to use
  this module for that purpose, C<-convert_blessed_universally> option
  may help, which tweaks C<encode> method of the backend to install
  C<UNIVERSAL::TO_JSON> method (locally) before encoding, so that
  all the objects that don't have their own C<TO_JSON> method can
  fall back on the method in the C<UNIVERSAL> namespace. Note that you
  still need to enable C<convert_blessed> flag to actually encode
  objects in a data structure, and C<UNIVERSAL::TO_JSON> method
  installed by this option only converts blessed hash/array references
  into their unblessed clone (including private keys/values that are
  not supposed to be exposed). Other blessed references will be
  converted into null.
  
  This feature is experimental and may be removed in the future.
  
  =item -no_export
  
  When you don't want to import functional interfaces from a module, you
  usually supply C<()> to its C<use> statement.
  
      use JSON (); # no functional interfaces
  
  If you don't want to import functional interfaces, but you also want to
  use any of the above options, add C<-no_export> to the option list.
  
     # no functional interfaces, while JSON::PP support is enabled.
     use JSON -support_by_pp, -no_export;
  
  =back
  
  =head1 FUNCTIONAL INTERFACE
  
  This section is taken from JSON::XS. C<encode_json> and C<decode_json>
  are exported by default.
  
  This module also exports C<to_json> and C<from_json> for backward
  compatibility. These are slower, and may expect/generate different stuff
  from what C<encode_json> and C<decode_json> do, depending on their
  options. It's better just to use Object-Oriented interfaces than using
  these two functions.
  
  =head2 encode_json
  
      $json_text = encode_json $perl_scalar
  
  Converts the given Perl data structure to a UTF-8 encoded, binary string
  (that is, the string contains octets only). Croaks on error.
  
  This function call is functionally identical to:
  
      $json_text = JSON->new->utf8->encode($perl_scalar)
  
  Except being faster.
  
  =head2 decode_json
  
      $perl_scalar = decode_json $json_text
  
  The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
  to parse that as an UTF-8 encoded JSON text, returning the resulting
  reference. Croaks on error.
  
  This function call is functionally identical to:
  
      $perl_scalar = JSON->new->utf8->decode($json_text)
  
  Except being faster.
  
  =head2 to_json
  
     $json_text = to_json($perl_scalar[, $optional_hashref])
  
  Converts the given Perl data structure to a Unicode string by default.
  Croaks on error.
  
  Basically, this function call is functionally identical to:
  
     $json_text = JSON->new->encode($perl_scalar)
  
  Except being slower.
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<to_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
     $json_text = to_json($perl_scalar, {utf8 => 1, pretty => 1})
     # => JSON->new->utf8(1)->pretty(1)->encode($perl_scalar)
  
  =head2 from_json
  
     $perl_scalar = from_json($json_text[, $optional_hashref])
  
  The opposite of C<to_json>: expects a Unicode string and tries
  to parse it, returning the resulting reference. Croaks on error.
  
  Basically, this function call is functionally identical to:
  
      $perl_scalar = JSON->new->decode($json_text)
  
  You can pass an optional hash reference to modify its behavior, but
  that may change what C<from_json> expects/generates (see
  C<ENCODING/CODESET FLAG NOTES> for details).
  
      $perl_scalar = from_json($json_text, {utf8 => 1})
      # => JSON->new->utf8(1)->decode($json_text)
  
  =head2 JSON::is_bool
  
      $is_boolean = JSON::is_bool($scalar)
  
  Returns true if the passed scalar represents either JSON::true or
  JSON::false, two constants that act like C<1> and C<0> respectively
  and are also used to represent JSON C<true> and C<false> in Perl strings.
  
  See L<MAPPING>, below, for more information on how JSON values are mapped to
  Perl.
  
  =head1 COMMON OBJECT-ORIENTED INTERFACE
  
  This section is also taken from JSON::XS.
  
  The object oriented interface lets you configure your own encoding or
  decoding style, within the limits of supported formats.
  
  =head2 new
  
      $json = JSON->new
  
  Creates a new JSON::XS-compatible backend object that can be used to de/encode JSON
  strings. All boolean flags described below are by default I<disabled>.
  
  The mutators for flags all return the backend object again and thus calls can
  be chained:
  
     my $json = JSON->new->utf8->space_after->encode({a => [1,2]})
     => {"a": [1, 2]}
  
  =head2 ascii
  
      $json = $json->ascii([$enable])
      
      $enabled = $json->get_ascii
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  generate characters outside the code range C<0..127> (which is ASCII). Any
  Unicode characters outside that range will be escaped using either a
  single \uXXXX (BMP characters) or a double \uHHHH\uLLLLL escape sequence,
  as per RFC4627. The resulting encoded JSON text can be treated as a native
  Unicode string, an ascii-encoded, latin1-encoded or UTF-8 encoded string,
  or any other superset of ASCII.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags. This results
  in a faster and more compact format.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is to produce JSON texts that can be
  transmitted over a 7-bit channel, as the encoded JSON texts will not
  contain any 8 bit characters.
  
    JSON->new->ascii(1)->encode([chr 0x10401])
    => ["\ud801\udc01"]
  
  =head2 latin1
  
      $json = $json->latin1([$enable])
      
      $enabled = $json->get_latin1
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the resulting JSON text as latin1 (or iso-8859-1), escaping any characters
  outside the code range C<0..255>. The resulting string can be treated as a
  latin1-encoded JSON text or a native Unicode string. The C<decode> method
  will not be affected in any way by this flag, as C<decode> by default
  expects Unicode, which is a strict superset of latin1.
  
  If C<$enable> is false, then the C<encode> method will not escape Unicode
  characters unless required by the JSON syntax or other flags.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  The main use for this flag is efficiently encoding binary data as JSON
  text, as most octets will not be escaped, resulting in a smaller encoded
  size. The disadvantage is that the resulting JSON text is encoded
  in latin1 (and must correctly be treated as such when storing and
  transferring), a rare encoding for JSON. It is therefore most useful when
  you want to store data structures known to contain binary data efficiently
  in files or databases, not when talking to other JSON encoders/decoders.
  
    JSON->new->latin1->encode (["\x{89}\x{abc}"]
    => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)
  
  =head2 utf8
  
      $json = $json->utf8([$enable])
      
      $enabled = $json->get_utf8
  
  If C<$enable> is true (or missing), then the C<encode> method will encode
  the JSON result into UTF-8, as required by many protocols, while the
  C<decode> method expects to be handled an UTF-8-encoded string.  Please
  note that UTF-8-encoded strings do not contain any characters outside the
  range C<0..255>, they are thus useful for bytewise/binary I/O. In future
  versions, enabling this option might enable autodetection of the UTF-16
  and UTF-32 encoding families, as described in RFC4627.
  
  If C<$enable> is false, then the C<encode> method will return the JSON
  string as a (non-encoded) Unicode string, while C<decode> expects thus a
  Unicode string.  Any decoding or encoding (e.g. to UTF-8 or UTF-16) needs
  to be done yourself, e.g. using the Encode module.
  
  See also the section I<ENCODING/CODESET FLAG NOTES> later in this document.
  
  Example, output UTF-16BE-encoded JSON:
  
    use Encode;
    $jsontext = encode "UTF-16BE", JSON->new->encode ($object);
  
  Example, decode UTF-32LE-encoded JSON:
  
    use Encode;
    $object = JSON->new->decode (decode "UTF-32LE", $jsontext);
  
  =head2 pretty
  
      $json = $json->pretty([$enable])
  
  This enables (or disables) all of the C<indent>, C<space_before> and
  C<space_after> (and in the future possibly more) flags in one call to
  generate the most readable (or most compact) form possible.
  
  =head2 indent
  
      $json = $json->indent([$enable])
      
      $enabled = $json->get_indent
  
  If C<$enable> is true (or missing), then the C<encode> method will use a multiline
  format as output, putting every array member or object/hash key-value pair
  into its own line, indenting them properly.
  
  If C<$enable> is false, no newlines or indenting will be produced, and the
  resulting JSON text is guaranteed not to contain any C<newlines>.
  
  This setting has no effect when decoding JSON texts.
  
  =head2 space_before
  
      $json = $json->space_before([$enable])
      
      $enabled = $json->get_space_before
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space before the C<:> separating keys from values in JSON objects.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts. You will also
  most likely combine this setting with C<space_after>.
  
  Example, space_before enabled, space_after and indent disabled:
  
     {"key" :"value"}
  
  =head2 space_after
  
      $json = $json->space_after([$enable])
      
      $enabled = $json->get_space_after
  
  If C<$enable> is true (or missing), then the C<encode> method will add an extra
  optional space after the C<:> separating keys from values in JSON objects
  and extra whitespace after the C<,> separating key-value pairs and array
  members.
  
  If C<$enable> is false, then the C<encode> method will not add any extra
  space at those places.
  
  This setting has no effect when decoding JSON texts.
  
  Example, space_before and indent disabled, space_after enabled:
  
     {"key": "value"}
  
  =head2 relaxed
  
      $json = $json->relaxed([$enable])
      
      $enabled = $json->get_relaxed
  
  If C<$enable> is true (or missing), then C<decode> will accept some
  extensions to normal JSON syntax (see below). C<encode> will not be
  affected in anyway. I<Be aware that this option makes you accept invalid
  JSON texts as if they were valid!>. I suggest only to use this option to
  parse application-specific files written by humans (configuration files,
  resource files etc.)
  
  If C<$enable> is false (the default), then C<decode> will only accept
  valid JSON texts.
  
  Currently accepted extensions are:
  
  =over 4
  
  =item * list items can have an end-comma
  
  JSON I<separates> array elements and key-value pairs with commas. This
  can be annoying if you write JSON texts manually and want to be able to
  quickly append elements, so this extension accepts comma at the end of
  such items not just between them:
  
     [
        1,
        2, <- this comma not normally allowed
     ]
     {
        "k1": "v1",
        "k2": "v2", <- this comma not normally allowed
     }
  
  =item * shell-style '#'-comments
  
  Whenever JSON allows whitespace, shell-style comments are additionally
  allowed. They are terminated by the first carriage-return or line-feed
  character, after which more white-space and comments are allowed.
  
    [
       1, # this comment not allowed in JSON
          # neither this one...
    ]
  
  =back
  
  =head2 canonical
  
      $json = $json->canonical([$enable])
      
      $enabled = $json->get_canonical
  
  If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
  by sorting their keys. This is adding a comparatively high overhead.
  
  If C<$enable> is false, then the C<encode> method will output key-value
  pairs in the order Perl stores them (which will likely change between runs
  of the same script, and can change even within the same run from 5.18
  onwards).
  
  This option is useful if you want the same data structure to be encoded as
  the same JSON text (given the same overall settings). If it is disabled,
  the same hash might be encoded differently even if contains the same data,
  as key-value pairs have no inherent ordering in Perl.
  
  This setting has no effect when decoding JSON texts.
  
  This setting has currently no effect on tied hashes.
  
  =head2 allow_nonref
  
      $json = $json->allow_nonref([$enable])
      
      $enabled = $json->get_allow_nonref
  
  If C<$enable> is true (or missing), then the C<encode> method can convert a
  non-reference into its corresponding string, number or null JSON value,
  which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
  values instead of croaking.
  
  If C<$enable> is false, then the C<encode> method will croak if it isn't
  passed an arrayref or hashref, as JSON texts must either be an object
  or array. Likewise, C<decode> will croak if given something that is not a
  JSON object or array.
  
  Example, encode a Perl scalar as JSON value with enabled C<allow_nonref>,
  resulting in an invalid JSON text:
  
     JSON->new->allow_nonref->encode ("Hello, World!")
     => "Hello, World!"
  
  =head2 allow_unknown
  
      $json = $json->allow_unknown ([$enable])
      
      $enabled = $json->get_allow_unknown
  
  If C<$enable> is true (or missing), then C<encode> will I<not> throw an
  exception when it encounters values it cannot represent in JSON (for
  example, filehandles) but instead will encode a JSON C<null> value. Note
  that blessed objects are not included here and are handled separately by
  c<allow_nonref>.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters anything it cannot encode as JSON.
  
  This option does not affect C<decode> in any way, and it is recommended to
  leave it off unless you know your communications partner.
  
  =head2 allow_blessed
  
      $json = $json->allow_blessed([$enable])
      
      $enabled = $json->get_allow_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then the C<encode> method will not
  barf when it encounters a blessed reference that it cannot convert
  otherwise. Instead, a JSON C<null> value is encoded instead of the object.
  
  If C<$enable> is false (the default), then C<encode> will throw an
  exception when it encounters a blessed object that it cannot convert
  otherwise.
  
  This setting has no effect on C<decode>.
  
  =head2 convert_blessed
  
      $json = $json->convert_blessed([$enable])
      
      $enabled = $json->get_convert_blessed
  
  See L<OBJECT SERIALISATION> for details.
  
  If C<$enable> is true (or missing), then C<encode>, upon encountering a
  blessed object, will check for the availability of the C<TO_JSON> method
  on the object's class. If found, it will be called in scalar context and
  the resulting scalar will be encoded instead of the object.
  
  The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
  returns other blessed objects, those will be handled in the same
  way. C<TO_JSON> must take care of not causing an endless recursion cycle
  (== crash) in this case. The name of C<TO_JSON> was chosen because other
  methods called by the Perl core (== not by the user of the object) are
  usually in upper case letters and to avoid collisions with any C<to_json>
  function or method.
  
  If C<$enable> is false (the default), then C<encode> will not consider
  this type of conversion.
  
  This setting has no effect on C<decode>.
  
  =head2 filter_json_object
  
      $json = $json->filter_json_object([$coderef])
  
  When C<$coderef> is specified, it will be called from C<decode> each
  time it decodes a JSON object. The only argument is a reference to the
  newly-created hash. If the code references returns a single scalar (which
  need not be a reference), this value (i.e. a copy of that scalar to avoid
  aliasing) is inserted into the deserialised data structure. If it returns
  an empty list (NOTE: I<not> C<undef>, which is a valid scalar), the
  original deserialised hash will be inserted. This setting can slow down
  decoding considerably.
  
  When C<$coderef> is omitted or undefined, any existing callback will
  be removed and C<decode> will not change the deserialised hash in any
  way.
  
  Example, convert all JSON objects into the integer 5:
  
     my $js = JSON->new->filter_json_object (sub { 5 });
     # returns [5]
     $js->decode ('[{}]'); # the given subroutine takes a hash reference.
     # throw an exception because allow_nonref is not enabled
     # so a lone 5 is not allowed.
     $js->decode ('{"a":1, "b":2}');
  
  =head2 filter_json_single_key_object
  
      $json = $json->filter_json_single_key_object($key [=> $coderef])
  
  Works remotely similar to C<filter_json_object>, but is only called for
  JSON objects having a single key named C<$key>.
  
  This C<$coderef> is called before the one specified via
  C<filter_json_object>, if any. It gets passed the single value in the JSON
  object. If it returns a single value, it will be inserted into the data
  structure. If it returns nothing (not even C<undef> but the empty list),
  the callback from C<filter_json_object> will be called next, as if no
  single-key callback were specified.
  
  If C<$coderef> is omitted or undefined, the corresponding callback will be
  disabled. There can only ever be one callback for a given key.
  
  As this callback gets called less often then the C<filter_json_object>
  one, decoding speed will not usually suffer as much. Therefore, single-key
  objects make excellent targets to serialise Perl objects into, especially
  as single-key JSON objects are as close to the type-tagged value concept
  as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
  support this in any way, so you need to make sure your data never looks
  like a serialised Perl hash.
  
  Typical names for the single object key are C<__class_whatever__>, or
  C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
  things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
  with real hashes.
  
  Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
  into the corresponding C<< $WIDGET{<id>} >> object:
  
     # return whatever is in $WIDGET{5}:
     JSON
        ->new
        ->filter_json_single_key_object (__widget__ => sub {
              $WIDGET{ $_[0] }
           })
        ->decode ('{"__widget__": 5')
  
     # this can be used with a TO_JSON method in some "widget" class
     # for serialisation to json:
     sub WidgetBase::TO_JSON {
        my ($self) = @_;
  
        unless ($self->{id}) {
           $self->{id} = ..get..some..id..;
           $WIDGET{$self->{id}} = $self;
        }
  
        { __widget__ => $self->{id} }
     }
  
  =head2 max_depth
  
      $json = $json->max_depth([$maximum_nesting_depth])
      
      $max_depth = $json->get_max_depth
  
  Sets the maximum nesting level (default C<512>) accepted while encoding
  or decoding. If a higher nesting level is detected in JSON text or a Perl
  data structure, then the encoder and decoder will stop and croak at that
  point.
  
  Nesting level is defined by number of hash- or arrayrefs that the encoder
  needs to traverse to reach a given point or the number of C<{> or C<[>
  characters without their matching closing parenthesis crossed to reach a
  given character in a string.
  
  Setting the maximum depth to one disallows any nesting, so that ensures
  that the object is only a single hash/object or array.
  
  If no argument is given, the highest possible setting will be used, which
  is rarely useful.
  
  =head2 max_size
  
      $json = $json->max_size([$maximum_string_size])
      
      $max_size = $json->get_max_size
  
  Set the maximum length a JSON text may have (in bytes) where decoding is
  being attempted. The default is C<0>, meaning no limit. When C<decode>
  is called on a string that is longer then this many bytes, it will not
  attempt to decode the string but throw an exception. This setting has no
  effect on C<encode> (yet).
  
  If no argument is given, the limit check will be deactivated (same as when
  C<0> is specified).
  
  =head2 encode
  
      $json_text = $json->encode($perl_scalar)
  
  Converts the given Perl value or data structure to its JSON
  representation. Croaks on error.
  
  =head2 decode
  
      $perl_scalar = $json->decode($json_text)
  
  The opposite of C<encode>: expects a JSON text and tries to parse it,
  returning the resulting simple scalar or reference. Croaks on error.
  
  =head2 decode_prefix
  
      ($perl_scalar, $characters) = $json->decode_prefix($json_text)
  
  This works like the C<decode> method, but instead of raising an exception
  when there is trailing garbage after the first JSON object, it will
  silently stop parsing there and return the number of characters consumed
  so far.
  
  This is useful if your JSON texts are not delimited by an outer protocol
  and you need to know where the JSON text ends.
  
     JSON->new->decode_prefix ("[1] the tail")
     => ([1], 3)
  
  =head1 ADDITIONAL METHODS
  
  The following methods are for this module only.
  
  =head2 backend
  
      $backend = $json->backend
  
  Since 2.92, C<backend> method returns an abstract backend module used currently,
  which should be JSON::Backend::XS (which inherits JSON::XS or Cpanel::JSON::XS),
  or JSON::Backend::PP (which inherits JSON::PP), not to monkey-patch the actual
  backend module globally.
  
  If you need to know what is used actually, use C<isa>, instead of string comparison.
  
  =head2 is_xs
  
      $boolean = $json->is_xs
  
  Returns true if the backend inherits JSON::XS or Cpanel::JSON::XS.
  
  =head2 is_pp
  
      $boolean = $json->is_pp
  
  Returns true if the backend inherits JSON::PP.
  
  =head2 property
  
      $settings = $json->property()
  
  Returns a reference to a hash that holds all the common flag settings.
  
      $json = $json->property('utf8' => 1)
      $value = $json->property('utf8') # 1
  
  You can use this to get/set a value of a particular flag.
  
  =head1 INCREMENTAL PARSING
  
  This section is also taken from JSON::XS.
  
  In some cases, there is the need for incremental parsing of JSON
  texts. While this module always has to keep both JSON text and resulting
  Perl data structure in memory at one time, it does allow you to parse a
  JSON stream incrementally. It does so by accumulating text until it has
  a full JSON object, which it then can decode. This process is similar to
  using C<decode_prefix> to see if a full JSON object is available, but
  is much more efficient (and can be implemented with a minimum of method
  calls).
  
  This module will only attempt to parse the JSON text once it is sure it
  has enough text to get a decisive result, using a very simple but
  truly incremental parser. This means that it sometimes won't stop as
  early as the full parser, for example, it doesn't detect mismatched
  parentheses. The only thing it guarantees is that it starts decoding as
  soon as a syntactically valid JSON text has been seen. This means you need
  to set resource limits (e.g. C<max_size>) to ensure the parser will stop
  parsing in the presence if syntax errors.
  
  The following methods implement this incremental parser.
  
  =head2 incr_parse
  
      $json->incr_parse( [$string] ) # void context
      
      $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
      
      @obj_or_empty = $json->incr_parse( [$string] ) # list context
  
  This is the central parsing function. It can both append new text and
  extract objects from the stream accumulated so far (both of these
  functions are optional).
  
  If C<$string> is given, then this string is appended to the already
  existing JSON fragment stored in the C<$json> object.
  
  After that, if the function is called in void context, it will simply
  return without doing anything further. This can be used to add more text
  in as many chunks as you want.
  
  If the method is called in scalar context, then it will try to extract
  exactly I<one> JSON object. If that is successful, it will return this
  object, otherwise it will return C<undef>. If there is a parse error,
  this method will croak just as C<decode> would do (one can then use
  C<incr_skip> to skip the erroneous part). This is the most common way of
  using the method.
  
  And finally, in list context, it will try to extract as many objects
  from the stream as it can find and return them, or the empty list
  otherwise. For this to work, there must be no separators (other than
  whitespace) between the JSON objects or arrays, instead they must be
  concatenated back-to-back. If an error occurs, an exception will be
  raised as in the scalar context case. Note that in this case, any
  previously-parsed JSON texts will be lost.
  
  Example: Parse some JSON arrays/objects in a given string and return
  them.
  
      my @objs = JSON->new->incr_parse ("[5][7][1,2]");
  
  =head2 incr_text
  
      $lvalue_string = $json->incr_text
  
  This method returns the currently stored JSON fragment as an lvalue, that
  is, you can manipulate it. This I<only> works when a preceding call to
  C<incr_parse> in I<scalar context> successfully returned an object. Under
  all other circumstances you must not call this function (I mean it.
  although in simple tests it might actually work, it I<will> fail under
  real world conditions). As a special exception, you can also call this
  method before having parsed anything.
  
  That means you can only use this function to look at or manipulate text
  before or after complete JSON objects, not while the parser is in the
  middle of parsing a JSON object.
  
  This function is useful in two cases: a) finding the trailing text after a
  JSON object or b) parsing multiple JSON objects separated by non-JSON text
  (such as commas).
  
  =head2 incr_skip
  
      $json->incr_skip
  
  This will reset the state of the incremental parser and will remove
  the parsed text from the input buffer so far. This is useful after
  C<incr_parse> died, in which case the input buffer and incremental parser
  state is left unchanged, to skip the text parsed so far and to reset the
  parse state.
  
  The difference to C<incr_reset> is that only text until the parse error
  occurred is removed.
  
  =head2 incr_reset
  
      $json->incr_reset
  
  This completely resets the incremental parser, that is, after this call,
  it will be as if the parser had never parsed anything.
  
  This is useful if you want to repeatedly parse JSON objects and want to
  ignore any trailing data, which means you have to reset the parser after
  each successful decode.
  
  =head1 MAPPING
  
  Most of this section is also taken from JSON::XS.
  
  This section describes how the backend modules map Perl values to JSON values and
  vice versa. These mappings are designed to "do the right thing" in most
  circumstances automatically, preserving round-tripping characteristics
  (what you put in comes out as something equivalent).
  
  For the more enlightened: note that in the following descriptions,
  lowercase I<perl> refers to the Perl interpreter, while uppercase I<Perl>
  refers to the abstract Perl language itself.
  
  =head2 JSON -> PERL
  
  =over 4
  
  =item object
  
  A JSON object becomes a reference to a hash in Perl. No ordering of object
  keys is preserved (JSON does not preserver object key ordering itself).
  
  =item array
  
  A JSON array becomes a reference to an array in Perl.
  
  =item string
  
  A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
  are represented by the same codepoints in the Perl string, so no manual
  decoding is necessary.
  
  =item number
  
  A JSON number becomes either an integer, numeric (floating point) or
  string scalar in perl, depending on its range and any fractional parts. On
  the Perl level, there is no difference between those as Perl handles all
  the conversion details, but an integer may take slightly less memory and
  might represent more values exactly than floating point numbers.
  
  If the number consists of digits only, this module will try to represent
  it as an integer value. If that fails, it will try to represent it as
  a numeric (floating point) value if that is possible without loss of
  precision. Otherwise it will preserve the number as a string value (in
  which case you lose roundtripping ability, as the JSON number will be
  re-encoded to a JSON string).
  
  Numbers containing a fractional or exponential part will always be
  represented as numeric (floating point) values, possibly at a loss of
  precision (in which case you might lose perfect roundtripping ability, but
  the JSON number will still be re-encoded as a JSON number).
  
  Note that precision is not accuracy - binary floating point values cannot
  represent most decimal fractions exactly, and when converting from and to
  floating point, this module only guarantees precision up to but not including
  the least significant bit.
  
  =item true, false
  
  These JSON atoms become C<JSON::true> and C<JSON::false>,
  respectively. They are overloaded to act almost exactly like the numbers
  C<1> and C<0>. You can check whether a scalar is a JSON boolean by using
  the C<JSON::is_bool> function.
  
  =item null
  
  A JSON null atom becomes C<undef> in Perl.
  
  =item shell-style comments (C<< # I<text> >>)
  
  As a nonstandard extension to the JSON syntax that is enabled by the
  C<relaxed> setting, shell-style comments are allowed. They can start
  anywhere outside strings and go till the end of the line.
  
  =back
  
  
  =head2 PERL -> JSON
  
  The mapping from Perl to JSON is slightly more difficult, as Perl is a
  truly typeless language, so we can only guess which JSON type is meant by
  a Perl value.
  
  =over 4
  
  =item hash references
  
  Perl hash references become JSON objects. As there is no inherent
  ordering in hash keys (or JSON objects), they will usually be encoded
  in a pseudo-random order. This module can optionally sort the hash keys
  (determined by the I<canonical> flag), so the same data structure will
  serialise to the same JSON text (given same settings and version of
  the same backend), but this incurs a runtime overhead and is only rarely useful,
  e.g. when you want to compare some JSON text against another for equality.
  
  =item array references
  
  Perl array references become JSON arrays.
  
  =item other references
  
  Other unblessed references are generally not allowed and will cause an
  exception to be thrown, except for references to the integers C<0> and
  C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
  also use C<JSON::false> and C<JSON::true> to improve readability.
  
     encode_json [\0,JSON::true]      # yields [false,true]
  
  =item JSON::true, JSON::false, JSON::null
  
  These special values become JSON true and JSON false values,
  respectively. You can also use C<\1> and C<\0> directly if you want.
  
  =item blessed objects
  
  Blessed objects are not directly representable in JSON, but C<JSON::XS>
  allows various ways of handling objects. See L<OBJECT SERIALISATION>,
  below, for details.
  
  =item simple scalars
  
  Simple Perl scalars (any scalar that is not a reference) are the most
  difficult objects to encode: this module will encode undefined scalars as
  JSON C<null> values, scalars that have last been used in a string context
  before encoding as JSON strings, and anything else as number value:
  
     # dump as number
     encode_json [2]                      # yields [2]
     encode_json [-3.0e17]                # yields [-3e+17]
     my $value = 5; encode_json [$value]  # yields [5]
  
     # used as string, so dump as string
     print $value;
     encode_json [$value]                 # yields ["5"]
  
     # undef becomes null
     encode_json [undef]                  # yields [null]
  
  You can force the type to be a string by stringifying it:
  
     my $x = 3.1; # some variable containing a number
     "$x";        # stringified
     $x .= "";    # another, more awkward way to stringify
     print $x;    # perl does it for you, too, quite often
  
  You can force the type to be a number by numifying it:
  
     my $x = "3"; # some variable containing a string
     $x += 0;     # numify it, ensuring it will be dumped as a number
     $x *= 1;     # same thing, the choice is yours.
  
  You can not currently force the type in other, less obscure, ways. Tell me
  if you need this capability (but don't forget to explain why it's needed
  :).
  
  Note that numerical precision has the same meaning as under Perl (so
  binary to decimal conversion follows the same rules as in Perl, which
  can differ to other languages). Also, your perl interpreter might expose
  extensions to the floating point numbers of your platform, such as
  infinities or NaN's - these cannot be represented in JSON, and it is an
  error to pass those in.
  
  =back
  
  =head2 OBJECT SERIALISATION
  
  As for Perl objects, this module only supports a pure JSON representation
  (without the ability to deserialise the object automatically again).
  
  =head3 SERIALISATION
  
  What happens when this module encounters a Perl object depends on the
  C<allow_blessed> and C<convert_blessed> settings, which are used in
  this order:
  
  =over 4
  
  =item 1. C<convert_blessed> is enabled and the object has a C<TO_JSON> method.
  
  In this case, the C<TO_JSON> method of the object is invoked in scalar
  context. It must return a single scalar that can be directly encoded into
  JSON. This scalar replaces the object in the JSON text.
  
  For example, the following C<TO_JSON> method will convert all L<URI>
  objects to JSON strings when serialised. The fact that these values
  originally were L<URI> objects is lost.
  
     sub URI::TO_JSON {
        my ($uri) = @_;
        $uri->as_string
     }
  
  =item 2. C<allow_blessed> is enabled.
  
  The object will be serialised as a JSON null value.
  
  =item 3. none of the above
  
  If none of the settings are enabled or the respective methods are missing,
  this module throws an exception.
  
  =back
  
  =head1 ENCODING/CODESET FLAG NOTES
  
  This section is taken from JSON::XS.
  
  The interested reader might have seen a number of flags that signify
  encodings or codesets - C<utf8>, C<latin1> and C<ascii>. There seems to be
  some confusion on what these do, so here is a short comparison:
  
  C<utf8> controls whether the JSON text created by C<encode> (and expected
  by C<decode>) is UTF-8 encoded or not, while C<latin1> and C<ascii> only
  control whether C<encode> escapes character values outside their respective
  codeset range. Neither of these flags conflict with each other, although
  some combinations make less sense than others.
  
  Care has been taken to make all flags symmetrical with respect to
  C<encode> and C<decode>, that is, texts encoded with any combination of
  these flag values will be correctly decoded when the same flags are used
  - in general, if you use different flag settings while encoding vs. when
  decoding you likely have a bug somewhere.
  
  Below comes a verbose discussion of these flags. Note that a "codeset" is
  simply an abstract set of character-codepoint pairs, while an encoding
  takes those codepoint numbers and I<encodes> them, in our case into
  octets. Unicode is (among other things) a codeset, UTF-8 is an encoding,
  and ISO-8859-1 (= latin 1) and ASCII are both codesets I<and> encodings at
  the same time, which can be confusing.
  
  =over 4
  
  =item C<utf8> flag disabled
  
  When C<utf8> is disabled (the default), then C<encode>/C<decode> generate
  and expect Unicode strings, that is, characters with high ordinal Unicode
  values (> 255) will be encoded as such characters, and likewise such
  characters are decoded as-is, no changes to them will be done, except
  "(re-)interpreting" them as Unicode codepoints or Unicode characters,
  respectively (to Perl, these are the same thing in strings unless you do
  funny/weird/dumb stuff).
  
  This is useful when you want to do the encoding yourself (e.g. when you
  want to have UTF-16 encoded JSON texts) or when some other layer does
  the encoding for you (for example, when printing to a terminal using a
  filehandle that transparently encodes to UTF-8 you certainly do NOT want
  to UTF-8 encode your data first and have Perl encode it another time).
  
  =item C<utf8> flag enabled
  
  If the C<utf8>-flag is enabled, C<encode>/C<decode> will encode all
  characters using the corresponding UTF-8 multi-byte sequence, and will
  expect your input strings to be encoded as UTF-8, that is, no "character"
  of the input string must have any value > 255, as UTF-8 does not allow
  that.
  
  The C<utf8> flag therefore switches between two modes: disabled means you
  will get a Unicode string in Perl, enabled means you get an UTF-8 encoded
  octet/binary string in Perl.
  
  =item C<latin1> or C<ascii> flags enabled
  
  With C<latin1> (or C<ascii>) enabled, C<encode> will escape characters
  with ordinal values > 255 (> 127 with C<ascii>) and encode the remaining
  characters as specified by the C<utf8> flag.
  
  If C<utf8> is disabled, then the result is also correctly encoded in those
  character sets (as both are proper subsets of Unicode, meaning that a
  Unicode string with all character values < 256 is the same thing as a
  ISO-8859-1 string, and a Unicode string with all character values < 128 is
  the same thing as an ASCII string in Perl).
  
  If C<utf8> is enabled, you still get a correct UTF-8-encoded string,
  regardless of these flags, just some more characters will be escaped using
  C<\uXXXX> then before.
  
  Note that ISO-8859-1-I<encoded> strings are not compatible with UTF-8
  encoding, while ASCII-encoded strings are. That is because the ISO-8859-1
  encoding is NOT a subset of UTF-8 (despite the ISO-8859-1 I<codeset> being
  a subset of Unicode), while ASCII is.
  
  Surprisingly, C<decode> will ignore these flags and so treat all input
  values as governed by the C<utf8> flag. If it is disabled, this allows you
  to decode ISO-8859-1- and ASCII-encoded strings, as both strict subsets of
  Unicode. If it is enabled, you can correctly decode UTF-8 encoded strings.
  
  So neither C<latin1> nor C<ascii> are incompatible with the C<utf8> flag -
  they only govern when the JSON output engine escapes a character or not.
  
  The main use for C<latin1> is to relatively efficiently store binary data
  as JSON, at the expense of breaking compatibility with most JSON decoders.
  
  The main use for C<ascii> is to force the output to not contain characters
  with values > 127, which means you can interpret the resulting string
  as UTF-8, ISO-8859-1, ASCII, KOI8-R or most about any character set and
  8-bit-encoding, and still get the same data structure back. This is useful
  when your channel for JSON transfer is not 8-bit clean or the encoding
  might be mangled in between (e.g. in mail), and works because ASCII is a
  proper subset of most 8-bit and multibyte encodings in use in the world.
  
  =back
  
  =head1 BACKWARD INCOMPATIBILITY
  
  Since version 2.90, stringification (and string comparison) for
  C<JSON::true> and C<JSON::false> has not been overloaded. It shouldn't
  matter as long as you treat them as boolean values, but a code that
  expects they are stringified as "true" or "false" doesn't work as
  you have expected any more.
  
      if (JSON::true eq 'true') {  # now fails
  
      print "The result is $JSON::true now."; # => The result is 1 now.
  
  And now these boolean values don't inherit JSON::Boolean, either.
  When you need to test a value is a JSON boolean value or not, use
  C<JSON::is_bool> function, instead of testing the value inherits
  a particular boolean class or not.
  
  =head1 BUGS
  
  Please report bugs on backend selection and additional features
  this module provides to RT or GitHub issues for this module:
  
  =over 4
  
  =item https://rt.cpan.org/Public/Dist/Display.html?Queue=JSON
  
  =item https://github.com/makamaka/JSON/issues
  
  =back
  
  Please report bugs and feature requests on decoding/encoding
  and boolean behaviors to the author of the backend module you
  are using.
  
  =head1 SEE ALSO
  
  L<JSON::XS>, L<Cpanel::JSON::XS>, L<JSON::PP> for backends.
  
  L<JSON::MaybeXS>, an alternative that prefers Cpanel::JSON::XS.
  
  C<RFC4627>(L<http://www.ietf.org/rfc/rfc4627.txt>)
  
  =head1 AUTHOR
  
  Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>
  
  JSON::XS was written by  Marc Lehmann <schmorp[at]schmorp.de>
  
  The release of this new version owes to the courtesy of Marc Lehmann.
  
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright 2005-2013 by Makamaka Hannyaharamitu
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself. 
  
  =cut
  
JSON

$fatpacked{"JSON/backportPP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP';
  package JSON::PP;use 5.005;use strict;use Exporter ();BEGIN {@JSON::backportPP::ISA=('Exporter')}use overload ();use JSON::backportPP::Boolean;use Carp ();$JSON::backportPP::VERSION='0.05';@JSON::PP::EXPORT=qw(encode_json decode_json from_json to_json);use constant P_ASCII=>0;use constant P_LATIN1=>1;use constant P_UTF8=>2;use constant P_INDENT=>3;use constant P_CANONICAL=>4;use constant P_SPACE_BEFORE=>5;use constant P_SPACE_AFTER=>6;use constant P_ALLOW_NONREF=>7;use constant P_SHRINK=>8;use constant P_ALLOW_BLESSED=>9;use constant P_CONVERT_BLESSED=>10;use constant P_RELAXED=>11;use constant P_LOOSE=>12;use constant P_ALLOW_BIGNUM=>13;use constant P_ALLOW_BAREKEY=>14;use constant P_ALLOW_SINGLEQUOTE=>15;use constant P_ESCAPE_SLASH=>16;use constant P_AS_NONBLESSED=>17;use constant P_ALLOW_UNKNOWN=>18;use constant OLD_PERL=>$] < 5.008 ? 1 : 0;use constant USE_B=>0;BEGIN {if (USE_B){require B}}BEGIN {my@xs_compati_bit_properties=qw(latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink allow_blessed convert_blessed relaxed allow_unknown);my@pp_bit_properties=qw(allow_singlequote allow_bignum loose allow_barekey escape_slash as_nonblessed);if (OLD_PERL){my$helper=$] >= 5.006 ? 'JSON::backportPP::Compat5006' : 'JSON::backportPP::Compat5005';eval qq| require $helper |;if ($@){Carp::croak $@}}for my$name (@xs_compati_bit_properties,@pp_bit_properties){my$property_id='P_' .uc($name);eval qq/
              sub $name {
                  my \$enable = defined \$_[1] ? \$_[1] : 1;
  
                  if (\$enable) {
                      \$_[0]->{PROPS}->[$property_id] = 1;
                  }
                  else {
                      \$_[0]->{PROPS}->[$property_id] = 0;
                  }
  
                  \$_[0];
              }
  
              sub get_$name {
                  \$_[0]->{PROPS}->[$property_id] ? 1 : '';
              }
          /}}my$JSON;sub encode_json ($) {($JSON ||= __PACKAGE__->new->utf8)->encode(@_)}sub decode_json {($JSON ||= __PACKAGE__->new->utf8)->decode(@_)}sub to_json($) {Carp::croak ("JSON::PP::to_json has been renamed to encode_json.")}sub from_json($) {Carp::croak ("JSON::PP::from_json has been renamed to decode_json.")}sub new {my$class=shift;my$self={max_depth=>512,max_size=>0,indent_length=>3,};bless$self,$class}sub encode {return $_[0]->PP_encode_json($_[1])}sub decode {return $_[0]->PP_decode_json($_[1],0x00000000)}sub decode_prefix {return $_[0]->PP_decode_json($_[1],0x00000001)}sub pretty {my ($self,$v)=@_;my$enable=defined$v ? $v : 1;if ($enable){$self->indent(1)->space_before(1)->space_after(1)}else {$self->indent(0)->space_before(0)->space_after(0)}$self}sub max_depth {my$max=defined $_[1]? $_[1]: 0x80000000;$_[0]->{max_depth}=$max;$_[0]}sub get_max_depth {$_[0]->{max_depth}}sub max_size {my$max=defined $_[1]? $_[1]: 0;$_[0]->{max_size}=$max;$_[0]}sub get_max_size {$_[0]->{max_size}}sub filter_json_object {if (defined $_[1]and ref $_[1]eq 'CODE'){$_[0]->{cb_object}=$_[1]}else {delete $_[0]->{cb_object}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub filter_json_single_key_object {if (@_==1 or @_ > 3){Carp::croak("Usage: JSON::PP::filter_json_single_key_object(self, key, callback = undef)")}if (defined $_[2]and ref $_[2]eq 'CODE'){$_[0]->{cb_sk_object}->{$_[1]}=$_[2]}else {delete $_[0]->{cb_sk_object}->{$_[1]};delete $_[0]->{cb_sk_object}unless %{$_[0]->{cb_sk_object}|| {}}}$_[0]->{F_HOOK}=($_[0]->{cb_object}or $_[0]->{cb_sk_object})? 1 : 0;$_[0]}sub indent_length {if (!defined $_[1]or $_[1]> 15 or $_[1]< 0){Carp::carp "The acceptable range of indent_length() is 0 to 15."}else {$_[0]->{indent_length}=$_[1]}$_[0]}sub get_indent_length {$_[0]->{indent_length}}sub sort_by {$_[0]->{sort_by}=defined $_[1]? $_[1]: 1;$_[0]}sub allow_bigint {Carp::carp("allow_bigint() is obsoleted. use allow_bignum() instead.");$_[0]->allow_bignum}{my$max_depth;my$indent;my$ascii;my$latin1;my$utf8;my$space_before;my$space_after;my$canonical;my$allow_blessed;my$convert_blessed;my$indent_length;my$escape_slash;my$bignum;my$as_nonblessed;my$depth;my$indent_count;my$keysort;sub PP_encode_json {my$self=shift;my$obj=shift;$indent_count=0;$depth=0;my$props=$self->{PROPS};($ascii,$latin1,$utf8,$indent,$canonical,$space_before,$space_after,$allow_blessed,$convert_blessed,$escape_slash,$bignum,$as_nonblessed)=@{$props}[P_ASCII .. P_SPACE_AFTER,P_ALLOW_BLESSED,P_CONVERT_BLESSED,P_ESCAPE_SLASH,P_ALLOW_BIGNUM,P_AS_NONBLESSED];($max_depth,$indent_length)=@{$self}{qw/max_depth indent_length/};$keysort=$canonical ? sub {$a cmp $b}: undef;if ($self->{sort_by}){$keysort=ref($self->{sort_by})eq 'CODE' ? $self->{sort_by}: $self->{sort_by}=~ /\D+/ ? $self->{sort_by}: sub {$a cmp $b}}encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")if(!ref$obj and!$props->[P_ALLOW_NONREF ]);my$str=$self->object_to_json($obj);$str .= "\n" if ($indent);unless ($ascii or $latin1 or $utf8){utf8::upgrade($str)}if ($props->[P_SHRINK ]){utf8::downgrade($str,1)}return$str}sub object_to_json {my ($self,$obj)=@_;my$type=ref($obj);if($type eq 'HASH'){return$self->hash_to_json($obj)}elsif($type eq 'ARRAY'){return$self->array_to_json($obj)}elsif ($type){if (blessed($obj)){return$self->value_to_json($obj)if ($obj->isa('JSON::PP::Boolean'));if ($convert_blessed and $obj->can('TO_JSON')){my$result=$obj->TO_JSON();if (defined$result and ref($result)){if (refaddr($obj)eq refaddr($result)){encode_error(sprintf("%s::TO_JSON method returned same object as was passed instead of a new one",ref$obj))}}return$self->object_to_json($result)}return "$obj" if ($bignum and _is_bignum($obj));if ($allow_blessed){return$self->blessed_to_json($obj)if ($as_nonblessed);return 'null'}encode_error(sprintf("encountered object '%s', but neither allow_blessed " ."nor convert_blessed settings are enabled",$obj))}else {return$self->value_to_json($obj)}}else{return$self->value_to_json($obj)}}sub hash_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');my$del=($space_before ? ' ' : '').':' .($space_after ? ' ' : '');for my$k (_sort($obj)){if (OLD_PERL){utf8::decode($k)}push@res,$self->string_to_json($k).$del .(ref$obj->{$k}? $self->object_to_json($obj->{$k}): $self->value_to_json($obj->{$k}))}--$depth;$self->_down_indent()if ($indent);return '{}' unless@res;return '{' .$pre .join(",$pre",@res).$post .'}'}sub array_to_json {my ($self,$obj)=@_;my@res;encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")if (++$depth > $max_depth);my ($pre,$post)=$indent ? $self->_up_indent(): ('','');for my$v (@$obj){push@res,ref($v)? $self->object_to_json($v): $self->value_to_json($v)}--$depth;$self->_down_indent()if ($indent);return '[]' unless@res;return '[' .$pre .join(",$pre",@res).$post .']'}sub _looks_like_number {my$value=shift;if (USE_B){my$b_obj=B::svref_2object(\$value);my$flags=$b_obj->FLAGS;return 1 if$flags & (B::SVp_IOK()| B::SVp_NOK())and!($flags & B::SVp_POK());return}else {no warnings 'numeric';return if utf8::is_utf8($value);return unless length((my$dummy="")& $value);return unless 0 + $value eq $value;return 1 if$value * 0==0;return -1}}sub value_to_json {my ($self,$value)=@_;return 'null' if(!defined$value);my$type=ref($value);if (!$type){if (_looks_like_number($value)){return$value}return$self->string_to_json($value)}elsif(blessed($value)and $value->isa('JSON::PP::Boolean')){return $$value==1 ? 'true' : 'false'}else {if ((overload::StrVal($value)=~ /=(\w+)/)[0]){return$self->value_to_json("$value")}if ($type eq 'SCALAR' and defined $$value){return $$value eq '1' ? 'true' : $$value eq '0' ? 'false' : $self->{PROPS}->[P_ALLOW_UNKNOWN ]? 'null' : encode_error("cannot encode reference to scalar")}if ($self->{PROPS}->[P_ALLOW_UNKNOWN ]){return 'null'}else {if ($type eq 'SCALAR' or $type eq 'REF'){encode_error("cannot encode reference to scalar")}else {encode_error("encountered $value, but JSON can only represent references to arrays or hashes")}}}}my%esc=("\n"=>'\n',"\r"=>'\r',"\t"=>'\t',"\f"=>'\f',"\b"=>'\b',"\""=>'\"',"\\"=>'\\\\',"\'"=>'\\\'',);sub string_to_json {my ($self,$arg)=@_;$arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;$arg =~ s/\//\\\//g if ($escape_slash);$arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;if ($ascii){$arg=JSON_PP_encode_ascii($arg)}if ($latin1){$arg=JSON_PP_encode_latin1($arg)}if ($utf8){utf8::encode($arg)}return '"' .$arg .'"'}sub blessed_to_json {my$reftype=reftype($_[1])|| '';if ($reftype eq 'HASH'){return $_[0]->hash_to_json($_[1])}elsif ($reftype eq 'ARRAY'){return $_[0]->array_to_json($_[1])}else {return 'null'}}sub encode_error {my$error=shift;Carp::croak "$error"}sub _sort {defined$keysort ? (sort$keysort (keys %{$_[0]})): keys %{$_[0]}}sub _up_indent {my$self=shift;my$space=' ' x $indent_length;my ($pre,$post)=('','');$post="\n" .$space x $indent_count;$indent_count++;$pre="\n" .$space x $indent_count;return ($pre,$post)}sub _down_indent {$indent_count--}sub PP_encode_box {{depth=>$depth,indent_count=>$indent_count,}}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',_encode_surrogates($_))}unpack('U*',$_[0]))}sub _encode_surrogates {my$uni=$_[0]- 0x10000;return ($uni / 0x400 + 0xD800,$uni % 0x400 + 0xDC00)}sub _is_bignum {$_[0]->isa('Math::BigInt')or $_[0]->isa('Math::BigFloat')}my$max_intsize;BEGIN {my$checkint=1111;for my$d (5..64){$checkint .= 1;my$int=eval qq| $checkint |;if ($int =~ /[eE]/){$max_intsize=$d - 1;last}}}{my%escapes=(b=>"\x8",t=>"\x9",n=>"\xA",f=>"\xC",r=>"\xD",'\\'=>'\\','"'=>'"','/'=>'/',);my$text;my$at;my$ch;my$len;my$depth;my$encoding;my$is_valid_utf8;my$utf8_len;my$utf8;my$max_depth;my$max_size;my$relaxed;my$cb_object;my$cb_sk_object;my$F_HOOK;my$allow_bignum;my$singlequote;my$loose;my$allow_barekey;sub _detect_utf_encoding {my$text=shift;my@octets=unpack('C4',$text);return 'unknown' unless defined$octets[3];return ($octets[0]and $octets[1])? 'UTF-8' : (!$octets[0]and $octets[1])? 'UTF-16BE' : (!$octets[0]and!$octets[1])? 'UTF-32BE' : ($octets[2])? 'UTF-16LE' : (!$octets[2])? 'UTF-32LE' : 'unknown'}sub PP_decode_json {my ($self,$want_offset);($self,$text,$want_offset)=@_;($at,$ch,$depth)=(0,'',0);if (!defined$text or ref$text){decode_error("malformed JSON string, neither array, object, number, string or atom")}my$props=$self->{PROPS};($utf8,$relaxed,$loose,$allow_bignum,$allow_barekey,$singlequote)=@{$props}[P_UTF8,P_RELAXED,P_LOOSE .. P_ALLOW_SINGLEQUOTE];if ($utf8){$encoding=_detect_utf_encoding($text);if ($encoding ne 'UTF-8' and $encoding ne 'unknown'){require Encode;Encode::from_to($text,$encoding,'utf-8')}else {utf8::downgrade($text,1)or Carp::croak("Wide character in subroutine entry")}}else {utf8::upgrade($text);utf8::encode($text)}$len=length$text;($max_depth,$max_size,$cb_object,$cb_sk_object,$F_HOOK)=@{$self}{qw/max_depth max_size cb_object cb_sk_object F_HOOK/};if ($max_size > 1){use bytes;my$bytes=length$text;decode_error(sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s" ,$bytes,$max_size),1)if ($bytes > $max_size)}white();decode_error("malformed JSON string, neither array, object, number, string or atom")unless defined$ch;my$result=value();if (!$props->[P_ALLOW_NONREF ]and!ref$result){decode_error('JSON text must be an object or array (but found number, string, true, false or null,' .' use allow_nonref to allow this)',1)}Carp::croak('something wrong.')if$len < $at;my$consumed=defined$ch ? $at - 1 : $at;white();return ($result,$consumed)if$want_offset;decode_error("garbage after JSON object")if defined$ch;$result}sub next_chr {return$ch=undef if($at >= $len);$ch=substr($text,$at++,1)}sub value {white();return if(!defined$ch);return object()if($ch eq '{');return array()if($ch eq '[');return string()if($ch eq '"' or ($singlequote and $ch eq "'"));return number()if($ch =~ /[0-9]/ or $ch eq '-');return word()}sub string {my$utf16;my$is_utf8;($is_valid_utf8,$utf8_len)=('',0);my$s='';if($ch eq '"' or ($singlequote and $ch eq "'")){my$boundChar=$ch;OUTER: while(defined(next_chr())){if($ch eq $boundChar){next_chr();if ($utf16){decode_error("missing low surrogate character in surrogate pair")}utf8::decode($s)if($is_utf8);return$s}elsif($ch eq '\\'){next_chr();if(exists$escapes{$ch}){$s .= $escapes{$ch}}elsif($ch eq 'u'){my$u='';for(1..4){$ch=next_chr();last OUTER if($ch !~ /[0-9a-fA-F]/);$u .= $ch}if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/){$utf16=$u}elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/){unless (defined$utf16){decode_error("missing high surrogate character in surrogate pair")}$is_utf8=1;$s .= JSON_PP_decode_surrogates($utf16,$u)|| next;$utf16=undef}else {if (defined$utf16){decode_error("surrogate pair expected")}if ((my$hex=hex($u))> 127){$is_utf8=1;$s .= JSON_PP_decode_unicode($u)|| next}else {$s .= chr$hex}}}else{unless ($loose){$at -= 2;decode_error('illegal backslash escape sequence in string')}$s .= $ch}}else{if (ord$ch > 127){unless($ch=is_valid_utf8($ch)){$at -= 1;decode_error("malformed UTF-8 character in JSON string")}else {$at += $utf8_len - 1}$is_utf8=1}if (!$loose){if ($ch =~ /[\x00-\x1f\x22\x5c]/){$at--;decode_error('invalid character encountered while parsing JSON string')}}$s .= $ch}}}decode_error("unexpected end of string while parsing JSON string")}sub white {while(defined$ch){if($ch eq '' or $ch =~ /\A[ \t\r\n]\z/){next_chr()}elsif($relaxed and $ch eq '/'){next_chr();if(defined$ch and $ch eq '/'){1 while(defined(next_chr())and $ch ne "\n" and $ch ne "\r")}elsif(defined$ch and $ch eq '*'){next_chr();while(1){if(defined$ch){if($ch eq '*'){if(defined(next_chr())and $ch eq '/'){next_chr();last}}else{next_chr()}}else{decode_error("Unterminated comment")}}next}else{$at--;decode_error("malformed JSON string, neither array, object, number, string or atom")}}else{if ($relaxed and $ch eq '#'){pos($text)=$at;$text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;$at=pos($text);next_chr;next}last}}}sub array {my$a=$_[0]|| [];decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq ']'){--$depth;next_chr();return$a}else {while(defined($ch)){push @$a,value();white();if (!defined$ch){last}if($ch eq ']'){--$depth;next_chr();return$a}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq ']'){--$depth;next_chr();return$a}}}$at-- if defined$ch and $ch ne '';decode_error(", or ] expected while parsing array")}sub object {my$o=$_[0]|| {};my$k;decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')if (++$depth > $max_depth);next_chr();white();if(defined$ch and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}else {while (defined$ch){$k=($allow_barekey and $ch ne '"' and $ch ne "'")? bareKey(): string();white();if(!defined$ch or $ch ne ':'){$at--;decode_error("':' expected")}next_chr();$o->{$k}=value();white();last if (!defined$ch);if($ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}if($ch ne ','){last}next_chr();white();if ($relaxed and $ch eq '}'){--$depth;next_chr();if ($F_HOOK){return _json_object_hook($o)}return$o}}}$at-- if defined$ch and $ch ne '';decode_error(", or } expected while parsing object/hash")}sub bareKey {my$key;while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){$key .= $ch;next_chr()}return$key}sub word {my$word=substr($text,$at-1,4);if($word eq 'true'){$at += 3;next_chr;return$JSON::PP::true}elsif($word eq 'null'){$at += 3;next_chr;return undef}elsif($word eq 'fals'){$at += 3;if(substr($text,$at,1)eq 'e'){$at++;next_chr;return$JSON::PP::false}}$at--;decode_error("'null' expected")if ($word =~ /^n/);decode_error("'true' expected")if ($word =~ /^t/);decode_error("'false' expected")if ($word =~ /^f/);decode_error("malformed JSON string, neither array, object, number, string or atom")}sub number {my$n='';my$v;my$is_dec;my$is_exp;if($ch eq '-'){$n='-';next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after initial minus)")}}if($ch eq '0'){my$peek=substr($text,$at,1);if($peek =~ /^[0-9a-dfA-DF]/){decode_error("malformed number (leading zero must not be followed by another digit)")}$n .= $ch;next_chr}while(defined$ch and $ch =~ /\d/){$n .= $ch;next_chr}if(defined$ch and $ch eq '.'){$n .= '.';$is_dec=1;next_chr;if (!defined$ch or $ch !~ /\d/){decode_error("malformed number (no digits after decimal point)")}else {$n .= $ch}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}if(defined$ch and ($ch eq 'e' or $ch eq 'E')){$n .= $ch;$is_exp=1;next_chr;if(defined($ch)and ($ch eq '+' or $ch eq '-')){$n .= $ch;next_chr;if (!defined$ch or $ch =~ /\D/){decode_error("malformed number (no digits after exp sign)")}$n .= $ch}elsif(defined($ch)and $ch =~ /\d/){$n .= $ch}else {decode_error("malformed number (no digits after exp sign)")}while(defined(next_chr)and $ch =~ /\d/){$n .= $ch}}$v .= $n;if ($is_dec or $is_exp){if ($allow_bignum){require Math::BigFloat;return Math::BigFloat->new($v)}}else {if (length$v > $max_intsize){if ($allow_bignum){require Math::BigInt;return Math::BigInt->new($v)}else {return "$v"}}}return$is_dec ? $v/1.0 : 0+$v}sub is_valid_utf8 {$utf8_len=$_[0]=~ /[\x00-\x7F]/ ? 1 : $_[0]=~ /[\xC2-\xDF]/ ? 2 : $_[0]=~ /[\xE0-\xEF]/ ? 3 : $_[0]=~ /[\xF0-\xF4]/ ? 4 : 0 ;return unless$utf8_len;my$is_valid_utf8=substr($text,$at - 1,$utf8_len);return ($is_valid_utf8 =~ /^(?:
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
          )$/x)? $is_valid_utf8 : ''}sub decode_error {my$error=shift;my$no_rep=shift;my$str=defined$text ? substr($text,$at): '';my$mess='';my$type='U*';if (OLD_PERL){my$type=$] < 5.006 ? 'C*' : utf8::is_utf8($str)? 'U*' : 'C*' }for my$c (unpack($type,$str)){$mess .= $c==0x07 ? '\a' : $c==0x09 ? '\t' : $c==0x0a ? '\n' : $c==0x0d ? '\r' : $c==0x0c ? '\f' : $c < 0x20 ? sprintf('\x{%x}',$c): $c==0x5c ? '\\\\' : $c < 0x80 ? chr($c): sprintf('\x{%x}',$c);if (length$mess >= 20){$mess .= '...';last}}unless (length$mess){$mess='(end of string)'}Carp::croak ($no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")")}sub _json_object_hook {my$o=$_[0];my@ks=keys %{$o};if ($cb_sk_object and @ks==1 and exists$cb_sk_object->{$ks[0]}and ref$cb_sk_object->{$ks[0]}){my@val=$cb_sk_object->{$ks[0]}->($o->{$ks[0]});if (@val==1){return$val[0]}}my@val=$cb_object->($o)if ($cb_object);if (@val==0 or @val > 1){return$o}else {return$val[0]}}sub PP_decode_box {{text=>$text,at=>$at,ch=>$ch,len=>$len,depth=>$depth,encoding=>$encoding,is_valid_utf8=>$is_valid_utf8,}}}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$un=pack('U*',$uni);utf8::encode($un);return$un}sub _decode_unicode {my$un=pack('U',hex shift);utf8::encode($un);return$un}BEGIN {unless (defined&utf8::is_utf8){require Encode;*utf8::is_utf8=*Encode::is_utf8}if (!OLD_PERL){*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;if ($] < 5.008003){package JSON::PP;require subs;subs->import('join');eval q|
                  sub join {
                      return '' if (@_ < 2);
                      my $j   = shift;
                      my $str = shift;
                      for (@_) { $str .= $j . $_; }
                      return $str;
                  }
              |}}sub JSON::PP::incr_parse {local$Carp::CarpLevel=1;($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_parse(@_)}sub JSON::PP::incr_skip {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_skip}sub JSON::PP::incr_reset {($_[0]->{_incr_parser}||= JSON::PP::IncrParser->new)->incr_reset}eval q{
          sub JSON::PP::incr_text : lvalue {
              $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;
  
              if ( $_[0]->{_incr_parser}->{incr_pos} ) {
                  Carp::croak("incr_text cannot be called when the incremental parser already started parsing");
              }
              $_[0]->{_incr_parser}->{incr_text};
          }
      } if ($] >= 5.006)}BEGIN {eval 'require Scalar::Util';unless($@){*JSON::PP::blessed=\&Scalar::Util::blessed;*JSON::PP::reftype=\&Scalar::Util::reftype;*JSON::PP::refaddr=\&Scalar::Util::refaddr}else{eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';*JSON::PP::blessed=sub {local($@,$SIG{__DIE__},$SIG{__WARN__});ref($_[0])? eval {$_[0]->a_sub_not_likely_to_be_here}: undef};require B;my%tmap=qw(B::NULL SCALAR B::HV HASH B::AV ARRAY B::CV CODE B::IO IO B::GV GLOB B::REGEXP REGEXP);*JSON::PP::reftype=sub {my$r=shift;return undef unless length(ref($r));my$t=ref(B::svref_2object($r));return exists$tmap{$t}? $tmap{$t}: length(ref($$r))? 'REF' : 'SCALAR'};*JSON::PP::refaddr=sub {return undef unless length(ref($_[0]));my$addr;if(defined(my$pkg=blessed($_[0]))){$addr .= bless $_[0],'Scalar::Util::Fake';bless $_[0],$pkg}else {$addr .= $_[0]}$addr =~ /0x(\w+)/;local $^W;hex($1)}}}$JSON::PP::true=do {bless \(my$dummy=1),"JSON::PP::Boolean"};$JSON::PP::false=do {bless \(my$dummy=0),"JSON::PP::Boolean"};sub is_bool {blessed $_[0]and $_[0]->isa("JSON::PP::Boolean")}sub true {$JSON::PP::true}sub false {$JSON::PP::false}sub null {undef}package JSON::PP::IncrParser;use strict;use constant INCR_M_WS=>0;use constant INCR_M_STR=>1;use constant INCR_M_BS=>2;use constant INCR_M_JSON=>3;use constant INCR_M_C0=>4;use constant INCR_M_C1=>5;$JSON::backportPP::IncrParser::VERSION='0.05';sub new {my ($class)=@_;bless {incr_nest=>0,incr_text=>undef,incr_pos=>0,incr_mode=>0,},$class}sub incr_parse {my ($self,$coder,$text)=@_;$self->{incr_text}='' unless (defined$self->{incr_text});if (defined$text){if (utf8::is_utf8($text)and!utf8::is_utf8($self->{incr_text})){utf8::upgrade($self->{incr_text});utf8::decode($self->{incr_text})}$self->{incr_text}.= $text}if (defined wantarray){my$max_size=$coder->get_max_size;my$p=$self->{incr_pos};my@ret;{do {unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){$self->_incr_parse($coder);if ($max_size and $self->{incr_pos}> $max_size){Carp::croak("attempted decode of JSON text of $self->{incr_pos} bytes size, but max_size is set to $max_size")}unless ($self->{incr_nest}<= 0 and $self->{incr_mode}==INCR_M_JSON){if ($self->{incr_mode}==INCR_M_WS and $self->{incr_pos}){$self->{incr_pos}=0;$self->{incr_text}=''}last}}my ($obj,$offset)=$coder->PP_decode_json($self->{incr_text},0x00000001);push@ret,$obj;use bytes;$self->{incr_text}=substr($self->{incr_text},$offset || 0);$self->{incr_pos}=0;$self->{incr_nest}=0;$self->{incr_mode}=0;last unless wantarray}while (wantarray)}if (wantarray){return@ret}else {return$ret[0]? $ret[0]: undef}}}sub _incr_parse {my ($self,$coder)=@_;my$text=$self->{incr_text};my$len=length$text;my$p=$self->{incr_pos};INCR_PARSE: while ($len > $p){my$s=substr($text,$p,1);last INCR_PARSE unless defined$s;my$mode=$self->{incr_mode};if ($mode==INCR_M_WS){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if (ord($s)> 0x20){if ($s eq '#'){$self->{incr_mode}=INCR_M_C0;redo INCR_PARSE}else {$self->{incr_mode}=INCR_M_JSON;redo INCR_PARSE}}$p++}}elsif ($mode==INCR_M_BS){$p++;$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($mode==INCR_M_C0 or $mode==INCR_M_C1){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq "\n"){$self->{incr_mode}=$self->{incr_mode}==INCR_M_C0 ? INCR_M_WS : INCR_M_JSON;last}$p++}next}elsif ($mode==INCR_M_STR){while ($len > $p){$s=substr($text,$p,1);last INCR_PARSE unless defined$s;if ($s eq '"'){$p++;$self->{incr_mode}=INCR_M_JSON;last INCR_PARSE unless$self->{incr_nest};redo INCR_PARSE}elsif ($s eq '\\'){$p++;if (!defined substr($text,$p,1)){$self->{incr_mode}=INCR_M_BS;last INCR_PARSE}}$p++}}elsif ($mode==INCR_M_JSON){while ($len > $p){$s=substr($text,$p++,1);if ($s eq "\x00"){$p--;last INCR_PARSE}elsif ($s eq "\x09" or $s eq "\x0a" or $s eq "\x0d" or $s eq "\x20"){if (!$self->{incr_nest}){$p--;last INCR_PARSE}next}elsif ($s eq '"'){$self->{incr_mode}=INCR_M_STR;redo INCR_PARSE}elsif ($s eq '[' or $s eq '{'){if (++$self->{incr_nest}> $coder->get_max_depth){Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')}next}elsif ($s eq ']' or $s eq '}'){if (--$self->{incr_nest}<= 0){last INCR_PARSE}}elsif ($s eq '#'){$self->{incr_mode}=INCR_M_C1;redo INCR_PARSE}}}}$self->{incr_pos}=$p;$self->{incr_parsing}=$p ? 1 : 0}sub incr_text {if ($_[0]->{incr_pos}){Carp::croak("incr_text cannot be called when the incremental parser already started parsing")}$_[0]->{incr_text}}sub incr_skip {my$self=shift;$self->{incr_text}=substr($self->{incr_text},$self->{incr_pos});$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}sub incr_reset {my$self=shift;$self->{incr_text}=undef;$self->{incr_pos}=0;$self->{incr_mode}=0;$self->{incr_nest}=0}1;
JSON_BACKPORTPP

$fatpacked{"JSON/backportPP/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_BOOLEAN';
  package JSON::PP::Boolean;use strict;use overload ("0+"=>sub {${$_[0]}},"++"=>sub {$_[0]=${$_[0]}+ 1},"--"=>sub {$_[0]=${$_[0]}- 1},fallback=>1,);$JSON::backportPP::Boolean::VERSION='0.05';1;
JSON_BACKPORTPP_BOOLEAN

$fatpacked{"JSON/backportPP/Compat5005.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5005';
  package JSON::backportPP5005;use 5.005;use strict;my@properties;$JSON::PP5005::VERSION='0.05';BEGIN {sub utf8::is_utf8 {0}sub utf8::upgrade {}sub utf8::downgrade {1}sub utf8::encode {}sub utf8::decode {}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&_decode_unicode;sub B::SVp_IOK () {0x01000000}sub B::SVp_NOK () {0x02000000}sub B::SVp_POK () {0x04000000}$INC{'bytes.pm'}=1}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): sprintf('\u%04x',$_)}unpack('C*',$_[0]))}sub _encode_latin1 {join('',map {chr($_)}unpack('C*',$_[0]))}sub _decode_surrogates {my$uni=0x10000 + (hex($_[0])- 0xD800)* 0x400 + (hex($_[1])- 0xDC00);my$bit=unpack('B32',pack('N',$uni));if ($bit =~ /^00000000000(...)(......)(......)(......)$/){my ($w,$x,$y,$z)=($1,$2,$3,$4);return pack('B*',sprintf('11110%s10%s10%s10%s',$w,$x,$y,$z))}else {Carp::croak("Invalid surrogate pair")}}sub _decode_unicode {my ($u)=@_;my ($utf8bit);if ($u =~ /^00([89a-f][0-9a-f])$/i){return pack('H2',$1)}my$bit=unpack("B*",pack("H*",$u));if ($bit =~ /^00000(.....)(......)$/){$utf8bit=sprintf('110%s10%s',$1,$2)}elsif ($bit =~ /^(....)(......)(......)$/){$utf8bit=sprintf('1110%s10%s10%s',$1,$2,$3)}else {Carp::croak("Invalid escaped unicode")}return pack('B*',$utf8bit)}sub JSON::PP::incr_text {$_[0]->{_incr_parser}||= JSON::PP::IncrParser->new;if ($_[0]->{_incr_parser}->{incr_parsing}){Carp::croak("incr_text can not be called when the incremental parser already started parsing")}$_[0]->{_incr_parser}->{incr_text}=$_[1]if (@_ > 1);$_[0]->{_incr_parser}->{incr_text}}1;
JSON_BACKPORTPP_COMPAT5005

$fatpacked{"JSON/backportPP/Compat5006.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'JSON_BACKPORTPP_COMPAT5006';
  package JSON::backportPP56;use 5.006;use strict;my@properties;$JSON::PP56::VERSION='0.05';BEGIN {sub utf8::is_utf8 {my$len=length $_[0];{use bytes;return$len!=length $_[0]}}sub utf8::upgrade {}sub utf8::downgrade ($;$) {return 1 unless (utf8::is_utf8($_[0]));if (_is_valid_utf8($_[0])){my$downgrade;for my$c (unpack("U*",$_[0])){if ($c < 256){$downgrade .= pack("C",$c)}else {$downgrade .= pack("U",$c)}}$_[0]=$downgrade;return 1}else {Carp::croak("Wide character in subroutine entry")unless ($_[1]);0}}sub utf8::encode ($) {if (utf8::is_utf8($_[0])){$_[0]=pack("C*",unpack("C*",$_[0]))}else {$_[0]=pack("U*",unpack("C*",$_[0]));$_[0]=pack("C*",unpack("C*",$_[0]))}}sub utf8::decode ($) {if (_is_valid_utf8($_[0])){utf8::downgrade($_[0]);$_[0]=pack("U*",unpack("U*",$_[0]))}}*JSON::PP::JSON_PP_encode_ascii=\&_encode_ascii;*JSON::PP::JSON_PP_encode_latin1=\&_encode_latin1;*JSON::PP::JSON_PP_decode_surrogates=\&JSON::PP::_decode_surrogates;*JSON::PP::JSON_PP_decode_unicode=\&JSON::PP::_decode_unicode;unless (defined&B::SVp_NOK){eval q{ sub B::SVp_NOK () { 0x02000000; } }}}sub _encode_ascii {join('',map {$_ <= 127 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _encode_latin1 {join('',map {$_ <= 255 ? chr($_): $_ <= 65535 ? sprintf('\u%04x',$_): sprintf('\u%x\u%x',JSON::PP::_encode_surrogates($_))}_unpack_emu($_[0]))}sub _unpack_emu {return!utf8::is_utf8($_[0])? unpack('C*',$_[0]): _is_valid_utf8($_[0])? unpack('U*',$_[0]): unpack('C*',$_[0])}sub _is_valid_utf8 {my$str=$_[0];my$is_utf8;while ($str =~ /(?:
            (
               [\x00-\x7F]
              |[\xC2-\xDF][\x80-\xBF]
              |[\xE0][\xA0-\xBF][\x80-\xBF]
              |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
              |[\xED][\x80-\x9F][\x80-\xBF]
              |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
              |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
              |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
            )
          | (.)
      )/xg){if (defined $1){$is_utf8=1 if (!defined$is_utf8)}else {$is_utf8=0 if (!defined$is_utf8);if ($is_utf8){return}}}return$is_utf8}1;
JSON_BACKPORTPP_COMPAT5006

$fatpacked{"Module/Build/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_BUILD_TINY';
  package Module::Build::Tiny;$Module::Build::Tiny::VERSION='0.05';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=qw/Build Build_PL/;use CPAN::Meta;use ExtUtils::Config 0.003;use ExtUtils::Helpers 0.020 qw/make_executable split_like_shell man1_pagename man3_pagename detildefy/;use ExtUtils::Install qw/pm_to_blib install/;use ExtUtils::InstallPaths 0.002;use File::Basename qw/basename dirname/;use File::Find ();use File::Path qw/mkpath rmtree/;use File::Spec::Functions qw/catfile catdir rel2abs abs2rel splitdir curdir/;use Getopt::Long 2.36 qw/GetOptionsFromArray/;use JSON::PP 2 qw/encode_json decode_json/;sub write_file {my ($filename,$content)=@_;open my$fh,'>',$filename or die "Could not open $filename: $!\n";print$fh $content}sub read_file {my ($filename,$mode)=@_;open my$fh,'<',$filename or die "Could not open $filename: $!\n";return do {local $/;<$fh>}}sub get_meta {my ($metafile)=grep {-e $_}qw/META.json META.yml/ or die "No META information provided\n";return CPAN::Meta->load_file($metafile)}sub manify {my ($input_file,$output_file,$section,$opts)=@_;return if -e $output_file && -M $input_file <= -M $output_file;my$dirname=dirname($output_file);mkpath($dirname,$opts->{verbose})if not -d $dirname;require Pod::Man;Pod::Man->new(section=>$section)->parse_from_file($input_file,$output_file);print "Manifying $output_file\n" if$opts->{verbose}&& $opts->{verbose}> 0;return}sub process_xs {my ($source,$options)=@_;die "Can't build xs files under --pureperl-only\n" if$options->{'pureperl-only'};my (undef,@parts)=splitdir(dirname($source));push@parts,my$file_base=basename($source,'.xs');my$archdir=catdir(qw/blib arch auto/,@parts);my$tempdir='temp';my$c_file=catfile($tempdir,"$file_base.c");require ExtUtils::ParseXS;mkpath($tempdir,$options->{verbose},oct '755');ExtUtils::ParseXS::process_file(filename=>$source,prototypes=>0,output=>$c_file);my$version=$options->{meta}->version;require ExtUtils::CBuilder;my$builder=ExtUtils::CBuilder->new(config=>$options->{config}->values_set);my$ob_file=$builder->compile(source=>$c_file,defines=>{VERSION=>qq/"$version"/,XS_VERSION=>qq/"$version"/ },include_dirs=>[curdir,dirname($source)]);require DynaLoader;my$mod2fname=defined&DynaLoader::mod2fname ? \&DynaLoader::mod2fname : sub {return $_[0][-1]};mkpath($archdir,$options->{verbose},oct '755')unless -d $archdir;my$lib_file=catfile($archdir,$mod2fname->(\@parts).'.' .$options->{config}->get('dlext'));return$builder->link(objects=>$ob_file,lib_file=>$lib_file,module_name=>join '::',@parts)}sub find {my ($pattern,$dir)=@_;my@ret;File::Find::find(sub {push@ret,$File::Find::name if /$pattern/ && -f},$dir)if -d $dir;return@ret}my%actions=(build=>sub {my%opt=@_;for my$pl_file (find(qr/\.PL$/,'lib')){(my$pm=$pl_file)=~ s/\.PL$//;system $^X,$pl_file,$pm and die "$pl_file returned $?\n"}my%modules=map {$_=>catfile('blib',$_)}find(qr/\.p(?:m|od)$/,'lib');my%scripts=map {$_=>catfile('blib',$_)}find(qr//,'script');my%shared=map {$_=>catfile(qw/blib lib auto share dist/,$opt{meta}->name,abs2rel($_,'share'))}find(qr//,'share');pm_to_blib({%modules,%scripts,%shared},catdir(qw/blib lib auto/));make_executable($_)for values%scripts;mkpath(catdir(qw/blib arch/),$opt{verbose});process_xs($_,\%opt)for find(qr/.xs$/,'lib');if ($opt{install_paths}->install_destination('bindoc')&& $opt{install_paths}->is_default_installable('bindoc')){manify($_,catfile('blib','bindoc',man1_pagename($_)),$opt{config}->get('man1ext'),\%opt)for keys%scripts}if ($opt{install_paths}->install_destination('libdoc')&& $opt{install_paths}->is_default_installable('libdoc')){manify($_,catfile('blib','libdoc',man3_pagename($_)),$opt{config}->get('man3ext'),\%opt)for keys%modules}},test=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';require TAP::Harness::Env;my%test_args=((verbosity=>$opt{verbose})x!!exists$opt{verbose},(jobs=>$opt{jobs})x!!exists$opt{jobs},(color=>1)x!!-t STDOUT,lib=>[map {rel2abs(catdir(qw/blib/,$_))}qw/arch lib/ ],);my$tester=TAP::Harness::Env->create(\%test_args);$tester->runtests(sort +find(qr/\.t$/,'t'))->has_errors and exit 1},install=>sub {my%opt=@_;die "Must run `./Build build` first\n" if not -d 'blib';install($opt{install_paths}->install_map,@opt{qw/verbose dry_run uninst/})},clean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp/},realclean=>sub {my%opt=@_;rmtree($_,$opt{verbose})for qw/blib temp Build _build_params MYMETA.yml MYMETA.json/},);sub Build {my$action=@ARGV && $ARGV[0]=~ /\A\w+\z/ ? shift@ARGV : 'build';die "No such action '$action'\n" if not $actions{$action};my($env,$bargv)=@{decode_json(read_file('_build_params'))};my%opt;GetOptionsFromArray($_,\%opt,qw/install_base=s install_path=s% installdirs=s destdir=s prefix=s config=s% uninst:1 verbose:1 dry_run:1 pureperl-only:1 create_packlist=i jobs=i/)for ($env,$bargv,\@ARGV);$_=detildefy($_)for grep {defined}@opt{qw/install_base destdir prefix/},values %{$opt{install_path}};@opt{'config','meta' }=(ExtUtils::Config->new($opt{config}),get_meta());$actions{$action}->(%opt,install_paths=>ExtUtils::InstallPaths->new(%opt,dist_name=>$opt{meta}->name))}sub Build_PL {my$meta=get_meta();printf "Creating new 'Build' script for '%s' version '%s'\n",$meta->name,$meta->version;my$dir=$meta->name eq 'Module-Build-Tiny' ? "use lib 'lib';" : '';write_file('Build',"#!perl\n$dir\nuse Module::Build::Tiny;\nBuild();\n");make_executable('Build');my@env=defined$ENV{PERL_MB_OPT}? split_like_shell($ENV{PERL_MB_OPT}): ();write_file('_build_params',encode_json([\@env,\@ARGV ]));$meta->save(@$_)for ['MYMETA.json'],['MYMETA.yml'=>{version=>1.4 }]}1;
MODULE_BUILD_TINY

$fatpacked{"Test/Deep.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP';
  use strict;use warnings;package Test::Deep;use Carp qw(confess);use Test::Deep::Cache;use Test::Deep::Stack;use Test::Deep::RegexpVersion;require overload;use Scalar::Util;my$Test;unless (defined$Test::Deep::NoTest::NoTest){require Test::Builder;$Test=Test::Builder->new}our ($Stack,%Compared,$CompareCache,%WrapCache,$Shallow);our$VERSION='0.05';$VERSION =~ tr/_//d;require Exporter;our@ISA=qw(Exporter);our$Snobby=1;our$Expects=0;our$LeafWrapper;our$DNE=\"";our$DNE_ADDR=Scalar::Util::refaddr($DNE);my@constructors=(All=>"",Any=>"",Array=>"",ArrayEach=>"array_each",ArrayElementsOnly=>"",ArrayLength=>"",ArrayLengthOnly=>"",Blessed=>"",Boolean=>"bool",Code=>"",Hash=>"",HashEach=>"hash_each",HashKeys=>"",HashKeysOnly=>"",Ignore=>"",Isa=>"Isa",ListMethods=>"",Methods=>"",None=>"",Number=>"num",Obj=>"obj_isa",RefType=>"",Regexp=>"re",RegexpMatches=>"",RegexpOnly=>"",RegexpRef=>"",RegexpRefOnly=>"",ScalarRef=>"scalref",ScalarRefOnly=>"",Shallow=>"",String=>"str",);my@CONSTRUCTORS_FROM_CLASSES;while (my ($pkg,$name)=splice@constructors,0,2){$name=lc($pkg)unless$name;my$full_pkg="Test::Deep::$pkg";my$file="$full_pkg.pm";$file =~ s#::#/#g;my$sub=sub {require$file;return$full_pkg->new(@_)};{no strict 'refs';*{$name}=$sub}push@CONSTRUCTORS_FROM_CLASSES,$name}{our@EXPORT_OK=qw(descend render_stack cmp_details deep_diag);our%EXPORT_TAGS;$EXPORT_TAGS{preload}=[];$EXPORT_TAGS{v0}=[qw(Isa blessed obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore isa listmethods methods noclass none noneof num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];$EXPORT_TAGS{v1}=[qw(obj_isa all any array array_each arrayelementsonly arraylength arraylengthonly bag bool cmp_bag cmp_deeply cmp_methods cmp_set code eq_deeply hash hash_each hashkeys hashkeysonly ignore listmethods methods noclass none noneof num re reftype regexpmatches regexponly regexpref regexprefonly scalarrefonly scalref set shallow str subbagof subhashof subsetof superbagof superhashof supersetof useclass) ];our@EXPORT=@{$EXPORT_TAGS{v0 }};$EXPORT_TAGS{all}=[@EXPORT,@EXPORT_OK ]}sub import {my$self=shift;my@sans_preload=grep {;$_ ne ':preload'}@_;if (@_!=@sans_preload){require Test::Deep::All;require Test::Deep::Any;require Test::Deep::Array;require Test::Deep::ArrayEach;require Test::Deep::ArrayElementsOnly;require Test::Deep::ArrayLength;require Test::Deep::ArrayLengthOnly;require Test::Deep::Blessed;require Test::Deep::Boolean;require Test::Deep::Cache::Simple;require Test::Deep::Cache;require Test::Deep::Class;require Test::Deep::Cmp;require Test::Deep::Code;require Test::Deep::Hash;require Test::Deep::HashEach;require Test::Deep::HashElements;require Test::Deep::HashKeys;require Test::Deep::HashKeysOnly;require Test::Deep::Ignore;require Test::Deep::Isa;require Test::Deep::ListMethods;require Test::Deep::Methods;require Test::Deep::MM;require Test::Deep::None;require Test::Deep::Number;require Test::Deep::Obj;require Test::Deep::Ref;require Test::Deep::RefType;require Test::Deep::Regexp;require Test::Deep::RegexpMatches;require Test::Deep::RegexpOnly;require Test::Deep::RegexpRef;require Test::Deep::RegexpRefOnly;require Test::Deep::RegexpVersion;require Test::Deep::ScalarRef;require Test::Deep::ScalarRefOnly;require Test::Deep::Set;require Test::Deep::Shallow;require Test::Deep::Stack;require Test::Deep::String}$self->export_to_level(1,$self,@_)}sub isa {if (@_==1){goto&Isa}else {goto&UNIVERSAL::isa}}sub cmp_deeply {my ($d1,$d2,$name)=@_;my ($ok,$stack)=cmp_details($d1,$d2);if (not $Test->ok($ok,$name)){my$diag=deep_diag($stack);$Test->diag($diag)}return$ok}sub cmp_details {my ($d1,$d2)=@_;local$Stack=Test::Deep::Stack->new;local$CompareCache=Test::Deep::Cache->new;local%WrapCache;my$ok=descend($d1,$d2);return ($ok,$Stack)}sub eq_deeply {my ($d1,$d2)=@_;my ($ok)=cmp_details($d1,$d2);return$ok}sub eq_deeply_cache {my ($d1,$d2,$name)=@_;local$Stack=Test::Deep::Stack->new;$CompareCache->local;my$ok=descend($d1,$d2);$CompareCache->finish($ok);return$ok}sub deep_diag {my$stack=shift;local$Stack=$stack;my$where=render_stack('$data',$stack);confess "No stack to diagnose" unless$stack;my$last=$stack->getLast;my$diag;my$message;my$got;my$expected;my$exp=$last->{exp};if (Scalar::Util::blessed($exp)){if ($exp->can("diagnostics")){$diag=$exp->diagnostics($where,$last);$diag =~ s/\n+$/\n/}else {if ($exp->can("diag_message")){$message=$exp->diag_message($where)}}}if (not defined$diag){$got=$exp->renderGot($last->{got})unless defined$got;$expected=$exp->renderExp unless defined$expected;$message="Compared $where" unless defined$message;$diag=<<EOM}return$diag}sub render_val {my$val=shift;my$rendered;if (defined$val){$rendered=ref($val)? (Scalar::Util::refaddr($val)eq $DNE_ADDR ? "Does not exist" : overload::StrVal($val)): qq('$val')}else {$rendered="undef"}return$rendered}sub descend {my ($d1,$d2)=@_;if (!ref$d1 and!ref$d2){if (defined$d1){return 1 if defined$d2 and $d1 eq $d2}else {return 1 if!defined$d2}}if (!$Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){my$where=$Stack->render('$data');confess "Found a special comparison in $where\nYou can only use specials in the expects structure"}if (ref$d1 and ref$d2){if ($Expects and Scalar::Util::blessed($d1)and $d1->isa("Test::Deep::Cmp")){return 0 unless Test::Deep::blessed(Scalar::Util::blessed($d2))->descend($d1);if ($d1->can("compare")){return$d1->compare($d2)}}my$s1=Scalar::Util::refaddr($d1);my$s2=Scalar::Util::refaddr($d2);if ($s1 eq $s2){return 1}if ($CompareCache->cmp($d1,$d2)){return 1}else {$CompareCache->add($d1,$d2)}}$d2=wrap($d2);$Stack->push({exp=>$d2,got=>$d1});if (ref($d1)and (Scalar::Util::refaddr($d1)==$DNE_ADDR)){return 0}if ($d2->descend($d1)){$Stack->pop;return 1}else {return 0}}sub wrap {my$data=shift;my$class=Scalar::Util::blessed($data);return$data if defined$class and $data->isa("Test::Deep::Cmp");if (defined$class and $data->can('as_test_deep_cmp')){my$cmp=$data->as_test_deep_cmp;return$cmp if$cmp->isa('Test::Deep::Cmp');Carp::confess("object in expected structure provides as_test_deep_cmp but it did not return a Test::Deep::Cmp")}my$reftype=_td_reftype($data);my$cmp;if($reftype eq ''){$cmp=$Test::Deep::LeafWrapper ? $Test::Deep::LeafWrapper->($data): shallow($data)}else {my$addr=Scalar::Util::refaddr($data);return$WrapCache{$addr}if$WrapCache{$addr};if($reftype eq 'ARRAY'){$cmp=array($data)}elsif($reftype eq 'HASH'){$cmp=hash($data)}elsif($reftype eq 'SCALAR' or $reftype eq 'REF'){$cmp=scalref($data)}elsif(($reftype eq 'Regexp')or ($reftype eq 'REGEXP')){$cmp=regexpref($data)}else {$cmp=$Test::Deep::LeafWrapper ? $Test::Deep::LeafWrapper->($data): shallow($data)}$WrapCache{$addr}=$cmp}return$cmp}sub _td_reftype {my$val=shift;my$reftype=Scalar::Util::reftype($val);return '' unless defined$reftype;return$reftype unless$Test::Deep::RegexpVersion::OldStyle;my$blessed=Scalar::Util::blessed($val);return$reftype unless defined$blessed;if ($blessed && $blessed eq "Regexp" and $reftype eq "SCALAR"){$reftype="Regexp"}return$reftype}sub render_stack {my ($var,$stack)=@_;return$stack->render($var)}sub cmp_methods {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,methods(@{shift()}),shift)}sub requireclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(1,$val)}*useclass=\&requireclass;sub noclass {require Test::Deep::Class;my$val=shift;return Test::Deep::Class->new(0,$val)}sub set {require Test::Deep::Set;return Test::Deep::Set->new(1,"",@_)}sub supersetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sup",@_)}sub subsetof {require Test::Deep::Set;return Test::Deep::Set->new(1,"sub",@_)}sub noneof {require Test::Deep::Set;return Test::Deep::Set->new(1,"none",@_)}sub cmp_set {local$Test::Builder::Level=$Test::Builder::Level + 1;return cmp_deeply(shift,set(@{shift()}),shift)}sub bag {require Test::Deep::Set;return Test::Deep::Set->new(0,"",@_)}sub superbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sup",@_)}sub subbagof {require Test::Deep::Set;return Test::Deep::Set->new(0,"sub",@_)}sub cmp_bag {local$Test::Builder::Level=$Test::Builder::Level + 1;my$ref=ref($_[1])|| "";confess "Argument 2 to cmp_bag is not an ARRAY ref (".render_val($_[1]).")" unless$ref eq "ARRAY";return cmp_deeply(shift,bag(@{shift()}),shift)}sub superhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SuperHash->new($val)}sub subhashof {require Test::Deep::Hash;my$val=shift;return Test::Deep::SubHash->new($val)}sub builder {if (@_){$Test=shift}return$Test}1;
  $message
     got : $got
  expect : $expected
  EOM
TEST_DEEP

$fatpacked{"Test/Deep/All.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ALL';
  use strict;use warnings;package Test::Deep::All;use Scalar::Util ();use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {(Scalar::Util::blessed($_)&& $_->isa('Test::Deep::All'))? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;my$data=$self->data;my$index=1;for my$cmp (@{$self->{val}}){$data->{index}=$index;$index++;next if Test::Deep::descend($got,$cmp);return 0}return 1}sub render_stack {my$self=shift;my$var=shift;my$data=shift;my$max=@{$self->{val}};return "(Part $data->{index} of $max in $var)"}1;
TEST_DEEP_ALL

$fatpacked{"Test/Deep/Any.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ANY';
  use strict;use warnings;package Test::Deep::Any;use Scalar::Util ();use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {(Scalar::Util::blessed($_)&& $_->isa('Test::Deep::Any'))? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;for my$cmp (@{$self->{val}}){return 1 if Test::Deep::eq_deeply_cache($got,$cmp)}return 0}sub renderExp {my$self=shift;my@expect=map {;Test::Deep::wrap($_)}@{$self->{val}};my$things=join(", ",map {$_->renderExp}@expect);return "Any of ( $things )"}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$got=$self->renderGot($last->{got});my$exp=$self->renderExp;my$diag=<<EOM;$diag =~ s/\n+$/\n/;return$diag}4;
  Comparing $where with Any
  got      : $got
  expected : $exp
  EOM
TEST_DEEP_ANY

$fatpacked{"Test/Deep/Array.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAY';
  use strict;use warnings;package Test::Deep::Array;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless Test::Deep::descend($got,Test::Deep::arraylength(scalar @$exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,Test::Deep::arrayelementsonly($exp))}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAY

$fatpacked{"Test/Deep/ArrayEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYEACH';
  use strict;use warnings;package Test::Deep::ArrayEach;use Test::Deep::Cmp;use Scalar::Util ();sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return unless ref$got && Scalar::Util::reftype($got)eq 'ARRAY';my$exp=[($self->{val})x @$got ];return Test::Deep::descend($got,$exp)}sub renderExp {my$self=shift;my$exp=shift;return '[ ' .$self->SUPER::renderExp($self->{val}).', ... ]'}1;
TEST_DEEP_ARRAYEACH

$fatpacked{"Test/Deep/ArrayElementsOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYELEMENTSONLY';
  use strict;use warnings;package Test::Deep::ArrayElementsOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;for my$i (0..$#{$exp}){$data->{index}=$i;my$got_elem=$got->[$i];my$exp_elem=$exp->[$i];return 0 unless Test::Deep::descend($got_elem,$exp_elem)}return 1}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= "[$data->{index}]";return$var}sub reset_arrow {return 0}1;
TEST_DEEP_ARRAYELEMENTSONLY

$fatpacked{"Test/Deep/ArrayLength.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTH';
  use strict;use warnings;package Test::Deep::ArrayLength;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"ARRAY");return Test::Deep::descend($got,Test::Deep::arraylengthonly($exp))}1;
TEST_DEEP_ARRAYLENGTH

$fatpacked{"Test/Deep/ArrayLengthOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ARRAYLENGTHONLY';
  use strict;use warnings;package Test::Deep::ArrayLengthOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$len=$self->{val};return @$got==$len}sub render_stack {my$self=shift;my ($var,$data)=@_;return "array length of $var"}sub renderVal {my$self=shift;my$val=shift;return "array with $val element(s)"}sub renderGot {my$self=shift;my$got=shift;return$self->renderVal(@$got + 0)}sub renderExp {my$self=shift;return$self->renderVal($self->{val})}1;
TEST_DEEP_ARRAYLENGTHONLY

$fatpacked{"Test/Deep/Blessed.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BLESSED';
  use strict;use warnings;package Test::Deep::Blessed;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$blessed=blessed($got);return Test::Deep::descend($blessed,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "blessed($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(blessed($got))}1;
TEST_DEEP_BLESSED

$fatpacked{"Test/Deep/Boolean.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_BOOLEAN';
  use strict;use warnings;package Test::Deep::Boolean;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift()? 1 : 0}sub descend {my$self=shift;my$got=shift;return!($got xor $self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a boolean"}sub renderExp {my$self=shift;$self->renderGot($self->{val})}sub renderGot {my$self=shift;my$val=shift;return ($val ? "true" : "false")." (".Test::Deep::render_val($val).")"}1;
TEST_DEEP_BOOLEAN

$fatpacked{"Test/Deep/Cache.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE';
  use strict;use warnings;package Test::Deep::Cache;use Test::Deep::Cache::Simple;sub new {my$pkg=shift;my$self=bless {},$pkg;$self->{expects}=[Test::Deep::Cache::Simple->new];$self->{normal}=[Test::Deep::Cache::Simple->new];$self->local;return$self}sub add {my$self=shift;my$type=$self->type;$self->{$type}->[-1]->add(@_)}sub cmp {my$self=shift;my$type=$self->type;for my$cache (@{$self->{$type}}){return 1 if$cache->cmp(@_)}return 0}sub local {my$self=shift;for my$type (qw(expects normal)){push(@{$self->{$type}},Test::Deep::Cache::Simple->new)}}sub finish {my$self=shift;my$keep=shift;for my$type (qw(expects normal)){my$caches=$self->{$type};my$last=pop @$caches;$caches->[-1]->absorb($last)if$keep}}sub type {return$Test::Deep::Expects ? "expects" : "normal"}1;
TEST_DEEP_CACHE

$fatpacked{"Test/Deep/Cache/Simple.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CACHE_SIMPLE';
  use strict;use warnings;package Test::Deep::Cache::Simple;use Carp qw(confess);use Scalar::Util qw(refaddr);BEGIN {if (grep /^weaken$/,@Scalar::Util::EXPORT_FAIL){*weaken=sub {}}else {Scalar::Util->import('weaken')}}sub new {my$pkg=shift;my$self=bless {},$pkg;return$self}sub add {my$self=shift;my ($d1,$d2)=@_;{local$SIG{__DIE__};local $@;eval{weaken($d1)};eval{weaken($d2)}}$self->{fn_get_key(@_)}=[$d1,$d2]}sub cmp {my$self=shift;my$key=fn_get_key(@_);my$pair=$self->{$key};if (ref($pair->[0])and ref($pair->[1])){return 1}else {delete$self->{$key};return 0}}sub absorb {my$self=shift;my$other=shift;@{$self}{keys %$other}=values %$other}sub fn_get_key {return join(",",sort (map {refaddr($_)}@_))}1;
TEST_DEEP_CACHE_SIMPLE

$fatpacked{"Test/Deep/Class.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CLASS';
  use strict;use warnings;package Test::Deep::Class;use Test::Deep::Cmp;sub init {my$self=shift;my$snobby=shift;my$val=shift;$self->{snobby}=$snobby;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;local$Test::Deep::Snobby=$self->{snobby};Test::Deep::wrap($self->{val})->descend($got)}1;
TEST_DEEP_CLASS

$fatpacked{"Test/Deep/Cmp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CMP';
  use strict;use warnings;package Test::Deep::Cmp;use overload '&'=>\&make_all,'|'=>\&make_any,'""'=>\&string,fallback=>1,;use Scalar::Util ();sub import {my$pkg=shift;my$callpkg=caller();if ($callpkg =~ /^Test::Deep::/){no strict 'refs';push @{$callpkg."::ISA"},$pkg}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {}sub make_all {my ($e1,$e2)=@_;return Test::Deep::all($e1,$e2)}sub make_any {my ($e1,$e2)=@_;return Test::Deep::any($e1,$e2)}sub cmp {my ($a1,$a2,$rev)=@_;($a1,$a2)=($a2,$a1)if$rev;return (overload::StrVal($a1)cmp overload::StrVal($a2))}sub string {my$self=shift;return overload::StrVal($self)}sub render_stack {my$self=shift;my$var=shift;return$var}sub renderExp {my$self=shift;return$self->renderGot($self->{val})}sub renderGot {my$self=shift;return Test::Deep::render_val(@_)}sub reset_arrow {return 1}sub data {my$self=shift;return$Test::Deep::Stack->getLast}1;
TEST_DEEP_CMP

$fatpacked{"Test/Deep/Code.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_CODE';
  use strict;use warnings;package Test::Deep::Code;use Test::Deep::Cmp;sub init {my$self=shift;my$code=shift || die "No coderef supplied";$self->{code}=$code}sub descend {my$self=shift;my$got=shift;my ($ok,$diag)=&{$self->{code}}($got);$self->data->{diag}=$diag;return$ok}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$error=$last->{diag};my$data=Test::Deep::render_val($last->{got});my$diag=<<EOM;if (defined($error)){$diag .= <<EOM}else {$diag .= <<EOM}return$diag}1;
  Ran coderef at $where on
  
  $data
  EOM
  and it said
  $error
  EOM
  it failed but it didn't say why.
  EOM
TEST_DEEP_CODE

$fatpacked{"Test/Deep/Hash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASH';
  use strict;use warnings;package Test::Deep::Hash;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;return 0 unless Test::Deep::descend($got,$self->hash_keys($exp));return 0 unless$self->test_class($got);return Test::Deep::descend($got,$self->hash_elements($exp))}sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::HashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::HashKeys->new(keys %$exp)}sub reset_arrow {return 0}package Test::Deep::SuperHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SuperHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeys->new(keys %$exp)}package Test::Deep::SubHash;use base 'Test::Deep::Hash';sub hash_elements {require Test::Deep::HashElements;my$self=shift;return Test::Deep::SubHashElements->new(@_)}sub hash_keys {require Test::Deep::HashKeys;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeys->new(keys %$exp)}1;
TEST_DEEP_HASH

$fatpacked{"Test/Deep/HashEach.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHEACH';
  use strict;use warnings;package Test::Deep::HashEach;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my%exp;@exp{keys %$got}=($self->{val})x (keys %$got);return Test::Deep::descend($got,\%exp)}1;
TEST_DEEP_HASHEACH

$fatpacked{"Test/Deep/HashElements.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHELEMENTS';
  use strict;use warnings;package Test::Deep::HashElements;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$data=$self->data;my$master=$self->getMaster($got,$exp);for my$key (keys %$master){$data->{index}=$key;my$got_elem=exists$got->{$key}? $got->{$key}: $Test::Deep::DNE;my$exp_elem=exists$exp->{$key}? $exp->{$key}: $Test::Deep::DNE;next if Test::Deep::descend($got_elem,$exp_elem);return 0}return 1}sub getMaster {my$self=shift;my ($got,$exp)=@_;return keys %$got > keys %$exp ? $got : $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;$var .= "->" unless$Test::Deep::Stack->incArrow;$var .= '{"'.quotemeta($data->{index}).'"}';return$var}sub reset_arrow {return 0}package Test::Deep::SuperHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$exp}package Test::Deep::SubHashElements;use base 'Test::Deep::HashElements';sub getMaster {my$self=shift;my ($got,$exp)=@_;return$got}1;
TEST_DEEP_HASHELEMENTS

$fatpacked{"Test/Deep/HashKeys.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYS';
  use strict;use warnings;package Test::Deep::HashKeys;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_reftype($got,"HASH");return Test::Deep::descend($got,$self->hashkeysonly($exp))}sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::HashKeysOnly->new(keys %$exp)}package Test::Deep::SuperHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SuperHashKeysOnly->new(keys %$exp)}package Test::Deep::SubHashKeys;use base 'Test::Deep::HashKeys';sub hashkeysonly {require Test::Deep::HashKeysOnly;my$self=shift;my$exp=shift;return Test::Deep::SubHashKeysOnly->new(keys %$exp)}1;
TEST_DEEP_HASHKEYS

$fatpacked{"Test/Deep/HashKeysOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_HASHKEYSONLY';
  use strict;use warnings;package Test::Deep::HashKeysOnly;use Test::Deep::Ref;sub init {my$self=shift;my%keys;@keys{@_}=();$self->{val}=\%keys;$self->{keys}=[sort @_]}sub descend {my$self=shift;my$hash=shift;my$data=$self->data;my$exp=$self->{val};my%got;@got{keys %$hash}=();my@missing;my@extra;while (my ($key,$value)=each %$exp){if (exists$got{$key}){delete$got{$key}}else {push(@missing,$key)}}my@diags;if (@missing and (not $self->ignoreMissing)){push(@diags,"Missing: ".nice_list(\@missing))}if (%got and (not $self->ignoreExtra)){push(@diags,"Extra: ".nice_list([keys%got]))}if (@diags){$data->{diag}=join("\n",@diags);return 0}return 1}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub nice_list {my$list=shift;return join(", ",(map {"'$_'"}sort @$list),)}sub ignoreMissing {return 0}sub ignoreExtra {return 0}package Test::Deep::SuperHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 0}sub ignoreExtra {return 1}package Test::Deep::SubHashKeysOnly;use base 'Test::Deep::HashKeysOnly';sub ignoreMissing {return 1}sub ignoreExtra {return 0}1;
  Comparing hash keys of $where
  $error
  EOM
TEST_DEEP_HASHKEYSONLY

$fatpacked{"Test/Deep/Ignore.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_IGNORE';
  use strict;use warnings;package Test::Deep::Ignore;use Test::Deep::Cmp;my$Singleton=__PACKAGE__->SUPER::new;sub new {return$Singleton}sub descend {return 1}1;
TEST_DEEP_IGNORE

$fatpacked{"Test/Deep/Isa.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_ISA';
  use strict;use warnings;package Test::Deep::Isa;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)? $got->isa($self->{val}): ref($got)eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into or ref of type '$self->{val}'"}1;
TEST_DEEP_ISA

$fatpacked{"Test/Deep/ListMethods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_LISTMETHODS';
  use strict;use warnings;package Test::Deep::ListMethods;use base 'Test::Deep::Methods';sub call_method {my$self=shift;return [$self->SUPER::call_method(@_)]}sub render_stack {my$self=shift;my$var=$self->SUPER::render_stack(@_);return "[$var]"}1;
TEST_DEEP_LISTMETHODS

$fatpacked{"Test/Deep/MM.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_MM';
  use strict;use warnings;package Test::Deep::MM;sub import {my$self=shift;my ($pkg)=caller();my$mpkg=$pkg."::Methods";for my$attr (@_){if ($attr =~ /^[a-z]/){no strict 'refs';*{$mpkg."::$attr"}=\&{$attr}}else {my$get_name=$mpkg."::get$attr";my$set_name=$mpkg."::set$attr";my$get_sub=sub {return $_[0]->{$attr}};my$set_sub=sub {return $_[0]->{$attr}=$_[1]};{no strict 'refs';*$get_name=$get_sub;*$set_name=$set_sub;push(@{$pkg."::ISA"},$mpkg)}}}}sub new {my$pkg=shift;my$self=bless {},$pkg;$self->init(@_);return$self}sub init {my$self=shift;while (@_){my$name=shift || confess("No name");my$method="set$name";$self->$method(shift)}}1;
TEST_DEEP_MM

$fatpacked{"Test/Deep/Methods.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_METHODS';
  use strict;use warnings;package Test::Deep::Methods;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my@methods;while (@_){my$name=shift;my$value=shift;push(@methods,[ref($name)? $name : [$name ],$value ])}$self->{methods}=\@methods}sub descend {my$self=shift;my$got=shift;my$data=$self->data;for my$method (@{$self->{methods}}){$data->{method}=$method;my ($call,$exp_res)=@$method;my ($name,@args)=@$call;local $@;my$got_res;if (!eval {$got_res=$self->call_method($got,$call);1}){die $@ unless $@ =~ /\ACan't locate object method "\Q$name"/;$got_res=$Test::Deep::DNE}next if Test::Deep::descend($got_res,$exp_res);return 0}return 1}sub call_method {my$self=shift;my ($got,$call)=@_;my ($name,@args)=@$call;return$got->$name(@args)}sub render_stack {my$self=shift;my ($var,$data)=@_;my$method=$data->{method};my ($call,$expect)=@$method;my ($name,@args)=@$call;my$args=@args ? "(".join(", ",@args).")" : "";$var .= "->$name$args";return$var}1;
TEST_DEEP_METHODS

$fatpacked{"Test/Deep/NoTest.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NOTEST';
  use strict;use warnings;package Test::Deep::NoTest;our$NoTest;{local$NoTest=1;require Test::Deep}sub import {my$import=Test::Deep->can("import");my$pkg=shift;unshift(@_,"Test::Deep");goto &$import}1;
TEST_DEEP_NOTEST

$fatpacked{"Test/Deep/None.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NONE';
  use strict;use warnings;package Test::Deep::None;use Test::Deep::Cmp;sub init {my$self=shift;my@list=map {eval {$_->isa('Test::Deep::None')}? @{$_->{val}}: $_}@_;$self->{val}=\@list}sub descend {my$self=shift;my$got=shift;for my$cmp (@{$self->{val}}){return 0 if Test::Deep::eq_deeply_cache($got,$cmp)}return 1}sub renderExp {my$self=shift;my@expect=map {;Test::Deep::wrap($_)}@{$self->{val}};my$things=join(", ",map {$_->renderExp}@expect);return "None of ( $things )"}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$got=$self->renderGot($last->{got});my$exp=$self->renderExp;my$diag=<<EOM;$diag =~ s/\n+$/\n/;return$diag}1;
  Comparing $where with None
  got      : $got
  expected : $exp
  EOM
TEST_DEEP_NONE

$fatpacked{"Test/Deep/Number.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_NUMBER';
  use strict;use warnings;package Test::Deep::Number;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;$self->{val}=shift(@_)+ 0;$self->{tolerance}=shift}sub descend {my$self=shift;my$got=shift;$self->data->{got_string}=$got;{no warnings 'numeric';$got += 0}$self->data->{got}=$got;if (defined(my$tolerance=$self->{tolerance})){return abs($got - $self->{val})<= $tolerance}else {return$got==$self->{val}}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a number"}sub renderGot {my$self=shift;my$val=shift;my$got_string=$self->data->{got_string};if ("$val" ne "$got_string"){$got_string=$self->SUPER::renderGot($got_string);return "$val ($got_string)"}else {return$val}}sub renderExp {my$self=shift;my$exp=$self->{val};if (defined(my$tolerance=$self->{tolerance})){return "$exp +/- $tolerance"}else {return$exp}}1;
TEST_DEEP_NUMBER

$fatpacked{"Test/Deep/Obj.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_OBJ';
  use strict;use warnings;package Test::Deep::Obj;use Test::Deep::Cmp;use Scalar::Util;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;return Scalar::Util::blessed($got)&& $got->isa($self->{val})}sub diag_message {my$self=shift;my$where=shift;return "Checking class of $where with isa()"}sub renderExp {my$self=shift;return "blessed into '$self->{val}' or subclass of '$self->{val}'"}1;
TEST_DEEP_OBJ

$fatpacked{"Test/Deep/Ref.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REF';
  use strict;use warnings;package Test::Deep::Ref;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub test_class {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::Snobby){return Test::Deep::descend($got,Test::Deep::blessed(blessed($exp)))}else {return 1}}sub test_reftype {my$self=shift;my$got=shift;my$reftype=shift;return Test::Deep::descend($got,Test::Deep::reftype($reftype))}1;
TEST_DEEP_REF

$fatpacked{"Test/Deep/RefType.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REFTYPE';
  use strict;use warnings;package Test::Deep::RefType;use Test::Deep::Cmp;use Scalar::Util qw(reftype);sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$reftype=reftype($got);return Test::Deep::descend($reftype,Test::Deep::shallow($exp))}sub render_stack {my$self=shift;my$var=shift;return "reftype($var)"}sub renderGot {my$self=shift;my$got=shift;$self->SUPER::renderGot(reftype($got))}1;
TEST_DEEP_REFTYPE

$fatpacked{"Test/Deep/Regexp.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXP';
  use strict;use warnings;package Test::Deep::Regexp;use Test::Deep::Cmp;use Test::Deep::RegexpMatches;sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val;if (my$matches=shift){$self->{matches}=Test::Deep::regexpmatches($matches,$val);$self->{flags}=shift || ""}}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};if (my$match_exp=$self->{matches}){my$flags=$self->{flags};my@match_got;if ($flags eq "g"){@match_got=$got =~ /$re/g}else {@match_got=$got =~ /$re/}if (@match_got){return Test::Deep::descend(\@match_got,$match_exp)}else {return 0}}else {return ($got =~ $re)? 1 : 0}}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub render_stack1 {my$self=shift;my$stack=shift;return "($stack =~ $self->{regex})"}sub renderExp {my$self=shift;return "$self->{val}"}sub renderGot {my$self=shift;my$got=shift;if (defined (my$class=Scalar::Util::blessed($got))){my$ostr=qq{$got};if ($ostr ne overload::StrVal($got)){return qq{'$ostr' (instance of $class)}}}return Test::Deep::render_val($got)}1;
TEST_DEEP_REGEXP

$fatpacked{"Test/Deep/RegexpMatches.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPMATCHES';
  use strict;use warnings;package Test::Deep::RegexpMatches;use Test::Deep::Array;use base 'Test::Deep::Array';use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=Test::Deep::array($val)unless blessed($val)and $val->isa("Test::Deep::Cmp");$self->{val}=$val;$self->{regex}=shift}sub descend {my$self=shift;my$got=shift;return Test::Deep::descend($got,$self->{val})}sub render_stack {my$self=shift;my$stack=shift;$stack="[$stack =~ $self->{regex}]";return$stack}sub reset_arrow {return 1}1;
TEST_DEEP_REGEXPMATCHES

$fatpacked{"Test/Deep/RegexpOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPONLY';
  use strict;use warnings;package Test::Deep::RegexpOnly;use Test::Deep::Cmp;use Scalar::Util qw(blessed);sub init {my$self=shift;my$val=shift;$val=ref$val ? $val : qr/$val/;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$re=$self->{val};return$got =~ $self->{val}? 1 : 0}sub diag_message {my$self=shift;my$where=shift;return "Using Regexp on $where"}sub renderExp {my$self=shift;return "$self->{val}"}1;
TEST_DEEP_REGEXPONLY

$fatpacked{"Test/Deep/RegexpRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREF';
  use strict;use warnings;package Test::Deep::RegexpRef;use Test::Deep::Ref;use Test::Deep::RegexpVersion;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};if ($Test::Deep::RegexpVersion::OldStyle){return 0 unless$self->test_class($got,"Regexp");return 0 unless$self->test_reftype($got,"SCALAR")}else {return 0 unless$self->test_reftype($got,"REGEXP")}return Test::Deep::descend($got,Test::Deep::regexprefonly($exp))}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREF

$fatpacked{"Test/Deep/RegexpRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPREFONLY';
  use strict;use warnings;package Test::Deep::RegexpRefOnly;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return$got eq $exp}sub render_stack {my$self=shift;my ($var,$data)=@_;return "m/$var/"}sub renderGot {my$self=shift;return shift().""}1;
TEST_DEEP_REGEXPREFONLY

$fatpacked{"Test/Deep/RegexpVersion.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_REGEXPVERSION';
  use strict;use warnings;package Test::Deep::RegexpVersion;our$OldStyle=($] < 5.011);1;
TEST_DEEP_REGEXPVERSION

$fatpacked{"Test/Deep/ScalarRef.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREF';
  use strict;use warnings;package Test::Deep::ScalarRef;use Test::Deep::Ref;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return 0 unless$self->test_class($got);return 0 unless$self->test_reftype($got,Scalar::Util::reftype($exp));return Test::Deep::descend($got,Test::Deep::scalarrefonly($exp))}1;
TEST_DEEP_SCALARREF

$fatpacked{"Test/Deep/ScalarRefOnly.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SCALARREFONLY';
  use strict;use warnings;package Test::Deep::ScalarRefOnly;use Test::Deep::Cmp;sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};return Test::Deep::descend($$got,$$exp)}sub render_stack {my$self=shift;my ($var,$data)=@_;return "\${$var}"}1;
TEST_DEEP_SCALARREFONLY

$fatpacked{"Test/Deep/Set.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SET';
  use strict;use warnings;package Test::Deep::Set;use Test::Deep::Cmp;sub init {my$self=shift;$self->{IgnoreDupes}=shift;$self->{SubSup}=shift;$self->{val}=[];$self->add(@_)}sub descend {my$self=shift;my$d1=shift;my$d2=$self->{val};my$IgnoreDupes=$self->{IgnoreDupes};my$data=$self->data;my$SubSup=$self->{SubSup};my$type=$IgnoreDupes ? "Set" : "Bag";my$diag;if (ref$d1 ne 'ARRAY'){my$got=Test::Deep::render_val($d1);$diag=<<EOM}if (not $diag){my@got=@$d1;my@found;my@missing;for my$expect (@$d2){my$found=0;for (my$i=$#got;$i >= 0;$i--){if (Test::Deep::eq_deeply_cache($got[$i],$expect)){$found=1;push(@found,$expect);splice(@got,$i,1);last unless$IgnoreDupes}}push(@missing,$expect)unless$found}my@diags;if (@missing and $SubSup ne "sub" && $SubSup ne "none"){push(@diags,"Missing: ".nice_list(\@missing))}if (@got and $SubSup ne "sup" && $SubSup ne "none"){my$got=__PACKAGE__->new($IgnoreDupes,"",@got);push(@diags,"Extra: ".nice_list($got->{val}))}if (@found and $SubSup eq "none"){my$found=__PACKAGE__->new($IgnoreDupes,"",@found);push(@diags,"Extra: ".nice_list($found->{val}))}$diag=join("\n",@diags)}if ($diag){$data->{diag}=$diag;return 0}else {return 1}}sub diagnostics {my$self=shift;my ($where,$last)=@_;my$type=$self->{IgnoreDupes}? "Set" : "Bag";$type="Sub$type" if$self->{SubSup}eq "sub";$type="Super$type" if$self->{SubSup}eq "sup";$type="NoneOf" if$self->{SubSup}eq "none";my$error=$last->{diag};my$diag=<<EOM;return$diag}sub add {my$self=shift;my@array=@_;my$IgnoreDupes=$self->{IgnoreDupes};my$already=$self->{val};local$Test::Deep::Expects=1;for my$new_elem (@array){my$want_push=1;my$push_this=$new_elem;for my$old_elem (@$already){if (Test::Deep::eq_deeply($new_elem,$old_elem)){$push_this=$old_elem;$want_push=!$IgnoreDupes;last}}push(@$already,$push_this)if$want_push}@$already=sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@$already}sub nice_list {my$list=shift;my@scalars=grep!ref $_,@$list;my$refs=grep ref $_,@$list;my@ref_string="$refs reference" if$refs;$ref_string[0].= "s" if$refs > 1;return join(", ",(map {Test::Deep::render_val($_)}sort {(defined$a ? $a : "")cmp (defined$b ? $b : "")}@scalars),@ref_string)}sub compare {my$self=shift;my$other=shift;return 0 if$self->{IgnoreDupes}!=$other->{IgnoreDupes};return Test::Deep::descend($self->{val},$other->{val})}1;
  got    : $got
  expect : An array to use as a $type
  EOM
  Comparing $where as a $type
  $error
  EOM
TEST_DEEP_SET

$fatpacked{"Test/Deep/Shallow.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_SHALLOW';
  use strict;use warnings;package Test::Deep::Shallow;use Test::Deep::Cmp;use Scalar::Util qw(refaddr);sub init {my$self=shift;my$val=shift;$self->{val}=$val}sub descend {my$self=shift;my$got=shift;my$exp=$self->{val};my$ok;if (!defined$got and!defined$exp){$ok=1}elsif (defined$got xor defined$exp){$ok=0}elsif (ref$got and ref$exp){$ok=refaddr($got)==refaddr($exp)}elsif (ref$got xor ref$exp){$ok=0}else {$ok=$got eq $exp}return$ok}1;
TEST_DEEP_SHALLOW

$fatpacked{"Test/Deep/Stack.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STACK';
  use strict;use warnings;package Test::Deep::Stack;use Carp qw(confess);use Scalar::Util;use Test::Deep::MM qw(new init Stack Arrow);sub init {my$self=shift;$self->SUPER::init(@_);$self->setStack([])unless$self->getStack}sub push {my$self=shift;push(@{$self->getStack},@_)}sub pop {my$self=shift;return pop @{$self->getStack}}sub render {my$self=shift;my$var=shift;my$stack=$self->getStack;$self->setArrow(0);for my$data (@$stack){my$exp=$data->{exp};if (Scalar::Util::blessed($exp)and $exp->isa("Test::Deep::Cmp")){$var=$exp->render_stack($var,$data);$self->setArrow(0)if$exp->reset_arrow}else {confess "Don't know how to render '$exp'"}}return$var}sub getLast {my$self=shift;return$self->getStack->[-1]}sub incArrow {my$self=shift;my$a=$self->getArrow;$self->setArrow($a + 1);return$a}sub length {my$self=shift;return @{$self->getStack}+ 0}1;
TEST_DEEP_STACK

$fatpacked{"Test/Deep/String.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_DEEP_STRING';
  use strict;use warnings;package Test::Deep::String;use Test::Deep::Cmp;sub init {my$self=shift;$self->{val}=shift}sub descend {my$self=shift;my$got=shift()."";$self->data->{got}=$got;return$got eq $self->{val}}sub diag_message {my$self=shift;my$where=shift;return "Comparing $where as a string"}1;
TEST_DEEP_STRING

$fatpacked{"Test/Fatal.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_FATAL';
  use strict;use warnings;package Test::Fatal;$Test::Fatal::VERSION='0.05';use Carp ();use Try::Tiny 0.07;use Exporter 5.57 'import';our@EXPORT=qw(exception);our@EXPORT_OK=qw(exception success dies_ok lives_ok);our ($REAL_TBL,$REAL_CALCULATED_TBL)=(1,1);sub exception (&) {my$code=shift;return try {my$incremented=$Test::Builder::Level - $REAL_CALCULATED_TBL;local$Test::Builder::Level=$REAL_CALCULATED_TBL;if ($incremented){$Test::Builder::Level += 5;for my$i (1..$incremented){my$caller=caller($Test::Builder::Level - 2);if ($caller eq __PACKAGE__){$Test::Builder::Level=$Test::Builder::Level + 5}else {$Test::Builder::Level=$Test::Builder::Level + 1}}}local$REAL_CALCULATED_TBL=$Test::Builder::Level;$code->();return undef}catch {return $_ if $_;my$problem=defined $_ ? 'false' : 'undef';Carp::confess("$problem exception caught by Test::Fatal::exception")}}sub success (&;@) {my$code=shift;return finally(sub {return if @_;$code->()},@_)}my$Tester;sub dies_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(exception(\&$code),$name);$ok or $Tester->diag("expected an exception but none was raised");return$ok}sub lives_ok (&;$) {my$code=shift;my$name=shift;require Test::Builder;$Tester ||= Test::Builder->new;my$ok=$Tester->ok(!exception(\&$code),$name);$ok or $Tester->diag("expected return but an exception was raised");return$ok}1;
TEST_FATAL

$fatpacked{"Test/MonkeyMock.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_MONKEYMOCK';
  package Test::MonkeyMock;use strict;use warnings;require Carp;our$VERSION='0.05';my$registry={};my$magic_counter=0;sub new {my$class=shift;$class=ref$class if ref$class;my ($instance)=@_;my$new_package;if ($instance){$new_package=__PACKAGE__ .'::' .ref($instance).'::__instance__' .($magic_counter++);no strict 'refs';@{$new_package .'::ISA'}=(ref($instance))}else {$instance={};$new_package=__PACKAGE__ .'::' .($magic_counter++);no strict 'refs';@{$new_package .'::ISA'}=__PACKAGE__}no strict 'refs';for my$method (qw/mock mocked_called mocked_call_args mocked_call_stack mocked_return_args mocked_return_stack/){*{$new_package .'::' .$method}=sub {goto &$method}}bless$instance,$new_package;return$instance}sub mock {my$self=shift;my ($method,$code,%options)=@_;if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless my$orig_method=$self->can($method);if (exists$registry->{ref($self)}->{'mocks'}->{$method}){push @{$registry->{ref($self)}->{'mocks'}->{$method}},{code=>$code,orig_code=>$orig_method};return$self}my$ref_self=ref($self);my$package=__PACKAGE__;$ref_self =~ s/^${package}::(.*)::__instance__\d+/$1/;my$new_package=__PACKAGE__ .'::' .$ref_self .'::__instance__' .$magic_counter++;$registry->{$new_package}=$registry->{ref($self)};my$mocks=$registry->{$new_package}->{'mocks'}||= {};$mocks->{$method}=[{code=>$code,orig_code=>$orig_method,options=>\%options}];no strict 'refs';@{$new_package .'::ISA'}=ref($self);*{$new_package .'::' .$method}=sub {_dispatch($new_package,$method,@_)};bless$self,$new_package}else {my$mocks=$registry->{ref($self)}->{'mocks'}||= {};push @{$mocks->{$method}},{code=>$code,options=>\%options }}return$self}sub mocked_called {my$self=shift;my ($method)=@_;my$mocks=$registry->{ref($self)}->{'mocks'}||= {};my$calls=$registry->{ref($self)}->{'calls'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}return$calls->{$method}->{called}|| 0}sub mocked_call_args {my$self=shift;my ($method,$frame)=@_;$frame ||= 0;my$stack=$self->mocked_call_stack($method);Carp::croak("Unknown frame '$frame'")unless @$stack > $frame;return @{$stack->[$frame]}}sub mocked_call_stack {my$self=shift;my ($method)=@_;Carp::croak("Method is required")unless$method;my$calls=$registry->{ref($self)}->{'calls'}||= {};my$mocks=$registry->{ref($self)}->{'mocks'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}Carp::croak("Method '$method' was not called")unless exists$calls->{$method};return$calls->{$method}->{stack}}sub mocked_return_args {my$self=shift;my ($method,$frame)=@_;$frame ||= 0;my$stack=$self->mocked_return_stack($method);Carp::croak("Unknown frame '$frame'")unless @$stack > $frame;return @{$stack->[$frame]}}sub mocked_return_stack {my$self=shift;my ($method)=@_;Carp::croak("Method is required")unless$method;my$returns=$registry->{ref($self)}->{'returns'}||= {};my$mocks=$registry->{ref($self)}->{'mocks'}||= {};if (ref($self)=~ m/__instance__/){Carp::croak("Unknown method '$method'")unless$self->can($method)}else {Carp::croak("Unmocked method '$method'")unless exists$mocks->{$method}}Carp::croak("Method '$method' was not called")unless exists$returns->{$method};return$returns->{$method}->{stack}}sub can {my$self=shift;my ($method)=@_;if (ref($self)=~ m/__instance__/){return$self->can($method)}else {my$mocks=$registry->{ref($self)}->{'mocks'}||= {};return$mocks->{$method}->[0]->{code}}}our$AUTOLOAD;sub AUTOLOAD {my$self=shift;my ($method)=(split /::/,$AUTOLOAD)[-1];return if$method =~ /^[A-Z]+$/;return _dispatch(ref($self),$method,$self,@_)}sub _dispatch {my$ref_self=shift;my$method=shift;my$calls=$registry->{$ref_self}->{'calls'}||= {};my$returns=$registry->{$ref_self}->{'returns'}||= {};my$mocks=$registry->{$ref_self}->{'mocks'}||= {};Carp::croak("Unmocked method '$method'")if!exists$mocks->{$method};for my$mock (@{$mocks->{$method}}){if (my$options=$mock->{options}){if (my$when=$options->{when}){next unless$when->(@_)}if (defined(my$frame=$options->{frame})){my$current_frame=$returns->{$method}->{stack}? @{$returns->{$method}->{stack}}: 0;next unless$frame==$current_frame}}$calls->{$method}->{called}++;push @{$calls->{$method}->{stack}},[@_[1 .. $#_]];my@result;if (my$code=$mock->{code}){@result=$code->(@_)}elsif (my$orig_code=$mock->{orig_code}){@result=$orig_code->(@_)}else {Carp::croak("Unmocked method '$method'")}push @{$returns->{$method}->{stack}},[@result];return wantarray ? @result : $result[0]}}1;
TEST_MONKEYMOCK

$fatpacked{"Test/TempDir/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TEST_TEMPDIR_TINY';
  use 5.006002;use strict;use warnings;package Test::TempDir::Tiny;our$VERSION='0.05';use Exporter 5.57 qw/import/;our@EXPORT=qw/tempdir in_tempdir/;use Carp qw/confess/;use Cwd qw/abs_path/;use Errno qw/EEXIST ENOENT/;{no warnings 'numeric';use File::Path 2.01 qw/remove_tree/}use File::Spec::Functions qw/catdir/;use File::Temp;my ($ROOT_DIR,$TEST_DIR,%COUNTER);my ($ORIGINAL_PID,$ORIGINAL_CWD,$TRIES,$DELAY,$SYSTEM_TEMP)=($$,abs_path("."),100,50 / 1000,0);sub _untaint {my$thing=shift;($thing)=$thing =~ /^(.*)$/;return$thing}sub tempdir {my$label=defined($_[0])? $_[0]: 'default';$label =~ tr{a-zA-Z0-9_-}{_}cs;_init()unless$ROOT_DIR && $TEST_DIR;my$suffix=++$COUNTER{$label};my$subdir=catdir($TEST_DIR,"${label}_${suffix}");mkdir _untaint($subdir)or confess("Couldn't create $subdir: $!");return$subdir}sub in_tempdir {my ($label,$code)=@_;my$wantarray=wantarray;my$cwd=abs_path(".");my$tempdir=tempdir($label);chdir$tempdir or die "Can't chdir to '$tempdir'";my (@ret);my$ok=eval {$code->($tempdir);1};my$err=$@;chdir$cwd or chdir "/" or die "Can't chdir to either '$cwd' or '/'";confess($err || "error from eval was lost")if!$ok;return}sub _inside_t_dir {-d "../t" && abs_path(".")eq abs_path("../t")}sub _init {my$DEFAULT_ROOT=catdir($ORIGINAL_CWD,"tmp");if (-d 't' && (-w $DEFAULT_ROOT || -w '.')){$ROOT_DIR=$DEFAULT_ROOT}elsif (_inside_t_dir()&& (-w '../$DEFAULT_ROOT' || -w '..')){$ROOT_DIR=catdir($ORIGINAL_CWD,"..","tmp")}else {$ROOT_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);$SYSTEM_TEMP=1}(my$dirname=$0)=~ tr{:\\/.}{_};$TEST_DIR=catdir($ROOT_DIR,$dirname);if (-d $TEST_DIR){remove_tree(_untaint($TEST_DIR),{safe=>0,keep_root=>1 });return}for my$n (1 .. $TRIES){if (!mkdir(_untaint($ROOT_DIR))){confess("Couldn't create $ROOT_DIR: $!")unless $!==EEXIST}$ROOT_DIR=abs_path($ROOT_DIR);if (mkdir _untaint($TEST_DIR)){$TEST_DIR=abs_path($TEST_DIR);return}if ($!!=ENOENT){confess("Couldn't create $TEST_DIR: $!")}if (-e $ROOT_DIR &&!-d _){confess("$ROOT_DIR is not a directory")}select(undef,undef,undef,$DELAY)if$n < $TRIES}warn "Couldn't create $TEST_DIR in $TRIES tries.\n" ."Using a regular tempdir instead.\n";$TEST_DIR=File::Temp::tempdir(TMPDIR=>1,CLEANUP=>1);return}sub _cleanup {return if$ENV{PERL_TEST_TEMPDIR_TINY_NOCLEANUP};if ($ROOT_DIR && -d $ROOT_DIR){if ($SYSTEM_TEMP or not $?){chdir _untaint($ORIGINAL_CWD)or chdir "/" or warn "Can't chdir to '$ORIGINAL_CWD' or '/'. Cleanup might fail.";remove_tree(_untaint($TEST_DIR),{safe=>0 })if -d $TEST_DIR}rmdir _untaint($ROOT_DIR)unless -l $ROOT_DIR}}sub _root_dir {return$ROOT_DIR}END {if ($$==$ORIGINAL_PID){if ($] lt "5.008000"){*Test::TempDir::Tiny::_CLEANER::DESTROY=\&_cleanup;*blob=bless({},'Test::TempDir::Tiny::_CLEANER')}else {require B;push @{B::end_av()->object_2svref},\&_cleanup}}}1;
TEST_TEMPDIR_TINY

$fatpacked{"Try/Tiny.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'TRY_TINY';
  package Try::Tiny;use 5.006;our$VERSION='0.05';use strict;use warnings;use Exporter 5.57 'import';our@EXPORT=our@EXPORT_OK=qw(try catch finally);use Carp;$Carp::Internal{+__PACKAGE__}++;BEGIN {my$su=$INC{'Sub/Util.pm'}&& defined&Sub::Util::set_subname;my$sn=$INC{'Sub/Name.pm'}&& eval {Sub::Name->VERSION(0.08)};unless ($su || $sn){$su=eval {require Sub::Util}&& defined&Sub::Util::set_subname;unless ($su){$sn=eval {require Sub::Name;Sub::Name->VERSION(0.08)}}}*_subname=$su ? \&Sub::Util::set_subname : $sn ? \&Sub::Name::subname : sub {$_[1]};*_HAS_SUBNAME=($su || $sn)? sub(){1}: sub(){0}}my%_finally_guards;sub try (&;@) {my ($try,@code_refs)=@_;my$wantarray=wantarray;my ($catch,@finally)=();for my$code_ref (@code_refs){if (ref($code_ref)eq 'Try::Tiny::Catch'){croak 'A try() may not be followed by multiple catch() blocks' if$catch;$catch=${$code_ref}}elsif (ref($code_ref)eq 'Try::Tiny::Finally'){push@finally,${$code_ref}}else {croak('try() encountered an unexpected argument (' .(defined$code_ref ? $code_ref : 'undef').') - perhaps a missing semi-colon before or')}}_subname(caller().'::try {...} '=>$try)if _HAS_SUBNAME;local$_finally_guards{guards}=[map {Try::Tiny::ScopeGuard->_new($_)}@finally ];my$prev_error=$@;my (@ret,$error);my$failed=not eval {$@=$prev_error;if ($wantarray){@ret=$try->()}elsif (defined$wantarray){$ret[0]=$try->()}else {$try->()};return 1};$error=$@;$@=$prev_error;if ($failed){push @$_,$error for @{$_finally_guards{guards}};if ($catch){for ($error){return$catch->($error)}}return}else {return$wantarray ? @ret : $ret[0]}}sub catch (&;@) {my ($block,@rest)=@_;croak 'Useless bare catch()' unless wantarray;_subname(caller().'::catch {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Catch'),@rest,)}sub finally (&;@) {my ($block,@rest)=@_;croak 'Useless bare finally()' unless wantarray;_subname(caller().'::finally {...} '=>$block)if _HAS_SUBNAME;return (bless(\$block,'Try::Tiny::Finally'),@rest,)}{package Try::Tiny::ScopeGuard;use constant UNSTABLE_DOLLARAT=>("$]" < '5.013002')? 1 : 0;sub _new {shift;bless [@_ ]}sub DESTROY {my ($code,@args)=@{$_[0]};local $@ if UNSTABLE_DOLLARAT;eval {$code->(@args);1}or do {warn "Execution of finally() block $code resulted in an exception, which " .'*CAN NOT BE PROPAGATED* due to fundamental limitations of Perl. ' .'Your program will continue as if this event never took place. ' ."Original exception text follows:\n\n" .(defined $@ ? $@ : '$@ left undefined...')."\n" }}}__PACKAGE__ 
TRY_TINY

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE


use strict;
use warnings;

use Getopt::Long;
use App::Kritika;
use App::Kritika::Settings;

my $opt_diff_branch;
my $opt_diff_ref;
my $opt_diff_snapshot;
GetOptions(
    'diff-branch=s'   => \$opt_diff_branch,
    'diff-ref=s'      => \$opt_diff_ref,
    'diff-snapshot=i' => \$opt_diff_snapshot,
) or die("Error in command line arguments\n");

my @files;

if ( !-t STDIN ) {
    @files = map { chomp $_; $_ } <>;
}
else {
    @files = @ARGV;
}

@files = grep { -f $_ } @files;

die <<"EOF" unless @files;
Usage: [--diff-ref=<reference>]
       [--diff-snapshot=<snapshot-seq>]
       [--diff-branch=<branch>]
       <file>...
EOF

my $settings = App::Kritika::Settings->new( file => $files[0] )->settings;

my $kritika = App::Kritika->new(
    %$settings,
    diff_branch   => $opt_diff_branch,
    diff_ref      => $opt_diff_ref,
    diff_snapshot => $opt_diff_snapshot
);

my $issues_found = 0;

my $report = $kritika->validate(@files);

if ( $report->{success} ) {
    print "No violations found\n";

    exit 0;
}
else {
    foreach my $file ( @{ $report->{files} } ) {
        if ( $file->{success} ) {
            print "$file->{path}:OK\n";
            next;
        }

        foreach my $violation ( sort { $a->{line_no} <=> $b->{line_no} }
            @{ $file->{violations} } )
        {
            $violation->{col_no} //= 1;
            print "$file->{path}:$violation->{line_no}:$violation->{col_no}: "
              . "[$violation->{profile}/$violation->{rule}] $violation->{message}\n";
        }
    }

    exit $report->{violations_found};
}

__END__

=head1 NAME

kritika - integrate with kritika.io

=head1 SYNOPSIS

    # Full file analysis
    kritika lib/MyFile.pm

    # Report only *new* violations
    kritika --diff master lib/OtherFile.pm
    kritika --diff #31 lib/OtherFile.pm
    kritika --diff 451e77f3 lib/OtherFile.pm

=head1 DESCRIPTION

This command allows you to quickly analyze file using L<https://kritika.io> service. Normally C<kritika.io> analyzes
your repository after the push, but of course sometimes you would like to know if something's wrong before doing
a commit.

=head2 Git Hook Example

This is based on the shipped with C<git> pre-push hook example.

    #!/bin/sh

    remote="$1"
    url="$2"

    z40=0000000000000000000000000000000000000000

    while read local_ref local_sha remote_ref remote_sha
    do
        if [ "$local_sha" = $z40 ]
        then
            :
        else
            if [ "$remote_sha" = $z40 ]
            then
                range="$local_sha"
            else
                range="$remote_sha..$local_sha"
            fi

            branch="$(git rev-parse --abbrev-ref HEAD)"

            git diff --name-only $range | kritika --diff-branch master --branch "$branch" --revision "$local_sha" || exit 1
        fi
    done

    exit 0

This command easily integrates with text editors.

=head1 CONFIGURATION

A special file C<.kritikarc> (or C<_kritikarc> on Windows) has to be placed in the root directory of the project with
the following configuration:

    # This is the default, if you're using public Kritika service this option is not needed
    base_url=https://kritika.io

    # This is your repository token that you can obtain from the repository integrations page on kritika.io
    token=deba194179c1bdd7fca70724d57d85a7ed8d6dbe

If you want to force project root, use C<root> option:

    root=/path/to/my/project

=head1 TEXT EDITORS

C<kritika> produces text output by default. This can be parsed by editors that support error reporting.

=head2 Vim

You can either manually call kritika from C<vim>:

    :!kritika %

Or use a C<compiler> plugin L<https://github.com/kritikaio/vim-kritika>.

    :compiler kritika
    :Kritika

=head2 SublimeText3

See L<https://github.com/kritikaio/SublimeLinter-kritika> plugin.

=head1 DEVELOPMENT

=head2 Repository

    http://github.com/kritikaio/app-kritika

=head1 CREDITS

=head1 AUTHOR

Viacheslav Tykhanovskyi, C<vti@cpan.org>.

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2017, Viacheslav Tykhanovskyi

This program is free software, you can redistribute it and/or modify it under
the terms of the Artistic License version 2.0.

=cut
