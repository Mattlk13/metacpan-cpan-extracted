#! /usr/bin/perl

# Beware: DON'T PERFORM ANY ACTIONS AT TOP LEVEL: this file runs many times under -n!

our $VERSION;
BEGIN {
    $VERSION = '0.58.0';
    my $execed = shift if @ARGV && $ARGV[0] eq '+'; # don't recursively call perl again for -p
    return unless @ARGV and $ARGV[0] =~ /^-/s;
    my $onepl = qr/[oOrhv?]|[pP](?:[1-9][0-9]*)?/; # simple pl opts, reflect these in pod/html
    my $one = qr/[cftTuUwWXan]|$onepl/; # simple opts to pass to perl, which handles them well
    my( $perl, @perl, @pl1, %seen );
    while( @ARGV ) {		# no for, may need to shift
	$_ = $ARGV[0];
	last unless /^-/s;
	shift;
	last if /^--$/s;
	if( /^--(?:help|version|color(?:|=never|=always|=auto))$/s ) {
	    push @pl::opts, $_;
	    next;
	}
	unshift @ARGV, "-$1" if s/^-$one*[0l][0-7]*$onepl+\K(0.*)//; # avoid -l012o0 -> -l0120
	if( /^(-$one*(?:[0l][0-7]*$one*)*)(?:([CdDFiImM0bBeEV])(.*))?$/s ) { # Perl does 0 & l inline only with oct arg.
	    my( $opts, $opt, $arg ) = ($1, $2, $3);
	    $seen{$_} ||= $opts =~ $_ for qw(a n o O p P r);
	    push @pl1, $1 while $opts =~ s/($onepl)//;
	    if( defined $opt ) {
		if( ! length $arg and $opt =~ /[IbBeEV]/ ) { # These can have arg glued or separated
		    $arg = shift;
		    unless( defined $arg ) {
			warn "Missing argument to -$opt.\n";
			exit 29;
		    }
		}
		if( $opt eq 'V' ) {
		    $perl = "perl$arg";
		    undef $opt; # treat $opts below
		} elsif( $opt eq 'I' ) {
		    push @perl, $opts.'I', $arg; # let perl check for empty arg
		} elsif( $opt =~ /[be]/i ) {
		    $seen{$opt} ||= $opt =~ /[be]/;
		    push @pl::opts, join( '', '-', @pl1, $opt ), $arg;
		    @pl1 = ();
		    undef $opt; # treat $opts below
		} else {
		    $seen{F} ||= $opt eq 'F';
		    push @perl, $opts.$opt.$arg;
		}
	    }
	    unless( defined $opt ) { # no else, because of -[bBeEV] above
		push @perl, $opts if 1 < length $opts;
	    }
	} else {
	    s/^-$one*(?:[0l][0-7]*$one*)*(.).*/-$1/;
	    warn "Unrecognized switch: $_  (-h will show valid options).\n";
	    exit 29;
	}
    }
    $seen{a} ||= push @perl, '-a' if $seen{F};
    $seen{n} ||= push @perl, '-n'
      if ! grep $seen{$_}, qw(o O)
      and grep $seen{$_}, qw(a b e p P r);
    push @pl::opts, join '', '-', @pl1 if @pl1;
#warn join '|', $perl // $^X, @perl, '--', $0, '+', @pl::opts, '--', @ARGV, "\n";
    if( ! $execed and $perl || @perl ) { # let perl do perl-opts
	unshift @ARGV, $perl //= $^X, @perl, '--', $0, '+', @pl::opts, '--';
	if( $^O =~ /^MSWin/ ) {
	    require Win32::ShellQuote;
	    my $ret = system {$ARGV[0]} Win32::ShellQuote::quote_system_list( @ARGV );
	    warn $perl, ": $!\n" if $!;
	    exit $ret >> 8;
	}
	exec @ARGV;
	warn $perl, ": $!\n";
	exit 1;
    }
}

use strict;

{
    package Data::Dumper;
    our $Deparse = 1;
    our $Quotekeys = 0;
    our $Sortkeys = sub { [&pl::sort_keys] };
    our $Terse = 1;
}

#use warnings;

use feature ':'.substr $^V, 1; # Enable latest optional features.
use sort 'stable';

use List::Util;
use List::Util @List::Util::EXPORT_OK;


our( $A, @A,
     @F, @FIELD,
     $H, $HEX_SORT,
     $I, $ARGIND,
     %K, %KEYDIFF,
     %N, %NUMBER,
     $q, $quote,
     $Q, $Quote,
     $R, $RESULT,
     @R, @RESULT,
     %R, %RESULT,
     $T, $TXT_SORT );



# Echo
sub echo(@) { local( $,, $\ )     = (' ', "\n");  print &pl::pretty }

# Echo without newline
sub Echo(@) { local( $,, $\, $| ) = (' ', '', 1); print &pl::pretty }

# Builtin format is useless in one-liners, but not overridable
sub form($@) {		  printf shift() . "\n", &pl::pretty }

# Format without newline
sub Form($@) { local $| = 1; printf shift,		 &pl::pretty }


sub benchmark(&@) {
    my( $code, $name, @args ) = @_;
    local( $a, $b ) = ($a, $b);
    $name //= 'anonymous';
    require Benchmark;
    local $SIG{__WARN__} = sub { die @_ };
    if( @args ) {
	echo Benchmark::timestr( Benchmark::countit( 10, $code )), "$name: $_"
	    for @args;
    } else {
	echo Benchmark::timestr( Benchmark::countit( 10, $code )), " $name";
    }
}

# Do it 100x for very fast test code (to increase weight compared to Benchmark overhead).
sub Benchmark(&@) {
    my( $code, @rest ) = @_;
    benchmark { for my $i (0..99) { &$code() }} @rest;
}

sub Config(@) {
    require Config;
    if( @_ ) {
	#{map { pairgrep { $a =~ /$_/ } %Config::Config } @_}; # needs 5.20
	my %config;
	while( my( $k, $v ) = each %Config::Config ) {
	    $k =~ $_ and $config{$k} = $v, last
	      for @_;
	}
	\%config;
    } else {
	\%Config::Config;
    }
}

sub Date(@) {
    my( $s, $us, $z, $zo );
    require Time::HiRes;
    for( @_ ) {
	if( ref ) {
	    ($s, $us) = @$_;
	} elsif( /^([-+]?)(1[0-4]|0?[0-9])(?:\.([0-9])([0-9])?|:([0-5])?([0-9]))?$/i ) {
	    $z = $2 * 3600  +  ($3 ? ($3.($4//0)) * 36  :  $6 ? (($5//0).$6) * 60  :  0);
	    $zo = sprintf ' %s%02d:%02d', $1 || '+', $z / 3600, $z % 3600 / 60;
	    $z = -$z if $1 eq '-';
	} elsif( /^([-+]?)(?=.)([0-9]*)(?:\.([0-9]*))?$/i ) {
	    my $nus = substr +($3 // '') . '0'x6, 0, 6;
	    if( $1 ) {
		($s, $us) = Time::HiRes::gettimeofday() unless defined $s;
		if( $1 eq '+' ) {
		    $s += $2 // 0;
		    $us += $nus;
		    ++$s, $us -= 1e6 if $us >= 1e6;
		} else {
		    $s -= $2 // 0;
		    $us -= $nus;
		    --$s, $us += 1e6 if $us < 0;
		}
	    } else {
		$s = $2 // 0;
		$us = $nus;
	    }
	}
    }
    ($s, $us) = Time::HiRes::gettimeofday() unless defined $s;
    if( $pl::isodate ) {
	my @time = reverse +(defined( $z ) ? gmtime $s + $z : localtime $s)[0..5];
	$s = sprintf '%04d-%02d-%02dT%02d:%02d:%02d.%06d%s', 1900 + shift( @time ), 1 + shift( @time ), @time, $us, $zo // '';
    } else {
	$s = defined( $z ) ? gmtime $s + $z : localtime $s;
	substr $s, 19, 0, $zo if $zo;
	substr $s, 19, 0, sprintf '.%06d', $us // 0;
    }
    defined wantarray ? $s : echo $s;
}

sub Isodate(@) {
    local $pl::isodate = 1;
    &Date;
}

# turns list of ipv4/6 addresses & hostnames or $_ into /etc/hosts format
# todo comment not found
sub hosts(@) {
    require Socket;
    package Socket;
    my( %res, %name );
    my $res = sub {
	my( $v4, $name, $aliases, undef, undef, @addr ) = @_;
	undef $name{$_} for $name, split ' ', $aliases;
	for( @addr ) {
	    $_ = unpack 'H*', $_;
	    if( $v4 ) { # make sortable by kind
		s/^(?=7f)/g/ or # loopback
		  s/^(?=a9fe)/i/ or # link local
		  s/^(?=0a|ac1|c0a8)/k/ or # private
		  substr $_, 0, 0, 'm';
	    } else {
		s/^(?=0+1$)/h/ or # loopback
		  s/^(?=fe[89ab])/j/ or # link local
		  s/^(?=fd)/l/ or # private
		  substr $_, 0, 0, 'n';
	    }
	    @{$res{$_}}{keys %name} = (); # don't just store %name, different names might point to same IP but not vice versa
	}
    };
    my @unpack = (\&unpack_sockaddr_in6, \&unpack_sockaddr_in);
    for my $name ( @_ ? @_ : $_ ) {
	if( exists &getaddrinfo ) { # somewhere > v5.16.3
	    for( getaddrinfo( $name, undef, {socktype => SOCK_STREAM()} )) {
		next unless ref; # 1st is return code
		%name = ();
		undef $name{$_->{canonname}} if defined $_->{canonname};
		my $v4 = $_->{family} == AF_INET();
		my $addr = $unpack[$v4]->( $_->{addr} );
		my @get = gethostbyaddr( $addr, $_->{family} );
		&$res( $v4, @get ? @get : ($name, (undef)x3, $addr) );
	    }
	} else {		# older perl
	    %name = ();
	    my $addr;
	    my $v6 = $name =~ /:/ || exists &inet_pton;
	    my @get = $v6 ? gethostbyaddr( $addr = inet_pton( AF_INET6(), $name ), AF_INET6()) :
	      $name =~ /[a-z]/i ? gethostbyname( $name ) :
	      gethostbyaddr $addr = inet_aton( $name ), AF_INET();
	    &$res( ! $v6, @get ? @get : ($name, (undef)x3, $addr) );
	}
    }
    for( sort keys %res ) {
	next if 1 == length;	# IPv6 on old perl
	my $ip = pack 'H*', substr $_, 1;
	::echo 4 == length $ip ? inet_ntoa( $ip ) : inet_ntop( AF_INET6(), $ip ),
	  sort grep ! /^[0-9.]+$|^(?=.*:)[0-9a-f:]+$/i, keys %{$res{$_}};
    }
}

# Fill keydiff arrays
sub keydiff(;$$) {
    my $val;
    if( @_ > 1 ) {
	$val = $_[1];
    } else {
	chomp( $val = $_ );
    }
    $KEYDIFF{@_ == 0 ? $1 : $_[0]}[$ARGIND] = $val;
}
sub Keydiff(;$$) {
    my $key = $FIELD[@_ == 0 ? 0 : $_[0]];
    if( @_ > 1 ) {
	keydiff $key, $_[1];
    } else {
	keydiff $key;
    }
}

# trim small values from %NUMBER
sub Number(;$) {
    my $n = $_[0] // 2;
    $NUMBER{$_} < $n and delete $NUMBER{$_} for keys %NUMBER;
}

# Pipe command to CODE
sub piped(&$@) {
    my $code = shift;
    open my $fd, "-|", @_ or die "$_[0]: $!\n";
    &$code() while <$fd>;
}


sub help(;$) {
    if( @_ && ! defined $_[0] ) {
	print <<\EOF;
usage: pl {-{BbeE} program} [-o] [-Vversion] [-perlopt...] [--] [main program] [arg ...]
  -bprog & -eprog   wrap begin/end program around each file in -n/-p...
  -Bprog & -Eprog   wrap begin/end program around program in same scope, my-vars work.
  -o                assume "for(@A) { ... }" loop around main program
  -O                assume "for $A (@A) { ... }" loop around main program
  -p[number]        print on each loop (also -o/-O) iteration, at most number times
  -P[number]        like -p, but print only if main program evaluates to true, like grep
  -r                reset "$." and -p/-P counter for each file
  -VVERSION         rerun with given version, which is just appended to "perl".
  --color[=when]    colorize the output; when can be 'never', 'always', or 'auto' (the default)
These options are handled by perl:
EOF
	piped { Echo if /^\s+-[0acCdDfFiImMntTuUvwWX]/ } $^X, '-h';
    }
    print <<\EOF;
Predefined functions:
  b { } name, arg... benchmark slow code for 10s, display name, looping over args.
  B { } name, arg... same, but run code 100 times in benchmark, to reduce overhead.
  C re...           %Config, e.g. C->{sitelib}, optionally only part matching regexps
  D [arg...][, tz]  Date (from arg [s, us], s{.us}, offset [+-]s{.us}, tz ([+-]0-14{:mm|.ff})
  e arg...          echo prettified args or $_ with spaces and newline
  E arg...          same, but no newline
  f fmt, arg...     format prettified args with newline
  F fmt, arg...     same, but no newline
  I [arg...][, tz]  Isodate (from arg [s, us], s{.us}, offset [+-]s{.us}, tz ([+-]0-14{:mm|.ff})
  k [key, value]    store value or chomped $_ in $K{key or $1}[$I] for keydiff
  K [number, value] same, but key is $F[number] or $F[0]
  N [n]             trim %N values less than n (default 2) e.g.; -EN or -E 'N 5'
  p { } cmd, arg... open pipe from cmd and loop over it.
Predefined & magic variables:
  *A	*ARGV	    A, $A & @A are aliases to ARGV, $ARGV & @ARGV
  $I	0..n	    index of ARG currently being processed in -o, -n or -p
  $q	'
  $Q	"
  %K	()[]	    at end, sort by keys, print keydiff of $I array elements.  Filled by k.
  %N	()	    at end, sort numerically by values
  *R	undef () {} at end, print each, if defined or not empty, %RESULT sorted by keys
EOF
}



# \todo help doc readline test:my
{
package pl;

our %c;

# It's annoyingly hard to figure out if all are unique & lexically compatible numbers, or whether to sort textually.
sub sort_keys(\%) {
    my $hash = $_[0];
    return () unless keys %$hash;
    goto TXT if $::TXT_SORT;
    my( $hex, $perl, $no_oct, %seen, @seen_oct ) = $::HEX_SORT;
    for( keys %$hash ) {
	goto TXT if /[^0-9a-fx._+-]/i;
	$hex = 0, last unless /^[0-9a-f](?:_?[0-9a-f]+)*$/i;
	goto TXT if exists $seen{hex $_};
	undef $seen{hex $_};
    }
    return sort { hex $a <=> hex $b } keys %$hash if $hex;

    %seen = ();
    for( keys %$hash ) {
	unless( $no_oct ||= /^[+-]?0(?=.*[89])/ ) {
	    if( /^[+-]?0(?:b(?:_?[01]+)*|x(?:_?[0-9a-f]+)*)$/i ) {
		goto TXT if exists $seen{eval $_};
		undef $seen{eval $_};
		$perl = 1, next;
	    }
	    if( /^[+-]?0(?:_?[0-7]+)*$/ ) {
		push @seen_oct, $_; # can't decide yet
		next;
	    }
	}

	if( /^[+-]?(?=.)[0-9]*(?:\.[0-9]*)?(?:(?<=.)e[+-]?[0-9]+)?$/i ) {
	    goto TXT if exists $seen{0 + $_};
	    undef $seen{0 + $_};
	    next;
	}

	goto TXT;
    }
    if( $perl ) {
	goto TXT if $no_oct;
	for( @seen_oct  ) {
	    goto TXT if exists $seen{eval $_};
	    undef $seen{eval $_};
	}
	return sort { eval $a <=> eval $b } keys %$hash;
    } else {
	for( @seen_oct  ) {
	    goto TXT if exists $seen{0 + $_};
	    undef $seen{0 + $_};
	}
	return sort { $a <=> $b } keys %$hash;
    }

  TXT:				# clearest solution here
    sort keys %$hash;
}


sub keydiff() {
    goto &_keydiff if $c{E} && eval { require Algorithm::Diff };
    for my $key ( sort_keys %::KEYDIFF ) {
	my( $same, $str ) = 1;
	$#{$::KEYDIFF{$key}} = $ARGIND - 1; # lengthen list if needed
	for( @{$::KEYDIFF{$key}} ) {
	    $str ||= $_ // '$pl::n_a';
	    $same = $str eq ($_ // '$pl::n_a');
	    last unless $same;
	}
	next if $same;
	::echo "$c{B}$key$c{E}";
	::echo defined() ? "\t$_" : "\t$c{I}n/a$c{E}"
	    for @{$::KEYDIFF{$key}};
    }
}
sub _keydiff() {
    for my $key ( sort_keys %::KEYDIFF ) {
	my( $max, $n, $ref ) = (0, 0);
	for( @{$::KEYDIFF{$key}} ) {
	    next unless defined;
	    $max = length if $max < length;
	    ++$n;
	    if( $ref ) {
		$ref = Algorithm::Diff::LCS( $ref, [split //] );
	    } else {
		$ref = [split //];
	    }
	}
	next if $n == $ARGIND && @$ref == $max;
	::echo "$c{B}$key$c{E}";
	$#{$::KEYDIFF{$key}} = $ARGIND - 1; # lengthen list if needed
	for( @{$::KEYDIFF{$key}} ) {
	    if( defined ) {
		if( ! @$ref ) {
		    substr $_, 0, 0, $c{R};
		} elsif( @$ref == length ) {
		    substr $_, 0, 0, $c{G};
		} else {
		    my( undef, $idx ) = Algorithm::Diff::LCSidx( $ref, [split //] );
		    for my $i ( reverse @$idx ) {
			substr $_, $i + 1, 0, $c{R};
			substr $_, $i, 0, $c{G};
		    }
		    substr $_, 0, 0, $c{R};
		    s/\e\[3.m(?=\e\[3.m|$)//g;
		    1 while s/(\e\[3.m)[^\e]+\K\1//;
		}
	    } else {
		$_ = "$c{I}n/a";
	    }
	    ::echo "\t$_$c{E}";
	}
    }
}

sub pretty {
    map {
	if( ! defined ) {
	    "$c{I}undef$c{E}";
	} elsif( !ref ) {
	    $_;
	} elsif( eval { $_->can( '(""' ) } ) {
	    "$_";
	} else {
	    require Data::Dumper;
	    my $ret = Data::Dumper::Dumper( $_ );
	    $ret =~ s/;?\n?$//s;
	    $ret;
	}
    } @_ ? @_ : $_;
}

sub getline {
    { local $\ = ''; print STDERR defined() ? '>> ' : '> ' }
    my $part = <>;
    if( defined $part ) {
	if( defined ) {
	    $_ .= "\n" . $part;
	} else {
	    $_ = $part;
	}
    } else {
	say '';
	exit;
    }
}
sub shell {
    # No my, as that would inject into eval.
    our $lp = eval { require Lexical::Persistence; Lexical::Persistence->new() };
    while( 1 ) {
	our $lines = undef;
	for( $lines ) {
	    &getline;
	    &getline while s/\\$//s;
	    if( /\{$/s ) {
		&getline until /\n\}$/s;
	    }
	}
	{
	    package main;
	    $lp ? $lp->do( $lines ) : eval $lines;
	}
	warn $@ if $@;
    }
}

sub selftest {
    eval join '', <::DATA>;
    warn $@ if $@;
}
}



# Put this before compiling caller's main program, as these get run LIFO.
END {
    echo $RESULT if defined $RESULT;
    echo for @RESULT;
    form "%s:  %s", $_, $RESULT{$_}
	for pl::sort_keys %RESULT;

    # todo lenint.lenfloat %d/f
    printf "%8d: %s\n", $NUMBER{$_}, $_
	for sort { $NUMBER{$a} <=> $NUMBER{$b} } pl::sort_keys %NUMBER;
    &pl::keydiff if keys %KEYDIFF;
}



BEGIN {
    *I = \$ARGIND;
    *FIELD = \@F;
    eval '*' . substr( $_, 1, 1 ) . " = \\$_" for
      qw'*ARGV &benchmark &Benchmark &Config &Date &echo &Echo &form &Form &hosts $HEX_SORT &Isodate &keydiff &Keydiff %KEYDIFF &Number %NUMBER &piped $quote $Quote *RESULT $TXT_SORT';

    ($ARGIND, $quote, $Quote, $H) = (0, "'", '"', 1);
    unless( @pl::opts || @ARGV ) {
	*pl::prog = \&pl::shell;
	return;
    }

    {
	# Assemble a program that works under perl -n, etc., while adding in pl's options.
	# This is wild stuff, as it has to blend in various options, while potentially accomodating an outer loop.
	my @prog;
	@prog[2, 4, 11, 13, 22] =
	  ('sub pl::prog { $pl::last = 1;',
	   'LINE: {',		# dummy loop
	   '} continue {',		# program didn't do last
	   '$pl::last = 0 }',
	   '}');

	while( @pl::opts ) {	# no for, need to shift
	    $_ = shift @pl::opts;
	    if( /^--color(?:()|=(a)lways|=(n)ever|=auto)$/s ) {
		$pl::c = defined( $1 ) || $2 ? 1 : $3 ? 0 : undef;
		next;
	    } elsif( /[?h]/ ) {
		help undef;
		exit;
	    } elsif( /v/ ) {
		echo "This is pl v$VERSION, with perl $^V

Copyright 1997-2020, Daniel Pfeiffer

Pl may be copied only under the terms of either the Artistic License or the
GNU General Public License, which may be found in the Perl 5 source kit.";
		exit;
	    }

	    if( /([be])/i ) {
		# put ; after \n as user may end with a comment
		my $bit = "\n#line 1 \"-$1 option\"\n" . shift( @pl::opts ) . "\n;";
		if( /b/ ) {
		    # Do it each time ARGV changes
		    $prog[5] = 'if( ($pl::exARGV //= "") ne $ARGV ) {' . $bit . '$pl::exARGV = $ARGV; }';
		} elsif( /B/ ) {
		    $prog[0] = $bit;
		} elsif( /e/ ) {
		    $prog[8] = "\nINIT { \$pl::_e = sub { $bit }}";
		    $pl::_e = '&$pl::_e();';
		} else {
		    $prog[9] = "\n;END { $bit }";
		}
	    }
	    @prog[3, 14] =
	      (/O/ ? 'for $ARGV (@ARGV) {' : 'for(@ARGV) {',
	       '} continue { ++$ARGIND; last if $pl::last }')
		if /o/i;
	    if( /p([1-9][0-9]*)?/i ) {
		my $p = $1;
		$prog[1] = '$pl::_pn = 0;';
		@prog[6, 10] =
		  ('$pl::_P = do {',
		   '}') if /P/;
		$prog[12] = '++$pl::_pn, print or die "-p destination: $!\n"' . (/P/ ? 'if $pl::_P;' : ';');
		$prog[13] =~ s/0/\$pl::_pn >= $p ? 2 : 0/ if $p;
	    }
	    $pl::_r = 1 if /r/;
	}
	$prog[7] = @ARGV ? "\n#line 1 \"main program\"\n" . shift() . "\n;" : ';';
	#$prog[13] =~ s/\$pl::last =( \$pl::_pn >= \d+)/ if($1 ) { &\$pl::_e() if \$pl::_e; exit }/ unless $pl::_r || $prog[14];
	$prog[14] //= 		# ! -[oO]
	  'if( $pl::last || eof ) { ++$ARGIND;' .
	    ($pl::_r ? 'close ARGV; $pl::_pn = 0;' : 'if( $pl::last ) { my $d = $.; close ARGV; $. = $d }') .
	      ($pl::_e // '') .
		($pl::_r ? '}' : 'exit if $pl::last == 2 }');
	# Don't pollute eval with my-vars
	$_ = join '', grep defined, @prog;
    };
    #no warnings 'experimental';	# overridden by -W
    no strict;
    if( $ENV{PLDUMP} ) { open STDOUT, '| perltidy -cb'; echo; exit }
    eval;
    if( $@ ) {
	warn $@;
	exit 255;
    }
    undef $_;
    @pl::c{qw(B I G R E)} = $pl::c // (-t STDOUT && $^O !~ /^MSWin/) ?
      map "\e[${_}m", 1, 3, 32, 31, '' :
      ('')x5;
}
&pl::prog; # will be called repeatedly if -n

__DATA__

# Code for pl::selftest

sub assert($$$) {
    my( $msg, $exp, $res ) = @_;
    warn "[[$msg]]\n" if defined $msg;
    warn pretty "  expected: ", $exp, "  got: ", $res
	if defined $exp ? (defined $res ? $exp ne $res : 1) : defined $res;
}

# Emulate -n from in-memory files.
sub n_loop(&@) {
    my $code = shift;
    $::I = 0;
    for my $arg ( @_ ) {
	open my $fd, '<', \$arg;
	$::A = "file$::I";
	&$code() for <$fd>;
	++$::I;
    }
}

sub stdout(&) {
    open my $fd, '>', \my $str;
    my $orig = select $fd;
    eval { $_[0]->() };
    warn $@ if $@;
    select $orig;
    close $fd;
    $str;
}

sub test_sort_keys(&$@) {
    my( $cmp, $msg ) = splice @_, 0, 2;
    warn "[[sort_$msg]]\n" if defined $msg;
    my( %x, $prev, $res );
    for( 0..9 ) {		# Retry, one sorting bug was key order related.
	@x{@_} = ();
	if( defined $prev ) {
	    $res = join '|', sort_keys %x;
	    last if $res ne $prev;
	} else {
	    $prev = join '|', sort_keys %x;
	}
    }
    assert undef, join( '|', $cmp ? sort $cmp @_ : sort @_ ), $res eq $prev ? $res : "$res\n\tand also: $prev";
}

warn "Starting tests\n";
# assert assert_ok1 => undef, undef;
# assert assert_ok2 => 1, 1;
# assert assert_ok3 => '', '';
# assert assert_fail1 => undef, 1;
# assert assert_fail2 => 1, undef;
# assert assert_fail3 => 0, 1;

# assert stdout => "$_\n", stdout \&::echo for 'foo', 'bar';

# assert n_loop => "file0 a\n\nfile0 b\nfile1 c\n\nfile2 d\n\nfile2 e\n\nfile2 f\n",
#     stdout { n_loop { ::echo $::A, $_ } "a\nb", "c\n", "d\ne\nf" };

my @l = qw(0 a b c aa bb cc 0b1 0b2 07 08 babe bad be);
( $H, $T ) = 0;
test_sort_keys undef, no_hex => @l;
$H = 1;
test_sort_keys { hex $a <=> hex $b } hex => @l;
$T = 1;
test_sort_keys undef, hex_txt => @l;
$T = 0;
test_sort_keys undef, txt => @l, 'z';
test_sort_keys undef, hex_mix => @l, qw(1.1 +2);
test_sort_keys undef, hex_dup => @l, 'c_c';
test_sort_keys undef, dupcasehex => @l, 'CC';
test_sort_keys { $a <=> $b } num => qw(-1 -.5 0 1 +2 3 04);
@l = qw(-1 0 1 -1.1 .2 +.3 5. -1e-2 +1e-2 -1.e2 -.1e2 1.E2 -0X2 0x0_2 -0b1_1 0B1_1 04 -04);
test_sort_keys { eval $a <=> eval $b } pl => @l;
test_sort_keys undef, no_oct => @l, '08';
test_sort_keys undef, dupx => @l, '0X2';
test_sort_keys undef, dupn => @l, 100;

my $stdin = <<\EOF;
echo 1
echo 2\
, 3
for( 4, 5 ) {
    echo;
}
EOF
#close STDIN; open STDIN, '<', \$stdin;
#::echo '[[', stdout( \&shell ), ']]';
warn "Ending tests\n";



=head1 NAME

pl - Perl One-Liner Magic Wand

=head1 SYNOPSIS

There are always those tasks too menial for dedicated script, but still too
cumbersome even with the many neat one-liner options of C<perl -E>.  This
small script fills the gap with many bells & whistles: Various one-letter
commands & magic variables (with meaningful aliases too) and more nifty loop
options take Perl programming to the command line.  C<List::Util> is fully
imported.  If you pass no program on the command line, starts a simple Perl
Shell.

How to C<e(cho)> values, including from C<@A(RGV)>, with single C<$q(uote)> &
double C<$Q(uote)>:

    pl 'echo "${quote}Perl$quote", "$Quote@ARGV$Quote"' one liner
    pl 'e "${q}Perl$q", "$Q@A$Q"' one liner

    >   'Perl' "one liner"

Same for hard-to-print values:

    pl 'echo \"Perl", \@ARGV, undef' one liner
    pl 'e \"Perl", \@A, undef' one liner

    >   \'Perl' [
    >     'one',
    >     'liner'
    >   ] undef

Loop over args, printing each with line ending.  And same, SHOUTING:

    pl -opl '' Perl one liner
    pl -opl '$_ = uc' Perl one liner

    >   Perl
    >   one
    >   liner
    >   PERL
    >   ONE
    >   LINER

Print up to 3 matching lines, resetting count (and C<$.>) for each file:

    pl -rP3 '/Perl.*one.*liner/' file*

Count hits in magic statistics hash C<%N(UMBER)>:

    pl -n '++$NUMBER{$1} while /(Perl|one|liner)/g' file*
    pl -n '++$N{$1} while /(Perl|one|liner)/g' file*

    >          2: one
    >          7: liner
    >          9: Perl

Though they are sometimes slightly, sometimes quite a bit more complicated,
most Perl one-liners from the internet work, just by omitting C<-e> or C<-E>
(pl has only one, but you can just as well concatenate them with C<;>).  See
L<minor differences|/"Minor Differences with perl -e"> for exceptions.

=head1 DESCRIPTION

I<Don't believe everything you read on SourceForge^H^H^H the internet! -- Aristotle ;-)>

Pl follows Perl's philosophy for one-liners: the one variable solely used in
one-liners, C<@F>, is single-lettered.  Because not everyone may like that, Pl
has it both ways.  Everything is aliased both as a word and as a single
letter, including Perl's own C<@F> & C<*ARGV>.

Perl one-liners, and hence pl, are by nature bilingual.  You must run the
command with its options & arguments, typically from Shell.  By design, Perl
quotes mimic Shell quotes, so here they collide.  As Perl also uses Shell
meta-characters like C<$>, the best solution is to protect Perl-code from the
Shell with single quotes.  That means they can't be used inside.  (An ugly way
around that is C<'\''>, which ends a string, blackslashes a quote and starts
another.  For literal quotes use C<$q(uote)>.)  Double quotes or C<q{}> are
the way to go.

=head1 DOCUMENTATION

=head2 Options

=over

=item C<-0I<[octal]>>

I<perl:> Specify record separator with B<-n>/B<-p> (C<\0>, if no argument).

=item C<-a>

I<perl:> Autosplit mode with B<-n>/B<-p> (splits C<$_> into C<@F(IELD)>).

=item C<-bI<prog>>

Run program before reading a new file in B<-n>/B<-p>.

=item C<-BI<prog>>

Add program before main program in same scope.  So you can use it to
initialise C<my> variables.  Whereas, if you define a my variable in the main
program of a B<-n>, B<-p>, B<-P>, B<-o> or B<-O> loop, it's a new variable on
each iteration.  This doesn't do a C<BEGIN> block, but this might be changed in
a later version if program is wrapped in C<{}>.

=item C<-c>

I<perl:> Check syntax only (runs C<BEGIN> and C<CHECK> blocks).

=item C<-CI<[number/list]>>

I<perl:> Enables the listed Unicode features.

=item C<--colorI<[=when]>>

Colorize some of the output; when can be C<never>, C<always>, or C<auto> (the default).

=item C<-dI<[:debugger]>>

I<perl:> Run program under debugger.

=item C<-DI<[number/list]>>

I<perl:> Set debugging flags (argument is a bit mask or alphabets).

=item C<-eI<prog>>

Run program after finishing reading a file in B<-n>/B<-p>.

=item C<-EI<prog>>

Add an C<END> block after main-program in same scope.  So C<my>-vars work as
follows: The C<END> block, is a closure of the 1st C<$inner> variable.  Perl
warns "Variable "$inner" will not stay shared":

    pl -OB 'my $outer' -E 'echo $inner, $outer' 'my $inner = $outer = $ARGV' a b c
    pl -OB 'my $outer' -E 'e $inner, $outer' 'my $inner = $outer = $A' a b c

    >   a c

=item C<-f>

I<perl:> Don't do F<$sitelib/sitecustomize.pl> at startup.

=item C<-FI</pattern/>>

I<perl:> Provide C<split()> pattern for B<-a> switch (C<//>'s are optional).

=item C<-II<directory>>

I<perl:> Specify C<@INC>/C<#include> directory (several B<-I>'s allowed).

=item C<-iI<[extension]>>

I<perl:> Edit C<< <> >> files in place (makes backup if extension supplied).

=item C<-n>

I<perl:> Assume C<< while (<>) { ... } >> loop around program.  It's a little
richer than that: if you use C<last>, it closes the current file, leaving you
to continue the loop on the next file.

=item C<-O>

Assume C<for $ARGV (@ARGV) { ... }> loop around main program.  In this case B<-p> doesn't imply B<-n>.

=item C<-o>

Assume C<for(@ARGV) { ... }> loop around main program.  In this case B<-p> doesn't imply B<-n>.

=item C<-pI<[number]>>

I<perl++:> On each loop C<print> (also B<-o>/B<-O>) iteration.  If number is given, print at most number times.

=item C<-PI<[number]>>

Like B<-p>, but print only if main program evaluates to true, like C<grep>.

=item C<-r>

Reset C<$.> and B<-p>/B<-P> counter for each file.

=item C<-T>

I<perl:> Enable tainting checks.

=item C<-t>

I<perl:> Enable tainting warnings.

=item C<-U>

I<perl:> Allow unsafe operations.

=item C<-u>

I<perl:> Dump core after parsing program.

=item C<-v>

I<perl:> Print version, patchlevel and license.

=item C<-VI<VERSION>>

Rerun with given perl version, which is just a string appended to F<perl>.

=item C<-W>

I<perl:> Enable all warnings.

=item C<-w>

I<perl:> Enable many useful warnings.

=item C<-X>

I<perl:> Disable all warnings.

=back

=head2 Functions

=over

=item C<benchmark { } I<[name[, arg...]]>>

Benchmark slow code for 10s, display name, looping over args.  (Abbrev: C<b>)

=item C<Benchmark { } I<[name[, arg...]]>>

Same, but run code 100 times in benchmark, to reduce overhead.  (Abbrev: C<B>)

=item C<Config I<[regexp...]>>

Import and return C<%Config>, e.g. C<< Config->{sitelib} >>, optionally only part matching regexps.  (Abbrev: C<C>)

=item C<Date I<[arg...][, tz]>>

I<Why is Halloween Christmas?  Because Oct. 31 = Dec. 25. ;-)>

Date (from arg [s, us], s{.us}, offset [+-]s{.us}, tz ([+-]0-14{:mm|.ff}).
Microseconds should be passed as strings, because floats have
implementation-dependent rounding issues.  Positive offsets must be passed as
strings, because otherwise the C<+> gets lost.  Returns the date, if called in
some context, else echoes it.  (Abbrev: C<D>)

    pl 'Date; $_ = Date -86400, "+3600"; e $_, " -- ", Date "+8:45"'
    pl 'D; $_ = D -86400, "+3600"; e $_, " -- ", D "+8:45"'

    >   Thu Sep  3 22:51:31.778038 2020
    >   Wed Sep  2 23:51:31.778104 2020  --  Fri Sep  4 05:36:31.778129 +08:45 2020

=item C<echo I<[arg...]>>

Echo prettified args or C<$_> with spaces and newline.  (Abbrev: C<e>)

=item C<Echo I<[arg...]>>

Same, but no newline.  (Abbrev: C<E>)

=item C<form I<format, arg...>>

Form(at) prettified args with newline.  (Abbrev: C<f>)

=item C<Form I<format, arg...>>

Same, but no newline.  (Abbrev: C<F>)

=item C<Isodate [arg...][, tz]>

Same as C<D(ate)>, but uses ISO format.  (Abbrev: C<I>)

    pl 'Isodate; $_ = Isodate 7 * -86400; e $_, " -- ", Isodate "+8.75"'
    pl 'I; $_ = I 7 * -86400; e $_, " -- ", I "+8.75"'

    >   2020-09-03T22:51:31.793797
    >   2020-08-27T22:51:31.793927  --  2020-09-04T05:36:31.793948 +08:45

=item C<keydiff I<[key[, value]]>>

Store value or chomped C<$_> in C<$KEYDIFF{key or $1}[$ARGIND]>.  At the
C<END> for each key (sorted numerically if possible) all values are
diffed. (Abbrev: C<k>)

=item C<Keydiff I<[number[, value]]>>

Same, but key is C<$FIELD[number]> or C<$F[0]>.  (Abbrev: C<K>)

=item C<Number I<[n]>>

Trim C<%N(UMBER)> values less than n (default 2) e.g.; C<B<-E>Number> or C<B<-E> 'N 5'>.  (Abbrev: C<N>)

=item C<piped { } I<cmd[, arg...]>>

Open pipe from cmd and loop over it.  (Abbrev: C<p>)

=back

=head2 Variables

=over

=item C<*ARGV>

I<perl:> C<ARGV>, C<$ARGV> & C<@ARGV> are all aliased to C<A>, C<$A> & C<@A>.  (Abbrev: C<*A>)

=item C<$ARGIND>

Index of ARG currently being processed in B<-o>, B<-n> or B<-p>.  (Abbrev: C<$I>)

=item C<@FIELD>

I<perl:> This is an alias to loop autosplit variable C<@F>.  (Abbrev: C<@F>)

=item C<$quote>

Predefined to a single quote C<'>.  There is no magic associated.  (Abbrev: C<$q>)

=item C<$Quote>

Predefined to a double quote C<">.  There is no magic associated.  (Abbrev: C<$Q>)

=item C<%KEYDIFF>

At END, sort by keys, print keydiff of C<$ARGIND> array elements.  Filled by
C<keydiff>.  (Abbrev: C<%K>)

=item C<%NUMBER>

At END, sort numerically by values.  (Abbrev: C<%N>)

=item C<*RESULT>

At END, echo C<$RESULT> if defined, then C<@RESULT> one per line if not empty,
then C<%RESULT> sorted by keys.  (Abbrev: C<*R>)

=back

=head1 COMPATIBILITY

Even if it is rarer nowadays, Perl 5.10 is still found out in the wild.  Pl
tries to accomodate it gracefully, falling back to what works.  Dumped
data-structures may be formatted with a funny margin and C<h(osts)> will find
the less IPv6 resolutions, the older your Perl.

=head2 Minor Differences with perl -e

Known minor differences are:

=over

=item *

don't C<goto LINE>, but C<next LINE> is fine

=item *

in a B<-n> loop C<last> is per file instead of behaving like C<exit>

=item *

using C<pop>, etc. to implicitly modify C<@A(RGV)> works in B<-B> BEGIN code,
but not in your main program (which gets compiled to a function)

=item *

shenanigans with unbalanced braces won't work

=back

=head2 Windows Notes

I<B<W>ork B<I>s B<N>ever B<D>one B<O>n B<W>indows B<S>ystems ;-)>

Do yourself a favour and get a real Shell, e.g. from WSL, Cygwin, MSYS, MinGW
or git!  If you can't avoid F<command.com> or F<cmd.exe>, you will have to
first convert all inner quotes to C<qq>.  Then convert the outer single quotes
to double quotes:

    pl "echo qq{${quote}Perl$quote}, qq{$Quote@ARGV$Quote}" one liner
    pl "e qq{${q}Perl$q}, qq{$Q@A$Q}" one liner

    >   'Perl' "one liner"

Any help for getting this to work in PowerShell is welcome!

While the old Windows 10 terminal understands ANSI escape sequences, it makes
it horribly hard to activate them.  So they are off by default, requiring
B<--color> to override that choice.

=for html <hr>

Pl is maintained on L<SourceForge|https://perl1liner.sourceforge.io/> and also
available on L<meta::cpan|https://metacpan.org/pod/distribution/App-pl/pl>.
